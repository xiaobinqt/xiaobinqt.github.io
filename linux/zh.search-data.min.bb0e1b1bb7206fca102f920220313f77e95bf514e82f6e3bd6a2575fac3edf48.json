[{"id":0,"href":"/linux/docs/part1-primary/1.1-operating-system/","title":"1.1 操作系统","section":"第一部分 基础知识","content":" 1.1 操作系统 # 1.1.1 基本特征 # 1. 并发 # 并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。\n并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。\n操作系统通过引入进程和线程，使得程序能够并发运行。\n2. 共享 # 共享是指系统中的资源可以被多个并发进程共同使用。\n有两种共享方式：互斥共享和同时共享。\n互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。\n3. 虚拟 # 虚拟技术把一个物理实体转换为多个逻辑实体。\n主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。\n多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。\n虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。\n4. 异步 # 异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。\n1.1.2 基本功能 # 1. 进程管理 # 进程控制、进程同步、进程通信、死锁处理、处理机调度等。\n2. 内存管理 # 内存分配、地址映射、内存保护与共享、虚拟内存等。\n3. 文件管理 # 文件存储空间的管理、目录管理、文件读写管理和保护等。\n4. 设备管理 # 完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。\n主要包括缓冲管理、设备分配、设备处理、虛拟设备等。\n1.2.3 系统调用 # 如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。\nLinux 的系统调用主要有以下这些：\nTask Commands 进程控制 fork(); exit(); wait(); 进程通信 pipe(); shmget(); mmap(); 文件操作 open(); read(); write(); 设备操作 ioctl(); read(); write(); 信息维护 getpid(); alarm(); sleep(); 安全 chmod(); umask(); chown(); 1.1.4 宏内核和微内核 # 1. 宏内核 # 宏内核是将操作系统功能作为一个紧密结合的整体放到内核。\n由于各模块共享信息，因此有很高的性能。\n2. 微内核 # 由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。\n在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。\n因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。\n1.1.5 中断分类 # 1. 外中断 # 由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。\n2. 异常 # 由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。\n3. 陷入 # 在用户程序中使用系统调用。\n"},{"id":1,"href":"/linux/docs/part3-sys-manage/3.1-network/","title":"3.1 网络","section":"第三部分 系统管理","content":" 3.1 网络 # 3.1.1 网络状态 # net-tools \u0026amp; iproute # Centos 7 之前一般使用 net-tools，Centos 7 之后主推 iproute / iproute2。\nifconfig # eth0 第一块网卡（网络接口)。很多时候，第一个网络接口也可能叫做下面的名字：\neno1 板载网卡 ens33 PCI-E网卡 enp0s3 无法获取物理信息的PCI-E网卡 CentOS 7 使用了一致性网络设备命名，以上都不匹配则使用 eth0。\n网关/路由 # route -n 使用-n参数不解析主机名，因为默认每个 ip 都会反解成域名，如果解析耗时会一直等待。\n网卡物理连接情况 # 在 Centos 6 上可以直接输入mii-tool回车，但是 Centos 7 上必须要加上网络接口名。\n因为用的是虚拟机，所以会有 SIOCGMIIPHY on \u0026rsquo;eth0\u0026rsquo; failed: Operation not supported 错误\n网络接口/网卡名称修改 # 网卡命名规则受 biosdevname 和 net.ifnames 两个参数影响。\nbiosdevname net.ifnames 网卡名 默认 0 1 ens33 组合1 1 0 em1 组合2 0 0 eth0 编辑/etc/default/grub文件，在 GRUB_CMDLINE_LINUX 中增加biosdevname=0 net.ifnames=0 GRUB_CMDLINE_LINUX=\u0026#34;crashkernel=auto rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet biosdevname=0 net.ifnames=0\u0026#34; 更新 grub grub2-mkconfig -o /boot/grub2/grub.cfg reboot 重启之后，网卡名的修改就成功了。 3.1.2 网络配置 # 修改 ip # ifconfig eth0 192.168.120.56 # 给eth0网卡配置IP地：192.168.120.56 ifconfig eth0 192.168.120.56 netmask 255.255.255.0 #给eth0网卡配置IP地址：192.168.120.56 ，并加上子掩码：255.255.255.0 ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255 # 给eth0网卡配置IP地址：192.168.120.56，加上子掩码：255.255.255.0，加上个广播地址： 192.168.120.255 启动关闭网卡 # ifconfig eth0 up ifup eth0 ifconfig eth0 down ifdown eth0 删除/添加网关 # route del default gw 192.168.48.2 # 删除网关 route add default gw 192.168.48.3 # 添加网关 明细路由 # route add -host 10.0.0.1 gw 192.168.48.4 # 通过设置主机 route add -net 192.168.0.0 netmask 255.255.255.0 gw 192.168.48.5 # 通过设置网段 3.1.3 路由命令 # 3.1.4 网络故障排除 # 3.1.5 网络服务管理 # 3.1.6 常用网络配置文件 # 参考 # 每天一个linux命令（52）：ifconfig命令 "},{"id":2,"href":"/linux/docs/part4-shell/4.1-introduction/","title":"4.1 Shell 简介","section":"第四部分 Shell","content":" 4.1 Shell 简介 # Shell 是命令解释器，用于解释用户对操作系统的操作。CentOS7 默认使用的 Shell 是 bash。\nShell 有很多可以再 /etc/shells 文件中查看：\n4.1.1 脚本格式 # UNIX 的哲学：一条命令只做一件事。为了组合命令和多次执行，使用脚本文件来保存需要执行的命令，并赋予该文件执行权限（chmod u+rx filename）。如果是二进制文件只需要一个可执性权限，如果是脚本文件需要可读和可执行权限。\nSha-Bang # 在 shell 脚本中，Sha-Bang（也称为 Shebang 或 Hashbang）是指位于脚本文件的第一行的特殊注释。它的形式是以井号 # 开头，紧随其后是一个叹号 !，再加上一个可执行程序的路径。\n下面是一个典型的 Sha-Bang 行示例：\n#!/bin/bash 在上述示例中，#!/bin/bash 是一个 Sha-Bang 行。其中 #!/bin/ 是固定的前缀，用于告诉系统该文件是一个可执行文件，接下来的 bash 是解释器的路径，表示使用 Bash 解释器来执行该脚本。\nSha-Bang 行的作用是指定脚本所需的解释器。当在命令行中运行脚本文件时，操作系统会读取脚本文件的第一行，根据其中的 Sha-Bang 行来确定要使用的解释器，并将该解释器用于执行该脚本。\n除了 #!/bin/bash，还可以使用其他解释器路径，如 /bin/sh、/usr/bin/env python 等，根据脚本的需求选择适当的解释器。\n需要注意的是，Sha-Bang 行必须位于脚本文件的第一行，否则它将不会被正确解析。同时，脚本文件需要具有执行权限才能被执行。\n4.1.2 不同执行方式 # 脚本的执行方式大致有以下几种：\n# bash 执行不需要赋予执行权限 bash ./filename.sh # 需要有执行权限 ./filename.sh source ./filename.sh . filename.sh bash 和 ./ 在执行时会产生一个新的子进程，对当前的环境不会产生影响。\n4.1.3 重定向符号 # 一个进程默认会打开标准输入、标准输出、错误输出三个文件描述符。\n输入重定向符号 \u0026lt;\nread var \u0026lt;/path/to/a/file 2\u0026gt; 表示将标准错误输出（stderr）重定向到指定的文件或设备。例如，command 2\u0026gt; error.log 将命令的错误输出重定向到名为 error.log 的文件。\n\u0026amp;\u0026gt; 表示将标准输出（stdout）和标准错误输出（stderr）均重定向到指定的文件或设备。例如，command \u0026amp;\u0026gt; output.log 将命令的输出（包括标准输出和错误输出）都重定向到名为 output.log 的文件。\n2\u0026gt; 只会重定向标准错误输出（stderr），而标准输出（stdout）仍然会输出到终端。\n\u0026amp;\u0026gt; 会同时重定向标准输出和标准错误输出，将它们都输出到指定的文件或设备。\necho 123 \u0026gt; /path/to/a/file 输入和输出重定向组合使用：\ncat \u0026gt; /path/to/a/file \u0026lt;\u0026lt;EOF 4.1.4 变量 # 定义 # 字母、数字、下划线 不以数字开头 赋值 # 变量名=变量值 a=123 等号 = 左右两边不能有空格。\n使用 let 为变量赋值 let a=10+20 将命令赋值给变量 l=ls 将命令结果赋值给变量，使用 $() 或者使用反引号 `` c=$(ls -l /etc) 变量值有空格等特殊字符可以包含在双引号 \u0026quot;\u0026quot; 或单引号 \u0026rsquo;\u0026rsquo; 中 引用 # ${变量名} 称作对变量的引用。\necho ${变量名} 查看变量的值。\n${变量名} 在部分情况下可以省略为 $变量名\n作用范围 # 变量的作用范围只在自己的 shell 中，子进程或平行 shell 都是不能使用的。\n如果想让变量的作用范围 “全局” 生效，可以用 source 或 . 的方式执行：\nexport 导出也可以让变量 “全局” 生效：\nunset 可以删除变量：\na=1 unset a "},{"id":3,"href":"/linux/docs/part7-faq/7.1-cmd/","title":"7.1 命令相关","section":"第七部分 常见问题","content":" 7.1 命令相关 # 7.1.1 du ls 对于查看文件大小的区别 # ls -lh 和 du 命令都可以查看文件，但是 du 查看的实际文件大小，ls 查看的文件大小可能包含空洞。\nafile 文件没有空洞，ls 和 du 显示的文件大小都是 40M。\nbfile 在写入的时候由于跳过了 20*4=80M，所以这 80M 是空洞文件，那么 ls 和 du 最后显示的结果就会不一样。\n"},{"id":4,"href":"/linux/docs/part1-primary/","title":"第一部分 基础知识","section":"Docs","content":""},{"id":5,"href":"/linux/docs/part1-primary/1.2-overview/","title":"1.2 总览","section":"第一部分 基础知识","content":" 1.2 总览 # 1.2.1 常用操作以及概念 # 快捷键 # Tab：命令和文件名补全； Ctrl+C：中断正在运行的程序； Ctrl+D：结束键盘输入（End Of File，EOF） 求助 # 1. \u0026ndash;help # 指令的基本用法与选项介绍。\n2. man # man 是 manual 的缩写，将指令的具体信息显示出来。\n当执行man date时，有 DATE(1) 出现，其中的数字代表指令的类型，常用的数字及其类型如下：\n代号 类型 1 用户在 shell 环境中可以操作的指令或者可执行文件 5 配置文件 8 系统管理员可以使用的管理指令 3. info # info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以跳转。\n4. doc # /usr/share/doc 存放着软件的一整套说明文件。\n关机 # 1. who # 在关机前需要先使用 who 命令查看有没有其它用户在线。\n2. sync # 为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作。\n3. shutdown # ## shutdown [-krhc] 时间 [信息] -k ： 不会关机，只是发送警告信息，通知所有在线的用户 -r ： 将系统的服务停掉后就重新启动 -h ： 将系统的服务停掉后就立即关机 -c ： 取消已经在进行的 shutdown PATH # 可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔。\n/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin sudo # sudo 允许一般用户使用 root 可执行的命令，不过只有在 /etc/sudoers 配置文件中添加的用户才能使用该指令。\n包管理工具 # RPM 和 DPKG 为最常见的两类软件包管理工具：\nRPM 全称为 Redhat Package Manager，最早由 Red Hat 公司制定实施，随后被 GNU 开源操作系统接受并成为许多 Linux 系统的既定软件标准。YUM 基于 RPM，具有依赖管理和软件升级功能。 与 RPM 竞争的是基于 Debian 操作系统的 DEB 软件包管理工具 DPKG，全称为 Debian Package，功能方面与 RPM 相似。 发行版 # Linux 发行版是 Linux 内核及各种应用软件的集成版本。\n基于的包管理工具 商业发行版 社区发行版 RPM Red Hat Fedora / CentOS DPKG Ubuntu Debian VIM 三个模式 # 一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容； 编辑模式（Insert mode）：按下i等按键之后进入，可以对文本进行编辑； 指令列模式（Bottom-line mode）：按下:按键之后进入，用于保存退出等操作。 在指令列模式下，有以下命令用于离开或者保存文件。\n命令 作用 :w 写入磁盘 :w! 当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关 :q 离开 :q! 强制离开不保存 :wq 写入磁盘后离开 :wq! 强制写入磁盘后离开 GNU # GNU 计划，译为革奴计划，它的目标是创建一套完全自由的操作系统，称为 GNU，其内容软件完全以 GPL 方式发布。其中 GPL 全称为 GNU 通用公共许可协议（GNU General Public License），包含了以下内容：\n以任何目的运行此程序的自由； 再复制的自由； 改进此程序，并公开发布改进的自由。 开源协议 # Choose an open source license(opens new window) 如何选择开源许可证？ 1.2.2 磁盘 # 磁盘接口 # 1. IDE # IDE（ATA）全称 Advanced Technology Attachment，接口速度最大为 133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被 SATA 所取代。\n2. SATA # SATA 全称 Serial ATA，也就是使用串口的 ATA 接口，抗干扰性强，且对数据线的长度要求比 ATA 低很多，支持热插拔等功能。SATA-II 的接口速度为 300MB/s，而 SATA-III 标准可达到 600MB/s 的传输速度。SATA 的数据线也比 ATA 的细得多，有利于机箱内的空气流通，整理线材也比较方便。\n3. SCSI # SCSI 全称是 Small Computer System Interface（小型机系统接口），SCSI 硬盘广为工作站以及个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速 15000rpm 的高转速，且传输时 CPU 占用率较低，但是单价也比相同容量的 ATA 及 SATA 硬盘更加昂贵。\n磁盘的文件名 # Linux 中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常见磁盘的文件名如下：\nIDE 磁盘：/dev/hd[a-d] SATA/SCSI/SAS 磁盘：/dev/sd[a-p] 其中文件名后面的序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关。\n1.2.3 分区 # 分区表 # 磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。\n1. MBR # MBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。\n分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它使用其它扇区来记录额外的分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。\nLinux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始。\n2. GPT # 扇区是磁盘的最小存储单位，旧磁盘的扇区大小通常为 512 bytes，而最新的磁盘支持 4 k。GPT 为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA），LBA 默认大小为 512 bytes。\nGPT 第 1 个区块记录了主要开机记录（MBR），紧接着是 33 个区块记录分区信息，并把最后的 33 个区块用于对分区信息进行备份。这 33 个区块第一个为 GPT 表头纪录，这个部份纪录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码 (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，可以使用备份分区进行恢复。\nGPT 没有扩展分区概念，都是主分区，每个 LBA 可以分 4 个分区，因此总共可以分 4 * 32 = 128 个分区。\nMBR 不支持 2.2 TB 以上的硬盘，GPT 则最多支持到 233 TB = 8 ZB。\n开机检测程序 # 1. BIOS # BIOS（Basic Input/Output System，基本输入输出系统），它是一个固件（嵌入在硬件中的软件），BIOS 程序存放在断电后内容不会丢失的只读内存中。\nBIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的主要开机记录（MBR），由主要开机记录（MBR）执行其中的开机管理程序，这个开机管理程序会加载操作系统的核心文件。\n主要开机记录（MBR）中的开机管理程序提供以下功能：选单、载入核心文件以及转交其它开机管理程序。转交这个功能可以用来实现多重引导，只需要将另一个操作系统的开机管理程序安装在其它分区的启动扇区上，在启动开机管理程序时，就可以通过选单选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。\n下图中，第一扇区的主要开机记录（MBR）中的开机管理程序提供了两个选单：M1、M2，M1 指向了 Windows 操作系统，而 M2 指向其它分区的启动扇区，里面包含了另外一个开机管理程序，提供了一个指向 Linux 的选单。\n安装多重引导，最好先安装 Windows 再安装 Linux。因为安装 Windows 时会覆盖掉主要开机记录（MBR），而 Linux 可以选择将开机管理程序安装在主要开机记录（MBR）或者其它分区的启动扇区，并且可以设置开机管理程序的选单。\n2. UEFI # BIOS 不可以读取 GPT 分区表，而 UEFI 可以。\n1.2.4 文件系统 # 分区与文件系统 # 对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统。\n组成 # 最主要的几个组成部分如下：\ninode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号； block：记录文件的内容，文件太大时，会占用多个 block。 除此之外还包括：\nsuperblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等； block bitmap：记录 block 是否被使用的位图。 文件读取 # 对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。\n而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。\n磁盘碎片 # 指一个文件内容所在的 block 过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能。\nblock # 在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。\n大小 1KB 2KB 4KB 最大单一文件 16GB 256GB 2TB 最大文件系统 2TB 8TB 16TB 一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。\ninode # inode 具体包含以下信息：\n权限 (read/write/excute)； 拥有者与群组 (owner/group)； 容量； 建立或状态改变的时间 (ctime)； 最近读取时间 (atime)； 最近修改时间 (mtime)； 定义文件特性的旗标 (flag)，如 SetUID\u0026hellip;； 该文件真正内容的指向 (pointer)。 inode 具有以下特点：\n每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)； 每个文件都仅会占用一个 inode。 inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用让 inode 记录的引用 block 块记录引用信息。\n目录 # 建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。\n可以看到文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的写权限有关。\n日志 # 如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。\next3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统。\n挂载 # 挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。\n目录配置 # 为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下：\n/ (root, 根目录) /usr (unix software resource)：所有系统默认软件都会安装到这个目录； /var (variable)：存放系统或程序运行过程中的数据文件。 1.2.5 文件 # 文件属性 # 用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。\n使用 ls 查看一个文件时，会显示一个文件的信息，例如\ndrwxr-xr-x 3 root root 17 May 6 00:14 .config 对这个信息的解释如下：\ndrwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段 3：链接数 root：文件拥有者 root：所属群组 17：文件大小 May 6 00:14：文件最后被修改的时间 .config：文件名 常见的文件类型及其含义有：\nd：目录 -：文件 l：链接文件 9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。\n文件时间有以下三种：\nmodification time (mtime)：文件的内容更新就会更新； status time (ctime)：文件的状态（权限、属性）更新就会更新； access time (atime)：读取文件时就会更新。 文件与目录的基本操作 # 1. ls # 列出文件或者目录的信息，目录的信息就是其中包含的文件。\n## ls [-aAdfFhilnrRSt] file|dir -a ：列出全部的文件 -d ：仅列出目录本身 -l ：以长数据串行列出，包含文件的属性与权限等等数据 2. cd # 更换当前目录。\ncd [相对路径或绝对路径] 3. mkdir # 创建目录。\n## mkdir [-mp] 目录名称 -m ：配置目录权限 -p ：递归创建目录 4. rmdir # 删除目录，目录必须为空。\nrmdir [-p] 目录名称 -p ：递归删除目录 5. touch # 更新文件时间或者建立新文件。\n## touch [-acdmt] filename -a ： 更新 atime -c ： 更新 ctime，若该文件不存在则不建立新文件 -m ： 更新 mtime -d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=\u0026#34;日期或时间\u0026#34; -t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm] 6. cp # 复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。\ncp [-adfilprsu] source destination -a ：相当于 -dr --preserve=all -d ：若来源文件为链接文件，则复制链接文件属性而非文件本身 -i ：若目标文件已经存在时，在覆盖前会先询问 -p ：连同文件的属性一起复制过去 -r ：递归复制 -u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制 --preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了 7. rm # 删除文件。\n## rm [-fir] 文件或目录 -r ：递归删除 8. mv # 移动文件。\n## mv [-fiu] source destination ## mv [options] source1 source2 source3 .... directory -f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 修改权限 # 可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。\n## chmod [-R] xyz dirname/filename 示例：将 .bashrc 文件的权限修改为 -rwxr-xr\u0026ndash;。\n## chmod 754 .bashrc 也可以使用符号来设定权限。\n## chmod [ugoa] [+-=] [rwx] dirname/filename - u：拥有者 - g：所属群组 - o：其他人 - a：所有人 - +：添加权限 - -：移除权限 - =：设定权限 示例：为 .bashrc 文件的所有用户添加写权限。\n## chmod a+w .bashrc 默认权限 # 文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。 目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。 可以通过 umask 设置或者查看默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r\u0026ndash;。\n目录的权限 # 文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。\n目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。\n链接 # ## ln [-sf] source_filename dist_filename -s ：默认是实体链接，加 -s 为符号链接 -f ：如果目标文件存在时，先删除目标文件 1. 实体链接 # 在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。\n删除任意一个条目，文件还是存在，只要引用数量不为 0。\n有以下限制：不能跨越文件系统、不能对目录进行链接。\n## ln /etc/crontab . ## ll -i /etc/crontab crontab 34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab 34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab 2. 符号链接 # 符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。\n当源文件被删除了，链接文件就打不开了。\n因为记录的是路径，所以可以为目录建立符号链接。\n## ll -i /etc/crontab /root/crontab2 34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab 53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -\u0026gt; /etc/crontab 获取文件内容 # 1. cat # 取得文件内容。\n## cat [-AbEnTv] filename -n ：打印出行号，连同空白行也会有行号，-b 不会 2. tac # 是 cat 的反向操作，从最后一行开始打印。\n3. more # 和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。\n4. less # 和 more 类似，但是多了一个向前翻页的功能。\n5. head # 取得文件前几行。\n## head [-n number] filename -n ：后面接数字，代表显示几行的意思 6. tail # 是 head 的反向操作，只是取得是后几行。\n7. od # 以字符或者十六进制的形式显示二进制文件。\n指令与文件搜索 # 1. which # 指令搜索。\n## which [-a] command -a ：将所有指令列出，而不是只列第一个 2. whereis # 文件搜索。速度比较快，因为它只搜索几个特定的目录。\n## whereis [-bmsu] dirname/filename 3. locate # 文件搜索。可以用关键字或者正则表达式进行搜索。\nlocate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。\n## locate [-ir] keyword -r：正则表达式 4. find # 文件搜索。可以使用文件的属性和权限进行搜索。\n## find [basedir] [option] example: find . -name \u0026#34;shadow*\u0026#34; ① 与时间有关的选项\n-mtime n ：列出在 n 天前的那一天修改过内容的文件 -mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件 -mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件 -newer file ： 列出比 file 更新的文件 +4、4 和 -4 的指示的时间范围如下：\n② 与文件拥有者和所属群组有关的选项\n-uid n -gid n -user name -group name -nouser ：搜索拥有者不存在 /etc/passwd 的文件 -nogroup：搜索所属群组不存在于 /etc/group 的文件 ③ 与文件权限和名称有关的选项\n-name filename -size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k -type TYPE -perm mode ：搜索权限等于 mode 的文件 -perm -mode ：搜索权限包含 mode 的文件 -perm /mode ：搜索权限包含任一 mode 的文件 1.2.6 压缩与打包 # 压缩文件名 # Linux 底下有很多压缩文件名，常见的如下：\n扩展名 压缩程序 *.Z compress *.zip zip *.gz gzip *.bz2 bzip2 *.xz xz *.tar tar 程序打包的数据，没有经过压缩 *.tar.gz tar 程序打包的文件，经过 gzip 的压缩 *.tar.bz2 tar 程序打包的文件，经过 bzip2 的压缩 *.tar.xz tar 程序打包的文件，经过 xz 的压缩 压缩指令 # 1. gzip # gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。\n经过 gzip 压缩过，源文件就不存在了。\n有 9 个不同的压缩等级可以使用。\n可以使用 zcat、zmore、zless 来读取压缩文件的内容。\n$ gzip [-cdtv#] filename -c ：将压缩的数据输出到屏幕上 -d ：解压缩 -t ：检验压缩文件是否出错 -v ：显示压缩比等信息 -# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6 2. bzip2 # 提供比 gzip 更高的压缩比。\n查看命令：bzcat、bzmore、bzless、bzgrep。\n$ bzip2 [-cdkzv#] filename -k ：保留源文件 3. xz # 提供比 bzip2 更佳的压缩比。\n可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。\n查看命令：xzcat、xzmore、xzless、xzgrep。\n$ xz [-dtlkc#] filename 打包 # 压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。\n$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename... ==打包压缩 $ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件] ==查看 $ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录] ==解压缩 -z ：使用 zip； -j ：使用 bzip2； -J ：使用 xz； -c ：新建打包文件； -t ：查看打包文件里面有哪些文件； -x ：解打包或解压缩的功能； -v ：在压缩/解压缩的过程中，显示正在处理的文件名； -f : filename：要处理的文件； -C 目录 ： 在特定目录解压缩。 使用方式 命令 打包压缩 tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称 查 看 tar -jtv -f filename.tar.bz2 解压缩 tar -jxv -f filename.tar.bz2 -C 要解压缩的目录 1.2.7 Bash # 可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。\n特性 # 命令历史：记录使用过的命令 命令与文件补全：快捷键：tab 命名别名：例如 ll 是 ls -al 的别名 shell scripts 通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件 变量操作 # 对一个变量赋值直接使用 =。\n对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式；\n输出变量使用 echo 命令。\n$ x=abc $ echo $x $ echo ${x} 变量内容如果有空格，必须使用双引号或者单引号。\n双引号内的特殊字符可以保留原本特性，例如 x=\u0026ldquo;lang is $LANG\u0026rdquo;，则 x 的值为 lang is zh_TW.UTF-8； 单引号内的特殊字符就是特殊字符本身，例如 x=\u0026lsquo;lang is $LANG\u0026rsquo;，则 x 的值为 lang is $LANG。 可以使用 指令 或者 $(指令) 的方式将指令的执行结果赋值给变量。例如 version=$(uname -r)，则 version 的值为 4.15.0-22-generic。\n可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。\nBash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令：\n$ declare [-aixr] variable -a ： 定义为数组类型 -i ： 定义为整数类型 -x ： 定义为环境变量 -r ： 定义为 readonly 类型 使用 [ ] 来对数组进行索引操作：\n$ array[1]=a $ array[2]=b $ echo ${array[1]} 指令搜索顺序 # 以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ； 由别名找到该指令来执行； 由 Bash 内置的指令来执行； 按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。 数据流重定向 # 重定向指的是使用文件代替标准输入、标准输出和标准错误输出。\n1 代码 运算符 标准输入 (stdin) 0 \u0026lt; 或 \u0026lt;\u0026lt; 标准输出 (stdout) 1 \u0026gt; 或 \u0026gt;\u0026gt; 标准错误输出 (stderr) 2 2\u0026gt; 或 2\u0026gt;\u0026gt; 其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。\n可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。\n如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2\u0026gt;\u0026amp;1 表示将标准错误输出转换为标准输出。\n$ find /home -name .bashrc \u0026gt; list 2\u0026gt;\u0026amp;1 1.2.8 管道指令 # 管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。\n在命令之间使用 | 分隔各个管道命令。\n$ ls -al /etc | less 提取指令 # cut 对数据进行切分，取出想要的部分。\n切分过程一行一行地进行。\n$ cut -d ：分隔符 -f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间 -c ：以字符为单位取出区间 示例 1：last 显示登入者的信息，取出用户名。\n$ last root pts/1 192.168.201.101 Sat Feb 7 12:35 still logged in root pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33) root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16) $ last | cut -d \u0026#39; \u0026#39; -f 1 示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。\n$ export declare -x HISTCONTROL=\u0026#34;ignoredups\u0026#34; declare -x HISTSIZE=\u0026#34;1000\u0026#34; declare -x HOME=\u0026#34;/home/dmtsai\u0026#34; declare -x HOSTNAME=\u0026#34;study.centos.vbird\u0026#34; .....(其他省略)..... $ export | cut -c 12- 排序指令 # sort 用于排序。\n$ sort [-fbMnrtuk] [file or stdin] -f ：忽略大小写 -b ：忽略最前面的空格 -M ：以月份的名字来排序，例如 JAN，DEC -n ：使用数字 -r ：反向排序 -u ：相当于 unique，重复的内容只出现一次 -t ：分隔符，默认为 tab -k ：指定排序的区间 示例：/etc/passwd 文件内容以 : 来分隔，要求以第三列进行排序。\n$ cat /etc/passwd | sort -t \u0026#39;:\u0026#39; -k 3 root:x:0:0:root:/root:/bin/bash dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash alex:x:1001:1002::/home/alex:/bin/bash arod:x:1002:1003::/home/arod:/bin/bash uniq 可以将重复的数据只取一个。\n$ uniq [-ic] -i ：忽略大小写 -c ：进行计数 示例：取得每个人的登录总次数\n$ last | cut -d \u0026#39; \u0026#39; -f 1 | sort | uniq -c 1 6 (unknown 47 dmtsai 4 reboot 7 root 1 wtmp 双向输出重定向 # 输出重定向会将输出内容重定向到文件中，而 tee 不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。\n$ tee [-a] file 字符转换指令 # tr 用来删除一行中的字符，或者对字符进行替换。\n$ tr [-ds] SET1 ... -d ： 删除行中 SET1 这个字符串 示例，将 last 输出的信息所有小写转换为大写。\n$ last | tr \u0026#39;[a-z]\u0026#39; \u0026#39;[A-Z]\u0026#39; col 将 tab 字符转为空格字符。\n$ col [-xb] -x ： 将 tab 键转换成对等的空格键 expand 将 tab 转换一定数量的空格，默认是 8 个。\n$ expand [-t] file -t ：tab 转为空格的数量 join 将有相同数据的那一行合并在一起。\n$ join [-ti12] file1 file2 -t ：分隔符，默认为空格 -i ：忽略大小写的差异 -1 ：第一个文件所用的比较字段 -2 ：第二个文件所用的比较字段 paste 直接将两行粘贴在一起。\n$ paste [-d] file1 file2 -d ：分隔符，默认为 tab 分区指令 # split 将一个文件划分成多个文件。\n$ split [-bl] file PREFIX -b ：以大小来进行分区，可加单位，例如 b, k, m 等 -l ：以行数来进行分区。 - PREFIX ：分区文件的前导名称 1.2.9 正则表达式 # grep # g/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。\n$ grep [-acinv] [--color=auto] 搜寻字符串 filename -c ： 统计匹配到行的个数 -i ： 忽略大小写 -n ： 输出行号 -v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行 --color=auto ：找到的关键字加颜色显示 示例：把含有 the 字符串的行提取出来（注意默认会有 \u0026ndash;color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串）\n$ grep -n \u0026#39;the\u0026#39; regular_express.txt 8:I can\u0026#39;t finish the test. 12:the symbol \u0026#39;*\u0026#39; is represented as start. 15:You are the best is mean you are the no. 1. 16:The world Happy is the same with \u0026#34;glad\u0026#34;. 18:google is the best tools for search keyword 示例：正则表达式 a{m,n} 用来匹配字符 a m~n 次，这里需要将 { 和 } 进行转义，因为它们在 shell 是有特殊意义的。\n$ grep -n \u0026#39;a\\{2,5\\}\u0026#39; regular_express.txt printf # 用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。\n$ printf \u0026#39;%10s %5i %5i %5i %8.2f \\n\u0026#39; $(cat printf.txt) DmTsai 80 60 92 77.33 VBird 75 55 80 70.00 Ken 60 90 70 73.33 awk # 是由 Alfred Aho，Peter Weinberger 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。\nawk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。\n示例：取出最近五个登录用户的用户名和 IP。首先用 last -n 5 取出用最近五个登录用户的所有信息，可以看到用户名和 IP 分别在第 1 列和第 3 列，我们用 $1 和 $3 就能取出这两个字段，然后用 print 进行打印。\n$ last -n 5 dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22) dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12) dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14) dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15) $ last -n 5 | awk \u0026#39;{print $1 \u0026#34;\\t\u0026#34; $3}\u0026#39; dmtsai 192.168.1.100 dmtsai 192.168.1.100 dmtsai 192.168.1.100 dmtsai 192.168.1.100 dmtsai Fri 可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。\n$ awk \u0026#39;条件类型 1 {动作 1} 条件类型 2 {动作 2} ...\u0026#39; filename 示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。\n$ cat /etc/passwd | awk \u0026#39;BEGIN {FS=\u0026#34;:\u0026#34;} $3 \u0026lt; 10 {print $1 \u0026#34;\\t \u0026#34; $3}\u0026#39; root 0 bin 1 daemon 2 awk 变量：\n变量名称 代表意义 NF 每一行拥有的字段总数 NR 目前所处理的是第几行数据 FS 目前的分隔字符，默认是空格键 示例：显示正在处理的行号以及每一行有多少字段\n$ last -n 5 | awk \u0026#39;{print $1 \u0026#34;\\t lines: \u0026#34; NR \u0026#34;\\t columns: \u0026#34; NF}\u0026#39; dmtsai lines: 1 columns: 10 dmtsai lines: 2 columns: 10 dmtsai lines: 3 columns: 10 dmtsai lines: 4 columns: 10 dmtsai lines: 5 columns: 9 1.2.10 进程管理 # 查看进程 # 1. ps # 查看某个时间点的进程信息。\n示例：查看自己的进程\n## ps -l 示例：查看系统所有进程\n## ps aux 示例：查看特定的进程\n## ps aux | grep threadx 2. pstree # 查看进程树。\n示例：查看所有进程树\n## pstree -A 3. top # 实时显示进程信息。\n示例：两秒钟刷新一次\n## top -d 2 4. netstat # 查看占用端口的进程\n示例：查看特定端口的进程\n## netstat -anp | grep port 进程状态 # 状态 说明 R running or runnable (on run queue)\n正在执行或者可执行，此时进程位于执行队列中。 D uninterruptible sleep (usually I/O)\n不可中断阻塞，通常为 IO 阻塞。 S interruptible sleep (waiting for an event to complete) 可中断阻塞，此时进程正在等待某个事件完成。 Z zombie (terminated but not reaped by its parent)\n僵死，进程已经终止但是尚未被其父进程获取信息。 T stopped (either by a job control signal or because it is being traced) 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。 SIGCHLD # 当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：\n得到 SIGCHLD 信号； waitpid() 或者 wait() 调用会返回。 其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。\n在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。\nwait() # pid_t wait(int *status) 父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。\n如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。\n参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。\nwaitpid() # pid_t waitpid(pid_t pid, int *status, int options) 作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。\npid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。\noptions 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。\n孤儿进程 # 一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。\n孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。\n由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。\n僵尸进程 # 一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。\n僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。\n系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。\n要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。\n参考资料 # 鸟哥. 鸟 哥 的 Linux 私 房 菜 基 础 篇 第 三 版[J]. 2009. Linux 平台上的软件包管理 Linux 之守护进程、僵死进程与孤儿进程 What is the difference between a symbolic link and a hard link? Linux process states GUID Partition Table 详解 wait 和 waitpid 函数 IDE、SATA、SCSI、SAS、FC、SSD 硬盘类型介绍 Akai IB-301S SCSI Interface for S2800,S3000 Parallel ATA ADATA XPG SX900 256GB SATA 3 SSD Review – Expanded Capacity and SandForce Driven Speed Decoding UCS Invicta – Part 1 硬盘 Difference between SAS and SATA BIOS File system design case studies Programming Project #4 FILE SYSTEM DESIGN "},{"id":6,"href":"/linux/docs/part2-sys-operate/2.1-help/","title":"2.1 帮助命令","section":"第二部分 系统操作","content":" 2.1 帮助命令 # 2.1.1 man # man 命令有很多 section，可以通过man man 查看，如下：\nman 1 可以省略 1 表示查看可执行程序或 shell 命令，如man ls。\n如果想要通过 man 查看文件的说明，可以使用man 5，比如 passwd 可以是一个系统命令也可以是一个配置文件/etc/passwd，那么man passwd 就是查看这个系统命令的说明，man 5 passwd就是查看/etc/passwd这个配置文件的说明。\n当不知道查看的是命令还是文件时可以使用man -a 关键字，比如man -a passwd，这样就会把所有的说明都列出来。\n2.1.2 help # shell（命令解释器）自带的命令称为内部命令，其他的是外部命令。可以用type 命令知道这个命令是内部命令还是外部命令。\n内部命令使用 help 帮助：help 命令\n外部命令使用 help 帮助：命令 --help\n2.1.3 info # info 帮助比 help 更详细，可以作为 help 的补充。\n"},{"id":7,"href":"/linux/docs/part2-sys-operate/2.2-ls/","title":"2.2 ls 命令","section":"第二部分 系统操作","content":" 2.2 ls 命令 # ls 可以查看多个目录，如\nls /root / 查看/root目录和/目录内容。\n2.2.1 常用选项 # -l 选项 # 单列输出。\n-a 选项 # 查看所有\n-r 选项 # 逆序排序，默认按文件名逆序。\n-t 选项 # 按时间信息排序。比如按时间逆序可以使用ls -lrt。\n-R 选项 # 递归列出全部目录的内容。\n-h 选项 # -h参数是更加人性化打印文件的尺寸大小，单位是G，M，K，否则显示文件的字节大小。\n如果只用ls -h是看不见文件或者目录大小的，必须加上ls -lh。\ndu 命令同样可以显示文件大小，但是 du 命令显示的实际文件大小，ls 显示的文件大小可能包含空洞。\n-d 选项 # 将目录名像其它文件一样列出，而不是列出它们的内容。\n"},{"id":8,"href":"/linux/docs/part3-sys-manage/3.2-net-trouble-removal/","title":"3.2 网络故障排除","section":"第三部分 系统管理","content":" 3.2 网络故障排除 # 3.2.1 ping # 测试主机之间网络的连通性。\n-c 参数 # 设置完成要求回应的次数。\n3.2.2 traceroute # 3.2.3 mtr # 3.2.4 nslookup # 3.2.4 telnet # 端口是否畅通 # telnet www.baidu.com 80 # 我当前主机到对方主机的 80 端口是否畅通 3.2.5 tcpdump # tcpdump -i any -n port 80 -i 选线 # 指定网卡，可以用 -i any 表示所有网卡或是-i eth0指定网络接口/网卡的数据包。\n-n 选项 # 不要使用域名的形式进行显示。\nport # 指定端口。\n指定主机和端口 # tcpdump -i any -n host 10.0.0.1 and port 80 tcpdump -i any -n host 10.0.0.1 保存抓取信息 # -w 选线可以把捕获信息保存为文件。\ntcpdump -i any -n host 10.0.0.1 -w /tmp/filename.txt 3.2.6 netstat # 查看服务的监听地址和端口。\nnetstat -ntpl -n 选线 # 直接使用 ip 地址，而不通过域名服务器。\n-c 选线 # 显示 TCP 传输协议的连线状况。\n-p 选线 # 显示对应进程。\n-l 选线 # 显示监控中的服务器的 Socket。\n3.2.7 ss # 比 netstat 好用的 socket 统计信息，iproute2 包附带的另一个工具，允许查询 socket 的有关统计信息。用法跟 netstat 基本相同。\n"},{"id":9,"href":"/linux/docs/part4-shell/4.2-env-config-file/","title":"4.2 环境变量","section":"第四部分 Shell","content":" 4.2 环境变量 # 4.2.1 系统环境变量 # 环境变量是每个 Shel 打开都可以直接获得到的变量。\nenv 命令可以查看所有已经存在的环境变量。\nset 可以查看到比 env 更多的环境变量，包括预定义变量。\n$PATH 是命令搜索路径，如果使用的命令不在 $PATH 下就需要使用完整路径。\n$? 可以查看上一条命令是否执行成功，成为返回 0\n$$ 查看当前进程的 PID\n$0 查看当前执行的脚本或程序的名称。\n位置参数 # $1,$2 ,...., $9,${10} ... ${2-_} 表示变量替换，意思是，如果 $2 不为空就取 $2，如果为空就是 _。\n$PS1 # $PS1 用于定义 Unix 或类 Unix 操作系统中的命令行提示符。它控制着命令行界面（shell）中显示的每个命令行的外观和格式。用于设置主提示符（primary prompt）。主提示符通常在每个命令行的开始处显示，并用于指示用户输入命令。\n$PS1 的值可以包含一些特殊的转义字符和变量，以便在提示符中插入特定的信息，例如当前用户名、主机名、当前工作目录等。\n下面是一个示例，展示如何设置 $PS1 变量来定义自定义的命令行提示符：\n# 设置自定义的命令行提示符 export PS1=\u0026#34;\\u@\\h:\\w\\$ \u0026#34; # 示例输出：user@hostname:/current/path$ 在上述示例中，$PS1 的值为 \u0026quot;\\u@\\h:\\w\\$ \u0026quot;，其中：\n\\u 表示当前用户名 \\h 表示当前主机名 \\w 表示当前工作目录 \\$ 表示一个符号（$ 表示普通用户，# 表示超级用户） 命令行提示符的格式将会显示为 user@hostname:/current/path$，其中 user 是当前用户名，hostname 是当前主机名，/current/path 是当前工作目录。\n4.2.2 配置文件 # 环境变量配置文件常见目录有：\n/etc/profile /etc/profile.d ~/.bash_profile ~/.bashrc /etc/bashrc 在 /etc 目录下是所有用户通用的，不管是普通用户还是管理员。用户家目录配置文件是用户特有的。\n.bashrc 和 .bash_profile 是在 Bash shell 中用于配置用户环境的特殊文件。它们有一些区别和不同的用途：\n.bashrc：\n作用：.bashrc 文件用于定义用户每次打开新的终端会话时需要加载的配置和环境变量。\n执行时机：每次打开新的终端会话（非登录会话）时，Bash shell 会自动加载并执行 .bashrc 文件。\n使用场景：通常用于定义个人偏好设置、自定义别名、设置环境变量等，适用于非登录终端会话的配置。\n.bash_profile：\n作用：.bash_profile 文件用于定义用户登录时需要加载的配置和环境变量。\n执行时机：用户登录时，Bash shell 会自动加载并执行 .bash_profile 文件。\n使用场景：通常用于执行一次性的初始化任务、设置全局环境变量、加载其他脚本等，适用于登录终端会话的配置。\n注意：\n在某些情况下，Bash shell 可能会加载 .bash_profile 作为登录会话的配置文件，如果 .bash_profile 文件不存在，它会尝试加载 .bash_login 文件，如果还不存在，则尝试加载 .profile 文件。\n在交互式登录会话中（例如通过 SSH 登录到远程服务器），Bash shell 会加载 .bash_profile，而不会加载 .bashrc。但在某些配置中，.bash_profile 也会显式地调用 .bashrc，以便在登录时也加载 .bashrc 的配置。\n在非登录会话中（例如打开新的终端窗口），Bash shell 只会加载 .bashrc，而不会加载 .bash_profile。\n总之，.bashrc 适用于非登录终端会话的配置，而 .bash_profile 适用于登录终端会话的配置。它们的区别在于执行时机和适用场景。你可以根据需求在这两个文件中定义和管理你的个人环境和配置。\n4.2.3 su - 和 su # su - 和 su 是系统中切换用户身份的命令。它们之间的主要区别如下：\n环境变量：su - 会启动一个新的登录会话，并使用目标用户的环境变量。这包括目标用户的 HOME 目录、PATH、shell 配置文件等。而 su 仅切换用户身份，但保留当前用户的环境变量。\n工作目录：su - 会将工作目录更改为目标用户的 HOME 目录，因为它创建了一个新的登录会话。而 su 保留当前工作目录，不会更改目录。\nshell 配置文件的加载：su -会加载目标用户的 shell 配置文件（例如 .bashrc、.profile 等），以确保使用目标用户的配置。su 不会加载目标用户的配置文件。\n权限：su - 通常需要输入目标用户的密码才能切换到目标用户。而 su 可以在当前用户有切换权限的情况下，直接切换到目标用户。\n综上所述，su - 在切换用户身份时提供了更完整的环境切换，包括环境变量、工作目录和 shell 配置文件的加载。它适用于需要完全切换到目标用户身份并执行相关操作的情况。而 su 仅切换用户身份，保留当前用户的环境，适用于临时需要执行某些操作而无需完全切换用户身份的情况。\n可以看下在执行 su - 和 su 两个命令的环境变量文件执行顺序：\n"},{"id":10,"href":"/linux/docs/part2-sys-operate/","title":"第二部分 系统操作","section":"Docs","content":""},{"id":11,"href":"/linux/docs/part1-primary/1.3-common-dir/","title":"1.3 常见目录","section":"第一部分 基础知识","content":" 1.3 常见目录 # / # 根目录 ├── /root # root 用户家目录 ├── /home/username # 普通用户家目录 ├── /etc # 配置文件目录 ├── /bin # 命令目录 ├── /sbib # 管理命令目录 ├── /usr/bin # 系统预装的其他命令 └── /usr/sbin # 系统预装的其他命令 "},{"id":12,"href":"/linux/docs/part2-sys-operate/2.3-shutdown/","title":"2.3 关机","section":"第二部分 系统操作","content":" 2.3 关机 # 1. who # 在关机前需要先使用 who 命令查看有没有其它用户在线。\n2. sync # 为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作。\n3. shutdown # ## shutdown [-krhc] 时间 [信息] -k ： 不会关机，只是发送警告信息，通知所有在线的用户 -r ： 将系统的服务停掉后就重新启动 -h ： 将系统的服务停掉后就立即关机 -c ： 取消已经在进行的 shutdown 参考 # Linux命令之关机shutdown "},{"id":13,"href":"/linux/docs/part3-sys-manage/3.3-net-manage/","title":"3.3 网络服务管理","section":"第三部分 系统管理","content":" 3.3 网络服务管理 # 网络管理工具常用的有 2 套，一个是 network，另一个是 networkManger。在 Centos 6 中只有 network，在某些 Centos 7 机器中可能 2 套都存在，不要把 2 套工具都 enable，在工作中，一般只用一个禁用另外一个。\nsystemctl disable NetworkManager systemctl enable NetworkManager service network status service network restart 一般在服务器上常用 network 工具。networkManager 常用在个人电脑上。\n3.3.1 设置主机名 # 临时修改主机名：hostname 临时主机名 系统重启后会被重置。\n永久修改主机名：hostnamectl 永久主机名 是对 /etc/hostname 文件的内容进行修改。\n3.3.1 service # 参考 # linux下/etc/hosts 和hostname文件的区别 "},{"id":14,"href":"/linux/docs/part4-shell/4.3-array/","title":"4.3 数组","section":"第四部分 Shell","content":" 4.3 数组 # 定义数组 IPTS=(10.0.0.1 10.0.0.2 10.0.0.3) 显示数组的所有元素 echo ${IPTS[@]} 显示数组元素个数 echo ${#PTS[@]} 显示数组的第一个元素 echo $IPTS[0]) "},{"id":15,"href":"/linux/docs/part3-sys-manage/","title":"第三部分 系统管理","section":"Docs","content":""},{"id":16,"href":"/linux/docs/part1-primary/1.4-process-manage/","title":"1.4 进程管理","section":"第一部分 基础知识","content":" 1.4 进程管理 # 1.4.1 进程与线程 # 1. 进程 # 进程是资源分配的基本单位。\n进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。\n下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。\n2. 线程 # 线程是独立调度的基本单位。\n一个进程中可以有多个线程，它们共享进程资源。\nQQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。\n3. 区别 # Ⅰ 拥有资源 # 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。\nⅡ 调度 # 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。\nⅢ 系统开销 # 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。\nⅣ 通信方面 # 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC（Inter-Process Communication，进程间通信）。\n1.4.2 进程状态的切换 # 就绪状态（ready）：等待被调度 运行状态（running） 阻塞状态（waiting）：等待资源 应该注意以下内容：\n只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。 1.4.3 进程调度算法 # 不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。\n1. 批处理系统 # 批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。\n1.1 先来先服务 first-come first-serverd（FCFS） # 非抢占式的调度算法，按照请求的顺序进行调度。\n有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。\n1.2 短作业优先 shortest job first（SJF） # 非抢占式的调度算法，按估计运行时间最短的顺序进行调度。\n长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。\n1.3 最短剩余时间优先 shortest remaining time next（SRTN） # 最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。\n2. 交互式系统 # 交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。\n2.1 时间片轮转 # 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。\n时间片轮转算法的效率和时间片的大小有很大关系：\n因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。 2.2 优先级调度 # 为每个进程分配一个优先级，按优先级进行调度。\n为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。\n2.3 多级反馈队列 # 一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。\n多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。\n每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。\n可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。\n3. 实时系统 # 实时系统要求一个请求在一个确定时间内得到响应。\n分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。\n1.4.4 进程同步 # 1. 临界区 # 对临界资源进行访问的那段代码称为临界区。\n为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。\n// entry section // critical section; // exit section 2. 同步与互斥 # 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。 互斥：多个进程在同一时刻只有一个进程能进入临界区。 3. 信号量 # 信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。\ndown : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0； up：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。 down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。\n如果信号量的取值只能为 0 或者 1，那么就成为了互斥量（Mutex），0 表示临界区已经加锁，1 表示临界区解锁。\ntypedef int semaphore; semaphore mutex = 1; void P1() { down(\u0026amp;mutex); // 临界区 up(\u0026amp;mutex); } void P2() { down(\u0026amp;mutex); // 临界区 up(\u0026amp;mutex); } 使用信号量实现生产者-消费者问题\n问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。\n因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。\n为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。\n注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。\n#define N 100 typedef int semaphore; semaphore mutex = 1; semaphore empty = N; semaphore full = 0; void producer() { while(TRUE) { int item = produce_item(); down(\u0026amp;empty); down(\u0026amp;mutex); insert_item(item); up(\u0026amp;mutex); up(\u0026amp;full); } } void consumer() { while(TRUE) { down(\u0026amp;full); down(\u0026amp;mutex); int item = remove_item(); consume_item(item); up(\u0026amp;mutex); up(\u0026amp;empty); } } 4. 管程 # 使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。\nc 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。\nmonitor ProducerConsumer integer i; condition c; procedure insert(); begin // ... end; procedure remove(); begin // ... end; end monitor; 管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。\n管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。\n使用管程实现生产者-消费者问题\n// 管程 monitor ProducerConsumer condition full, empty; integer count := 0; condition c; procedure insert(item: integer); begin if count = N then wait(full); insert_item(item); count := count + 1; if count = 1 then signal(empty); end; function remove: integer; begin if count = 0 then wait(empty); remove = remove_item; count := count - 1; if count = N -1 then signal(full); end; end monitor; // 生产者客户端 procedure producer begin while true do begin item = produce_item; ProducerConsumer.insert(item); end end; // 消费者客户端 procedure consumer begin while true do begin item = ProducerConsumer.remove; consume_item(item); end end; 1.4.5 经典同步问题 # 1. 哲学家进餐问题 # 五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。\n下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。\n#define N 5 void philosopher(int i) { while(TRUE) { think(); take(i); // 拿起左边的筷子 take((i+1)%N); // 拿起右边的筷子 eat(); put(i); put((i+1)%N); } } 为了防止死锁的发生，可以设置两个条件：\n必须同时拿起左右两根筷子； 只有在两个邻居都没有进餐的情况下才允许进餐。 #define N 5 #define LEFT (i + N - 1) % N // 左邻居 #define RIGHT (i + 1) % N // 右邻居 #define THINKING 0 #define HUNGRY 1 #define EATING 2 typedef int semaphore; int state[N]; // 跟踪每个哲学家的状态 semaphore mutex = 1; // 临界区的互斥，临界区是 state 数组，对其修改需要互斥 semaphore s[N]; // 每个哲学家一个信号量 void philosopher(int i) { while(TRUE) { think(i); take_two(i); eat(i); put_two(i); } } void take_two(int i) { down(\u0026amp;mutex); state[i] = HUNGRY; check(i); up(\u0026amp;mutex); down(\u0026amp;s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去 } void put_two(i) { down(\u0026amp;mutex); state[i] = THINKING; check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了 check(RIGHT); up(\u0026amp;mutex); } void eat(int i) { down(\u0026amp;mutex); state[i] = EATING; up(\u0026amp;mutex); } // 检查两个邻居是否都没有用餐，如果是的话，就 up(\u0026amp;s[i])，使得 down(\u0026amp;s[i]) 能够得到通知并继续执行 void check(i) { if(state[i] == HUNGRY \u0026amp;\u0026amp; state[LEFT] != EATING \u0026amp;\u0026amp; state[RIGHT] !=EATING) { state[i] = EATING; up(\u0026amp;s[i]); } } 2. 读者-写者问题 # 允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。\n一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。\ntypedef int semaphore; semaphore count_mutex = 1; semaphore data_mutex = 1; int count = 0; void reader() { while(TRUE) { down(\u0026amp;count_mutex); count++; if(count == 1) down(\u0026amp;data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问 up(\u0026amp;count_mutex); read(); down(\u0026amp;count_mutex); count--; if(count == 0) up(\u0026amp;data_mutex); up(\u0026amp;count_mutex); } } void writer() { while(TRUE) { down(\u0026amp;data_mutex); write(); up(\u0026amp;data_mutex); } } 1.4.6 进程通信 # 进程同步与进程通信很容易混淆，它们的区别在于：\n进程同步：控制多个进程按一定顺序执行； 进程通信：进程间传输信息。 进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。\n1. 管道 # 管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。\n#include \u0026lt;unistd.h\u0026gt; int pipe(int fd[2]); 它具有以下限制：\n只支持半双工通信（单向交替传输）； 只能在父子进程或者兄弟进程中使用。 2. FIFO # 也称为命名管道，去除了管道只能在父子进程中使用的限制。\n#include \u0026lt;sys/stat.h\u0026gt; int mkfifo(const char *path, mode_t mode); int mkfifoat(int fd, const char *path, mode_t mode); FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。\n3. 消息队列 # 相比于 FIFO，消息队列具有以下优点：\n消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难； 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法； 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。 4. 信号量 # 它是一个计数器，用于为多个进程提供对共享数据对象的访问。\n5. 共享存储 # 允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。\n需要使用信号量用来同步对共享存储的访问。\n多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。\n6. 套接字 # 与其它通信机制不同的是，它可用于不同机器间的进程通信。\n"},{"id":17,"href":"/linux/docs/part2-sys-operate/2.4-cp/","title":"2.4 cp 命令","section":"第二部分 系统操作","content":" 2.4 cp 命令 # 将源文件或目录复制到目标文件或目录中。\n2.4.1 常用选项 # -p 选项 # 在复制文件后，文件的时间会发生变化，属主也有可能会发生变化。-p可以保留源文件或目录的属性。\n-a 选项 # 在复制文件后，权限，属主和时间都不发生变化。\n-f 选项 # 强行复制文件或目录，不论目标文件或目录是否已存在。\n-r 选项 # 递归处理，将指定目录下的所有文件与子目录一并处理。\n"},{"id":18,"href":"/linux/docs/part3-sys-manage/3.4-soft-install/","title":"3.4 软件安装","section":"第三部分 系统管理","content":" 3.4 软件安装 # 3.4.1 软件包管理器 # 包管理器是方便软件安装、卸载，解决软件依赖关系的重要工具。\nCentOS、RedHat 使用 yum 包管理器，软件安装包格式为 rpm。 Debian、Ubuntu 使用 apt 包管理器，软件安装包格式为 deb。 3.4.2 rpm 包和 rpm 命令 # 包格式 # 命令常用参数 # -q 查询软件包，-qa 查看所有。 rpm -qa -i 安装软件包\n-e 卸载软件包\n问题 # 使用 rpm 时需要手动解决依赖关系，在实际应用中用的不多，常用 yum 命令安装。软件包来源不可靠。\n3.4.3 yum 仓库 # 修改 yum 源 # 阿里巴巴官方镜像站 https://developer.aliyun.com/mirror/\n经常需要安装 epel 来扩展 yum 仓库源，不常见的一些软件可以通过 epel 仓库来安装：\nyum install epel-release -y 常用选项 # install 安装软件包 remove 卸载软件包 list | grouplist 查看软件包 update 升级软件包 yum update 如果加上软件包名会去升级指定的软件，如果什么都不加会去升级所有的软件包。\n3.4.4 源代码编译安装 # 有时 yum 源中没有最新的软件包，这时可以通过源代码编译安装的方式。\n以下通过编译安装 openresty 示例：\nwget https://openresty.org/download/openresty-1.15.8.1.tar.gz ## 下载 tar -zxf openresty-1.15.8.1.tar.gz cd openresty-1.15.8.1/ ./configure --prefix=/usr/local/openresty ## prefix 指定安装目录 make -j2 # -j2 使用 2 个逻辑 CPU 进行编译,如果代码之间没有一定的依赖关系一般会加快编译速度 make install 安装过程中可能需要 gcc 和 c++，需要提前安装下：\nyum install gcc gcc-c++ 如果遇到以下错误：\n./configure: error: the HTTP rewrite module requires the PCRE library 需要安装下 pcre\nyum install pcre-devel 如果遇到以下错误\nerror: SSL modules require the OpenSSL library 需要安装下 openssl\nyum -y install openssl openssl-devel 通过安装 openresty 可知，在安装过程中需要手动去解决依赖关系，而且经常不能一次性的去解决，往往需要通过经验和 google 才能解决问题，这也是源代码编译安装不太流行的原因。\n3.4.5 内核升级 # 查看内核版本可以使用 uname -r。\nyum 方式 # uname -r yum update # 升级已安装的其他软件包和补丁 yum install kernel-3.10.0 # 升级内核版本 源代码方式 # 源代码方式并不推荐，因为不会自动解决依赖关系，需要手动去解决。编译内核根分区至少要有 10G 的空间，如果小于 10G 可能会出现安装失败的情况。\n# 1. 安装依赖包 yum install gcc gcc-c++ make ncurses-devel openssl-devel elfutils-libelf-devel -y # 2. 去官方网站下载并解压缩内核 https://www.kernel.org # 可以在 https://mirrors.edge.kernel.org/pub/linux/kernel/ 这里找到需要的版本 wget https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.1.10.tar.xz tar xvf linux-5.1.10.tar.xz -C /usr/src/kernels # 3. 配置内核编译参数（可选），可以直接使用当前系统的配置，参看 4 cd /usr/src/kernels/linux-5.1.10/ make menuconfig | allyesconfig | allnoconfig # make menuconfig allyesconfig 所有我都选 yes.. # 4. 使用当前系统内核配置 cp /boot/config-kernelversion.platform /usr/src/kernels/linux-5.1.10/.config # kernelversion 内核版本 platform 平台，比如 config-3.10.0-957.el7.x86_64 # 5. 查看CPU lscpu # 6. 编译 make -j2 all # 7. 安装内核 make modules_install make install 安装成功后 reboot 重启引导使用新内核启动即可。\n3.4.6 grub 配置文件 # grub 全称 “Grand unified bootloader”，是 GNU 项目的一个启动加载包。grub 的作用就是负责加载所选择的内核，当有多个系统内核时，可以手动选择要启动的系统，在 grub 图形界面上有多系统选项菜单。\n/etc/default/grub 模板的一些配置 /etc/grub.d/ 在这个文件夹下有写高级配置 /boot/grub2/grub.cfg 不直接编辑，通过命令生成 grub2-mkconfig -o /boot/grub2/grub.cfg 常见配置项 # 引导内核 grub2-editenv list # 查看当前引导内核 grep ^menu /boot/grub2/grub.cfg # 查看有几个内核版本 grub2-set-default X # 设置引导内核，X 从 0 开始 查看错误信息 当内核引导出现问题时，可以把 GRUB_CMDLINE_LINUX 配置中的rhgb quiet参数去掉，让打印出更详细的信息。\n参考 # the HTTP rewrite module requires the PCRE library configure: error: SSL modules require the OpenSSL library. "},{"id":19,"href":"/linux/docs/part4-shell/4.4-escape-quot/","title":"4.4 转义和引用","section":"第四部分 Shell","content":" 4.4 转义和引用 # 4.4.1 特殊字符 # 一个字符不仅有字面意义，还有元意（meta-meaning）\n# 注释 ; 分号 \\ 转义符号 “ 和 \u0026rsquo; 引号 4.4.2 转义符号 # \\n，\\r，\\t 单个字母的转义\n\\$，\\\u0026quot;，\\\\ 单个非字母的转义\n"},{"id":20,"href":"/linux/docs/part4-shell/","title":"第四部分 Shell","section":"Docs","content":""},{"id":21,"href":"/linux/docs/part1-primary/1.5-deadlock/","title":"1.5 死锁","section":"第一部分 基础知识","content":" 1.5 死锁 # 1.5.1 必要条件 # 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。 占有和等待：已经得到了某个资源的进程可以再请求新的资源。 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 1.5.2 处理方法 # 主要有以下四种方法：\n鸵鸟策略 死锁检测与死锁恢复 死锁预防 死锁避免 1.5.3 鸵鸟策略 # 把头埋在沙子里，假装根本没发生问题。\n因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。\n当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。\n大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。\n1.5.4 死锁检测与死锁恢复 # 不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。\n1. 每种类型一个资源的死锁检测 # 上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。\n图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。\n每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。\n2. 每种类型多个资源的死锁检测 # 上图中，有三个进程四个资源，每个数据代表的含义如下：\nE 向量：资源总量 A 向量：资源剩余量 C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量 R 矩阵：每个进程请求的资源数量 进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。\n算法总结如下：\n每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。\n寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。 如果没有这样一个进程，算法终止。 3. 死锁恢复 # 利用抢占恢复 利用回滚恢复 通过杀死进程恢复 1.5.5 死锁预防 # 在程序运行之前预防发生死锁。\n1. 破坏互斥条件 # 例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。\n2. 破坏占有和等待条件 # 一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。\n3. 破坏不可抢占条件 # 4. 破坏环路等待 # 给资源统一编号，进程只能按编号顺序来请求资源。\n1.5.6 死锁避免 # 在程序运行时避免发生死锁。\n1. 安全状态 # 图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。\n定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。\n安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。\n2. 单个资源的银行家算法 # 一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。\n上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。\n3. 多个资源的银行家算法 # 上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。\n检查一个状态是否安全的算法如下：\n查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。 重复以上两步，直到所有进程都标记为终止，则状态时安全的。 如果一个状态不是安全的，需要拒绝进入这个状态。\n"},{"id":22,"href":"/linux/docs/part2-sys-operate/2.5-file-view/","title":"2.5 文件查看命令","section":"第二部分 系统操作","content":" 2.5 文件查看命令 # 2.5.1 cat # 参看文件打印到标准输出。\n2.5.1 head # 查看文件开头，比如前 5 行head -5 文件名。\n2.5.1 tail # 查看文件结尾，查看最后 3 行tail -3 文件名。\n可以使用-f跟踪文件变化。\n2.5.1 wc # 统计文件的字节数、字数、行数。\n-l 参数 # 统计行数。\n"},{"id":23,"href":"/linux/docs/part3-sys-manage/3.5-process/","title":"3.5 进程管理","section":"第三部分 系统管理","content":" 3.5 进程管理 # 进程是运行中的程序，从程序开始运行到终止的整个生命周期是可管理的。\n以 C 程序为例，程序的启动是从 main 函数开始的：\nint main(int agrc,char *argv[]) 程序终止的方式并不唯一，可以分为正常终止和异常终止。正常终止也分为从 main 返回、调用 exit 等方式。异常终止分为调用 abort、接收信号等。\n3.5.1 进程查看 # ps # ps 可以查看当前系统的进程状态。\n-e 选项 显示所有程序。\n-f 选项 常搭配 -e 选项使用。显示 UID（有效用户ID），PPID（父进程）等信息，进程由哪个用户启动的，有时启动用户和运行用户可能不一样，比如 Nginx 由 root 启动，但是实际的运行身份是 nobody。\n-L 选线 进程中的线程，LWP 轻量级进程也就是线程。\npstree # 如果没有 pstree 命令可以自行安装。\nyum install psmisc -y top # top 可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具。\ntop 界面主要分为两个部分，前 5 行展示的是系统的整体性能，光标下面部分是系统中每个进程的具体信息。光标所在处是用来输入操作命令的。\n系统的整体性能 # 第一行：\ntop - 14:39:05 up 36 days, 21:26, 3 users, load average: 56.31, 55.92, 56.03 top：名称 14:39:05：系统当前时间 up 36 days, 21:26：系统以及运行的时间，和 uptime 命令相等 3 users：当前有 3 个用户在线 load average: 56.31, 55.92, 56.03：系统一定时间内的平均负载，分别是 1 分钟、5 分钟、15 分钟。 主要关注load average这个值，所谓系统负载就是：在一段时间内，CPU 正在处理以及等待 CPU 处理的进程数之和。系统在同一时间运行的进程数和系统 CPU 核数相关，一般来说 Load Average 的数值别超过这台机器的总核数，就没什么问题。\n第二行：\nTasks: 265 total, 2 running, 263 sleeping, 0 stopped, 0 zombie Tasks：任务，也就是进程 265 total：当前总共有 265 个任务，也就是 265 个进程 2 running：2 个进程正在运行 263 sleeping：263 个进程正在休眠 0 stopped：0 个停止的进程 0 zombie：1 个僵尸进程 第三行：\n%Cpu(s): 88.9 us, 7.9 sy, 0.0 ni, 1.7 id, 0.0 wa, 1.4 hi, 0.0 si, 0.0 st %Cpu(s)：CPU 使用率 88.9 us：用户空间占用 CPU 时间的百分比（大部分进程都运行在用户态，通常都是希望用户空间 CPU 越高越好） 7.9 sy：内核空间占用 CPU 时间的百分比（Linux 内核态占用的 CPU 时间，系统 CPU 占用越高，表明系统某部分存在瓶颈。通常这个值越低越好） 0.0 ni：占用 CPU 时间的百分比（ni 是 nice 的缩写，进程用户态的优先级，如果调整过优先级，那么展示的就是调整过 nice 值的进程消耗掉的CPU 时间，如果系统中没有进程被调整过 nice 值，那么 ni 就显示为 0） 1.7 id：空闲 CPU 占用率，等待进程运行 0.0 wa：等待输入输出的 CPU 时间百分比（CPU 的处理速度是很快的，磁盘 IO 操作是非常慢的。wa 表示 CPU 在等待 IO 操作完成所花费的时间。系统不应该花费大量的时间来等待 IO 操作，否则就说明 IO 存在瓶颈） 1.4 hi：CPU 硬中断时间百分比（硬中断是硬盘、网卡等硬件设备发送给 CPU 的中断消息） 0.0 si：CPU 软中断时间百分比（软中断是由程序发出的中断 ） 0.0 st：被强制等待（involuntary wait）虚拟 CPU 的时间，此时 Hypervisor 在为另一个虚拟处理器服务。 第四行：\nMiB Mem : 15508.4 total, 3858.4 free, 3369.3 used, 828.07 buff/cache MiB Mem：内存 15508.4 total：物理内存总量 3858.4 free：空闲内存量 3369.3 used：已使用的内存量 828.07 buff/cache：用作内核缓存的内存量 第五行：\nMiB Swap: 4096.0 total, 3855.1 free, 240.9 used. 10823.7 avail Mem MiB Swap：交换空间（虚拟内存，当内存不足的时候，把一部分硬盘空间虚拟城内存使用） 4096.0 total：交换区总量 3855.1 free：空闲交换区总量 240.9 used：使用的交换区总量 10823.7 avail Mem：可用于启动一个新应用的内存（物理内存），和 free 不同，它计算的是可回收的 page cache 和 memory slab 第四行和第五行输出信息，等同于使用 free -m 命令。\n进程信息 # PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND PID：进程 id USER：进程所有者 PR：进程的优先级，越小优先级越高 NI：nice 值，负值表示高优先级，正值表示低优先级 VIRT：进程使用的虚拟内存，单位是 kb RES：进程使用的物理内存，单位 kb SHR：进程使用的共享内存，单位 kb S：进程状态（S 表示休眠，R 表示正在运行，Z 表示僵死状态，N 表示该进程优先值为负数，I 表示空闲状态） %CPU：进程占用的 CPU 使用率 %MEM：进程使用的物理内存和总内存的百分比 TIME+：进程使用的 CPU 时间总计，单位 1/100 秒 COMMAND：命令行 上述列是 top 命令的默认显示，还有一些参数可以使用 top 的交互命令选择显示，按 f 键，选择需要展示的部分。\n命令行选项 # 格式：top [选项]\n选项 功能 -p 只显示某个进程的信息 -d 设置刷新时间，默认是5s -c 显示产生进程的完整命令，默认是进程名 -o 指定要排序的字段，比如 top -o PID 按照 PID 从大到小，top -o -PID 按照 PID 从小到大 -n 指定刷新次数，比如 top -n 3，刷新输出3次后退出 -b 以非交互非全屏模式运行，以批次的方式执行top，一般配合-n指定输出几次统计信息，将输出重定向到指定文件，比如 top -b -n 3 \u0026gt; /tmp/top.tmp -i 不显示任何闲置 (idle) 或无用 (zombie) 的进程 -u 查找特定用户启动的进程 交互命令 # top命令在执行过程中可以使用一些交互功能：\n按键 功能 h 键 按下h键，会显示帮助画面 c 键 按下c键，会显示产生进程的完整命令，等同于-c参数，再次按下c键，变为默认显示 f 键 按下f键，可以选择需要展示的项目 M 键 按下M键，根据驻留内存大小（RES）排序 P 键 按下P键，根据CPU使用百分比大小进行排序 T 键 按下T键，根据时间/累计时间进行排序 E 键 按下E键，切换顶部内存显示单位 e 键 按下e键，切换进程内存显示单位 l 键 按下l键，切换显示平均负载和启动时间信息。 t 键 按下t键，切换显示CPU状态信息 m 键 按下m键，切换显示内存信息 VIRT、RES、SHR含义 # VIRT:\n进程 “需要的” 虚拟内存大小，包括进程使用的库、代码、数据，以及 malloc、new 分配的堆空间和分配的栈空间等； 假如进程新申请 10MB 的内存，但实际只使用了 1MB，那么它会增长 10MB，而不是实际的 1MB 使用量。 RES:\n进程当前使用的内存大小，包括使用中的 malloc、new 分配的堆空间和分配的栈空间，但不包括 swap out 量； 包含其他进程的共享； 如果申请 10MB 的内存，实际使用 1MB，它只增长 1MB； SHR:\n进程当前使用的内存大小，包括使用中的 malloc、new 分配的堆空间和分配的栈空间，但不包括 swap out 量； 包含其他进程的共享； 如果申请 10MB 的内存，实际使用 1MB，它只增长 1MB； 上述三个值是从 /proc/pid/statm 文件中格式化读出来的，前三个值分别是 VIRT、RES、SHR，单位是页，常见的是 4kb。\n3.5.2 进程的控制命令 # 调整优先级 # nice 范围从 -20 到 19，值越小优先级越高，抢占资源就越多 renice 重新设置优先级 当服务在运行的时候想调整优先级，可以用 renice 设置。\n作业控制 # 作业控制是一个命令行功能，也叫后台运行。\ngoreground（fg）：前台进程，是在终端中运行的命令，占领终端。\nbackground（bg）：后台进程，没有控制终端，他不需要终端的交互，看不到，但是在运行。可以使用 \u0026amp; 符号让服务在后台运行。\n如果想要挂起程序，可以使用 ctrl+z。如下，这是用top -p 89781 就可以看到是 stopped 的状态。如果想让再恢复运行，可以使用 fg 或 bg 唤醒。\njobs # 如何想让后台运行的程序调回前台，可以用 jobs。\n3.5.3 进程的通信方式 # 信号 # 信号是进程间通信方式之一，典型用法是：终端用户输入中断命令，通过信号机制停止一个程序的运行。\nkill -l可以查看所有的信号。\nSIGINT 通知前台进程组终止进程 ctrl+C SIGKILL立即结束程序，不能被阻塞和处理 kil -9 pid 3.5.5 守护进程和系统日志 # nohup 和 daemon 都是 Linux/Unix 系统中的概念，它们都可以让程序在后台运行，但它们的实现方式和作用有所不同。\nnohup 更适合运行一次性任务，而 daemon 更适合长期运行的系统服务。nohup 通常将输出信息重定向到文件中，而 daemon 通常将输出信息写入到系统日志中。\nnohup # nohup 命令使进程忽路 hangup（挂起）信号，即使终端关闭服务也不会停止，一般配置 \u0026amp; 使用。\n/proc/ 目录在硬盘上是不存在，是操作系统读取内存的信息以文件的方式进行呈现，用户可以像操作文件一样操作这些，大多数的操作都是查看。 daemon # daemon是守护进程的一种实现方式。守护进程是指在后台运行的一类长期运行的进程，通常不与任何终端关联。它们通常在系统启动时启动，并且在系统关闭时停止。守护进程通常用于提供一些系统服务，如网络服务、系统日志、计划任务等。\n与 nohup 不同的是，守护进程通常会将自己的进程号（PID）写入到一个文件中，以便于其他程序查询和控制它。同时，守护进程通常会把自己从父进程中分离出来，以避免与其他进程产生关联。\n另外，守护进程通常会将输出信息写入到系统日志中，而不是输出到控制台。这可以让系统管理员更方便地查看守护进程的状态和运行日志。\nscreen # screen 可以规避因网络问题导致的异常，比如正在操作终端，突然终端断开了，再次连接时就不能回到上次的执行环境了。\n如果没有 screen 命令可以进行安装。\nyum install screen -y 输入 screen 进入 screen 环境 ctrl+a 再按 d 退出（detached） screen 环境，当按 ctrl+a 时是没有反应的要注意。 screen -ls 查看 screen 的会话 screen -r sessionid 恢复会话 常见系统日志 # /var/log/messages：是一个系统日志文件，包含系统进程和服务的日志信息，包括系统启动、关机、登录和注销信息，以及用户和系统进程发出的警告和错误信息。这些日志信息对于排除系统问题和调试应用程序非常有用。\n/var/log/dmesg：提供了关于硬件设备、驱动程序和内核模块的详细信息，以及任何可能会影响系统操作的错误或警告消息，可以帮助诊断与硬件相关的问题，例如设备驱动程序或文件系统错误等。\n/var/log/secure： 包含系统认证和安全相关的消息，如登录和注销信息，sudo 命令的使用，以及系统和应用程序的安全事件。这些日志信息对于跟踪和分析安全事件非常有用。\n3.5.5 systemctl # service 对于服务的启动和停止的控制好坏完全决定与写脚本的同学，systemctl 是对 service 功能的强化。\nservice 的启动脚本放在 /etc/init.d 目录。systemctl 的脚本放在 /usr/lib/systemd/system 目录。一般 service 的脚本行数和复杂程度远大于 systemctl。\nsystemctl 的运行级别在目录 /lib/systemd/system 下，.service 文件表示服务，.target 文件表示运行级别。\n常见操作 # systemctl start|stop|restart|reload enable disable 服务名称 查看当前系统的运行级别\nsystemctl get-default # 设置默认的启动级别 systemctl set-default multi-user.target 3.5.1 SELinux 简介 # SELinux 是 Security Enhanced Linux 缩写，采用委任式存取控制，是在进行程序、文件等细节权限设置依据的一个核心模块。\n自主式（DAC） # 当程序要操作文件时，系统根据程序的 Owner/Group，对比文件的权限，若通过权限检查，则可操作文件，但可能造成问题：\nroot 具有最高权限，若某程序属于 root，则该程序可操作系统的任何文件； 使用者可利用程序来变更文件的权限。 委任式（MAC） # 也即是 SELinux 所采用的方式，可针对特定程序与特定文件来进行权限的控制。\n即使是 root，在使用不同程序时所取到的权限也不一定是 root，而是根据该程序的设定； 程序也不能任意使用系统文件，因为每个文件也有针对该程序可用的权限设定。 常见命令 # selinux 配置文件在 /etc/selinux/config 里，可以直接修改配置文件让其生效，修改后需要重启系统。\n临时修改可以使用 setenforce 命令\n参考 # top命令详细解读 Linux基础——SELinux "},{"id":24,"href":"/linux/docs/part4-shell/4.5-operator/","title":"4.5 运算符","section":"第四部分 Shell","content":" 4.5 运算符 # 4.5.1 赋值运算符 # = 赋值运算符，用于算数赋值和字符串赋值。使用 unset 取消为变量的赋值。= 除了作为赋值运算符还可以作为测试操作符。\n4.5.2 基本运算符 # + - * / ** % 使用 expr 进行运算。只能支持整数。\nexpr 4 + 5 数字常量 # let 变量名=变量值\n变量值使用 0 开头为八进制\n变量值使用 0x 开头为十六进制\n双圆括号是 let 命令的简化\n((a=10)) ((a++)) echo $((10+20)) "},{"id":25,"href":"/linux/docs/part5-text-operate/","title":"第五部分 文本操作","section":"Docs","content":""},{"id":26,"href":"/linux/docs/part1-primary/1.6-memory-manage/","title":"1.6 内存管理","section":"第一部分 基础知识","content":" 1.6 内存管理 # 1.6.1 虚拟内存 # 虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。\n为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。\n从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。\n1.6.2 分页系统地址映射 # 内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。\n一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。\n下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。\n1.6.3 页面置换算法 # 在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。\n页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。\n页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。\n1. 最佳 # OPT, Optimal replacement algorithm\n所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。\n是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。\n举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：\n7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1 开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。\n2. 最近最久未使用 # LRU, Least Recently Used\n虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。\n为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。\n因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。\n4，7，0，7，1，0，1，2，1，2，6 ### 3. 最近未使用 NRU, Not Recently Used\n每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：\nR=0，M=0 R=0，M=1 R=1，M=0 R=1，M=1 当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。\nNRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。\n4. 先进先出 # FIFO, First In First Out\n选择换出的页面是最先进入的页面。\n该算法会将那些经常被访问的页面换出，导致缺页率升高。\n5. 第二次机会算法 # FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：\n当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。\n6. 时钟 # Clock\n第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。\n1.6.4 分段 # 虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。\n下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。\n分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。\n1.6.5 段页式 # 程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。\n1.6.6 分页与分段的比较 # 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。\n地址空间的维度：分页是一维地址空间，分段是二维的。\n大小是否可以改变：页的大小不可变，段的大小可以动态改变。\n出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。\n"},{"id":27,"href":"/linux/docs/part2-sys-operate/2.6-backup-compression/","title":"2.6 压缩和打包","section":"第二部分 系统操作","content":" 2.6 压缩和打包 # 2.6.1 压缩文件名 # Linux 下有很多压缩文件名，常见的如下：\n扩展名 压缩程序 *.Z compress *.zip zip *.gz gzip *.bz2 bzip2 *.xz xz *.tar tar 程序打包的数据，没有经过压缩 *.tar.gz tar 程序打包的文件，经过 gzip 的压缩 *.tar.bz2 tar 程序打包的文件，经过 bzip2 的压缩 *.tar.xz tar 程序打包的文件，经过 xz 的压缩 *.tbz2 *.tar.bz2 的缩写 *.tgz *.tar.gz 的缩写 2.6.2 压缩指令 # 1. gzip # gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。\n经过 gzip 压缩过，源文件就不存在了。gzip 命令只能用来压缩文件，不能压缩目录，即便指定了目录，也只能压缩目录内的所有文件。gzip 命令不需要指定压缩包名。\n有 9 个不同的压缩等级可以使用。\n可以使用 zcat、zmore、zless 来读取压缩文件的内容。\n$ gzip [-cdtv#] filename -c ：将压缩的数据输出到屏幕上 -d ：解压缩 -t ：检验压缩文件是否出错 -v ：显示压缩比等信息 -# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6 2. bzip2 # 提供比 gzip 更高的压缩比。\n查看命令：bzcat、bzmore、bzless、bzgrep。\n$ bzip2 [-cdkzv#] filename -k ：保留源文件 -z ：-d 选项的补充，强制进行压缩操作，而不管执行的是哪个程序 3. xz # 提供比 bzip2 更佳的压缩比。\n可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。\n查看命令：xzcat、xzmore、xzless、xzgrep。\n$ xz [-dtlkc#] filename -l ：列出有关.xz文件的信息 2.6.3 打包 # 压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。\n$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename... ==打包压缩 $ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件] ==查看 $ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录] ==解压缩 -z ：使用 zip； -j ：使用 bzip2； -J ：使用 xz； -c ：新建打包文件； -t ：查看打包文件里面有哪些文件； -x ：解打包或解压缩的功能； -v ：在压缩/解压缩的过程中，显示正在处理的文件名； -f : filename：要处理的文件； -C 目录 ： 在特定目录解压缩。 使用方式 命令 打包压缩 tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称 查 看 tar -jtv -f filename.tar.bz2 解压缩 tar -jxv -f filename.tar.bz2 -C 要解压缩的目录 参考 # Linux命令之压缩gzip "},{"id":28,"href":"/linux/docs/part3-sys-manage/3.6-memory-disk/","title":"3.6 内存和磁盘管理","section":"第三部分 系统管理","content":" 3.6 内存和磁盘管理 # 3.6.1 内存和磁盘使用率查看 # 内存使用率 # free 和 top 命令效果基本无差，区别就是 free 是静态的，top 是动态的。\nfree # 一般多少 G 内存用 free -m 查看，多少 T 内存用 free -g 查看。\ntop # 磁盘使用率 # fdisk # 慎用。fdisk 不仅可以用来查看磁盘，还可以用来磁盘分区，在实际工作中慎用。\n查看磁盘信息可以用 fdisk -l。\ndf # 用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为 KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。\ndu # 也是查看使用空间的，但是与 d f命令不同的是 du 命令是对文件和目录磁盘使用的空间的查看。\ndu 和 ls 的区别 # ls -lh 和 du 命令都可以查看文件，但是 du 查看的实际文件大小，ls 查看的文件大小可能包含空洞。\nafile 文件没有空洞，ls 和 du 显示的文件大小都是 40M。\nbfile 在写入的时候由于跳过了 20*4=80M，所以这 80M 是空洞文件，那么 ls 和 du 最后显示的结果就会不一样。\n在底层中，ls 其实统计的是 i 节点的文件大小信息，i 节点的数据块有可能是空的。du 统计的是数据块（datablock）个数的信息。\n3.6.2 常见文件系统 # ext4 # xfs # NTFS # NTFS 是有版权的，需要安装额外的软件才能读写。\n3.6.3 磁盘配额的使用 # 3.6.4 磁盘的分区与挂载 # 硬盘分区有三种，主磁盘分区、扩展磁盘分区、逻辑分区。一个硬盘可以有一个主分区，一个扩展分区，也可以有一个主分区和若干逻辑分区。\n一个硬盘可以有 1 到 3 个主分区和 1 个扩展分区，也可以只有主分区而没有扩展分区，但主分区必须至少有 1 个，扩展分区则最多只有 1 个,且主分区+扩展分区总共不能超过 4 个。逻辑分区可以有若干个。扩展分区不能直接使用，必须分成若干逻辑分区。所有的逻辑分区都是扩展分区的一部分。\n1、主分区。主分区是硬盘的启动分区，他是独立的，也是硬盘的第一个分区——正常情况下，我们常说的 “C盘” 就是硬盘上的主分区。主分区也可称为 “引导分区”，会被操作系统和主板认定为这个硬盘的第一个分区。所以 C 盘永远都是排在所有磁盘分区的第一的位置上。\n2、扩展分区。除去主分区所占用的容量以外，剩下的容量就被认定为扩展分区（也可以这么讲：一块硬盘除去主分区外的容量后，如果对剩下的容量进行了再分区，那么，这个再分区就是扩展分区）。打个不太恰当的比喻就是主分区是主人，而扩展分区是仆人，主分区和扩展分区为主从关系。\n3、逻辑分区。扩展分区是不能直接使用的，他是以逻辑分区的方式来使用的，所以说扩展分区可以分成若干个逻辑分区。他们的关系是包含的关系，所有的逻辑分区都是扩展分区的一部分——扩展分区如果不再进行分区了，那么扩展分区就是逻辑分区了。\n对它们之间的关系可以这样比喻：在仆人（扩展分区）中进行细分类，分成洗衣服的（逻辑分区D盘）、扫地的（逻辑分区E盘）、做饭的（逻辑分区F盘）等等。 所以扩展分区和逻辑分区的关系相当于再分类关系。\n常用命令 # fdisk # fdisk /dev/sdc 新建分区按 n 键。\nmkfs # 创建完分区需要对这个分区进行使用，把这个分区映射成一个盘符。\nmkfs 用于在设备上（通常为硬盘）创建 Linux 文件系统。mkfs 本身并不执行建立文件系统的工作，而是去调用相关的程序来执行。\nparted # 如果磁盘大与 2T 不能使用 fdisk 进行分区，需要用 parted。\nmount # 用于挂载 Linux 系统外的文件。\n将 /dev/hda1 挂在 /mnt 之下。\nmount /dev/hda1 /mnt 将 /dev/hda1 用只读模式挂在 /mnt 之下。\nmount -o ro /dev/hda1 /mnt 常见配置文件 # 使用 mount 挂载命令只在内存中生效的临时配置，如果要使参数进行固话，可以修改配置文件 /etc/fstab。\n3.6.5 交换分区（虚拟内存）的查看与创建 # 3.6.6 软件 RAID 的使用 # 3.6.7 逻辑卷管理 # 3.6.8 系统综合状态查看 # "},{"id":29,"href":"/linux/docs/part6-service-manage/","title":"第六部分 服务管理","section":"Docs","content":""},{"id":30,"href":"/linux/docs/part1-primary/1.7-link/","title":"1.7 链接","section":"第一部分 基础知识","content":" 1.7 链接 # 1.7.1 编译系统 # 以下是一个 hello.c 程序：\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;hello, world\\n\u0026#34;); return 0; } 在 Unix 系统上，由编译器把源文件转换为目标文件。\ngcc -o hello hello.c 这个过程大致如下：\n预处理阶段：处理以 # 开头的预处理命令； 编译阶段：翻译成汇编文件； 汇编阶段：将汇编文件翻译成可重定位目标文件； 链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。 1.7.2 静态链接 # 静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：\n符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。 1.7.2 目标文件 # 可执行目标文件：可以直接在内存中执行； 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件； 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接； 1.7.3 动态链接 # 静态库有以下两个问题：\n当静态库更新时那么整个程序都要重新进行链接； 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。 共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：\n在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中； 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。 "},{"id":31,"href":"/linux/docs/part1-primary/1.7-device-manage/","title":"1.7 设备管理","section":"第一部分 基础知识","content":" 1.7 设备管理 # 1.7.1 磁盘结构 # 盘面（Platter）：一个磁盘有多个盘面； 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道； 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小； 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）； 制动手臂（Actuator arm）：用于在磁道之间移动磁头； 主轴（Spindle）：使整个盘面转动。 1.7.2 磁盘调度算法 # 读写一个磁盘块的时间的影响因素有：\n旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上） 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上） 实际的数据传输时间 其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。\n1. 先来先服务 # FCFS, First Come First Served\n按照磁盘请求的顺序进行调度。\n优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。\n2. 最短寻道时间优先 # SSTF, Shortest Seek Time First\n优先调度与当前磁头所在磁道距离最近的磁道。\n虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。\n3. 电梯算法 # SCAN\n电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。\n电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。\n因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。\n"},{"id":32,"href":"/linux/docs/part2-sys-operate/2.7-vim/","title":"2.7 vim","section":"第二部分 系统操作","content":" 2.7 vim # 2.7.1 vim 三种模式 # 一般指令模式（Command mode）：vim 的默认模式，可以用于移动游标查看内容； 编辑模式（Insert mode）：按下i等按键之后进入，可以对文本进行编辑； 指令列模式（Bottom-line mode）：按下:按键之后进入，用于保存退出等操作。 在指令列模式下，有以下命令用于离开或者保存文件。\n命令 作用 :w 写入磁盘，也可以加上保存路径，如 :w /tmp/test.txt :w! 当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关 :q 离开 :q! 强制离开不保存 :wq 写入磁盘后离开 :wq! 强制写入磁盘后离开 2.7.2 正常模式 # 按键 作用 I 进入插入模式，光标会移到当前行的开头位置 a 进入插入模式，光标会移动到下一个字符位置 A 进入插入模式，光标会移动到当前行末尾位置 o 进入插入模式，会向下新开一行，光标会移动到新行开头位置 O 进入插入模式，会向上新开一行，光标会移动到新行开头位置 h 前移 l 后移 j 下移 k 上移 u 撤销操作，可以多次撤销 x 单个字符删除 r 替换字符 ^ 回到当前行首 $ 回到当前行尾 ctrl+r 重做，恢复撤销 yy 和 p yy 复制一行，p 粘贴 复制多行 # 比如复制 3 行，光标移到要复制的开头位置，先按 3，再按 yy，就复制了 3 行。\n复制光标到行结尾 # 在光标位置，先按 y 再按 $。\n跳到指定行 # 先输入行号，比如 11，再按 ctrl+g 或是 G。\n按 2 下 g（小写的 g），gg 会直接跳到第一行。GG 会跳到文本最后一行。\n2.7.3 命令模式 # 临时执行命令 # :! 命令可以在命令模式临时执行命令。比如临时执行ifconfig命令。\n查找替换 # :/要查找的字符串，按 n 往下继续查找。shift+n 定位到上一个查找到的结果。\n:s/old/new 只在光标所在行进行替换。\n:3,5s/old/new 对 3-5 行指定行进行替换。\n:%s/old/new 全文替换。可以加上 g，:%s/old/new/g进行全局替换。\n2.7.4 可视模式 # 按键 作用 v 字符可视模式 V（shift+v） 行可视模式 ctrl+v 块可视模式，配合 d 和I命令可以进行块的便利操作 2.7.5 常见问题 # 1. E388: Couldn\u0026rsquo;t find definition # 这个问题会导致 vim 的上下左右方向键不能使用。解决方法如下：\nvim ~/.vimrc 如果家目录没有 .vimrc 文件可以 touch 新建一个。在 .vimrc 文件中添加\n:set term=builtin_ansi 2. WARNING: terminal is not fully functional # 修改环境变量 TERM\nexport TERM=xterm 3. vim 乱码问题 # #方式一： vim /etc/vim/vimr #方式二： vim ~/.vimrc 在打开的文件末尾添加如下内容：\nset fileencodings=utf-8,gb2312,gbk,gb18030 set termencoding=utf-8 set encoding=prc "},{"id":33,"href":"/linux/docs/part7-faq/","title":"第七部分 常见问题","section":"Docs","content":""},{"id":34,"href":"/linux/docs/part1-primary/1.8-instruction-arch/","title":"1.8 指令集","section":"第一部分 基础知识","content":" 1.8 指令集 # 1.8.1 指令集架构 # 指令集架构是指一套软硬件的标准规范，CPU芯片和软件应用会围绕这套规范设计。从CPU发明到现在，有非常多种架构，从常见的x86、ARM，到不太常见的RISC-V，MIPS、IA64，它们之间的差距都非常大。\n有些时候我们会遇到在本地开发环境编译和运行正常的代码，在生产环境却无法正常工作，当然这个问题背后会有多种原因，而不同机器使用的不同指令集可能是原因之一。\n指令集架构是计算机的抽象模型，在很多时候也被称作架构或者计算机架构，它是计算机软件和硬件之间的接口和桥梁。一个为特定指令集架构编写的应用程序能够运行在所有支持这种指令集架构的机器上，也就是说如果当前应用程序支持 x86 的指令集，那么就可以运行在所有使用 x86 指令集的机器上，这其实就是抽象层的作用，每一个指令集架构都定义了支持的数据结构、寄存器、管理主内存的硬件支持（例如内存一致、地址模型和虚拟内存）、支持的指令集和 IO 模型，它的引入其实就在软件和硬件之间引入了一个抽象层，让同一个二进制文件能够在不同版本的硬件上运行。如果一个编程语言想要在所有的机器上运行，它就可以将中间代码转换成使用不同指令集架构的机器码，这可比为不同硬件单独移植要简单的太多了。\n1.8.2 复杂指令集（CISC）和精简指令集（RISC） # 最常见的指令集架构分类方法是根据指令的复杂度将其分为复杂指令集（CISC）和精简指令集（RISC），复杂指令集架构包含了很多特定的指令，但是其中的一些指令很少会被程序使用，而精简指令集只实现了经常被使用的指令，不常用的操作都会通过组合简单指令来实现。\n复杂指令集的特点就是指令数目多并且复杂，每条指令的字节长度并不相等，x86 就是常见的复杂指令集处理器，它的指令长度大小范围非常广，从 1 到 15 字节不等，对于长度不固定的指令，计算机必须额外对指令进行判断，这需要付出额外的性能损失。\n而精简指令集对指令的数目和寻址方式做了精简，大大减少指令数量的同时更容易实现，指令集中的每一个指令都使用标准的字节长度、执行时间相比复杂指令集会少很多，处理器在处理指令时也可以流水执行，提高了对并行的支持。作为一种常见的精简指令集处理器，arm 使用 4 个字节作为指令的固定长度，省略了判断指令的性能损失3，精简指令集其实就是利用了我们耳熟能详的 20/80 原则，用 20% 的基础指令和它们的组合来解决问题。\n复杂指令集和精简指令集的使用是设计上的权衡，经过这么多年的发展，两种指令集也相互借鉴和学习，与最开始刚被设计出来时已经有了较大的差别。最开始的计算机使用复杂指令集是因为当时计算机的性能和内存比较有限，业界需要尽可能地减少机器需要执行的指令，所以更倾向于高度编码、长度不等以及多操作数的指令。不过随着计算机性能的提升，出现了精简指令集这种牺牲代码密度换取简单实现的设计；除此之外，硬件的飞速提升还带来了更多的寄存器和更高的时钟频率，软件开发人员也不再直接接触汇编代码，而是通过编译器和汇编器生成指令，复杂的机器指令对于编译器来说很难利用，所以精简指令在这种场景下更适合。\n参考 # 机器码生成 "},{"id":35,"href":"/linux/docs/part2-sys-operate/2.8-user-manage/","title":"2.8 用户管理","section":"第二部分 系统操作","content":" 2.8 用户管理 # 命令 作用 useradd 新建用户 userdel 删除用户 passwd 修改用户密码 usermod 修改用户属性 chage 修改帐号和密码的有效期限 groupadd 新建用户组 groupdel 删除用户组 2.8.1 useradd # useradd 用户名 useradd -g 用户组 用户名 当不指定用户组时，会创建一个同名的用户组。\n2.8.2 passwd # passwd wislon 当修改自己的密码时，直接输入 passwd 回车。\n2.8.3 userdel # userdel 用户名 当加上-r选项时，会删除用户的家目录。\n2.8.4 usermod # 用于修改用户的基本信息。\n常用选项 # -d 选项 # 修改用户登入时的目录，只是修改/etc/passwd中用户的家目录配置信息，不会自动创建新的家目录，通常和-m一起使用。\n-m 选项 # 移动用户家目录到新的位置，不能单独使用，一般与-d一起使用。\n-g 选项 # 修改用户所属的用户组。\nusermod -g 用户组 用户名 2.8.5 groupadd # 创建一个新的用户组。\n2.8.6 passwd 配置文件 # /etc/passwd 文件中，各个字段以:分隔，如下\nntp:x:38:38::/etc/ntp:/sbin/nologin user1:x:1004:1004::/home/user1:/bin/bash 值1：表示用户名 值2：是否需要密码验证，x需要，空为不需要。 值3：用户 ID 值4：用户组 ID 值5：注释 值6：家目录 值7：用户登录后的命令解释器，当值为/sbin/nologin时不能登录终端。 2.8.6 shadow 配置文件 # /etc/shadow 文件跟用户密码相关。各个字段以:分隔，如下\nwilson:$6$OlPoziO9$SvSfAjR4yHWkUpAYIEHL6jUxF7FypoiOWRhVTftR3CZJUIwpWZcSguhVHfc1xVj9A9tr8ArZxvH.G//tyR0Qm/:19390:0:99999:7::: w:!!:19390:0:99999:7::: user1:!!:19390:0:99999:7::: 值1：用户名 值2：加密后的密码 2.8.7 group 配置文件 # /etc/group 文件跟用户组相关。各个字段以:分隔，如下\nstapsys:x:157: mail:x:12:postfix wilson:x:1002: w:x:1003: group1:x:1004: user1:x:1005: 值1：用户组名 值2：是否需要密码验证 值3：用户组 GID 值4：其他组设置 "},{"id":36,"href":"/linux/docs/part2-sys-operate/2.9-switch-user/","title":"2.9 切换用户","section":"第二部分 系统操作","content":" 2.9 切换用户 # su用于切换用户，如果普通用户切换成管理员需要输入密码，那么就需要把密码告诉普通用户，有暴露 root 密码的风险。\nsudo可以避免暴露 root 密码，可以直接把某些命令授权给普通用户执行，普通用户在执行时不需要 root 用户密码。\n2.9.1 su # 用于切换当前用户身份到其他用户身份。\n- 参数在变更账号后并改变工作目录到该账号的家目录。\n2.9.1 sudo # 以其他身份来执行命令。\nvisudo 设置需要使用 sudo 的用户（组）。\nwilson ALL=/usr/sbin/shutdown # wilson 用户被授予 shutdown 执行权限，多个命令以 , 分隔。 wilson ALL=/usr/sbin/shutdown NOPASSWD # wilson 用户被授予 shutdown 执行权限，不需要输入密码 "},{"id":37,"href":"/linux/docs/part2-sys-operate/2.10-file-dir/","title":"2.10 文件和文件夹","section":"第二部分 系统操作","content":" 2.10 文件和文件夹 # 2.10.1 文件类型 # - 普通文件 d 目录文件 b 块特殊文件 c 字符特殊文件 l 符号链接 f 命名管道 s 套接字文件 创建新文件有默认权限，根据 umask 值计算，属主和属组根据当前进程的用户来设定。\n在 linux 中创建文件默认是 (0)666 权限，需要减去 umask 的值。如：\n2.10.2 权限表示 # 普通文件 # r=4 读 w=2 写 x=1 执行 目录 # x 进入目录 rx 显示目录内的文件名 wx 修改目录内的文件名 x 权限只能进入目录\nrx 权限能进入并目录，显示目录内容，也可以读取文件，但是不能对文件进行操作\nwx 权限能进入目录，但是不能显示目录内容，可以读取/修改/删除文件\n2.10.3 修改权限 # chmod # chmod 可以修改文件和目录权限。\nu 表示用户，g 表示用户组，o 表示其他用户，a 表示所有。\nchmod u+x /tmp/testfile chmod u-wx /tmp/testfile chmod u=rwx /tmp/testfile chmod 755 /tmp/testfile chown # 更改文件或目录的所属用户和用户组。\nchown 用户 文件 chown :用户组 文件 chown 用户:用户组 文件 chgrp # 可以单独更新用户组，不常用。\nchgrp 用户组 文件 2.10.4 特殊权限 # SUID 用于二进制可执行文件，执行命令时取得文件属主权限，如/usr/bin/passwd SGID 用于目录，在该目录下创建新的文件和目录，权限自动更改为该目录的属组 SBIT 用于目录，该目录下新建的文件和目录，仅 root 和自己可以删除，如/tmp SUID # 说明 # 可以看到/etc/passwd除了 root 用户其实没有其他可以修改的，但是其他人也可以修改自己的密码，所以/usr/bin/passwd的权限就是 SUID，也就是任何人在执行 passwd 命令时自动获取到属主权限也就是 root 权限。\n添加方式 # 以 chmod 在原始权限加 4，比如原始权限是 744，那么就修改后的就是 4744，示例如下\nSBIT # 以 chmod 在原始权限加 1，比如原始权限是 744，那么就修改后的就是 1744，示例如下\n"},{"id":38,"href":"/linux/docs/part2-sys-operate/2.11-awk/","title":"2.11 awk 命令","section":"第二部分 系统操作","content":" 2.11 awk 命令 # awk 是一种处理文本文件的语言，是一个强大的文件分析工具。\nawk 比较倾向于将一行分成多个 “字段” 进行处理。awk 信息的读入是逐行读取的，执行结果可以通过 print 将字段数据打印显示。在使用 awk 命令的过程中，可以使用逻辑操作符，\u0026amp;\u0026amp;、|| 、!，还可以进行简单的数学运算，如+、-、*、/、%、^分别表示加、减、乘、除、取余和乘方。\n2.11.1 使用格式 # awk 「选项」 \u0026#39;模式或条件{操作}\u0026#39; 文件名 # 格式1 awk -f 脚本文件 文件名 # 格式2 2.11.2 内置变量 # 内置变量 功能 NF 当前处理的行的字段个数（就是：有多少列） NR 当前处理的行的行号（就是：有多少行） FNR 读取文件的记录数（行号），从1开始，新的文件重新从1开始计数 $0 当前处理的行的整行内容（就是：表示一行的内容） $n 当前处理行的第n个字段（就是：第n列） FILENAME 被处理的文件名 FS 指定每行的字段分隔符，默认为空格或制表位（相当于选项 -F ） OFS 输出字段的分隔符，默认也是空格 RS 行分割符。awk 从文件上读取资料时，将根据 RS 的定义把资料切割成许多条记录，而 awk 一次仅读取一条记录，预设值是\\n ORS 输出分割符，默认也是换行符 $n 用法 # n 为数字，数字为几就表示第几列。\n直接输入全部内容。 要求输出的是第 1 列。但是没有指定分隔符，awk 默认是以空格位分割。所有它认为这整个一行都是一列。 设定分割符号:，输出第 5 列。 设定分割符号x，输出第 1 列。 输出时，显示列的空格。 设置多个分割符。 $0 用法 # $0 表示整行。\nNF 和 NR 用法 # NF 表示该处理的行序号是多少，表示多少列。NR 表示该处理的行，有多少行。\n打印每一行的列数。 显示行号。 显示行号，并显示每一行的内容。 打印第 2 行，不加 print 也一样，默认就是打印。 打印第 2 行的第 1 列。 打印最后一列。 打印总行数。 打印文件最后一行。 加上文字描述行数和列数。 FNR 用法 # 可以看到当有多个文件时，序号会分别标好每一个文件内容的行号，不同文件会从头开始。（NR会连续在一起）。\nRS 用法 # 指定以什么为换行符，这里指定是冒号，指定的必须是原文里存在的字符。\n2.11.3 BEGIN 和 END 用法 # 逐行执行开始之前执行什么任务，结束之后再执行什么任务，用 BEGIN、END。\nBEGIN：一般用来做初始化操作，仅在读取数据记录之前执行一次。 END：一般用来做汇总操作，仅在读取完数据记录之后执行一次。 常见用法 # 在打印之前定义字段分割符为冒号:。 OFS 定义了输出时以什么分隔，$1$2 中间要用逗号分隔，因为逗号默认被映射为 OFS 变量，而这个变量默认是空格。 把多行合并成一行输出，输出的时候自定义以空格分隔每行，本来默认的是回车键。 2.11.4 包含与不包含 # 用~表示包含，用!~表示不包含。\n2.11.5 数值与字符串比较 # 逻辑运算 # 2.11.6 常见问题 # 获取本机 ip 地址 # 查看本机流量有多少字节 # 查看根分区的可用量 # 2.11.7 总结 # awk 常用操作是提取转换文本文件内容，awk 功能十分强大，几乎其它文本处理命令能做的，awk 都能做。\n$n ：表示截取哪一列，通常和print一起使用 $0 ：表示整行内容 NF ：表示该行有多少列 NR ：表示该行的行号 FNR ：表示读取两个文件时，序号会分别从0开始标 FS ：表示读取文件的分隔符（默认空格） OFS ：表示输入的内容以什么为分割符（默认空格） RS ：表示读取文件的以什么为换行符（默认\\n） ORS ：表示输出的内容以什么为换行符（默认\\n） ~ ：表示包含 !~ ：表示不包含 参考 # shell之三剑客awk（基础用法） "},{"id":39,"href":"/linux/docs/part2-sys-operate/2.12-sed/","title":"2.12 sed 命令","section":"第二部分 系统操作","content":" 2.12 sed 命令 # 2.12.1 简介 # sed（stream EDitor）是一个强大而简单的文本解析转换工具，可以读取文本，并根据指定的条件对文本内容进行编辑（删除、替换，添加、移动等），最后输出所有行或仅输出处理的某些行。\nsed 也可以在无交互的情况下实现相当复杂的文本处理操作，被广泛应用于 shell 脚本中，用以完成各种自动化处理任务。\nsed 的工作流程主要包括读取、执行和显示三个过程：\n读取： sed 从输入流（文件、管道、标准输入）中读取一行内容并存储到临时的缓冲区（又称模式空间）。 执行： 默认情况下，所有的 sed 命令都在模式空间中顺序地执行，除非指定了行的地址，否则 sed 命令将会在所有行上一次执行。 显示： 发送修改后的内容到输出流，在发送数据后，模式空间将会被清空。 在所有的文件内容都被处理完成之前，上述过程将重复执行，直至所有内容被处理完。\n默认情况下所有的 sed 命令，都是在模式空间内执行的，因此输入的文件并不会发生变化。\n2.12.2 选项操作 # 通常情况下调用 sed 命令有两种格式。\n“参数” 是指操作的目标文件，当存在多个操作对象时，文件之间用逗号分隔。 sed [选项] \u0026#39;操作\u0026#39; 参数 scriptfile 表示脚本文件，需要用-f选项指定，当脚本文件出现在目标文件之前时，表示通过指定的脚本文件来处理输入的目标文件。 sed [选项] -f scriptfile 参数 常见选项 # 选项 功能 -e 表示用指定命令或者脚本来处理输入的文本文件 -f 表示用指定的脚本文件来处理输入的文本文件 -h 显示帮助 -n 表示仅显示处理后的结果 -i 直接编辑文本文件 -r或-E 使用扩展正则表达式 -s 将多个文件视为独立文件，而不是单个连续的长文件流 操作指令 # 「操作」用于指定文件对操作的动作行为，也就是 sed 的命令。\n通常情况下是采用的[n1[,n2]]操作参数的格式。n1、n2 是可选的，代表选择进行操作的行数，如操作需要在 5~20 行之间进行，则表示为「5,20 动作行为」。\n选项 功能 a 增加，在当前行下面增加一行指定内容 i 插入，在选定行上面插入一行指定内容 c 替换，将选定行替换为指定内容 s 替换，替换指定的字符串 y 字符替换（字符一一替换） p 打印，如果同时指定行，表示打印指定行，如果不指定行，则表示打印所有内容，如果有非打印字符，则以 ASCII 码输出。其通常与-n选项一起使用。 d 删除，删除选定的行 2.12.3 选项案例 # -n 仅显示处理后的结果 # sed 在处理文件时，会将处理的内容放入到缓冲区（模式空间）中进行处理，然后在模式空间中对内容进行（增删改查）最后以标准输出的形式将内容输出出来。\nsed 从标准输入中读取 hahah.txt 文件的内容到缓冲区中，然后再在缓冲区中对 3p 进行打印，最后不仅将第 3 行打印，也将源文件打印。\n如果加上 -n 选项，-n 选项的意思就是，仅显示处理后的结果。文件内容被标准输入到缓冲空间后，sed 通过设定的选项知道了，需要输出哪些内容，仅输出处理的行。所以 -n 选项通常和 p 动作放在一起使用。\n-e 设置多个命令 # sed 命令可以不只包含一个命令。如果要包含多个命令，只需要每个命令前加上一个 -e 选项即可。\n注意：-e 选项的后面要接命令内容，不允许再夹杂其它选项\n-f 文件编辑 # 使用sed脚本将多个编辑指令存放到文件中（每行一条编辑指定），然后通过 -f 选项来调用。\n例如：执行一下命令即将第 1~5 行内容转移至第 15 行后。\n-i 进行修改文件 # 可以使用 -i 选项直接修改到文件中的内容，对源文件进行生效。\n2.12.4 操作案例 # p 输出指定行 # sed -n \u0026#39;3p\u0026#39; test.txt # 输出第 3 行 sed -n \u0026#39;3,5p\u0026#39; test.txt # 输出 3~5 行 sed -n \u0026#39;p;n\u0026#39; test.txt # 输出所有奇数行,n 表示读入下一行资料 sed -n \u0026#39;n;p\u0026#39; test.txt # 输出所有偶数行,n 表示读入下一行资料 sed -n \u0026#39;1,5{p;n}\u0026#39; test.txt # 输出第 1~5 行之间的奇数行(第 1、3、5 行) sed -n \u0026#39;10,${n;p}\u0026#39; test.txt # 输出第 10 行至文件尾之间的偶数行 sed -n p test.txt # 输出所有行 sed -n \u0026#39;3,$p\u0026#39; test.txt # 输出第 3 行至文件尾之间的行 结合正则表达式 # sed 命令结合正则表达式，格式略有不同，正则表达式以/包围。\nsed -n \u0026#39;/the/p\u0026#39; test.txt # 输出包含 the 的行 sed -n \u0026#39;4,/the/p\u0026#39; test.txt # 输出从第 4 行至最后一个包含 the 的行 sed -n \u0026#39;/the/=\u0026#39; test.txt # 输出包含the 的行所在的行号,等号(=)用来输出行号 sed -n \u0026#39;/^PI/p\u0026#39; test.txt # 输出以PI 开头的行 sed -n \u0026#39;/[0-9]$/p\u0026#39; test.txt # 输出以数字结尾的行 sed -n \u0026#39;/\\\u0026lt;wood\\\u0026gt;/p\u0026#39; test.txt # 输出包含单词wood 的行,\\\u0026lt;、\\\u0026gt;代表单词边界 d 删除指定行 # nl 文件名可以输出文件内容加上行号。\nnl test.txt | sed \u0026#39;3d\u0026#39; # 删除第 3 行 nl test.txt | sed \u0026#39;3,5d\u0026#39; # 删除第 3~5 行 # 删除包含 cross 的行,如果要删除不包含 cross 的行,用 ! 符号表示取反操作, 如\u0026#39;/cross/!d\u0026#39; nl test.txt | sed \u0026#39;/cross/d\u0026#39; sed \u0026#39;/^[a-z]/d\u0026#39; test.txt # 删除以小写字母开头的行 sed \u0026#39;/\\.$/d\u0026#39; test.txt # 删除以\u0026#34;.\u0026#34;结尾的行 sed \u0026#39;/^$/d\u0026#39; test.txt # 删除所有空行 s 替换符合条件的文件 # 在使用 sed 命令进行替换操作时需要用到 s（字符串替换）、c（整行/整块替换）、y（字符转换）。\ng 表示全局替换。\nsed \u0026#39;s/the/THE/\u0026#39; test.txt # 将每行中的第一个 the 替换为 THE sed \u0026#39;s/l/L/2\u0026#39; test.txt # 将每行中的第 2 个 l 替换为 L sed \u0026#39;s/the/THE/g\u0026#39; test.txt # 将文件中的所有 the 替换为 THE sed \u0026#39;s/o//g\u0026#39; test.txt # 将文件中的所有 o 删除(替换为空串（就是不存在的，不是空格）) sed \u0026#39;s/^/#/\u0026#39; test.txt # 在每行行首插入 # 号 sed \u0026#39;/the/s/^/#/\u0026#39; test.txt # 在包含 the 的每行行首插入 # 号 sed \u0026#39;s/$/EOF/\u0026#39; test.txt # 在每行行尾插入字符串 EOF sed \u0026#39;3,5s/the/THE/g\u0026#39; test.txt # 将第 3~5 行中的所有 the 替换为 THE sed \u0026#39;/the/s/o/O/g\u0026#39; test.txt # 将包含 the 的所有行中的 o 都替换为 O y 替换字符 # y///和s///有什么区别呢？主要有以下两点：\ny 的语法格式是y/source/dest/，表示将 源 中的字符对位替换为 目的 中的字符。而 s 的语法格式是s/regexp/replacement/，表示通过正则匹配到的内容替换为 replacement 部分。\ny 只是简单的逐字替换，没有很多花样。s 支持 \u0026amp; 符号和预存储等特性，可以实现更多灵活的替换效果。\ny 动作只是简单的替换字符，逐个替换。\n移动 {H;d} 插入 a 指定内容 # 常用参数\n参数 功能 H 复制到剪切板 g、G 将剪切板的数据覆盖/追加到指定行 w 保存为文件 r 读取指定文件 a 追加指定内容（a 是加入在行后，i 是加入在前行，6a 是指定多少行进行加入） I，i 忽略大小写 d 将以前的删除 $ 表示最后 sed \u0026#39;/the/{H;d};$G\u0026#39; test.txt # 将包含 the 的行迁移至文件末尾,{;}用于多个操作 sed \u0026#39;1,5{H;d};17G\u0026#39; test.txt # 将第 1~5 行内容转移至第 17 行后 sed \u0026#39;/the/w out.file\u0026#39; test.txt # 将包含the 的行另存为文件 out.file sed \u0026#39;/the/r /etc/hostname\u0026#39; test.txt # 将文件/etc/hostname 的内容添加到包含 the 的每行以后 sed \u0026#39;3aNew\u0026#39; test.txt # 在第 3 行后插入一个新行,内容为New sed \u0026#39;/the/aNew\u0026#39; test.txt # 在包含the 的每行后插入一个新行,内容为 New sed \u0026#39;3aNew1\\nNew2\u0026#39; test.txt # 在第 3 行后插入多行内容,中间的\\n 表示换行 将包含 the 的行迁移至文件末尾，{ ; }用于多个操作。 将第 1~2 行内容转移至第 5 行后。 将包含 the 的行另存为文件 out.file。 在第 3 行后插入一个新行，内容为 NEW。 2.12.5 总结 # sed 命令，主要用于修改配置文件中的内容，通过 -i 选项，可以使得文件修改内容生效。可以结合正则表达式进行一些复杂的修改，在一键部署各种服务中，可以实现免交互，直接进行修改。\n参考 # shell之三剑客sed命令 sed 高级命令用例 "},{"id":40,"href":"/linux/docs/part2-sys-operate/2.13-cut-sort-uniq-tr/","title":"2.13 cut、sort、uniq、tr 命令","section":"第二部分 系统操作","content":" 2.13 cut、sort、uniq、tr 命令 # 2.13.1 cut # 概述 # cut 是列截取工具。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。\n如果不指定 file 参数，cut 命令将读取标准输入。必须指定 -b(字节) 、-c(字符) 或 -f(第几列) 标志之一。\n字符和字节的区别\n字节（byte）是计量单位，表示数据量多少，是计算机信息技术用于计量存储容量的一种计量单位，通常情况下 1 字节等于 8 位。 字符（character）计算机中使用的字母、数字、字和符号。 一般在英文状态下，一个字母或字符占用一个字节， 一个汉字占用两个字节 。\n常用选线 # 格式：cut [选项] [文件路径] 选项 功能 -b 按字节截取 -c 按字符截取，常用于中文 -d 指定以什么为分割符截取，默认为制表符 -f 通常和 -d 一起使用（表示截取第几列） 案例演示 # 截取 /etc/passwd 文件的中 root 用户的第 7 列（-d -f） 按字节截取（-b） 按字符截取（-c） 截取第一位是 1，不是 0。\n2.13.2 sort # 概述 # sort 是一个以行为单位对文件内容进行排序的工具，也可以根据不同的数据类型来排序。例如：数据和字符的排序就不一样。\n常用选线 # 格式：sort [选项] [文件路径] 选项 功能 -t 指定分隔符，默认使用[Tab]键或空格分隔 -k 指定排序区域，哪个区间排序 -n 按照数字进行排序，默认是以字母形式排序 -u 等同于uniq，表示相同的数据仅显示一行，注意：如果行尾有空格就去重就不成功 -r 反向排序，默认升序 -o 将排序的结果转存至指定文件 案例演示 # 不加任何选项，默认按照第一列升序，字母的话就是从 a 到 z 指定分隔符（-t），指定排序的列（-k），升序排列 指定分隔符，指定排序的列，降序排列（-r） 指定分隔符，指定排序的列，降序排列，并将排序后的内容输入到/home/ydq/ydq.txt中（-o） 去掉文件中重复（可以是不连续的）的行（-u） 2.13.3 uniq # 概述 # uniq 主要用于去除连续的重复行，注意，是连续的行。通常和 sort 结合使用，先排序使之变成连续的行，再执行去重操作，否则不连续的重复行它不能去重。\n常用选线 # 不加选项的话，是直接去掉重复的行。\n格式：uniq [选项] 文件路径 选项 功能 -c 统计重复的行（在它前面标上重复的次数） -d 仅显示重复的行 -u 仅显示出现一次的行（不重复的行） 案例演示 # 统计连续重复的行（-c） 显示连续重复的行（-d），显示不连续重复的行（-u） 查看当前登录用户，去掉重复的行 统计历史登录过系统的用户 2.13.4 tr # tr 是修改工具，可以转换或删除文件中的字符。\n概述 # 可以用一个字符来替换另一个字符 可以完全除去一些字符 可以用来去掉重复的字符 从标准输入中替换，缩减和注释或删除字符，并将结果写到标准输出 常用选线 # 从标准输入中替换、缩减和/或删除字符，并将结果写到标准输出。\n格式： tr [选项] \u0026#39;字符集1\u0026#39; \u0026#39;字符集2\u0026#39; 选项 功能 -d 删除字符 -s 删除所有重复出现的字符，只保留一个（如果是空行，全部去掉） 案例演示 # 将所有小写的改成大写 替换字母，一一对应替换 替换字符，不是一一对应 将字符替换成特殊字符 删除字符（-d） 对字符去重（-s） 去掉所有的空行 2.13.5 面试题 # 1. 统计当前连接主机数 # 2. 统计当前主机的连接状态 # 2.13.6 总结 # cut ：表示截取列 # 可以按照字符（-c）按照字节（-b）或者根据分割符（-d）来选取要截取的列（-f）。\nsort：表示排序 # 默认以字母排序，数字排序需要加选项（-n），反向排序需要加选项（-r）。 还可以选择按照哪一列进行排序，需要先定义分割符（-t），然后根据分割符去选取对应的列（-k），最后进行排序。 可以将排序后的内容输入到其它文件，使用选项（-o）可以指定需要注入的文件名。 还可以将进行去重（-u），可以是不连续的行，进行去重。 uniq：表示去重 # 主要注意的是它必须是连续的行，不然无法去重 可以根据选项，选择显示不重复的行（-u） 还可以选择显示重复的行（-d） 还可以统计连续重复的数量（-c） tr：表示修改字符 # 可以修改对应的字符，按照字符对应一一修改，如果有重复的字符，它会按照最后一个字符对应的修改字符进行替换，如果对应的字符不够时，它会将修改的最后一个字符进替换。 还可以进行删除（-d），删除文本中所对应的字符 还可以进行去重（-s），但是去重的字符必须是连续在一起的两个字符（会保留其中一个），不然无法去重成功。 参考 # shell之常用工具（cut、sort、uniq、tr） "},{"id":41,"href":"/linux/docs/","title":"Docs","section":"简介","content":""}]