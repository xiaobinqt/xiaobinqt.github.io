<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>简介 on Linux 学习笔记</title>
    <link>https://example.com/linux/</link>
    <description>Recent content in 简介 on Linux 学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <atom:link href="https://example.com/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1.1 操作系统</title>
      <link>https://example.com/linux/docs/part1-primary/1.1-operating-system/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part1-primary/1.1-operating-system/</guid>
      <description>1.1 操作系统 # 1.1.1 基本特征 # 1. 并发 # 并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。
并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。
操作系统通过引入进程和线程，使得程序能够并发运行。
2. 共享 # 共享是指系统中的资源可以被多个并发进程共同使用。
有两种共享方式：互斥共享和同时共享。
互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。
3. 虚拟 # 虚拟技术把一个物理实体转换为多个逻辑实体。
主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。
多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。
虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。
4. 异步 # 异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。
1.1.2 基本功能 # 1. 进程管理 # 进程控制、进程同步、进程通信、死锁处理、处理机调度等。
2. 内存管理 # 内存分配、地址映射、内存保护与共享、虚拟内存等。
3. 文件管理 # 文件存储空间的管理、目录管理、文件读写管理和保护等。
4. 设备管理 # 完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。
主要包括缓冲管理、设备分配、设备处理、虛拟设备等。
1.2.3 系统调用 # 如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。
Linux 的系统调用主要有以下这些：
Task Commands 进程控制 fork(); exit(); wait(); 进程通信 pipe(); shmget(); mmap(); 文件操作 open(); read(); write(); 设备操作 ioctl(); read(); write(); 信息维护 getpid(); alarm(); sleep(); 安全 chmod(); umask(); chown(); 1.</description>
    </item>
    <item>
      <title>3.1 网络</title>
      <link>https://example.com/linux/docs/part3-sys-manage/3.1-network/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part3-sys-manage/3.1-network/</guid>
      <description>3.1 网络 # 3.1.1 网络状态 # net-tools &amp;amp; iproute # Centos 7 之前一般使用 net-tools，Centos 7 之后主推 iproute / iproute2。
ifconfig # eth0 第一块网卡（网络接口)。很多时候，第一个网络接口也可能叫做下面的名字：
eno1 板载网卡 ens33 PCI-E网卡 enp0s3 无法获取物理信息的PCI-E网卡 CentOS 7 使用了一致性网络设备命名，以上都不匹配则使用 eth0。
网关/路由 # route -n 使用-n参数不解析主机名，因为默认每个 ip 都会反解成域名，如果解析耗时会一直等待。
网卡物理连接情况 # 在 Centos 6 上可以直接输入mii-tool回车，但是 Centos 7 上必须要加上网络接口名。
因为用的是虚拟机，所以会有 SIOCGMIIPHY on &amp;rsquo;eth0&amp;rsquo; failed: Operation not supported 错误
网络接口/网卡名称修改 # 网卡命名规则受 biosdevname 和 net.ifnames 两个参数影响。
biosdevname net.ifnames 网卡名 默认 0 1 ens33 组合1 1 0 em1 组合2 0 0 eth0 编辑/etc/default/grub文件，在 GRUB_CMDLINE_LINUX 中增加biosdevname=0 net.</description>
    </item>
    <item>
      <title>4.1 Shell 简介</title>
      <link>https://example.com/linux/docs/part4-shell/4.1-introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part4-shell/4.1-introduction/</guid>
      <description>4.1 Shell 简介 # Shell 是命令解释器，用于解释用户对操作系统的操作。CentOS7 默认使用的 Shell 是 bash。
Shell 有很多可以再 /etc/shells 文件中查看：
4.1.1 脚本格式 # UNIX 的哲学：一条命令只做一件事。为了组合命令和多次执行，使用脚本文件来保存需要执行的命令，并赋予该文件执行权限（chmod u+rx filename）。如果是二进制文件只需要一个可执性权限，如果是脚本文件需要可读和可执行权限。
Sha-Bang # 在 shell 脚本中，Sha-Bang（也称为 Shebang 或 Hashbang）是指位于脚本文件的第一行的特殊注释。它的形式是以井号 # 开头，紧随其后是一个叹号 !，再加上一个可执行程序的路径。
下面是一个典型的 Sha-Bang 行示例：
#!/bin/bash 在上述示例中，#!/bin/bash 是一个 Sha-Bang 行。其中 #!/bin/ 是固定的前缀，用于告诉系统该文件是一个可执行文件，接下来的 bash 是解释器的路径，表示使用 Bash 解释器来执行该脚本。
Sha-Bang 行的作用是指定脚本所需的解释器。当在命令行中运行脚本文件时，操作系统会读取脚本文件的第一行，根据其中的 Sha-Bang 行来确定要使用的解释器，并将该解释器用于执行该脚本。
除了 #!/bin/bash，还可以使用其他解释器路径，如 /bin/sh、/usr/bin/env python 等，根据脚本的需求选择适当的解释器。
需要注意的是，Sha-Bang 行必须位于脚本文件的第一行，否则它将不会被正确解析。同时，脚本文件需要具有执行权限才能被执行。
4.1.2 不同执行方式 # 脚本的执行方式大致有以下几种：
# bash 执行不需要赋予执行权限 bash ./filename.sh # 需要有执行权限 ./filename.sh source .</description>
    </item>
    <item>
      <title>5.1 正则表达式</title>
      <link>https://example.com/linux/docs/part5-text-operate/5.1-regular/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part5-text-operate/5.1-regular/</guid>
      <description>5.1 正则表达式 # 5.1.1 元字符 # 元字符是正则表达式中具有特殊含义的字符。它们用于表示模式的不同部分或进行模式匹配的控制。常见的元字符包括：
. 匹配除换行符外的任意单个字符 * 匹配前面的元素零次或多次 [] 匹配方括号中的字符类中的任意一个 ^ 匹配开头 $ 匹配结尾 \ 转义后面的特殊字符 + 匹配前面的元素一次或多次 ? 匹配前面的元素零次或一次 | 匹配它前面或后面的正则表达式 5.1.2 通配符 # 通配符是在文件系统中使用的一种模式匹配机制。它用于匹配文件名或路径的模式。常见的通配符包括：
* 匹配任意长度的任意字符。 ? 匹配单个字符。 [&amp;hellip;]（方括号）：定义一个字符集，匹配括号内的任意一个字符。 通配符主要用于文件名的模式匹配，例如在命令行中使用 ls 或 find 命令时，可以使用通配符来筛选文件名。
5.1.3 find 命令 # find 主要是在目录中查找指定文件，可以结合正则表达式实现复杂的查找功能。
find 支持正则可以使用 -regex：
find /etc/ -regex .*wd$ -type d 查找目录，-type f 查找文件：</description>
    </item>
    <item>
      <title>6.1 防火墙</title>
      <link>https://example.com/linux/docs/part6-service-manage/6.1-firewall/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part6-service-manage/6.1-firewall/</guid>
      <description>6.1 防火墙 # 6.1.1 分类 # 软件防火墙和硬件防火墙是两种常见的网络安全设备或软件，用于保护计算机系统和网络免受未授权访问、恶意攻击和网络威胁等。
软件防火墙（Software Firewall）： 软件防火墙是一种安装在计算机系统上的软件应用程序，用于监控和控制网络流量。它可以通过检查网络数据包的来源、目的地、协议和端口等信息，来判断是否允许或阻止数据包的传输。软件防火墙通常运行在操作系统的网络协议栈之上，能够保护单个计算机系统或网络中的特定主机。常见的软件防火墙包括Windows防火墙、IPTables、NetFilter等。
硬件防火墙（Hardware Firewall）： 硬件防火墙是一种独立的物理设备，专门用于网络安全防护。它通常部署在网络的边界位置，作为网络流量的第一道防线。硬件防火墙通过硬件和专用的嵌入式软件来执行数据包过滤和访问控制。它可以监控和检测网络流量，并根据预先定义的规则和策略来允许或阻止数据包的传输。硬件防火墙通常具有更高的性能和吞吐量，并且对于整个网络中的所有主机都提供保护。常见的硬件防火墙包括 Cisco ASA、Palo Alto Networks、Fortinet 等。
包过滤防火墙（Packet Filtering Firewall）和应用层防火墙（Application Layer Firewall）是防火墙的两种不同类型：
包过滤防火墙： 包过滤防火墙是一种基于网络数据包的源地址、目的地址、端口号和协议等信息进行过滤和控制的防火墙。它工作在网络协议栈的较低层，可以根据预定义的规则，对数据包进行简单的检查和处理。包过滤防火墙通常比较高效，并且适用于处理大量数据包的情况。但它的检查范围相对较窄，仅能检查和过滤网络层（IP层）和传输层（TCP/UDP层）的信息。
应用层防火墙： 应用层防火墙是一种工作在网络协议栈较高层的防火墙，它能够检查和过滤网络流量中的应用层数据，如 HTTP、FTP、SMTP 等协议的内容。应用层防火墙能够深入检查数据包的有效载荷，根据应用层协议的特征和规则来判断和阻止恶意行为。它提供了更高级的安全功能，如访问控制、应用程序识别、反病毒扫描、入侵检测等。然而，相对于包过滤防火墙，应用层防火墙的处理开销较大，对性能有一定的影响。
综上，软件防火墙和硬件防火墙是不同类型的防火墙设备或软件，而包过滤防火墙和应用层防火墙是防火墙的两种不同功能和层次的分类。它们的选择和使用取决于网络环境、安全需求和性能要求。
iptables # iptables 是一个软件防火墙，而不是硬件防火墙，提供了对 Linux 内核网络层的访问控制和数据包过滤的功能。
iptables 可以通过定义规则集来控制传入、传出和转发的网络流量。这些规则可以基于源 IP 地址、目标 IP 地址、协议、端口号等条件进行过滤和操作。使用 iptables 可以实现诸如网络地址转换（NAT）、端口转发、数据包屏蔽、阻止 DoS（拒绝服务）攻击等功能。
iptables 的工作方式是通过配置 iptables 规则表来匹配和处理网络数据包。常见的 iptables 规则表包括 filter 表（用于过滤数据包）、nat 表（用于网络地址转换）和 mangle 表（用于特殊处理数据包）。管理员可以使用命令行界面（CLI）或脚本来配置和管理 iptables。
尽管 iptables 是一个软件防火墙，但它在 Linux 系统中可以与硬件防火墙配合使用。在网络架构中，可以将 Linux 服务器作为边界设备放置在硬件防火墙之后，并使用 iptables 来增强安全性和网络流量控制。这种组合的优势是，硬件防火墙负责网络的第一道防线，而 iptables 在服务器本身提供了更细粒度的流量控制和策略定制能力。
CentOS 6 默认的防火墙是 iptables。CentOS 7 默认的防火墙是 firewallD（底层使用 netfilter）。</description>
    </item>
    <item>
      <title>7.1 命令相关</title>
      <link>https://example.com/linux/docs/part7-faq/7.1-cmd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part7-faq/7.1-cmd/</guid>
      <description>7.1 命令相关 # 7.1.1 du ls 对于查看文件大小的区别 # ls -lh 和 du 命令都可以查看文件，但是 du 查看的实际文件大小，ls 查看的文件大小可能包含空洞。
afile 文件没有空洞，ls 和 du 显示的文件大小都是 40M。
bfile 在写入的时候由于跳过了 20*4=80M，所以这 80M 是空洞文件，那么 ls 和 du 最后显示的结果就会不一样。</description>
    </item>
    <item>
      <title>1.2 总览</title>
      <link>https://example.com/linux/docs/part1-primary/1.2-overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part1-primary/1.2-overview/</guid>
      <description>1.2 总览 # 1.2.1 常用操作以及概念 # 快捷键 # Tab：命令和文件名补全； Ctrl+C：中断正在运行的程序； Ctrl+D：结束键盘输入（End Of File，EOF） 求助 # 1. &amp;ndash;help # 指令的基本用法与选项介绍。
2. man # man 是 manual 的缩写，将指令的具体信息显示出来。
当执行man date时，有 DATE(1) 出现，其中的数字代表指令的类型，常用的数字及其类型如下：
代号 类型 1 用户在 shell 环境中可以操作的指令或者可执行文件 5 配置文件 8 系统管理员可以使用的管理指令 3. info # info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以跳转。
4. doc # /usr/share/doc 存放着软件的一整套说明文件。
关机 # 1. who # 在关机前需要先使用 who 命令查看有没有其它用户在线。
2. sync # 为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作。
3. shutdown # ## shutdown [-krhc] 时间 [信息] -k ： 不会关机，只是发送警告信息，通知所有在线的用户 -r ： 将系统的服务停掉后就重新启动 -h ： 将系统的服务停掉后就立即关机 -c ： 取消已经在进行的 shutdown PATH # 可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔。</description>
    </item>
    <item>
      <title>2.1 帮助命令</title>
      <link>https://example.com/linux/docs/part2-sys-operate/2.1-help/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part2-sys-operate/2.1-help/</guid>
      <description>2.1 帮助命令 # 2.1.1 man # man 命令有很多 section，可以通过man man 查看，如下：
man 1 可以省略 1 表示查看可执行程序或 shell 命令，如man ls。
如果想要通过 man 查看文件的说明，可以使用man 5，比如 passwd 可以是一个系统命令也可以是一个配置文件/etc/passwd，那么man passwd 就是查看这个系统命令的说明，man 5 passwd就是查看/etc/passwd这个配置文件的说明。
当不知道查看的是命令还是文件时可以使用man -a 关键字，比如man -a passwd，这样就会把所有的说明都列出来。
2.1.2 help # shell（命令解释器）自带的命令称为内部命令，其他的是外部命令。可以用type 命令知道这个命令是内部命令还是外部命令。
内部命令使用 help 帮助：help 命令
外部命令使用 help 帮助：命令 --help
2.1.3 info # info 帮助比 help 更详细，可以作为 help 的补充。</description>
    </item>
    <item>
      <title>2.2 ls 命令</title>
      <link>https://example.com/linux/docs/part2-sys-operate/2.2-ls/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part2-sys-operate/2.2-ls/</guid>
      <description>2.2 ls 命令 # ls 可以查看多个目录，如
ls /root / 查看/root目录和/目录内容。
2.2.1 常用选项 # -l 选项 # 单列输出。
-a 选项 # 查看所有
-r 选项 # 逆序排序，默认按文件名逆序。
-t 选项 # 按时间信息排序。比如按时间逆序可以使用ls -lrt。
-R 选项 # 递归列出全部目录的内容。
-h 选项 # -h参数是更加人性化打印文件的尺寸大小，单位是G，M，K，否则显示文件的字节大小。
如果只用ls -h是看不见文件或者目录大小的，必须加上ls -lh。
du 命令同样可以显示文件大小，但是 du 命令显示的实际文件大小，ls 显示的文件大小可能包含空洞。
-d 选项 # 将目录名像其它文件一样列出，而不是列出它们的内容。</description>
    </item>
    <item>
      <title>3.2 网络故障排除</title>
      <link>https://example.com/linux/docs/part3-sys-manage/3.2-net-trouble-removal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part3-sys-manage/3.2-net-trouble-removal/</guid>
      <description>3.2 网络故障排除 # 3.2.1 ping # 测试主机之间网络的连通性。
-c 参数 # 设置完成要求回应的次数。
3.2.2 traceroute # 3.2.3 mtr # 3.2.4 nslookup # 3.2.4 telnet # 端口是否畅通 # telnet www.baidu.com 80 # 我当前主机到对方主机的 80 端口是否畅通 3.2.5 tcpdump # tcpdump -i any -n port 80 -i 选线 # 指定网卡，可以用 -i any 表示所有网卡或是-i eth0指定网络接口/网卡的数据包。如果不指定网卡，默认 tcpdump 只会监视第一个网络接口，一般是 eth0。
-n 选项 # 不要使用域名的形式进行显示。
port # 指定端口。
指定主机和端口 # tcpdump -i any -n host 10.0.0.1 and port 80 tcpdump -i any -n host 10.</description>
    </item>
    <item>
      <title>4.2 环境变量</title>
      <link>https://example.com/linux/docs/part4-shell/4.2-env-config-file/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part4-shell/4.2-env-config-file/</guid>
      <description>4.2 环境变量 # 4.2.1 系统环境变量 # 环境变量是每个 Shel 打开都可以直接获得到的变量。
env 命令可以查看所有已经存在的环境变量。
set 可以查看到比 env 更多的环境变量，包括预定义变量。
$PATH 是命令搜索路径，如果使用的命令不在 $PATH 下就需要使用完整路径。
$? 可以查看上一条命令是否执行成功，成为返回 0
$$ 查看当前进程的 PID
$0 查看当前执行的脚本或程序的名称。
位置参数 # $1,$2 ,...., $9,${10} ... ${2-_} 表示变量替换，意思是，如果 $2 不为空就取 $2，如果为空就是 _。
$PS1 # $PS1 用于定义 Unix 或类 Unix 操作系统中的命令行提示符。它控制着命令行界面（shell）中显示的每个命令行的外观和格式。用于设置主提示符（primary prompt）。主提示符通常在每个命令行的开始处显示，并用于指示用户输入命令。
$PS1 的值可以包含一些特殊的转义字符和变量，以便在提示符中插入特定的信息，例如当前用户名、主机名、当前工作目录等。
下面是一个示例，展示如何设置 $PS1 变量来定义自定义的命令行提示符：
# 设置自定义的命令行提示符 export PS1=&amp;#34;\u@\h:\w\$ &amp;#34; # 示例输出：user@hostname:/current/path$ 在上述示例中，$PS1 的值为 &amp;quot;\u@\h:\w\$ &amp;quot;，其中：
\u 表示当前用户名 \h 表示当前主机名 \w 表示当前工作目录 \$ 表示一个符号（$ 表示普通用户，# 表示超级用户） 命令行提示符的格式将会显示为 user@hostname:/current/path$，其中 user 是当前用户名，hostname 是当前主机名，/current/path 是当前工作目录。</description>
    </item>
    <item>
      <title>5.2 sed 命令</title>
      <link>https://example.com/linux/docs/part5-text-operate/5.2-sed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part5-text-operate/5.2-sed/</guid>
      <description>5.2 sed 命令 # 5.2.1 简介 # sed（stream EDitor）是一个强大而简单的文本解析转换工具，可以读取文本，并根据指定的条件对文本内容进行编辑（删除、替换，添加、移动等），最后输出所有行或仅输出处理的某些行。
sed 也可以在无交互的情况下实现相当复杂的文本处理操作，将不规范的文本，处理为 “比较规范” 的文本，被广泛应用于 shell 脚本中，用以完成各种自动化处理任务。
sed 的工作流程主要包括读取、执行和显示三个过程：
读取： sed 从输入流（文件、管道、标准输入）中读取一行内容并存储到临时的缓冲区（又称模式空间）。 执行： 默认情况下，所有的 sed 命令都在模式空间中顺序地执行，除非指定了行的地址，否则 sed 命令将会在所有行上一次执行。 显示： 发送修改后的内容到输出流，在发送数据后，模式空间将会被清空。 在所有的文件内容都被处理完成之前，上述过程将重复执行，直至所有内容被处理完。
默认情况下所有的 sed 命令，都是在模式空间内执行的，因此输入的文件并不会发生变化。
5.2.2 选项操作 # 通常情况下调用 sed 命令有两种格式。
“参数” 是指操作的目标文件，当存在多个操作对象时，文件之间用逗号分隔。 sed [选项] &amp;#39;操作&amp;#39; 参数 scriptfile 表示脚本文件，需要用-f选项指定，当脚本文件出现在目标文件之前时，表示通过指定的脚本文件来处理输入的目标文件。 sed [选项] -f scriptfile 参数 常见选项 # 选项 功能 -e 表示用指定命令或者脚本来处理输入的文本文件 -f 表示用指定的脚本文件来处理输入的文本文件 -h 显示帮助 -n 表示仅显示处理后的结果 -i 直接编辑文本文件 -r 或 -E 使用扩展正则表达式 -s 将多个文件视为独立文件，而不是单个连续的长文件流 操作指令 # 「操作」用于指定文件对操作的动作行为，也就是 sed 的命令。</description>
    </item>
    <item>
      <title>6.2 ssh</title>
      <link>https://example.com/linux/docs/part6-service-manage/6.2-ssh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part6-service-manage/6.2-ssh/</guid>
      <description>6.2 ssh # 6.2.1 ssh 和 telnet # SSH（Secure Shell）和 Telnet 是两种用于远程登录和管理计算机系统的网络协议，它们在功能和安全性方面存在一些重要的区别。
Telnet 是一种最早的远程登录协议，它使用明文传输数据，包括用户名和密码等敏感信息。由于数据不加密，Telnet 协议在传输过程中容易受到网络嗅探和中间人攻击的风险。因此，Telnet 在现代网络环境中很少使用，主要用于一些特殊的应用场景或旧版系统的维护。
SSH 是一种安全的远程登录协议，它通过加密传输数据，提供了更高的安全性。SSH 使用公钥加密和对称密钥加密的组合，可以保护登录过程中传输的用户名、密码和其他敏感数据。由于 SSH 使用加密技术，网络嗅探和中间人攻击对SSH连接的影响较小。
相比之下，Telne t的主要优点是简单易用，而 SSH 则提供了更高的安全性和功能。SSH 不仅可以进行远程登录，还可以在远程计算机上执行命令、传输文件和建立安全的远程连接。SSH 广泛应用于服务器管理、远程维护和安全通信等领域。
总结来说，Telnet 是一种不安全的远程登录协议，而 SSH 是一种安全的替代方案。在现代网络环境中，建议使用 SSH 来进行远程登录和管理计算机系统，以保护数据的安全性。
6.2.2 telnet 使用 # # 安装客户端 yum install telnet -y # 安装服务端 yum install telnet-server xinetd -y # 启动 telnet 服务 systemctl start xinetd.service systemctl start telnet.socket # 登录 telnet # telnet ip telnet 192.168.14.12 在用 telnet 登录尽量使用非 root 用户，因为 telnet 传输是明文的，在有些情况下 root 用户登录是被限制的。</description>
    </item>
    <item>
      <title>1.3 常见目录</title>
      <link>https://example.com/linux/docs/part1-primary/1.3-common-dir/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part1-primary/1.3-common-dir/</guid>
      <description> 1.3 常见目录 # / # 根目录 ├── /root # root 用户家目录 ├── /home/username # 普通用户家目录 ├── /etc # 配置文件目录 ├── /bin # 命令目录 ├── /sbib # 管理命令目录 ├── /usr/bin # 系统预装的其他命令 └── /usr/sbin # 系统预装的其他命令 </description>
    </item>
    <item>
      <title>2.3 关机</title>
      <link>https://example.com/linux/docs/part2-sys-operate/2.3-shutdown/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part2-sys-operate/2.3-shutdown/</guid>
      <description> 2.3 关机 # 1. who # 在关机前需要先使用 who 命令查看有没有其它用户在线。
2. sync # 为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作。
3. shutdown # ## shutdown [-krhc] 时间 [信息] -k ： 不会关机，只是发送警告信息，通知所有在线的用户 -r ： 将系统的服务停掉后就重新启动 -h ： 将系统的服务停掉后就立即关机 -c ： 取消已经在进行的 shutdown 参考 # Linux命令之关机shutdown </description>
    </item>
    <item>
      <title>3.3 网络服务管理</title>
      <link>https://example.com/linux/docs/part3-sys-manage/3.3-net-manage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part3-sys-manage/3.3-net-manage/</guid>
      <description> 3.3 网络服务管理 # 网络管理工具常用的有 2 套，一个是 network，另一个是 networkManger。在 Centos 6 中只有 network，在某些 Centos 7 机器中可能 2 套都存在，不要把 2 套工具都 enable，在工作中，一般只用一个禁用另外一个。
systemctl disable NetworkManager systemctl enable NetworkManager service network status service network restart 一般在服务器上常用 network 工具。networkManager 常用在个人电脑上。
3.3.1 设置主机名 # 临时修改主机名：hostname 临时主机名 系统重启后会被重置。
永久修改主机名：hostnamectl 永久主机名 是对 /etc/hostname 文件的内容进行修改。
3.3.1 service # 参考 # linux下/etc/hosts 和hostname文件的区别 </description>
    </item>
    <item>
      <title>4.3 数组</title>
      <link>https://example.com/linux/docs/part4-shell/4.3-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part4-shell/4.3-array/</guid>
      <description> 4.3 数组 # 定义数组 IPTS=(10.0.0.1 10.0.0.2 10.0.0.3) 显示数组的所有元素 echo ${IPTS[@]} 显示数组元素个数 echo ${#PTS[@]} 显示数组的第一个元素 echo $IPTS[0]) </description>
    </item>
    <item>
      <title>5.3 awk 命令</title>
      <link>https://example.com/linux/docs/part5-text-operate/5.3-awk/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part5-text-operate/5.3-awk/</guid>
      <description>5.3 awk 命令 # awk 是一种处理文本文件的语言，是一个强大的文件分析工具。常用于处理 “比较规范” 的文本处理，统计数量并输出指定字段。
awk 比较倾向于将一行分成多个 “字段” 进行处理。awk 信息的读入是逐行读取的，执行结果可以通过 print 将字段数据打印显示。在使用 awk 命令的过程中，可以使用逻辑操作符，&amp;amp;&amp;amp;、|| 、!，还可以进行简单的数学运算，如+、-、*、/、%、^分别表示加、减、乘、除、取余和乘方。
5.3.1 使用格式 # awk 「选项」 &amp;#39;模式或条件{操作}&amp;#39; 文件名 # 格式1 awk -f 脚本文件 文件名 # 格式2 5.3.2 内置变量 # 内置变量 功能 NF 当前处理的行的字段个数（就是：有多少列） NR 当前处理的行的行号（就是：有多少行） FNR 读取文件的记录数（行号），从1开始，新的文件重新从1开始计数 $0 当前处理的行的整行内容（就是：表示一行的内容） $n 当前处理行的第n个字段（就是：第n列） FILENAME 被处理的文件名 FS 指定每行的字段分隔符，默认为空格或制表位（相当于选项 -F ） OFS 输出字段的分隔符，默认也是空格 RS 行分割符。awk 从文件上读取资料时，将根据 RS 的定义把资料切割成许多条记录，而 awk 一次仅读取一条记录，预设值是\n ORS 输出分割符，默认也是换行符 $n 用法 # n 为数字，数字为几就表示第几列。</description>
    </item>
    <item>
      <title>6.3 ftp</title>
      <link>https://example.com/linux/docs/part6-service-manage/6.3-ftp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part6-service-manage/6.3-ftp/</guid>
      <description>6.3 ftp # 6.3.1 协议介绍 # FTP（File Transfer Protocol）是一种用于在计算机网络上进行文件传输的标准协议。它使用客户端-服务器模型，在客户端和服务器之间进行文件传输和交互。
FTP 协议定义了一套命令和响应规范，用于控制和管理文件传输过程。它支持用户身份验证、目录浏览、文件上传和下载等操作。
在 FTP 中，存在两种模式来建立数据连接：主动（Active）模式和被动（Passive）模式。
主动模式（Active Mode）：
在主动模式下，FTP 客户端使用随机生成的端口（通常大于1024）向服务器的默认 FTP 数据端口（端口20）发起连接。 FTP 客户端发送一个 PORT 命令，其中包含客户端的 IP 地址和数据端口号。 FTP 服务器使用它的默认控制端口（端口21）向 FTP 客户端的指定数据端口发起连接，以建立数据连接，并进行文件传输。 主动模式需要 FTP 服务器能够主动连接 FTP 客户端，因此 FTP 服务器通常需要允许外部访问，并配置防火墙和 NAT 设备以允许数据连接。 被动模式（Passive Mode）：
在被动模式下，FTP 客户端发送 PASV 命令给 FTP 服务器，请求进入被动模式。 FTP 服务器在一个固定的范围内选择一个可用的端口（通常大于1024），并将其作为数据端口。 FTP 服务器将自己的 IP 地址和数据端口作为响应发送给FTP客户端。 FTP 客户端使用这个 IP 地址和数据端口发起连接，以建立数据连接，并进行文件传输。 被动模式适用于FTP客户端位于防火墙或 NAT 后面的情况，因为它不需要FTP服务器主动连接FTP客户端。 总结来说，主动模式和被动模式是 FTP 用于建立数据连接的两种不同方式。主动模式要求 FTP 服务器主动连接 FTP 客户端，而被动模式则允许 FTP 客户端主动连接 FTP 服务器。在配置 FTP 服务器和网络环境时，需要根据具体情况选择适合的模式，并确保防火墙和 NAT 设备正确配置以允许数据连接的建立。</description>
    </item>
    <item>
      <title>1.4 进程管理</title>
      <link>https://example.com/linux/docs/part1-primary/1.4-process-manage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part1-primary/1.4-process-manage/</guid>
      <description>1.4 进程管理 # 1.4.1 进程与线程 # 1. 进程 # 进程是资源分配的基本单位。
进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。
下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。
2. 线程 # 线程是独立调度的基本单位。
一个进程中可以有多个线程，它们共享进程资源。
QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。
3. 区别 # Ⅰ 拥有资源 # 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
Ⅱ 调度 # 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
Ⅲ 系统开销 # 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
Ⅳ 通信方面 # 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC（Inter-Process Communication，进程间通信）。
1.4.2 进程状态的切换 # 就绪状态（ready）：等待被调度 运行状态（running） 阻塞状态（waiting）：等待资源 应该注意以下内容：</description>
    </item>
    <item>
      <title>2.4 cp 命令</title>
      <link>https://example.com/linux/docs/part2-sys-operate/2.4-cp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part2-sys-operate/2.4-cp/</guid>
      <description>2.4 cp 命令 # 将源文件或目录复制到目标文件或目录中。
2.4.1 常用选项 # -p 选项 # 在复制文件后，文件的时间会发生变化，属主也有可能会发生变化。-p可以保留源文件或目录的属性。
-a 选项 # 在复制文件后，权限，属主和时间都不发生变化。
-f 选项 # 强行复制文件或目录，不论目标文件或目录是否已存在。
-r 选项 # 递归处理，将指定目录下的所有文件与子目录一并处理。</description>
    </item>
    <item>
      <title>3.4 软件安装</title>
      <link>https://example.com/linux/docs/part3-sys-manage/3.4-soft-install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part3-sys-manage/3.4-soft-install/</guid>
      <description>3.4 软件安装 # 3.4.1 软件包管理器 # 包管理器是方便软件安装、卸载，解决软件依赖关系的重要工具。
CentOS、RedHat 使用 yum 包管理器，软件安装包格式为 rpm。 Debian、Ubuntu 使用 apt 包管理器，软件安装包格式为 deb。 3.4.2 rpm 包和 rpm 命令 # 包格式 # 命令常用参数 # -q 查询软件包，-qa 查看所有。 rpm -qa -i 安装软件包
-e 卸载软件包
问题 # 使用 rpm 时需要手动解决依赖关系，在实际应用中用的不多，常用 yum 命令安装。软件包来源不可靠。
3.4.3 yum 仓库 # 修改 yum 源 # 阿里巴巴官方镜像站 https://developer.aliyun.com/mirror/
经常需要安装 epel 来扩展 yum 仓库源，不常见的一些软件可以通过 epel 仓库来安装：
yum install epel-release -y 常用选项 # install 安装软件包 remove 卸载软件包 list | grouplist 查看软件包 update 升级软件包 yum update 如果加上软件包名会去升级指定的软件，如果什么都不加会去升级所有的软件包。</description>
    </item>
    <item>
      <title>4.4 转义和引用</title>
      <link>https://example.com/linux/docs/part4-shell/4.4-escape-quot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part4-shell/4.4-escape-quot/</guid>
      <description>4.4 转义和引用 # 4.4.1 特殊字符 # 一个字符不仅有字面意义，还有元意（meta-meaning）
# 注释 ; 分号 \ 转义符号 “ 和 &amp;rsquo; 引号 引号 # &amp;rsquo; 单引号，完全引用。
&amp;quot; 双引号，不完全引用，变量会进行解释。
` 反引号，执行命令
括号 # ()，(())，$() 圆括号 单独使用圆括号会产生一个子 shell (yz=123)
数组初始化 lPS=(ip1 ip2 ip3)
[]，[[]] 方括号 []（方括号）是传统的条件测试语法，也被称为单方括号条件测试。它执行基本的条件测试，主要用于进行字符串比较和数值比较。例如，可以来检查两个字符串是否相等，或者一个数值是否大于另一个数值。
[[]]（双方括号）是高级的条件测试语法，也被称为双方括号条件测试。它是 Bash shell 的扩展功能，提供了更多的条件测试选项和功能。它支持字符串比较、模式匹配、正则表达式匹配、文件匹配等更复杂的条件测试。此外，双方括号还提供了更灵活的逻辑运算符和字符串操作符。
在使用条件测试时，以下是一些[]和[[]]的区别和注意事项：
[] 需要在参数和操作符周围使用空格，而 [[]] 不需要使用空格。
[] 是 POSIX 标准的一部分，因此在大多数 Shell 中都可以使用。而 [[]] 是 Bash shell 的扩展功能，只能在 Bash 或兼容 Bash 的 Shell 中使用。
[] 使用标准的文本模式匹配，而 [[]] 支持更灵活的模式匹配，如通配符模式 * 和 ?</description>
    </item>
    <item>
      <title>5.4 cut、sort、uniq、tr 命令</title>
      <link>https://example.com/linux/docs/part5-text-operate/5.4-cut-sort-uniq-tr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part5-text-operate/5.4-cut-sort-uniq-tr/</guid>
      <description>5.4 cut、sort、uniq、tr 命令 # 5.4.1 cut # 概述 # cut 是列截取工具。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。
如果不指定 file 参数，cut 命令将读取标准输入。必须指定 -b(字节) 、-c(字符) 或 -f(第几列) 标志之一。
字符和字节的区别
字节（byte）是计量单位，表示数据量多少，是计算机信息技术用于计量存储容量的一种计量单位，通常情况下 1 字节等于 8 位。 字符（character）计算机中使用的字母、数字、字和符号。 一般在英文状态下，一个字母或字符占用一个字节， 一个汉字占用两个字节 。
常用选线 # 格式：cut [选项] [文件路径] 选项 功能 -b 按字节截取 -c 按字符截取，常用于中文 -d 指定以什么为分割符截取，默认为制表符 -f 通常和 -d 一起使用（表示截取第几列） 案例演示 # 截取 /etc/passwd 文件的中 root 用户的第 7 列（-d -f） 按字节截取（-b） 按字符截取（-c） 截取第一位是 1，不是 0。
5.4.2 sort # 概述 # sort 是一个以行为单位对文件内容进行排序的工具，也可以根据不同的数据类型来排序。例如：数据和字符的排序就不一样。</description>
    </item>
    <item>
      <title>6.4 samba</title>
      <link>https://example.com/linux/docs/part6-service-manage/6.4-samba/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part6-service-manage/6.4-samba/</guid>
      <description>6.4 samba # 6.4.1 简介 # Samba 是一个开源软件套件，用于在 Linux 和 UNIX 系统上实现文件和打印机共享。它允许 Linux/UNIX 系统与 Windows 操作系统之间进行文件和资源共享，使得 Linux/UNIX 系统可以像 Windows 一样访问和使用网络共享资源。
Samba 提供了 SMB/CIFS（Server Message Block/Common Internet File System）协议的实现，这是 Windows 操作系统中用于文件和打印机共享的标准协议。通过 Samba，Linux/UNIX 系统可以作为 SMB/CIFS 服务器或客户端，与 Windows 系统进行通信。
以下是 Samba 的一些主要特点和用途：
文件共享：Samba 允许在 Linux/UNIX 系统上共享文件和目录，并通过 SMB/CIFS 协议使其对 Windows 用户可见。这意味着 Windows 用户可以通过网络访问和操作 Linux/UNIX 系统上的共享文件。
打印机共享：Samba 还支持共享打印机，使得 Windows 用户可以通过网络连接和使用 Linux/UNIX 系统上的打印机。
用户认证和权限控制：Samba 提供了用户认证和权限控制功能，可以限制对共享资源的访问权限，确保只有经过授权的用户可以访问和修改共享文件。
集成到 Windows 域：Samba 可以作为 Windows 域控制器的替代品，提供类似于 Windows Active Directory 的用户管理和身份验证功能。</description>
    </item>
    <item>
      <title>1.5 死锁</title>
      <link>https://example.com/linux/docs/part1-primary/1.5-deadlock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part1-primary/1.5-deadlock/</guid>
      <description>1.5 死锁 # 1.5.1 必要条件 # 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。 占有和等待：已经得到了某个资源的进程可以再请求新的资源。 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 1.5.2 处理方法 # 主要有以下四种方法：
鸵鸟策略 死锁检测与死锁恢复 死锁预防 死锁避免 1.5.3 鸵鸟策略 # 把头埋在沙子里，假装根本没发生问题。
因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。
当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。
大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。
1.5.4 死锁检测与死锁恢复 # 不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。
1. 每种类型一个资源的死锁检测 # 上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。
图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。
每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。
2. 每种类型多个资源的死锁检测 # 上图中，有三个进程四个资源，每个数据代表的含义如下：
E 向量：资源总量 A 向量：资源剩余量 C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量 R 矩阵：每个进程请求的资源数量 进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</description>
    </item>
    <item>
      <title>2.5 文件查看命令</title>
      <link>https://example.com/linux/docs/part2-sys-operate/2.5-file-view/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part2-sys-operate/2.5-file-view/</guid>
      <description>2.5 文件查看命令 # 2.5.1 cat # 参看文件打印到标准输出。
在实践中，往往需要将 shell 脚本中的多行内容，输出到一个文本文件中。例如输出一段内容，作为一个新的脚本。举例如下：
cat &amp;gt; test.sh &amp;lt;&amp;lt;EOF this is a test this is another test this is final test EOF 在 cat 命令后面紧接着是一个重定向符 &amp;gt; 和文件名。它的作用则是将 cat 打开的文件内容输出到文件中。cat 打开的是 EOF 标记的所有内容，也就是将这些内容输出到文件中去。
输出的内容支持变量传递
# 定义变量sample she=&amp;#34;beautiful girl&amp;#34; cat &amp;gt; test.txt &amp;lt;&amp;lt;EOF this is a test this is another test this is final test I love $she EOF 2.5.1 head # 查看文件开头，比如前 5 行head -5 文件名。</description>
    </item>
    <item>
      <title>3.5 进程管理</title>
      <link>https://example.com/linux/docs/part3-sys-manage/3.5-process/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part3-sys-manage/3.5-process/</guid>
      <description>3.5 进程管理 # 进程是运行中的程序，从程序开始运行到终止的整个生命周期是可管理的。
以 C 程序为例，程序的启动是从 main 函数开始的：
int main(int agrc,char *argv[]) 程序终止的方式并不唯一，可以分为正常终止和异常终止。正常终止也分为从 main 返回、调用 exit 等方式。异常终止分为调用 abort、接收信号等。
3.5.1 进程查看 # ps # ps 可以查看当前系统的进程状态。
-e 选项 显示所有程序。
-f 选项 常搭配 -e 选项使用。显示 UID（有效用户ID），PPID（父进程）等信息，进程由哪个用户启动的，有时启动用户和运行用户可能不一样，比如 Nginx 由 root 启动，但是实际的运行身份是 nobody。
-L 选线 进程中的线程，LWP 轻量级进程也就是线程。
pstree # 如果没有 pstree 命令可以自行安装。
yum install psmisc -y top # top 可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具。
top 界面主要分为两个部分，前 5 行展示的是系统的整体性能，光标下面部分是系统中每个进程的具体信息。光标所在处是用来输入操作命令的。
系统的整体性能 # 第一行：
top - 14:39:05 up 36 days, 21:26, 3 users, load average: 56.</description>
    </item>
    <item>
      <title>4.5 运算符</title>
      <link>https://example.com/linux/docs/part4-shell/4.5-operator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part4-shell/4.5-operator/</guid>
      <description> 4.5 运算符 # 4.5.1 赋值运算符 # = 赋值运算符，用于算数赋值和字符串赋值。使用 unset 取消为变量的赋值。= 除了作为赋值运算符还可以作为测试操作符。
4.5.2 基本运算符 # + - * / ** % 使用 expr 进行运算。只能支持整数。
# 主要符号和数字之间要有空格 expr 4 + 5 数字常量 # let 变量名=变量值
变量值使用 0 开头为八进制
变量值使用 0x 开头为十六进制
双圆括号是 let 命令的简化，所以在实际使用中较少会使用到 let。
((a=10)) ((a++)) echo $((10+20)) </description>
    </item>
    <item>
      <title>6.5 NFS</title>
      <link>https://example.com/linux/docs/part6-service-manage/6.5-nfs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part6-service-manage/6.5-nfs/</guid>
      <description>6.5 NFS # 6.5.1 简介 # NFS（Network File System）是一种用于在网络上共享文件系统的协议。它允许一个计算机系统（称为NFS服务器）与其他计算机系统（称为NFS客户端）共享其本地文件系统，并允许客户端通过网络透明地访问和操作服务器上的文件。
以下是NFS服务的一些主要特点和用途：
文件共享：NFS允许将NFS服务器上的文件和目录共享给NFS客户端。这意味着客户端可以像访问本地文件一样访问和操作服务器上的共享文件。
分布式访问：NFS允许多个NFS客户端同时访问和修改共享文件。这使得多个用户可以在不同的计算机上协同工作，并共享相同的文件和数据。
透明访问：NFS为客户端提供了透明的访问体验，使得共享文件的访问方式类似于本地文件。客户端可以像访问本地文件一样使用标准的文件操作（如打开、读取、写入和关闭文件）来访问NFS服务器上的文件。
安全性：NFS提供了一些安全机制来保护共享文件的访问。例如，可以使用访问控制列表（ACL）来限制对文件的访问权限，并使用身份验证和加密来保护数据的安全性。
性能优化：NFS在设计时考虑了性能优化，并使用一些技术来提高文件访问的效率。例如，NFS使用缓存机制来减少网络传输，提高文件的访问速度。
使用NFS时，通常会有一个或多个NFS服务器，它们共享其本地文件系统，并提供对这些共享文件的访问。然后，NFS客户端可以通过挂载（mount）NFS服务器上的共享目录，使其在本地文件系统中可用。
NFS服务器和客户端之间的通信是基于RPC（Remote Procedure Call）机制的，通过NFS协议进行文件访问和操作。
需要注意的是，NFS是一种开放标准的协议，并且有多个实现可用。常用的NFS实现包括NFSv3和NFSv4。不同的实现可能会有一些细微的差异和特性，因此在使用特定的NFS实现时，应该参考相应的文档和资源以获取更详细的信息和指导。
6.5.2 配置和启动 # 启动 NFS服务 # 安装 yum install -y nfs-utils systemctl start stop nfs.service NFS 的配置文件在 /etc/exports，文件不存在可以手动创建。文件格式如下：
# 共享目录 访问控制 # 括号和主机不能有空格 # /data/share 192.168.11.2(ro) 192.168.11.3(rw) # 所有人访问呢 # /data/share *(rw,sync,all_squash) /data/share *(rw,sync,all_squash) 在另一台机器（客户端）上可以使用 showmount 查看 nfs 机器的共享了哪些目录：
如果没有 showmount 命令，可以使用 yum install showmount -y 安装。
all_squash 选项 # 在NFS配置中，all_squash 选项用于指定对于所有远程访问的用户，将其映射为指定的匿名用户。这个选项通常用于安全性和权限管理。</description>
    </item>
    <item>
      <title>1.6 内存管理</title>
      <link>https://example.com/linux/docs/part1-primary/1.6-memory-manage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part1-primary/1.6-memory-manage/</guid>
      <description>1.6 内存管理 # 1.6.1 虚拟内存 # 虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。
为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。
从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。
1.6.2 分页系统地址映射 # 内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。
一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。
下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。
1.6.3 页面置换算法 # 在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。
页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。
页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。
1. 最佳 # OPT, Optimal replacement algorithm
所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。
是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。
举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：
7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1 开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。
2. 最近最久未使用 # LRU, Least Recently Used</description>
    </item>
    <item>
      <title>2.6 压缩和打包</title>
      <link>https://example.com/linux/docs/part2-sys-operate/2.6-backup-compression/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part2-sys-operate/2.6-backup-compression/</guid>
      <description>2.6 压缩和打包 # 2.6.1 压缩文件名 # Linux 下有很多压缩文件名，常见的如下：
扩展名 压缩程序 *.Z compress *.zip zip *.gz gzip *.bz2 bzip2 *.xz xz *.tar tar 程序打包的数据，没有经过压缩 *.tar.gz tar 程序打包的文件，经过 gzip 的压缩 *.tar.bz2 tar 程序打包的文件，经过 bzip2 的压缩 *.tar.xz tar 程序打包的文件，经过 xz 的压缩 *.tbz2 *.tar.bz2 的缩写 *.tgz *.tar.gz 的缩写 2.6.2 压缩指令 # 1. gzip # gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。
经过 gzip 压缩过，源文件就不存在了。gzip 命令只能用来压缩文件，不能压缩目录，即便指定了目录，也只能压缩目录内的所有文件。gzip 命令不需要指定压缩包名。
有 9 个不同的压缩等级可以使用。
可以使用 zcat、zmore、zless 来读取压缩文件的内容。</description>
    </item>
    <item>
      <title>3.6 内存和磁盘管理</title>
      <link>https://example.com/linux/docs/part3-sys-manage/3.6-memory-disk/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part3-sys-manage/3.6-memory-disk/</guid>
      <description>3.6 内存和磁盘管理 # 3.6.1 内存和磁盘使用率查看 # 内存使用率 # free 和 top 命令效果基本无差，区别就是 free 是静态的，top 是动态的。
free # 一般多少 G 内存用 free -m 查看，多少 T 内存用 free -g 查看。
top # 磁盘使用率 # fdisk # 慎用。fdisk 不仅可以用来查看磁盘，还可以用来磁盘分区，在实际工作中慎用。
查看磁盘信息可以用 fdisk -l。
df # 用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为 KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。
du # 也是查看使用空间的，但是与 d f命令不同的是 du 命令是对文件和目录磁盘使用的空间的查看。
du 和 ls 的区别 # ls -lh 和 du 命令都可以查看文件，但是 du 查看的实际文件大小，ls 查看的文件大小可能包含空洞。
afile 文件没有空洞，ls 和 du 显示的文件大小都是 40M。</description>
    </item>
    <item>
      <title>4.6 测试和判断</title>
      <link>https://example.com/linux/docs/part4-shell/4.6-test-and-judge/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part4-shell/4.6-test-and-judge/</guid>
      <description>4.6 测试和判断 # 4.6.1 退出状态 # 退出程序命令
exit exit 10 表示自定义返回 10 给 Shell，返回值非 0 位不正常退出。
$? 判断当前 Shell 前一个进程是否正常退出。
4.6.2 测试命令 test # test 命令用于检查文件或者比较值
test 可以做以下测试：
文件测试 整数比较测试 字符串测试 test 测试语句可以简化为 [] 符号
[] 符号还有扩展写法 [[]] 支持 &amp;amp;&amp;amp;、‖、&amp;lt;、&amp;gt;</description>
    </item>
    <item>
      <title>6.6 nginx</title>
      <link>https://example.com/linux/docs/part6-service-manage/6.6-nginx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part6-service-manage/6.6-nginx/</guid>
      <description>6.6 nginx # 6.6.1 nginx 和 OpenResty # Nginx和OpenResty是两个不同但有关联的项目。
Nginx 是一个开源的高性能 Web 服务器和反向代理服务器。它具有轻量级、高并发处理能力和低内存消耗等特点，常被用于搭建静态网站、负载均衡和反向代理等场景。Nginx 通常使用 C 语言编写，并以模块化设计的方式提供丰富的功能扩展。
OpenResty 是一个基于 Nginx 的 Web 应用服务器软件集成包，它将 Nginx 与一组扩展模块和第三方库进行了集成，以提供更强大的功能。 OpenResty 允许开发人员使用 Lua 编程语言来编写 Nginx 的配置文件和扩展模块，从而实现高度可定制的 Web 应用程序。通过 OpenResty，开发人员可以在 Nginx 中使用 Lua 编写的脚本，以实现动态内容生成、API 网关、缓存加速和高级负载均衡等功能。
可以说 OpenResty 是一个基于 Nginx 的增强版本，它通过添加 Lua 编程语言的支持和一系列扩展模块，使得 Nginx 可以处理更复杂的任务和场景。OpenResty 在一些需要高度定制化和可扩展性的 Web 应用程序中非常有用，特别是对于需要动态脚本处理和扩展功能的情况。
Nginx 是一个独立的高性能 Web 服务器和反向代理服务器，而 OpenResty 是基于 Nginx 的 Web 应用服务器软件集成包，通过添加 Lua 编程语言的支持和扩展模块，扩展了 Nginx 的功能。
6.6.2 OpenResty 安装 # 安装可以使用如下 2 条命令：</description>
    </item>
    <item>
      <title>1.7 链接</title>
      <link>https://example.com/linux/docs/part1-primary/1.7-link/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part1-primary/1.7-link/</guid>
      <description> 1.7 链接 # 1.7.1 编译系统 # 以下是一个 hello.c 程序：
#include &amp;lt;stdio.h&amp;gt; int main() { printf(&amp;#34;hello, world\n&amp;#34;); return 0; } 在 Unix 系统上，由编译器把源文件转换为目标文件。
gcc -o hello hello.c 这个过程大致如下：
预处理阶段：处理以 # 开头的预处理命令； 编译阶段：翻译成汇编文件； 汇编阶段：将汇编文件翻译成可重定位目标文件； 链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。 1.7.2 静态链接 # 静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：
符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。 1.7.2 目标文件 # 可执行目标文件：可以直接在内存中执行； 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件； 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接； 1.7.3 动态链接 # 静态库有以下两个问题：
当静态库更新时那么整个程序都要重新进行链接； 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。 共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：
在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中； 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。 </description>
    </item>
    <item>
      <title>1.7 设备管理</title>
      <link>https://example.com/linux/docs/part1-primary/1.7-device-manage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part1-primary/1.7-device-manage/</guid>
      <description>1.7 设备管理 # 1.7.1 磁盘结构 # 盘面（Platter）：一个磁盘有多个盘面； 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道； 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小； 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）； 制动手臂（Actuator arm）：用于在磁道之间移动磁头； 主轴（Spindle）：使整个盘面转动。 1.7.2 磁盘调度算法 # 读写一个磁盘块的时间的影响因素有：
旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上） 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上） 实际的数据传输时间 其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。
1. 先来先服务 # FCFS, First Come First Served
按照磁盘请求的顺序进行调度。
优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。
2. 最短寻道时间优先 # SSTF, Shortest Seek Time First
优先调度与当前磁头所在磁道距离最近的磁道。
虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。
3. 电梯算法 # SCAN
电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。
电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。
因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</description>
    </item>
    <item>
      <title>2.7 vim</title>
      <link>https://example.com/linux/docs/part2-sys-operate/2.7-vim/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part2-sys-operate/2.7-vim/</guid>
      <description>2.7 vim # 2.7.1 vim 三种模式 # 一般指令模式（Command mode）：vim 的默认模式，可以用于移动游标查看内容； 编辑模式（Insert mode）：按下i等按键之后进入，可以对文本进行编辑； 指令列模式（Bottom-line mode）：按下:按键之后进入，用于保存退出等操作。 在指令列模式下，有以下命令用于离开或者保存文件。
命令 作用 :w 写入磁盘，也可以加上保存路径，如 :w /tmp/test.txt :w! 当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关 :q 离开 :q! 强制离开不保存 :wq 写入磁盘后离开 :wq! 强制写入磁盘后离开 2.7.2 正常模式 # 按键 作用 I 进入插入模式，光标会移到当前行的开头位置 a 进入插入模式，光标会移动到下一个字符位置 A 进入插入模式，光标会移动到当前行末尾位置 o 进入插入模式，会向下新开一行，光标会移动到新行开头位置 O 进入插入模式，会向上新开一行，光标会移动到新行开头位置 h 前移 l 后移 j 下移 k 上移 u 撤销操作，可以多次撤销 x 单个字符删除 r 替换字符 ^ 回到当前行首 $ 回到当前行尾 ctrl+r 重做，恢复撤销 yy 和 p yy 复制一行，p 粘贴 复制多行 # 比如复制 3 行，光标移到要复制的开头位置，先按 3，再按 yy，就复制了 3 行。</description>
    </item>
    <item>
      <title>4.7 流程控制</title>
      <link>https://example.com/linux/docs/part4-shell/4.7-process-control/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part4-shell/4.7-process-control/</guid>
      <description>4.7 流程控制 # 4.7.1 if # if-then # if [ 测试条件成立 ] 或 命令返回值是否为0 then 执行相应命令 fi 结束 if-then-else # if [ 测试条件成立 ] then 执行相应命令 else 测试条件不成立，执行相应命令 fi 结束 if-elif-else # if [ 测试条件成立 ] elif [ 测试条件成立 ] then 执行相应命令 else 测试条件不成立，执行相应命令 fi 结束 嵌套 if # if [ 测试条件成立 ]; then 执行相应命令 if [ 测试条件成立 ]; then 执行相应命令 fi fi 4.7.2 case 分支 # case &amp;#34;$变量&amp;#34; in &amp;#34;情况1&amp;#34; ) 命令…;; &amp;#34;情况2&amp;#34; ) 命令…;; *) 命令…;; esac 4.</description>
    </item>
    <item>
      <title>6.7 DNS</title>
      <link>https://example.com/linux/docs/part6-service-manage/6.7-dns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part6-service-manage/6.7-dns/</guid>
      <description>6.7 DNS # 6.7.1 简介 # DNS（Domain Name System）是一个用于将域名转换为与之关联的IP地址的分布式命名系统。它充当了互联网上域名与IP地址之间的映射服务。
正向查询（Forward Lookup）：正向查询是根据给定的域名获取相应的IP地址。当你在浏览器中输入一个网址（例如 www.example.com），DNS 系统会执行正向查询以查找与该域名关联的 IP 地址，从而将你的请求转发到正确的服务器。
反向查询（Reverse Lookup）：反向查询是根据给定的 IP 地址获取相应的域名。它是正向查询的逆过程。通过反向查询，你可以查找给定 IP 地址所对应的域名。这对于网络管理员来说是有用的，可以通过 IP 地址确定主机的域名。
根域名（Root Domain）：根域名是 DNS 层次结构中的顶级域名，表示为一个点（.）。它是 DNS 命名空间的最高级别，所有其他域名都是从根域名派生出来的。根域名由一组 13 个根服务器（Root Servers）来管理，这些服务器分布在全球各个地点。
www：www 是一个常见的域名前缀，表示 “World Wide Web”。通常，网站会使用类似 www.example.com 的域名来表示其 Web 服务。这是出于历史原因，当互联网刚刚兴起时，许多网站选择以 www 作为其主要 Web 服务器的标识。
FQDN（Fully Qualified Domain Name）：FQDN 是一个完全限定域名，包括所有级别的域名，从根域名一直到最低级别的域名。例如，www.example.com 是一个 FQDN，它包含三个级别的域名：com（顶级域名）、example（二级域名）和www（三级域名）。
6.7.2 BIND # BIND（Berkeley Internet Name Domain）是一个开源的 DNS 软件实现，它是最常用和广泛部署的 DNS 服务器软件之一。BIND 软件提供了 DNS 协议的实现，允许将域名解析请求映射到相应的 IP 地址。
DNS（Domain Name System）是一个分布式的命名系统，用于将域名转换为与之关联的 IP 地址。它充当了互联网上域名与 IP 地址之间的映射服务。BIND 作为 DNS 服务器软件，实现了 DNS 协议的功能，用于接收来自客户端的域名解析请求，并将其转发到相应的域名服务器以获取相应的 IP 地址。</description>
    </item>
    <item>
      <title>1.8 指令集</title>
      <link>https://example.com/linux/docs/part1-primary/1.8-instruction-arch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part1-primary/1.8-instruction-arch/</guid>
      <description> 1.8 指令集 # 1.8.1 指令集架构 # 指令集架构是指一套软硬件的标准规范，CPU芯片和软件应用会围绕这套规范设计。从CPU发明到现在，有非常多种架构，从常见的x86、ARM，到不太常见的RISC-V，MIPS、IA64，它们之间的差距都非常大。
有些时候我们会遇到在本地开发环境编译和运行正常的代码，在生产环境却无法正常工作，当然这个问题背后会有多种原因，而不同机器使用的不同指令集可能是原因之一。
指令集架构是计算机的抽象模型，在很多时候也被称作架构或者计算机架构，它是计算机软件和硬件之间的接口和桥梁。一个为特定指令集架构编写的应用程序能够运行在所有支持这种指令集架构的机器上，也就是说如果当前应用程序支持 x86 的指令集，那么就可以运行在所有使用 x86 指令集的机器上，这其实就是抽象层的作用，每一个指令集架构都定义了支持的数据结构、寄存器、管理主内存的硬件支持（例如内存一致、地址模型和虚拟内存）、支持的指令集和 IO 模型，它的引入其实就在软件和硬件之间引入了一个抽象层，让同一个二进制文件能够在不同版本的硬件上运行。如果一个编程语言想要在所有的机器上运行，它就可以将中间代码转换成使用不同指令集架构的机器码，这可比为不同硬件单独移植要简单的太多了。
1.8.2 复杂指令集（CISC）和精简指令集（RISC） # 最常见的指令集架构分类方法是根据指令的复杂度将其分为复杂指令集（CISC）和精简指令集（RISC），复杂指令集架构包含了很多特定的指令，但是其中的一些指令很少会被程序使用，而精简指令集只实现了经常被使用的指令，不常用的操作都会通过组合简单指令来实现。
复杂指令集的特点就是指令数目多并且复杂，每条指令的字节长度并不相等，x86 就是常见的复杂指令集处理器，它的指令长度大小范围非常广，从 1 到 15 字节不等，对于长度不固定的指令，计算机必须额外对指令进行判断，这需要付出额外的性能损失。
而精简指令集对指令的数目和寻址方式做了精简，大大减少指令数量的同时更容易实现，指令集中的每一个指令都使用标准的字节长度、执行时间相比复杂指令集会少很多，处理器在处理指令时也可以流水执行，提高了对并行的支持。作为一种常见的精简指令集处理器，arm 使用 4 个字节作为指令的固定长度，省略了判断指令的性能损失3，精简指令集其实就是利用了我们耳熟能详的 20/80 原则，用 20% 的基础指令和它们的组合来解决问题。
复杂指令集和精简指令集的使用是设计上的权衡，经过这么多年的发展，两种指令集也相互借鉴和学习，与最开始刚被设计出来时已经有了较大的差别。最开始的计算机使用复杂指令集是因为当时计算机的性能和内存比较有限，业界需要尽可能地减少机器需要执行的指令，所以更倾向于高度编码、长度不等以及多操作数的指令。不过随着计算机性能的提升，出现了精简指令集这种牺牲代码密度换取简单实现的设计；除此之外，硬件的飞速提升还带来了更多的寄存器和更高的时钟频率，软件开发人员也不再直接接触汇编代码，而是通过编译器和汇编器生成指令，复杂的机器指令对于编译器来说很难利用，所以精简指令在这种场景下更适合。
参考 # 机器码生成 </description>
    </item>
    <item>
      <title>2.8 用户管理</title>
      <link>https://example.com/linux/docs/part2-sys-operate/2.8-user-manage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part2-sys-operate/2.8-user-manage/</guid>
      <description>2.8 用户管理 # 命令 作用 useradd 新建用户 userdel 删除用户 passwd 修改用户密码 usermod 修改用户属性 chage 修改帐号和密码的有效期限 groupadd 新建用户组 groupdel 删除用户组 2.8.1 useradd # useradd 用户名 useradd -g 用户组 用户名 当不指定用户组时，会创建一个同名的用户组。
2.8.2 passwd # passwd wislon 当修改自己的密码时，直接输入 passwd 回车。
2.8.3 userdel # userdel 用户名 当加上-r选项时，会删除用户的家目录。
2.8.4 usermod # 用于修改用户的基本信息。
常用选项 # -d 选项 # 修改用户登入时的目录，只是修改/etc/passwd中用户的家目录配置信息，不会自动创建新的家目录，通常和-m一起使用。
-m 选项 # 移动用户家目录到新的位置，不能单独使用，一般与-d一起使用。
-g 选项 # 修改用户所属的用户组。
usermod -g 用户组 用户名 2.8.5 groupadd # 创建一个新的用户组。</description>
    </item>
    <item>
      <title>4.8 函数</title>
      <link>https://example.com/linux/docs/part4-shell/4.8-function/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part4-shell/4.8-function/</guid>
      <description>4.8 函数 # 函数用于 “包含” 重复使用的命令集合。
4.8.1 自定义函数 # function fname( # 命令 } # 函数的执行 `fname` function 关键字可以省略。
变量和参数 # 函数作用范围的变量可以使用 local 申明，只在函数内部生效：
local 变量名 函数的参数：$1 $2 $3 ${10} .. $n
4.8.2 系统脚本 # 系统自建了函数库，可以在脚本中引用，目录是 /etc/init.d/functions，如果想导入系统函数库，可以使用 source 函数脚本文件 “导入” 函数。</description>
    </item>
    <item>
      <title>6.8 NAS</title>
      <link>https://example.com/linux/docs/part6-service-manage/6.8-nas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part6-service-manage/6.8-nas/</guid>
      <description>6.8 NAS # 6.8.1 简介 # NAS（Network Attached Storage）是一种网络附加存储设备，它提供了一种简单和方便的方法来集中存储和共享文件、数据和媒体内容。NAS 设备通常连接到局域网（LAN）上，可以通过网络协议（如 NFS、SMB/CIFS、AFP 等）提供文件共享服务，使多台计算机或其他设备可以同时访问和使用存储在 NAS 上的文件。
NAS 设备通常是一个独立的硬件设备，它包含一个或多个硬盘驱动器组成的存储系统，并配备了一个嵌入式操作系统和网络接口。它可以通过以太网连接到局域网，并通过网络协议提供文件服务。一些高级的NAS设备还提供其他功能，如备份、远程访问、多用户访问控制、多媒体流媒体等。
NAS 的优点包括：
简单易用：NAS 设备通常具有友好的用户界面和配置工具，使其易于安装、设置和管理。
文件共享和协作：通过 NAS 设备，多个用户可以方便地共享和访问存储在同一个位置的文件，促进文件的协作和共享。
数据备份：NAS 设备通常提供内置的备份功能，可以自动备份计算机或其他设备上的数据，保护数据免受意外丢失或损坏。
远程访问：一些 NAS 设备支持远程访问，使用户可以通过互联网从任何地方安全地访问和管理存储的文件。
扩展性：NAS 设备通常具有可扩展的存储容量，可以根据需求添加更多的硬盘驱动器来扩展存储空间。
NAS 设备适用于个人用户、家庭用户和小型办公环境，以满足数据存储、共享和备份的需求。它提供了一个中心化的存储解决方案，使用户能够轻松管理和访问存储的文件和数据。</description>
    </item>
    <item>
      <title>1.9 国内镜像源</title>
      <link>https://example.com/linux/docs/part1-primary/1.9-mirrors-sources/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part1-primary/1.9-mirrors-sources/</guid>
      <description>1.9 国内镜像源 # Alpine # Alpine 的源文件为：
/etc/apk/repositories
默认的源地址为：http://dl-cdn.alpinelinux.org/， 修改地址可以编辑源文件 /etc/apk/repositories。
国内镜像及修改方法，采用国内阿里云的源，文件内容为：
https://mirrors.aliyun.com/alpine/v3.6/main/
https://mirrors.aliyun.com/alpine/v3.6/community/
命令：
sed -i &amp;rsquo;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&amp;rsquo; /etc/apk/repositories
如果采用中国科技大学的源，文件内容为：
https://mirrors.ustc.edu.cn/alpine/v3.6/main/
https://mirrors.ustc.edu.cn/alpine/v3.6/community/
命令：
sed -i &amp;rsquo;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&amp;rsquo; /etc/apk/repositories
如果采用中国科技大学的源，文件内容为：
https://mirrors.tuna.tsinghua.edu.cn/alpine/v3.6/main/
https://mirrors.tuna.tsinghua.edu.cn/alpine/v3.6/community/
命令：
sed -i &amp;rsquo;s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g&amp;rsquo; /etc/apk/repositories</description>
    </item>
    <item>
      <title>2.9 切换用户</title>
      <link>https://example.com/linux/docs/part2-sys-operate/2.9-switch-user/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part2-sys-operate/2.9-switch-user/</guid>
      <description> 2.9 切换用户 # su用于切换用户，如果普通用户切换成管理员需要输入密码，那么就需要把密码告诉普通用户，有暴露 root 密码的风险。
sudo可以避免暴露 root 密码，可以直接把某些命令授权给普通用户执行，普通用户在执行时不需要 root 用户密码。
2.9.1 su # 用于切换当前用户身份到其他用户身份。
- 参数在变更账号后并改变工作目录到该账号的家目录。
2.9.1 sudo # 以其他身份来执行命令。
visudo 设置需要使用 sudo 的用户（组）。
wilson ALL=/usr/sbin/shutdown # wilson 用户被授予 shutdown 执行权限，多个命令以 , 分隔。 wilson ALL=/usr/sbin/shutdown NOPASSWD # wilson 用户被授予 shutdown 执行权限，不需要输入密码 </description>
    </item>
    <item>
      <title>4.9 脚本和计划任务</title>
      <link>https://example.com/linux/docs/part4-shell/4.9-script-cron/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part4-shell/4.9-script-cron/</guid>
      <description>4.9 脚本和计划任务 # 4.9.1 脚本优先级控制 # 可以使用 nice 和 renice 调整脚本优先级。
nice 命令用于启动一个新进程，并设置其优先级。通过指定一个优先级值（范围从 -20（最高优先级）到 +19（最低优先级）），可以告诉操作系统如何在调度进程时优先考虑它们。较低的优先级值意味着更高的优先级。
例如，要在启动一个进程时设置较低的优先级，可以使用以下命令：
nice -n 10 command 上述命令将启动一个新的进程 command，并将其优先级设置为 +10。需要注意的是，使用 nice 启动的进程的优先级相对于默认值进行了调整。
renice 命令用于修改已经运行的进程的优先级。可以使用 renice 命令将已经运行的进程的优先级增加或降低。
例如，要将进程的优先级提高到较高值，可以使用以下命令：
renice -n -5 &amp;lt;PID&amp;gt; 上述命令将进程 的优先级降低了 5。
更改进程的优先级需要适当的权限。通常，只有具有足够权限（如 root 用户或具有 CAP_SYS_NICE 权限的用户）才能增加或降低进程的优先级。
脚本避免出现 “不可控的” 死循环，死循环导致 cpu 占用过高，死循环导致死机。
4.9.2 捕获信号 # kill 默认会发送 15 号信号给应用程序 ctrl + C 发送 2 号信号给应用程序 9 号信号不可阻塞，kill -9 不能进行捕获 trap 命令可以用来捕获信号。
4.9.3 计划任务 # 一次性计划任务 # 一次性计划任务使用的是 at 命令，如果没有 at 命令可以先通过 yum 或 apt 安装。</description>
    </item>
    <item>
      <title>2.10 文件和文件夹</title>
      <link>https://example.com/linux/docs/part2-sys-operate/2.10-file-dir/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/linux/docs/part2-sys-operate/2.10-file-dir/</guid>
      <description>2.10 文件和文件夹 # 2.10.1 文件类型 # - 普通文件 d 目录文件 b 块特殊文件 c 字符特殊文件 l 符号链接 f 命名管道 s 套接字文件 创建新文件有默认权限，根据 umask 值计算，属主和属组根据当前进程的用户来设定。
在 linux 中创建文件默认是 (0)666 权限，需要减去 umask 的值。如：
2.10.2 权限表示 # 普通文件 # r=4 读 w=2 写 x=1 执行 目录 # x 进入目录 rx 显示目录内的文件名 wx 修改目录内的文件名 x 权限只能进入目录
rx 权限能进入并目录，显示目录内容，也可以读取文件，但是不能对文件进行操作
wx 权限能进入目录，但是不能显示目录内容，可以读取/修改/删除文件
2.10.3 修改权限 # chmod # chmod 可以修改文件和目录权限。
u 表示用户，g 表示用户组，o 表示其他用户，a 表示所有。
chmod u+x /tmp/testfile chmod u-wx /tmp/testfile chmod u=rwx /tmp/testfile chmod 755 /tmp/testfile chown # 更改文件或目录的所属用户和用户组。</description>
    </item>
  </channel>
</rss>
