<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>转载 - 系列 - xiaobinqt 博客 - 技术改变生活</title>
        <link>https://www.xiaobinqt.cn/series/reproduce/</link>
        <description>转载 - 系列 - xiaobinqt 博客 - 技术改变生活</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaobinqt@163.com (xiaobinqt)</managingEditor>
            <webMaster>xiaobinqt@163.com (xiaobinqt)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><atom:link href="https://www.xiaobinqt.cn/series/reproduce/" rel="self" type="application/rss+xml" /><item>
    <title>高并发分布式架构演进</title>
    <link>https://www.xiaobinqt.cn/highly-concurrent-architecture-evolution/</link>
    <pubDate>Mon, 29 Aug 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/highly-concurrent-architecture-evolution/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/89de4f7569e845ad91eab0a8857d5afb.png" referrerpolicy="no-referrer">
            </div><!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<blockquote>
<p>原文链接：<a href="https://segmentfault.com/a/1190000018626163" target="_blank" rel="noopener noreferrer">https://segmentfault.com/a/1190000018626163</a></p>
</blockquote>
<h2 id="0-目录和说明" class="headerLink">
    <a href="#0-%e7%9b%ae%e5%bd%95%e5%92%8c%e8%af%b4%e6%98%8e" class="header-mark"></a>0. 目录和说明</h2><p>文章在介绍一些基本概念后，按照以下过程阐述了整个架构的演进过程：</p>
<ul>
<li>
<p>单机架构</p>
</li>
<li>
<p>第一次演进：Tomcat 与数据库分开部署</p>
</li>
<li>
<p>第二次演进：引入本地缓存和分布式缓存</p>
</li>
<li>
<p>第三次演进：引入反向代理实现负载均衡</p>
</li>
<li>
<p>第四次演进：数据库读写分离</p>
</li>
<li>
<p>第五次演进：数据库按业务分库</p>
</li>
<li>
<p>第六次演进：把大表拆分为小表</p>
</li>
<li>
<p>第七次演进：使用 LVS 或 F5 来使多个 Nginx 负载均衡</p>
</li>
<li>
<p>第八次演进：通过 DNS 轮询实现机房间的负载均衡</p>
</li>
<li>
<p>第九次演进：引入 NoSQL 数据库和搜索引擎等技术</p>
</li>
<li>
<p>第十次演进：大应用拆分为小应用</p>
</li>
<li>
<p>第十一次演进：复用的功能抽离成微服务</p>
</li>
<li>
<p>第十二次演进：引入企业服务总线 ESB 屏蔽服务接口的访问差异</p>
</li>
<li>
<p>第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理</p>
</li>
<li>
<p>第十四次演进：以云平台承载系统</p>
</li>
</ul>
<h2 id="1-概述" class="headerLink">
    <a href="#1-%e6%a6%82%e8%bf%b0" class="header-mark"></a>1. 概述</h2><p>本文以淘宝作为例子，介绍从一百个到千万级并发情况下服务端的架构的演进过程，同时列举出每个演进阶段会遇到的相关技术，让大家对架构的演进有一个整体的认知，文章最后汇总了一些架构设计的原则。</p>
<blockquote>
<p>特别说明：本文以淘宝为例仅仅是为了便于说明演进过程可能遇到的问题，并非是淘宝真正的技术演进路径</p>
</blockquote>
<h2 id="2-基本概念" class="headerLink">
    <a href="#2-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" class="header-mark"></a>2. 基本概念</h2><p>在介绍架构之前，为了避免部分读者对架构设计中的一些概念不了解，下面对几个最基础的概念进行介绍。</p>
<ul>
<li><strong>分布式</strong></li>
</ul>
<p>系统中的多个模块在不同服务器上部署，即可称为分布式系统，如 Tomcat 和数据库分别部署在不同的服务器上，或两个相同功能的 Tomcat 分别部署在不同服务器上</p>
<ul>
<li><strong>高可用</strong></li>
</ul>
<p>系统中部分节点失效时，其他节点能够接替它继续提供服务，则可认为系统具有高可用性</p>
<ul>
<li><strong>集群</strong></li>
</ul>
<p>一个特定领域的软件部署在多台服务器上并<strong>作为一个整体</strong>提供一类服务，这个整体称为集群。如 Zookeeper 中的 Master 和 Slave 分别部署在多台服务器上，共同组成一个整体提供集中配置服务。在常见的集群中，客户端往往能够连接任意一个节点获得服务，并且当集群中一个节点掉线时，其他节点往往能够自动的接替它继续提供服务，这时候说明集群具有高可用性</p>
<ul>
<li><strong>负载均衡</strong></li>
</ul>
<p>请求发送到系统时，通过某些方式把请求均匀分发到多个节点上，使系统中每个节点能够均匀的处理请求负载，则可认为系统是负载均衡的</p>
<ul>
<li><strong>正向代理和反向代理</strong></li>
</ul>
<p>系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去，在外部网络看来就是代理服务器发起的访问，此时代理服务器实现的是正向代理；当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上，对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。简单来说，<strong>正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程</strong>。</p>
<h2 id="3-架构演进" class="headerLink">
    <a href="#3-%e6%9e%b6%e6%9e%84%e6%bc%94%e8%bf%9b" class="header-mark"></a>3. 架构演进</h2><h3 id="31-单机架构" class="headerLink">
    <a href="#31-%e5%8d%95%e6%9c%ba%e6%9e%b6%e6%9e%84" class="header-mark"></a>3.1 单机架构</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/1f117811d1f646bbbb030f52013818ab.png" title="单机架构" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/1f117811d1f646bbbb030f52013818ab.png" data-sub-html="<h2>单机架构</h2><p>单机架构</p>">
        
    </a><figcaption class="image-caption">单机架构</figcaption>
    </figure></p>
<p>以淘宝作为例子。在网站最初时，应用数量与用户数都较少，可以把 Tomcat 和数据库部署在同一台服务器上。浏览器往 <code>www.taobao.com</code> 发起请求时，首先经过 DNS 服务器（域名系统）把域名转换为实际 IP 地址
<code>10.102.4.1</code>，浏览器转而访问该 IP 对应的 Tomcat。</p>
<blockquote>
<p>随着用户数的增长，Tomcat 和数据库之间竞争资源，单机性能不足以支撑业务</p>
</blockquote>
<h3 id="32-第一次演进tomcat-与数据库分开部署" class="headerLink">
    <a href="#32-%e7%ac%ac%e4%b8%80%e6%ac%a1%e6%bc%94%e8%bf%9btomcat-%e4%b8%8e%e6%95%b0%e6%8d%ae%e5%ba%93%e5%88%86%e5%bc%80%e9%83%a8%e7%bd%b2" class="header-mark"></a>3.2 第一次演进：Tomcat 与数据库分开部署</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/51b57795a18a487daae0807e4e005d73.png" title="第一次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/51b57795a18a487daae0807e4e005d73.png" data-sub-html="<h2>第一次演进</h2><p>第一次演进</p>">
        
    </a><figcaption class="image-caption">第一次演进</figcaption>
    </figure></p>
<p>Tomcat 和数据库分别独占服务器资源，显著提高两者各自性能。</p>
<blockquote>
<p>随着用户数的增长，并发读写数据库成为瓶颈</p>
</blockquote>
<h3 id="33-第二次演进引入本地缓存和分布式缓存" class="headerLink">
    <a href="#33-%e7%ac%ac%e4%ba%8c%e6%ac%a1%e6%bc%94%e8%bf%9b%e5%bc%95%e5%85%a5%e6%9c%ac%e5%9c%b0%e7%bc%93%e5%ad%98%e5%92%8c%e5%88%86%e5%b8%83%e5%bc%8f%e7%bc%93%e5%ad%98" class="header-mark"></a>3.3 第二次演进：引入本地缓存和分布式缓存</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/08062e488e3a42c3952d2e083e117f28.png" title="第二次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/08062e488e3a42c3952d2e083e117f28.png" data-sub-html="<h2>第二次演进</h2><p>第二次演进</p>">
        
    </a><figcaption class="image-caption">第二次演进</figcaption>
    </figure></p>
<p>在 Tomcat 同服务器上或同 JVM 中增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的 html 页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力。其中涉及的技术包括：使用 memcached 作为本地缓存，使用 Redis 作为分布式缓存，还会涉及缓存一致性、缓存穿透/击穿、缓存雪崩、热点数据集中失效等问题。</p>
<blockquote>
<p>缓存抗住了大部分的访问请求，随着用户数的增长，并发压力主要落在单机的 Tomcat 上，响应逐渐变慢</p>
</blockquote>
<h3 id="34-第三次演进引入反向代理实现负载均衡" class="headerLink">
    <a href="#34-%e7%ac%ac%e4%b8%89%e6%ac%a1%e6%bc%94%e8%bf%9b%e5%bc%95%e5%85%a5%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86%e5%ae%9e%e7%8e%b0%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" class="header-mark"></a>3.4 第三次演进：引入反向代理实现负载均衡</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/447531a9c371496e9263e32a312b192c.png" title="第三次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/447531a9c371496e9263e32a312b192c.png" data-sub-html="<h2>第三次演进</h2><p>第三次演进</p>">
        
    </a><figcaption class="image-caption">第三次演进</figcaption>
    </figure></p>
<p>在多台服务器上分别部署 Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个 Tomcat 中。此处假设 Tomcat 最多支持 100 个并发，Nginx 最多支持 50000 个并发，那么理论上 Nginx 把请求分发到 500 个 Tomcat 上，就能抗住 50000 个并发。其中涉及的技术包括：Nginx、HAProxy，两者都是工作在网络第七层的反向代理软件，主要支持 http 协议，还会涉及 session 共享、文件上传下载的问题。</p>
<blockquote>
<p>反向代理使应用服务器可支持的并发量大大增加，但并发量的增长也意味着更多请求穿透到数据库，单机的数据库最终成为瓶颈</p>
</blockquote>
<h3 id="35-第四次演进数据库读写分离" class="headerLink">
    <a href="#35-%e7%ac%ac%e5%9b%9b%e6%ac%a1%e6%bc%94%e8%bf%9b%e6%95%b0%e6%8d%ae%e5%ba%93%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb" class="header-mark"></a>3.5 第四次演进：数据库读写分离</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/53d08f904fa54100bb891bacf5d55eec.png" title="第四次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/53d08f904fa54100bb891bacf5d55eec.png" data-sub-html="<h2>第四次演进</h2><p>第四次演进</p>">
        
    </a><figcaption class="image-caption">第四次演进</figcaption>
    </figure></p>
<p>把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据。其中涉及的技术包括：Mycat，它是数据库中间件，可通过它来组织数据库的分离读写和分库分表，客户端通过它来访问下层数据库，还会涉及数据同步，数据一致性的问题。</p>
<blockquote>
<p>业务逐渐变多，不同业务之间的访问量差距较大，不同业务直接竞争数据库，相互影响性能</p>
</blockquote>
<h3 id="36-第五次演进数据库按业务分库" class="headerLink">
    <a href="#36-%e7%ac%ac%e4%ba%94%e6%ac%a1%e6%bc%94%e8%bf%9b%e6%95%b0%e6%8d%ae%e5%ba%93%e6%8c%89%e4%b8%9a%e5%8a%a1%e5%88%86%e5%ba%93" class="header-mark"></a>3.6 第五次演进：数据库按业务分库</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/effe7db154244811af27331d0b1a4d8c.png" title="第五次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/effe7db154244811af27331d0b1a4d8c.png" data-sub-html="<h2>第五次演进</h2><p>第五次演进</p>">
        
    </a><figcaption class="image-caption">第五次演进</figcaption>
    </figure></p>
<p>把不同业务的数据保存到不同的数据库中，使业务之间的资源竞争降低，对于访问量大的业务，可以部署更多的服务器来支撑。这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决，但这不是本文讨论的重点，有兴趣的可以自行搜索解决方案。</p>
<blockquote>
<p>随着用户数的增长，单机的写库会逐渐会达到性能瓶颈</p>
</blockquote>
<h3 id="37-第六次演进把大表拆分为小表" class="headerLink">
    <a href="#37-%e7%ac%ac%e5%85%ad%e6%ac%a1%e6%bc%94%e8%bf%9b%e6%8a%8a%e5%a4%a7%e8%a1%a8%e6%8b%86%e5%88%86%e4%b8%ba%e5%b0%8f%e8%a1%a8" class="header-mark"></a>3.7 第六次演进：把大表拆分为小表</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/2fad6020cd9b4b97baebc993157067dc.png" title="第六次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/2fad6020cd9b4b97baebc993157067dc.png" data-sub-html="<h2>第六次演进</h2><p>第六次演进</p>">
        
    </a><figcaption class="image-caption">第六次演进</figcaption>
    </figure></p>
<p>比如针对评论数据，可按照商品 ID 进行 hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户 ID 或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀的分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能。其中前面提到的 Mycat 也支持在大表拆分为小表情况下的访问控制。</p>
<p>这种做法显著的增加了数据库运维的难度，对 DBA 的要求较高。数据库设计到这种结构时，已经可以称为分布式数据库，但是这只是一个逻辑的数据库整体，数据库里不同的组成部分是由不同的组件单独来实现的，如分库分表的管理和请求分发，由 Mycat 实现，SQL 的解析由单机的数据库实现，读写分离可能由网关和消息队列来实现，查询结果的汇总可能由数据库接口层来实现等等，这种架构其实是 <strong><ruby>MPP<rt>Massively Parallel Processing</rt></ruby></strong>
（大规模并行处理）架构的一类实现。</p>
<p>目前开源和商用都已经有不少 MPP 数据库，开源中比较流行的有 Greenplum、TiDB、Postgresql XC、HAWQ 等，商用的如南大通用的 GBase、睿帆科技的雪球 DB、华为的 LibrA 等等，不同的 MPP 数据库的侧重点也不一样，如 TiDB 更侧重于分布式 OLTP 场景，Greenplum 更侧重于分布式 OLAP 场景，这些 MPP 数据库基本都提供了类似 Postgresql、Oracle、MySQL 那样的 SQL 标准支持能力，能把一个查询解析为分布式的执行计划分发到每台机器上并行执行，最终由数据库本身汇总数据进行返回，也提供了诸如权限管理、分库分表、事务、数据副本等能力，并且大多能够支持 100 个节点以上的集群，大大降低了数据库运维的成本，并且使数据库也能够实现水平扩展。</p>
<blockquote>
<p>数据库和 Tomcat 都能够水平扩展，可支撑的并发大幅提高，随着用户数的增长，最终单机的 Nginx 会成为瓶颈</p>
</blockquote>
<h3 id="38-第七次演进使用-lvs-或-f5-来使多个-nginx-负载均衡" class="headerLink">
    <a href="#38-%e7%ac%ac%e4%b8%83%e6%ac%a1%e6%bc%94%e8%bf%9b%e4%bd%bf%e7%94%a8-lvs-%e6%88%96-f5-%e6%9d%a5%e4%bd%bf%e5%a4%9a%e4%b8%aa-nginx-%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" class="header-mark"></a>3.8 第七次演进：使用 LVS 或 F5 来使多个 Nginx 负载均衡</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/1b37027ad49a4aaeb4485885ad9a696a.png" title="第七次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/1b37027ad49a4aaeb4485885ad9a696a.png" data-sub-html="<h2>第七次演进</h2><p>第七次演进</p>">
        
    </a><figcaption class="image-caption">第七次演进</figcaption>
    </figure></p>
<p>由于瓶颈在 Nginx，因此无法通过两层的 Nginx 来实现多个 Nginx 的负载均衡。图中的 <strong><ruby>LVS<rt>Linux Virtual Server</rt></ruby></strong> 和 F5 是工作在网络第四层的负载均衡解决方案，其中 LVS 是软件，运行在操作系统内核态，可对 TCP 请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于 Nginx，可假设单机的 LVS 可支持几十万个并发的请求转发；F5 是一种负载均衡硬件，与 LVS 提供的能力类似，性能比 LVS 更高，但价格昂贵。</p>
<p>由于 LVS 是单机版的软件，若 LVS 所在服务器宕机则会导致整个后端系统都无法访问，因此需要有备用节点。可使用 keepalived 软件模拟出虚拟 IP，然后把虚拟 IP 绑定到多台 LVS 服务器上，浏览器访问虚拟 IP 时，会被路由器重定向到真实的 LVS 服务器，当主 LVS 服务器宕机时，keepalived 软件会自动更新路由器中的路由表，把虚拟 IP 重定向到另外一台正常的 LVS 服务器，从而达到 LVS 服务器高可用的效果。</p>
<p>此处需要注意的是，上图中从 Nginx 层到 Tomcat 层这样画并不代表全部 Nginx 都转发请求到全部的 Tomcat，在实际使用时，可能会是几个 Nginx 下面接一部分的 Tomcat，这些 Nginx 之间通过 keepalived 实现高可用，其他的 Nginx 接另外的 Tomcat，这样可接入的 Tomcat 数量就能成倍的增加。</p>
<blockquote>
<p>由于 LVS 也是单机的，随着并发数增长到几十万时，LVS 服务器最终会达到瓶颈，此时用户数达到千万甚至上亿级别，用户分布在不同的地区，与服务器机房距离不同，导致了访问的延迟会明显不同</p>
</blockquote>
<h3 id="39-第八次演进通过-dns-轮询实现机房间的负载均衡" class="headerLink">
    <a href="#39-%e7%ac%ac%e5%85%ab%e6%ac%a1%e6%bc%94%e8%bf%9b%e9%80%9a%e8%bf%87-dns-%e8%bd%ae%e8%af%a2%e5%ae%9e%e7%8e%b0%e6%9c%ba%e6%88%bf%e9%97%b4%e7%9a%84%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" class="header-mark"></a>3.9 第八次演进：通过 DNS 轮询实现机房间的负载均衡</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/460349470a99405eb838823aa29cbe27.png" title="第八次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/460349470a99405eb838823aa29cbe27.png" data-sub-html="<h2>第八次演进</h2><p>第八次演进</p>">
        
    </a><figcaption class="image-caption">第八次演进</figcaption>
    </figure></p>
<p>在 DNS 服务器中可配置一个域名对应多个 IP 地址，每个 IP 地址对应到不同的机房里的虚拟 IP。当用户访问 <code>www.taobao.com</code> 时，DNS 服务器会使用轮询策略或其他策略，来选择某个 IP 供用户访问。此方式能实现机房间的负载均衡，至此，系统可做到机房级别的水平扩展，千万级到亿级的并发量都可通过增加机房来解决，系统入口处的请求并发量不再是问题。</p>
<blockquote>
<p>随着数据的丰富程度和业务的发展，检索、分析等需求越来越丰富，单单依靠数据库无法解决如此丰富的需求</p>
</blockquote>
<h3 id="310-第九次演进引入-nosql-数据库和搜索引擎等技术" class="headerLink">
    <a href="#310-%e7%ac%ac%e4%b9%9d%e6%ac%a1%e6%bc%94%e8%bf%9b%e5%bc%95%e5%85%a5-nosql-%e6%95%b0%e6%8d%ae%e5%ba%93%e5%92%8c%e6%90%9c%e7%b4%a2%e5%bc%95%e6%93%8e%e7%ad%89%e6%8a%80%e6%9c%af" class="header-mark"></a>3.10 第九次演进：引入 NoSQL 数据库和搜索引擎等技术</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/4431084b90e14e95bad5a0beb93e9196.png" title="第九次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/4431084b90e14e95bad5a0beb93e9196.png" data-sub-html="<h2>第九次演进</h2><p>第九次演进</p>">
        
    </a><figcaption class="image-caption">第九次演进</figcaption>
    </figure></p>
<p>当数据库中的数据多到一定规模时，数据库就不适用于复杂的查询了，往往只能满足普通查询的场景。对于统计报表场景，在数据量大时不一定能跑出结果，而且在跑复杂查询时会导致其他查询变慢，对于全文检索、可变数据结构等场景，数据库天生不适用。因此需要针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统 HDFS 解决，对于 key value 类型的数据，可通过 HBase 和 Redis 等方案解决，对于全文检索场景，可通过搜索引擎如 ElasticSearch 解决，对于多维分析场景，可通过 Kylin 或 Druid 等方案解决。</p>
<p>当然，引入更多组件同时会提高系统的复杂度，不同的组件保存的数据需要同步，需要考虑一致性的问题，需要有更多的运维手段来管理这些组件等。</p>
<blockquote>
<p>引入更多组件解决了丰富的需求，业务维度能够极大扩充，随之而来的是一个应用中包含了太多的业务代码，业务的升级迭代变得困难</p>
</blockquote>
<h3 id="311-第十次演进大应用拆分为小应用" class="headerLink">
    <a href="#311-%e7%ac%ac%e5%8d%81%e6%ac%a1%e6%bc%94%e8%bf%9b%e5%a4%a7%e5%ba%94%e7%94%a8%e6%8b%86%e5%88%86%e4%b8%ba%e5%b0%8f%e5%ba%94%e7%94%a8" class="header-mark"></a>3.11 第十次演进：大应用拆分为小应用</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/8cb5f4af10c54384bcda7ac1a19bdaba.png" title="第十次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/8cb5f4af10c54384bcda7ac1a19bdaba.png" data-sub-html="<h2>第十次演进</h2><p>第十次演进</p>">
        
    </a><figcaption class="image-caption">第十次演进</figcaption>
    </figure></p>
<p>按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心 Zookeeper 来解决。</p>
<blockquote>
<p>不同应用之间存在共用的模块，由应用单独管理会导致相同代码存在多份，导致公共功能升级时全部应用代码都要跟着升级</p>
</blockquote>
<h3 id="312-第十一次演进复用的功能抽离成微服务" class="headerLink">
    <a href="#312-%e7%ac%ac%e5%8d%81%e4%b8%80%e6%ac%a1%e6%bc%94%e8%bf%9b%e5%a4%8d%e7%94%a8%e7%9a%84%e5%8a%9f%e8%83%bd%e6%8a%bd%e7%a6%bb%e6%88%90%e5%be%ae%e6%9c%8d%e5%8a%a1" class="header-mark"></a>3.12 第十一次演进：复用的功能抽离成微服务</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/542da2f0e6704dd2bc537098708aedcc.png" title="第十一次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/542da2f0e6704dd2bc537098708aedcc.png" data-sub-html="<h2>第十一次演进</h2><p>第十一次演进</p>">
        
    </a><figcaption class="image-caption">第十一次演进</figcaption>
    </figure></p>
<p>如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过 HTTP、TCP 或 RPC 请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理。此外，可以通过 Dubbo、SpringCloud 等框架实现服务治理、限流、熔断、降级等功能，提高服务的稳定性和可用性。</p>
<blockquote>
<p>不同服务的接口访问方式不同，应用代码需要适配多种访问方式才能使用服务，此外，应用访问服务，服务之间也可能相互访问，调用链将会变得非常复杂，逻辑变得混乱</p>
</blockquote>
<h3 id="313-第十二次演进引入企业服务总线-esb-屏蔽服务接口的访问差异" class="headerLink">
    <a href="#313-%e7%ac%ac%e5%8d%81%e4%ba%8c%e6%ac%a1%e6%bc%94%e8%bf%9b%e5%bc%95%e5%85%a5%e4%bc%81%e4%b8%9a%e6%9c%8d%e5%8a%a1%e6%80%bb%e7%ba%bf-esb-%e5%b1%8f%e8%94%bd%e6%9c%8d%e5%8a%a1%e6%8e%a5%e5%8f%a3%e7%9a%84%e8%ae%bf%e9%97%ae%e5%b7%ae%e5%bc%82" class="header-mark"></a>3.13 第十二次演进：引入企业服务总线 ESB 屏蔽服务接口的访问差异</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/a2f54a652b6141f88fc441a97e8dea97.png" title="第十二次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/a2f54a652b6141f88fc441a97e8dea97.png" data-sub-html="<h2>第十二次演进</h2><p>第十二次演进</p>">
        
    </a><figcaption class="image-caption">第十二次演进</figcaption>
    </figure></p>
<p>通过 ESB 统一进行访问协议转换，应用统一通过 ESB 来访问后端服务，服务与服务之间也通过 ESB 来相互调用，以此降低系统的耦合程度。这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的
<strong><ruby>SOA<rt>Service-Oriented Architecture</rt></ruby></strong>（面向服务）架构，这种架构与微服务架构容易混淆，因为表现形式十分相似。</p>
<p>个人理解，微服务架构更多是指把系统里的公共服务抽取出来单独运维管理的思想，而 SOA 架构则是指一种拆分服务并使服务接口访问变得统一的架构思想，SOA 架构中包含了微服务的思想。</p>
<blockquote>
<p>业务不断发展，应用和服务都会不断变多，应用和服务的部署变得复杂，同一台服务器上部署多个服务还要解决运行环境冲突的问题，
此外，对于如大促这类需要动态扩缩容的场景，需要水平扩展服务的性能，就需要在新增的服务上准备运行环境，部署服务等，运维将变得十分困难</p>
</blockquote>
<h3 id="314-第十三次演进引入容器化技术实现运行环境隔离与动态服务管理" class="headerLink">
    <a href="#314-%e7%ac%ac%e5%8d%81%e4%b8%89%e6%ac%a1%e6%bc%94%e8%bf%9b%e5%bc%95%e5%85%a5%e5%ae%b9%e5%99%a8%e5%8c%96%e6%8a%80%e6%9c%af%e5%ae%9e%e7%8e%b0%e8%bf%90%e8%a1%8c%e7%8e%af%e5%a2%83%e9%9a%94%e7%a6%bb%e4%b8%8e%e5%8a%a8%e6%80%81%e6%9c%8d%e5%8a%a1%e7%ae%a1%e7%90%86" class="header-mark"></a>3.14 第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/ebae2b361aaa4d00a266279ffb59f28e.png" title="第十三次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/ebae2b361aaa4d00a266279ffb59f28e.png" data-sub-html="<h2>第十三次演进</h2><p>第十三次演进</p>">
        
    </a><figcaption class="image-caption">第十三次演进</figcaption>
    </figure></p>
<p>目前最流行的容器化技术是 Docker，最流行的容器管理服务是 Kubernetes(K8S)，应用/服务可以打包为 Docker 镜像，通过 K8S 来动态分发和部署镜像。Docker 镜像可理解为一个能运行你的应用/服务的最小的操作系统，里面放着应用/服务的运行代码，运行环境根据实际的需要设置好。把整个“操作系统”打包为一个镜像后，就可以分发到需要部署相关服务的机器上，直接启动 Docker 镜像就可以把服务起起来，使服务的部署和运维变得简单。</p>
<p>在大促的之前，可以在现有的机器集群上划分出服务器来启动 Docker 镜像，增强服务的性能，大促过后就可以关闭镜像，对机器上的其他服务不造成影响（在 3.14 节之前，服务运行在新增机器上需要修改系统配置来适配服务，这会导致机器上其他服务需要的运行环境被破坏）。</p>
<blockquote>
<p>使用容器化技术后服务动态扩缩容问题得以解决，但是机器还是需要公司自身来管理，在非大促的时候，还是需要闲置着大量的机器资源来应对大促，机器自身成本和运维成本都极高，资源利用率低</p>
</blockquote>
<h3 id="315-第十四次演进以云平台承载系统" class="headerLink">
    <a href="#315-%e7%ac%ac%e5%8d%81%e5%9b%9b%e6%ac%a1%e6%bc%94%e8%bf%9b%e4%bb%a5%e4%ba%91%e5%b9%b3%e5%8f%b0%e6%89%bf%e8%bd%bd%e7%b3%bb%e7%bb%9f" class="header-mark"></a>3.15 第十四次演进：以云平台承载系统</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/9c8cba63d6594fa19726b0b0c97fe17d.png" title="第十四次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/9c8cba63d6594fa19726b0b0c97fe17d.png" data-sub-html="<h2>第十四次演进</h2><p>第十四次演进</p>">
        
    </a><figcaption class="image-caption">第十四次演进</figcaption>
    </figure></p>
<p>系统可部署到公有云上，利用公有云的海量机器资源，解决动态硬件资源的问题，在大促的时间段里，在云平台中临时申请更多的资源，结合 Docker 和 K8S 来快速部署服务，在大促结束后释放资源，真正做到按需付费，资源利用率大大提高，同时大大降低了运维成本。</p>
<p>所谓的云平台，就是把海量机器资源，通过统一的资源管理，抽象为一个资源整体，在之上可按需动态申请硬件资源（如 CPU、内存、网络等），并且之上提供通用的操作系统，提供常用的技术组件（如 Hadoop 技术栈，MPP 数据库等）供用户使用，甚至提供开发好的应用，用户不需要关系应用内部使用了什么技术，就能够解决需求（如音视频转码服务、邮件服务、个人博客等）。在云平台中会涉及如下几个概念：</p>
<ul>
<li>
<p><strong>IaaS</strong>基础设施即服务。对应于上面所说的机器资源统一为资源整体，可动态申请硬件资源的层面；</p>
</li>
<li>
<p><strong>PaaS</strong>平台即服务。对应于上面所说的提供常用的技术组件方便系统的开发和维护；</p>
</li>
<li>
<p><strong>SaaS</strong>软件即服务。对应于上面所说的提供开发好的应用或服务，按功能或性能要求付费。</p>
</li>
</ul>
<blockquote>
<p>至此，以上所提到的从高并发访问问题，到服务的架构和系统实施的层面都有了各自的解决方案，但同时也应该意识到，在上面的介绍中，其实是有意忽略了诸如跨机房数据同步、分布式事务实现等等的实际问题，这些问题以后有机会再拿出来单独讨论</p>
</blockquote>
<h2 id="4-架构设计总结" class="headerLink">
    <a href="#4-%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1%e6%80%bb%e7%bb%93" class="header-mark"></a>4. 架构设计总结</h2><ul>
<li><strong>架构的调整是否必须按照上述演变路径进行？</strong></li>
</ul>
<p>不是的，以上所说的架构演变顺序只是针对某个侧面进行单独的改进，在实际场景中，可能同一时间会有几个问题需要解决，或者可能先达到瓶颈的是另外的方面，这时候就应该按照实际问题实际解决。如在政府类的并发量可能不大，但业务可能很丰富的场景，高并发就不是重点解决的问题，此时优先需要的可能会是丰富需求的解决方案。</p>
<ul>
<li><strong>对于将要实施的系统，架构应该设计到什么程度？</strong></li>
</ul>
<p>对于单次实施并且性能指标明确的系统，架构设计到能够支持系统的性能指标要求就足够了，但要留有扩展架构的接口以便不备之需。对于不断发展的系统，如电商平台，应设计到能满足下一阶段用户量和性能指标要求的程度，并根据业务的增长不断的迭代升级架构，以支持更高的并发和更丰富的业务。</p>
<ul>
<li><strong>服务端架构和大数据架构有什么区别</strong>?</li>
</ul>
<p>所谓的“大数据”其实是海量数据采集清洗转换、数据存储、数据分析、数据服务等场景解决方案的一个统称，在每一个场景都包含了多种可选的技术，如数据采集有 Flume、Sqoop、Kettle 等，数据存储有分布式文件系统 HDFS、FastDFS，NoSQL 数据库 HBase、MongoDB 等，数据分析有 Spark 技术栈、机器学习算法等。总的来说大数据架构就是根据业务的需求，整合各种大数据组件组合而成的架构，一般会提供分布式存储、分布式计算、多维分析、数据仓库、机器学习算法等能力。而服务端架构更多指的是应用组织层面的架构，底层能力往往是由大数据架构来提供。</p>
<ul>
<li>
<p><strong>有没有一些架构设计的原则？</strong></p>
<ul>
<li>
<p>N+1 设计。系统中的每个组件都应做到没有单点故障；</p>
</li>
<li>
<p>回滚设计。确保系统可以向前兼容，在系统升级时应能有办法回滚版本；</p>
</li>
<li>
<p>禁用设计。应该提供控制具体功能是否可用的配置，在系统出现故障时能够快速下线功能；</p>
</li>
<li>
<p>监控设计。在设计阶段就要考虑监控的手段；</p>
</li>
<li>
<p>多活数据中心设计。若系统需要极高的高可用，应考虑在多地实施数据中心进行多活，至少在一个机房断电的情况下系统依然可用；</p>
</li>
<li>
<p>采用成熟的技术。刚开发的或开源的技术往往存在很多隐藏的 bug，出了问题没有商业支持可能会是一个灾难；</p>
</li>
<li>
<p>资源隔离设计。应避免单一业务占用全部资源；</p>
</li>
<li>
<p>架构应能水平扩展。系统只有做到能水平扩展，才能有效避免瓶颈问题；</p>
</li>
<li>
<p>非核心则购买。非核心功能若需要占用大量的研发资源才能解决，则考虑购买成熟的产品；</p>
</li>
<li>
<p>使用商用硬件。商用硬件能有效降低硬件故障的机率；</p>
</li>
<li>
<p>快速迭代。系统应该快速开发小功能模块，尽快上线进行验证，早日发现问题大大降低系统交付的风险；</p>
</li>
<li>
<p>无状态设计。服务接口应该做成无状态的，当前接口的访问不依赖于接口上次访问的状态。</p>
</li>
</ul>
</li>
</ul>
]]></description>
</item><item>
    <title>session cookie token 的区别</title>
    <link>https://www.xiaobinqt.cn/session-cookie-token-difference/</link>
    <pubDate>Sat, 11 Jun 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/session-cookie-token-difference/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220824/ee39a9cb19524d918d984db89b1661a5.png" referrerpolicy="no-referrer">
            </div><!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="cookie-和-session" class="headerLink">
    <a href="#cookie-%e5%92%8c-session" class="header-mark"></a>Cookie 和 Session</h2><p>HTTP 协议是一种<code>无状态协议</code>，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录；Session 和 Cookie 的主要目的就是为了弥补 HTTP 的无状态特性。</p>
<h3 id="session-是什么" class="headerLink">
    <a href="#session-%e6%98%af%e4%bb%80%e4%b9%88" class="header-mark"></a>Session 是什么</h3><p>客户端请求服务端，服务端会为这次请求开辟一块<code>内存空间</code>，这个对象便是 Session 对象，存储结构为 <code>ConcurrentHashMap</code>。Session 弥补了 HTTP 无状态特性，服务器可以利用 Session 存储客户端在同一个会话期间的一些操作记录。</p>
<h3 id="session-如何判断是否是同一会话" class="headerLink">
    <a href="#session-%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e6%98%af%e5%90%a6%e6%98%af%e5%90%8c%e4%b8%80%e4%bc%9a%e8%af%9d" class="header-mark"></a>Session 如何判断是否是同一会话</h3><p>服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 <code>sessionId</code> ，并通过响应头的 <strong>Set-Cookie：JSESSIONID=XXXXXXX</strong> 命令，向客户端发送要求设置 Cookie 的响应；客户端收到响应后，在本机客户端设置了一个 <strong>JSESSIONID=XXXXXXX</strong> 的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220824/50c3ccd67e62465ab1beaa691995ed06.png" title="会话" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220824/50c3ccd67e62465ab1beaa691995ed06.png" data-sub-html="<h2>会话</h2><p>会话</p>">
        
    </a><figcaption class="image-caption">会话</figcaption>
    </figure></p>
<p>接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。</p>
<h3 id="session-的缺点" class="headerLink">
    <a href="#session-%e7%9a%84%e7%bc%ba%e7%82%b9" class="header-mark"></a>Session 的缺点</h3><p>Session 机制有个缺点，比如 A 服务器存储了 Session，就是做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。</p>
<h3 id="cookies-是什么" class="headerLink">
    <a href="#cookies-%e6%98%af%e4%bb%80%e4%b9%88" class="header-mark"></a>Cookies 是什么</h3><p>HTTP 协议中的 Cookie 包括 <code>Web Cookie</code> 和<code>浏览器 Cookie</code>，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。</p>
<blockquote>
<p>HTTP Cookie 机制是 HTTP 协议无状态的一种补充和改良</p>
</blockquote>
<p>Cookie 主要用于下面三个目的</p>
<ul>
<li><code>会话管理</code></li>
</ul>
<p>登陆、购物车、游戏得分或者服务器应该记住的其他内容</p>
<ul>
<li><code>个性化</code></li>
</ul>
<p>用户偏好、主题或者其他设置</p>
<ul>
<li><code>追踪</code></li>
</ul>
<p>记录和分析用户行为</p>
<p>Cookie 曾经用于一般的客户端存储。虽然这是合法的，因为它们是在客户端上存储数据的唯一方法，但如今建议使用现代存储 API。Cookie 随每个请求一起发送，因此它们<strong>可能会降低性能</strong>（尤其是对于移动数据连接而言）。</p>
<h3 id="创建-cookie" class="headerLink">
    <a href="#%e5%88%9b%e5%bb%ba-cookie" class="header-mark"></a>创建 Cookie</h3><p>当接收到客户端发出的 HTTP 请求时，服务器可以发送带有响应的 <code>Set-Cookie</code> 标头，Cookie 通常由浏览器存储，然后将 Cookie 与 HTTP 标头一同向服务器发出请求。</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Max-Age</code></td>
<td>设置cookie的过期时间，单位为秒</td>
</tr>
<tr>
<td><code>Domain</code></td>
<td>指定了Cookie所属的域名</td>
</tr>
<tr>
<td><code>Path</code></td>
<td>指定了Cookie所属的路径</td>
</tr>
<tr>
<td><code>HttpOnly</code></td>
<td>告诉浏览器此Cookie只能靠浏览器Http协议传输,禁止其他方式访问</td>
</tr>
<tr>
<td><code>Secure</code></td>
<td>告诉浏览器此Cookie只能在Https安全协议中传输,如果是Http则禁止传输</td>
</tr>
</tbody>
</table>
<h4 id="set-cookie-和-cookie-标头" class="headerLink">
    <a href="#set-cookie-%e5%92%8c-cookie-%e6%a0%87%e5%a4%b4" class="header-mark"></a>Set-Cookie 和 Cookie 标头</h4><p><code>Set-Cookie</code> HTTP 响应标头将 cookie 从服务器发送到用户代理。下面是一个发送 Cookie 的例子</p>
<p><a class="lightgallery" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e399c20870a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.png" title="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e399c20870a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.png" data-thumbnail="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e399c20870a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.png">
        
    </a></p>
<p>此标头告诉客户端存储 Cookie</p>
<p>现在，随着对服务器的每个新请求，浏览器将使用 Cookie 头将所有以前存储的 Cookie 发送回服务器。</p>
<p><a class="lightgallery" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e399aefd856~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.png" title="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e399aefd856~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.png" data-thumbnail="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e399aefd856~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.png">
        
    </a></p>
<p>有两种类型的 Cookies，一种是 <strong><ruby>Session Cookies<rt>会话 cookie</rt></ruby></strong>，一种是 <strong><ruby>Persistent Cookies<rt>永久 cookie</rt></ruby></strong>，如果 Cookie 不包含到期日期，则将其视为会话 Cookie。会话 Cookie 存储在内存中，永远不会写入磁盘，当浏览器关闭时，此后 Cookie 将永久丢失。如果 Cookie 包含<code>有效期</code> ，则将其视为持久性 Cookie。在到期指定的日期，Cookie 将从磁盘中删除。</p>
<p>还有一种是 Cookie 的 <code>Secure</code> 和 <code>HttpOnly</code> 标记。</p>
<h4 id="会话-cookies" class="headerLink">
    <a href="#%e4%bc%9a%e8%af%9d-cookies" class="header-mark"></a>会话 Cookies</h4><p>上面的示例创建的是会话 Cookie ，会话 Cookie 有个特征，客户端关闭时 Cookie 会删除，因为它<strong>没有指定</strong><code>Expires</code>或 <code>Max-Age</code> 指令。</p>
<p>但是，Web 浏览器可能会使用会话还原，这会使大多数会话 Cookie 保持永久状态，就像从未关闭过浏览器一样。</p>
<h4 id="永久性-cookies" class="headerLink">
    <a href="#%e6%b0%b8%e4%b9%85%e6%80%a7-cookies" class="header-mark"></a>永久性 Cookies</h4><p>永久性 Cookie 不会在客户端关闭时过期，而是在<code>特定日期（Expires）</code>或<code>特定时间长度（Max-Age）</code>外过期。例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="cookie-的-secure-和-httponly-标记" class="headerLink">
    <a href="#cookie-%e7%9a%84-secure-%e5%92%8c-httponly-%e6%a0%87%e8%ae%b0" class="header-mark"></a>Cookie 的 Secure 和 HttpOnly 标记</h4><p>安全的 Cookie 需要经过 HTTPS 协议通过加密的方式发送到服务器。即使是安全的，也不应该将敏感信息存储在cookie 中，因为它们本质上是不安全的，并且此标志不能提供真正的保护。</p>
<p><strong>HttpOnly 的作用</strong></p>
<ul>
<li>
<p>会话 Cookie 中缺少 HttpOnly 属性会导致攻击者可以通过程序( JS 脚本、Applet 等)获取到用户的 Cookie 信息，造成用户 Cookie 信息泄露，增加攻击者的跨站脚本攻击威胁。</p>
</li>
<li>
<p>HttpOnly 是微软对 Cookie 做的扩展，该值指定 Cookie 是否可通过客户端脚本访问。</p>
</li>
<li>
<p>如果在 Cookie 中<strong>没有设置</strong> <code>HttpOnly</code> 属性为 true，可能导致 Cookie 被窃取。窃取的 Cookie 可以包含标识站点用户的敏感信息，如 ASP.NET 会话 ID 或 Forms 身份验证票证，攻击者可以重播窃取的 Cookie，以便伪装成用户或获取敏感信息，进行跨站脚本攻击等。</p>
</li>
</ul>
<h3 id="cookie-的作用域" class="headerLink">
    <a href="#cookie-%e7%9a%84%e4%bd%9c%e7%94%a8%e5%9f%9f" class="header-mark"></a>Cookie 的作用域</h3><p><code>Domain</code> 和 <code>Path</code> 标识定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。</p>
<p><code>Domain</code> 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前主机(<strong>不包含子域名</strong>）。如果指定了<code>Domain</code>，则一般包含子域名。</p>
<p>例如，如果设置 <code>Domain=mozilla.org</code>，则 Cookie 也包含在子域名中（如<code>developer.mozilla.org</code>）。</p>
<p>例如，设置 <code>Path=/docs</code>，则以下地址都会匹配：</p>
<ul>
<li><code>/docs</code></li>
<li><code>/docs/Web/</code></li>
<li><code>/docs/Web/HTTP</code></li>
</ul>
<h2 id="json-web-token-和-session-cookies-的对比" class="headerLink">
    <a href="#json-web-token-%e5%92%8c-session-cookies-%e7%9a%84%e5%af%b9%e6%af%94" class="header-mark"></a>JSON Web Token 和 Session Cookies 的对比</h2><p><code>JSON Web Token</code>，简称 <code>JWT</code>，它和 <code>Session</code>都可以为网站提供用户的身份认证，但是它们不是一回事。</p>
<h3 id="jwt-和-session-cookies-的相同之处" class="headerLink">
    <a href="#jwt-%e5%92%8c-session-cookies-%e7%9a%84%e7%9b%b8%e5%90%8c%e4%b9%8b%e5%a4%84" class="header-mark"></a>JWT 和 Session Cookies 的相同之处</h3><p>在探讨 JWT 和 Session Cookies 之前，有必要需要先去理解一下它们的相同之处。</p>
<p>它们既可以对用户进行身份验证，也可以用来在用户单击进入不同页面时以及登陆网站或应用程序后进行身份验证。</p>
<p>如果没有这两者，那你可能需要在每个页面切换时都需要进行登录了。因为 HTTP 是一个无状态的协议。这也就意味着当你访问某个网页，然后单击同一站点上的另一个页面时，服务器的<code>内存中</code>将不会记住你之前的操作。</p>
<p><a class="lightgallery" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e399ae02cc8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.png" title="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e399ae02cc8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.png" data-thumbnail="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e399ae02cc8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.png">
        
    </a></p>
<p>因此，如果你登录并访问了你有权访问的另一个页面，由于 HTTP 不会记录你刚刚登录的信息，因此你将再次登录。</p>
<p><strong>JWT 和 Session Cookies 就是用来处理在不同页面之间切换，保存用户登录信息的机制</strong>。</p>
<p>也就是说，这两种技术都是<strong>用来保存你的登录状态</strong>，能够让你在浏览任意受密码保护的网站。通过在每次产生新的请求时对用户数据进行身份验证来解决此问题。</p>
<p>所以 JWT 和 Session Cookies 的相同之处是什么？那就是它们能够支持你在发送不同请求之间，记录并验证你的登录状态的一种机制。</p>
<h3 id="什么是-session-cookies" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-session-cookies" class="header-mark"></a>什么是 Session Cookies</h3><p>Session Cookies 也称为<code>会话 Cookies</code>，在 Session Cookies 中，用户的登录状态会保存在<code>服务器</code>的<code>内存</code>中。当用户登录时，Session 就被服务端安全的创建。</p>
<p>在每次请求时，服务器都会从会话 Cookie 中读取 SessionId，如果服务端的数据和读取的 SessionId 相同，那么服务器就会发送响应给浏览器，允许用户登录。</p>
<p>⚠️ 下图有点问题，域名应该一致。</p>
<p><a class="lightgallery" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e39cc16b100~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.png" title="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e39cc16b100~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.png" data-thumbnail="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e39cc16b100~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.png">
        
    </a></p>
<h3 id="什么是-json-web-tokens" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-json-web-tokens" class="header-mark"></a>什么是 Json Web Tokens</h3><p>Json Web Token 的简称就是 JWT，通常可以称为 <code>Json 令牌</code>。它是<code>RFC 7519</code> 中定义的用于<code>安全的</code>将信息作为 <code>Json 对象</code>进行传输的一种形式。JWT 中存储的信息是经过<code>数字签名</code>
的，因此可以被信任和理解。可以使用 HMAC 算法或使用 RSA/ECDSA 的公用/专用密钥对 JWT 进行签名。</p>
<p>使用 JWT 主要用来下面两点</p>
<ul>
<li>
<p><code>认证(Authorization)</code>：这是使用 JWT 最常见的一种情况，一旦用户登录，后面每个请求都会包含 JWT，从而允许用户访问该令牌所允许的路由、服务和资源。<code>单点登录</code>是当今广泛使用 JWT 的一项功能，因为它的开销很小。</p>
</li>
<li>
<p><code>信息交换(Information Exchange)</code>：JWT 是能够安全传输信息的一种方式。通过使用公钥/私钥对 JWT 进行签名认证。此外，由于签名是使用 <code>head</code> 和 <code>payload</code>
计算的，因此你还可以验证内容是否遭到篡改。</p>
</li>
</ul>
<h4 id="jwt-的格式" class="headerLink">
    <a href="#jwt-%e7%9a%84%e6%a0%bc%e5%bc%8f" class="header-mark"></a>JWT 的格式</h4><p>下面，我们会探讨一下 JWT 的组成和格式是什么</p>
<p>JWT 主要由三部分组成，每个部分用 <code>.</code> 进行分割，各个部分分别是</p>
<ul>
<li><code>Header</code></li>
<li><code>Payload</code></li>
<li><code>Signature</code></li>
</ul>
<p>因此，一个非常简单的 JWT 组成会是下面这样</p>
<p><a class="lightgallery" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e39ca50d82a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.png" title="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e39ca50d82a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.png" data-thumbnail="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e39ca50d82a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.png">
        
    </a></p>
<p><strong>Header</strong></p>
<p>Header 是 JWT 的标头，它通常由两部分组成：<code>令牌的类型(即 JWT)</code>和使用的 <code>签名算法</code>，例如 <code>HMAC SHA256</code>（写成 HS256） 或 <code>RSA</code>。</p>
<p>例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;alg&#34;: &#34;HS256&#34;,
</span></span><span class="line"><span class="cl">  &#34;typ&#34;: &#34;JWT&#34;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>指定类型和签名算法后，Json 块被 <code>Base64Url</code> 编码形成 JWT 的第一部分。</p>
<p><strong>Payload</strong></p>
<p>Token 的第二部分是 <code>Payload</code>，Payload 中包含一个声明。声明是有关实体（通常是用户）和其他数据的声明。共有三种类型的声明：<strong><code>registered</code>, <code>public</code> 和 <code>private</code></strong> 声明。</p>
<ul>
<li><code>registered 声明</code>： 包含一组建议使用的预定义声明，主要包括</li>
</ul>
<table>
<thead>
<tr>
<th>ISS</th>
<th>签发人</th>
</tr>
</thead>
<tbody>
<tr>
<td>iss (issuer)</td>
<td>签发人</td>
</tr>
<tr>
<td>exp (expiration time)</td>
<td>过期时间</td>
</tr>
<tr>
<td>sub (subject)</td>
<td>主题</td>
</tr>
<tr>
<td>aud (audience)</td>
<td>受众</td>
</tr>
<tr>
<td>nbf (Not Before)</td>
<td>生效时间</td>
</tr>
<tr>
<td>iat (Issued At)</td>
<td>签发时间</td>
</tr>
<tr>
<td>jti (JWT ID)</td>
<td>编号</td>
</tr>
</tbody>
</table>
<ul>
<li><code>public 声明</code>：公共的声明，可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密。</li>
<li><code>private 声明</code>：自定义声明，旨在在同意使用它们的各方之间共享信息，既不是注册声明也不是公共声明。</li>
</ul>
<p>例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;sub&#34;: &#34;1234567890&#34;,
</span></span><span class="line"><span class="cl">  &#34;name&#34;: &#34;John Doe&#34;,
</span></span><span class="line"><span class="cl">  &#34;admin&#34;: true
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后 payload Json 块会被<code>Base64Url</code> 编码形成 JWT 的第二部分。</p>
<p><strong>signature</strong></p>
<p>JWT 的第三部分是一个签证信息，这个签证信息由三部分组成</p>
<ul>
<li>header (base64后的)</li>
<li>payload (base64后的)</li>
<li>secret</li>
</ul>
<p>比如我们需要 HMAC SHA256 算法进行签名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">HMACSHA256(
</span></span><span class="line"><span class="cl">  base64UrlEncode(header) + &#34;.&#34; +
</span></span><span class="line"><span class="cl">  base64UrlEncode(payload),
</span></span><span class="line"><span class="cl">  secret)
</span></span></code></pre></td></tr></table>
</div>
</div><p>签名用于验证消息在此过程中没有更改，并且对于使用私钥进行签名的令牌，它还可以验证 JWT 的发送者的真实身份</p>
<h4 id="拼凑在一起" class="headerLink">
    <a href="#%e6%8b%bc%e5%87%91%e5%9c%a8%e4%b8%80%e8%b5%b7" class="header-mark"></a>拼凑在一起</h4><p>现在我们把上面的三个由点分隔的 Base64-URL 字符串部分组成在一起，这个字符串可以在 HTML 和 HTTP 环境中轻松传递这些字符串。</p>
<p>下面是一个完整的 JWT 示例，它对 header 和 payload 进行编码，然后使用 signature 进行签名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
</span></span></code></pre></td></tr></table>
</div>
</div><p><a class="lightgallery" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e39cc29f678~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.png" title="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e39cc29f678~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.png" data-thumbnail="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e39cc29f678~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.png">
        
    </a></p>
<p>如果想自己测试编写的话，可以访问 JWT 官网 <a href="https://jwt.io/#debugger-io" target="_blank" rel="noopener noreferrer">https://jwt.io/#debugger-io</a></p>
<h3 id="jwt-和-session-cookies-的不同" class="headerLink">
    <a href="#jwt-%e5%92%8c-session-cookies-%e7%9a%84%e4%b8%8d%e5%90%8c" class="header-mark"></a>JWT 和 Session Cookies 的不同</h3><p>JWT 和 Session Cookies 都提供安全的用户身份验证，但是它们有以下几点不同</p>
<h4 id="密码签名" class="headerLink">
    <a href="#%e5%af%86%e7%a0%81%e7%ad%be%e5%90%8d" class="header-mark"></a>密码签名</h4><p>JWT 具有加密签名，而 Session Cookies 则没有。</p>
<h4 id="json-是无状态的" class="headerLink">
    <a href="#json-%e6%98%af%e6%97%a0%e7%8a%b6%e6%80%81%e7%9a%84" class="header-mark"></a>JSON 是无状态的</h4><p>JWT 是<code>无状态</code>的，因为声明被存储在<code>客户端</code>，而不是服务端内存中。</p>
<p>身份验证可以在<code>本地</code>进行，而不是在请求必须通过服务器数据库或类似位置中进行。 这意味着可以对用户进行多次身份验证，而无需与站点或应用程序的数据库进行通信，也无需在此过程中消耗大量资源。</p>
<h4 id="可扩展性" class="headerLink">
    <a href="#%e5%8f%af%e6%89%a9%e5%b1%95%e6%80%a7" class="header-mark"></a>可扩展性</h4><p>Session Cookies 是存储在服务器内存中，这就意味着如果网站或者应用很大的情况下会耗费大量的资源。由于 JWT 是无状态的，在许多情况下，它们可以节省服务器资源。因此 JWT 要比 Session Cookies 具有更强的<code>可扩展性</code>。</p>
<h4 id="jwt-支持跨域认证" class="headerLink">
    <a href="#jwt-%e6%94%af%e6%8c%81%e8%b7%a8%e5%9f%9f%e8%ae%a4%e8%af%81" class="header-mark"></a>JWT 支持跨域认证</h4><p>Session Cookies 只能用在<code>单个节点的域</code>或者它的<code>子域</code>中有效。如果它们尝试通过第三个节点访问，就会被禁止。如果你希望自己的网站和其他站点建立安全连接时，这是一个问题。</p>
<p>使用 JWT 可以解决这个问题，使用 JWT 能够通过<code>多个节点</code>进行用户认证，也就是我们常说的<code>跨域认证</code>。</p>
<h3 id="jwt-和-session-cookies-的选型" class="headerLink">
    <a href="#jwt-%e5%92%8c-session-cookies-%e7%9a%84%e9%80%89%e5%9e%8b" class="header-mark"></a>JWT 和 Session Cookies 的选型</h3><p>我们上面探讨了 JWT 和 Cookies 的不同点，相信你也会对选型有了更深的认识，大致来说</p>
<p>对于只需要登录用户并访问存储在站点数据库中的一些信息的中小型网站来说，Session Cookies 通常就能满足。</p>
<p>如果你有企业级站点，应用程序或附近的站点，并且需要处理大量的请求，尤其是第三方或很多第三方（包括位于不同域的API），则 JWT 显然更适合。</p>
<h2 id="faq" class="headerLink">
    <a href="#faq" class="header-mark"></a>FAQ</h2><h4 id="如何禁用-cookies-后使用-session" class="headerLink">
    <a href="#%e5%a6%82%e4%bd%95%e7%a6%81%e7%94%a8-cookies-%e5%90%8e%e4%bd%bf%e7%94%a8-session" class="header-mark"></a>如何禁用 Cookies 后，使用 Session</h4><ul>
<li>如果禁用了 Cookies，服务器仍会将 sessionId 以 cookie 的方式发送给浏览器，但是，浏览器不再保存这个cookie (即sessionId) 了。</li>
<li>如果想要继续使用 session，需要采用 <code>URL 重写</code>
的方式来实现，可以参考 <a href="https://www.cnblogs.com/Renyi-Fan/p/11012086.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/Renyi-Fan/p/11012086.html</a></li>
</ul>
<h3 id="jwt-前端解码" class="headerLink">
    <a href="#jwt-%e5%89%8d%e7%ab%af%e8%a7%a3%e7%a0%81" class="header-mark"></a>JWT 前端解码</h3><p>在线解密工具<a href="https://www.box3.cn/tools/jwt.html" target="_blank" rel="noopener noreferrer">https://www.box3.cn/tools/jwt.html</a></p>
<p>npm 包<a href="https://www.npmjs.com/package/jwt-decode" target="_blank" rel="noopener noreferrer">https://www.npmjs.com/package/jwt-decode</a></p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://juejin.cn/post/6844904115080790023" target="_blank" rel="noopener noreferrer">看完这篇 Session、Cookie、Token，和面试官扯皮就没问题了</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener noreferrer">JSON Web Token 入门教程</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/193090304" target="_blank" rel="noopener noreferrer">认证方式的前世今生，以及 JWT 的使用</a></li>
</ul>
]]></description>
</item><item>
    <title>MySQL 常见问题（二）</title>
    <link>https://www.xiaobinqt.cn/mysql-faq-2/</link>
    <pubDate>Sat, 21 May 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/mysql-faq-2/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="索引数据结构为什么不使用红黑树或b树" class="headerLink">
    <a href="#%e7%b4%a2%e5%bc%95%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e4%bd%bf%e7%94%a8%e7%ba%a2%e9%bb%91%e6%a0%91%e6%88%96b%e6%a0%91" class="header-mark"></a>索引数据结构为什么不使用红黑树或B树</h2><p>在 InnoDB 引擎中，索引的底层数据结构是 B+ 树。MySQL 的数据是存储在硬盘的，在查询时一般是不能「一次性」把全部数据加载到内存中。红黑树是「二叉查找树」的变种，一个 Node 节点只能存储一个<code>Key</code>和一个<code>Value</code>。B 和 B+ 树跟红黑树不一样，它们算是「多路搜索树」，相较于「二叉搜索树」而言，一个 Node 节点可以存储的信息会更多，「多路搜索树」的高度会比「二叉搜索树」更低。</p>
<p>了解了区别之后，其实就很容易发现，在数据不能一次加载至内存的场景下，数据需要被检索出来，选择 B 或 B+ 树的理由就很充分了，一个 Node 节点存储信息更多（相较于二叉搜索树）， 树的高度更低，
<strong>树的高度影响检索的速度</strong>。</p>
<p>B+ 树相对于 B 树而言，它又有两种特性：</p>
<ul>
<li>
<p>B+ 树非叶子节点不存储数据，在相同的数据量下，B+ 树更加矮壮。数据都存储在叶子节点上，非叶子节点的存储能存储更多的索引，所以整棵树就更加矮壮。<strong>树的高度能够决定磁盘 IO 的次数</strong>，磁盘 IO 次数越少，对于性能的提升就越大。</p>
</li>
<li>
<p>因为叶子节点存储所有数据，所以 B+ 树的全局扫描能力更强一些，因为它只需要扫描叶子节点。但是 B 树需要遍历整个树。B+ 树叶子节点之间组成一个链表，方便于遍历查询，遍历操作在 MySQL 中比较常见。</p>
</li>
</ul>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221201/b768c90fe50b48aa8d7deec33efd7e8c.png" title="b&#43;树" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221201/b768c90fe50b48aa8d7deec33efd7e8c.png" data-sub-html="<h2>b&#43;树</h2><p>b&#43;树</p>">
        
    </a><figcaption class="image-caption">b+树</figcaption>
    </figure></p>
<p>在 MySQL InnoDB 引擎下，每创建一个索引，相当于生成了一颗 B+ 树。如果该索引是「聚集（聚簇）索引」，那当前 B+ 树的叶子节点存储着「主键和当前行的数据」，如果该索引是「非聚簇索引」，那当前 B+ 树的叶子节点存储着「主键和当前索引列值」</p>
<p>比如写了一句👇</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="k">select</span> * from user where id &gt;<span class="o">=</span> <span class="m">10</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>那只要定位到 id 为 10 的记录，然后在叶子节点之间通过遍历链表（叶子节点组成的链表），即可找到往后的记录了。由于 B 树是会在非叶子节点也存储数据，要遍历的时候可能就得<strong>跨层</strong>检索，相对麻烦些。基于树的层级以及业务使用场景的特性，所以 MySQL 选择了 B+ 树作为索引的底层数据结构。</p>
<h2 id="什么叫做回表" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e5%8f%ab%e5%81%9a%e5%9b%9e%e8%a1%a8" class="header-mark"></a>什么叫做回表</h2><p>当我们使用索引查询数据时，检索出来的数据可能包含其他列，但走的索引树，叶子节点只能查到当前列值以及主键 ID，所以需要根据主键 ID 再去查一遍数据，得到SQL 所需的列。</p>
<p>举个例子，如果给订单号字段<code>orderId</code>建了个索引，但查询的 SQL 是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="k">select</span> orderId,orderName from orderdetail where <span class="nv">orderId</span> <span class="o">=</span> <span class="m">123</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<code>orderId</code>的索引树的叶子节点只有<code>orderId</code>和主键<code>Id</code>，而我们还想检索出<code>orderName</code>，所以 MySQL 会拿到 ID 再去查出<code>orderName</code>给我们返回，这种操作就叫回表。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221201/89f82e92055d4bd78318ab9baa4d9dd5.png" title="回表" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221201/89f82e92055d4bd78318ab9baa4d9dd5.png" data-sub-html="<h2>回表</h2><p>回表</p>">
        
    </a><figcaption class="image-caption">回表</figcaption>
    </figure></p>
<p>想要避免回表，也可以使用覆盖索引（能使用就使用，因为可以避免回表操作）。</p>
<p>所谓的覆盖索引，实际上就是你想要查出的列刚好在叶子节点上都存在，比如建了<code>orderId</code>和<code>orderName</code>联合索引，刚好我需要查询也是<code>orderId</code>和<code>orderName</code>，这些数据都存在索引树的叶子节点上，就不需要回表操作了。所以，如果查询的字段恰好命中联合索引的字段，则可以避免回表操作。</p>
<h2 id="什么是最左匹配原则" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%9c%80%e5%b7%a6%e5%8c%b9%e9%85%8d%e5%8e%9f%e5%88%99" class="header-mark"></a>什么是最左匹配原则</h2><p>如果有联合索引 (a,b,c,d)，实际上其实新建了 <code>a</code>，<code>ab</code>，<code>abc</code>，<code>abcb</code> 四个索引，因此只要查询中使用了这 4 组字段，都可以让联合索引生效。</p>
<p>查询条件 <code>a=1 and b=2 and c&gt;3 and d=4</code>，这里只能使用<code>a</code>，<code>b</code>和<code>a、b</code>索引，而不能使用<code>a、b、c</code>或<code>a、b、c、d</code>索引。</p>
<p>先匹配最左边的，索引只能用于查找<code>key</code>是否存在或相等，遇到范围查询<code>&gt;</code>、<code>&lt;</code>、<code>between</code>、<code>like</code>左匹配等就不能进一步匹配了，后续退化为线性查找，这就是最左匹配原则。</p>
<h2 id="实际项目中如何生成主键" class="headerLink">
    <a href="#%e5%ae%9e%e9%99%85%e9%a1%b9%e7%9b%ae%e4%b8%ad%e5%a6%82%e4%bd%95%e7%94%9f%e6%88%90%e4%b8%bb%e9%94%ae" class="header-mark"></a>实际项目中如何生成主键</h2><p>用自增主键。首先主键得保证它的唯一性和空间尽可能短，这两块是需要考虑的。由于索引的有序特性，id 本身具有连续性使得对应的数据也会按照顺序存储在磁盘上，写入性能和检索性能都很高。如果使用 uuid 这种随机 id，那么在频繁插入数据的时候，就会导致随机磁盘 IO，从而导致性能较低。</p>
<h2 id="如何理解innodb引擎中的事务" class="headerLink">
    <a href="#%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3innodb%e5%bc%95%e6%93%8e%e4%b8%ad%e7%9a%84%e4%ba%8b%e5%8a%a1" class="header-mark"></a>如何理解InnoDB引擎中的事务</h2><p>事务可以使「一组操作」要么全部成功，要么全部失败。事务其目的是为了「保证数据最终的一致性」。</p>
<h2 id="事务的特性" class="headerLink">
    <a href="#%e4%ba%8b%e5%8a%a1%e7%9a%84%e7%89%b9%e6%80%a7" class="header-mark"></a>事务的特性</h2><p>ACID，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p>
<p><strong>原子性</strong>指的是：当前事务的操作要么同时成功，要么同时失败。原子性由 undo log 日志来保证，因为 undo log 记载着数据修改前的信息。</p>
<p>比如我们要 insert 一条数据了，那 undo log 会记录的一条对应的 delete 日志。我们要 update 一条记录时，那 undo log 会记录之前的「旧值」的 update 记录。</p>
<p>如果执行事务过程中出现异常的情况，那执行「回滚」。InnoDB 引擎就是利用 undo log 记录下的数据，来将数据「恢复」到事务开始之前。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/8a8fcedc257b42c8ad74a868363fdafe.png" title="原子性" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/8a8fcedc257b42c8ad74a868363fdafe.png" data-sub-html="<h2>原子性</h2><p>原子性</p>">
        
    </a><figcaption class="image-caption">原子性</figcaption>
    </figure></p>
<p><strong>隔离性</strong>指的是：在事务「并发」执行时，他们内部的操作不能互相干扰。如果多个事务可以同时操作一个数据，那么就会产生脏读、不可重复读、幻读的问题。于是，事务与事务之间需要存在「一定」的隔离。</p>
<p>在 InnoDB 引擎中，定义了四种隔离级别供我们使用，分别是：<strong><ruby>read uncommitted<rt>读未提交</rt></ruby></strong>、<strong><ruby>read committed<rt>读已提交</rt></ruby></strong>、<strong><ruby>repeatable read<rt>可重复复读</rt></ruby></strong>、<strong><ruby>serializable<rt>串行</rt></ruby></strong>。</p>
<p>不同的隔离级别对事务之间的隔离性是不一样的，级别越高事务隔离性越好，但性能就越低，而隔离性是由 MySQL 的各种锁来实现的，只是它屏蔽了加锁的细节。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/20d805b51694457d955fbf985e0e9adb.png" title="隔离性" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/20d805b51694457d955fbf985e0e9adb.png" data-sub-html="<h2>隔离性</h2><p>隔离性</p>">
        
    </a><figcaption class="image-caption">隔离性</figcaption>
    </figure></p>
<p><strong>持久性</strong>指的就是：一旦提交了事务，它对数据库的改变就应该是永久性的。说白了就是，会将数据持久化在硬盘上。</p>
<p>而持久性由 redo log 日志来保证。当我们要修改数据时，MySQL 是先把这条记录所在的「页」找到，然后把该页加载到内存中，将对应记录进行修改。</p>
<p>为了防止内存修改完了，MySQL 就挂掉的问题。如果内存改完，直接挂掉，那这次的修改相当于就丢失了。对于这个问题，MySQL引入了 redo log，内存写完了，然后会写一份 redo log，这份 redo log 记载着这次在某个页上做了什么修改。即便 MySQL 在中途挂了，我们还可以根据 redo log 来对数据进行恢复。redo log 是顺序写的，写入速度很快。并且它记录的是物理修改（xxxx 页做了 xxx 修改），文件的体积很小，恢复速度很快。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/a58e871764ee402e933beb1c10adae7c.png" title="持久性" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/a58e871764ee402e933beb1c10adae7c.png" data-sub-html="<h2>持久性</h2><p>持久性</p>">
        
    </a><figcaption class="image-caption">持久性</figcaption>
    </figure></p>
<p><strong>一致性</strong>任何一个事务发生的前后，库中的数据变化必须一致。可以理解为我们使用事务的「目的」，而「隔离性」「原子性」「持久性」均是为了保障「一致性」的手段，保证一致性需要由应用程序代码来保证。比如，如果事务在发生的过程中，出现了异常情况，此时你就得回滚事务，而不是强行提交事务来导致数据不一致。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/4702334e18194c00b62d4001d1100e13.png" title="一致性" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/4702334e18194c00b62d4001d1100e13.png" data-sub-html="<h2>一致性</h2><p>一致性</p>">
        
    </a><figcaption class="image-caption">一致性</figcaption>
    </figure></p>
<h2 id="什么是两阶段提交" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e4%b8%a4%e9%98%b6%e6%ae%b5%e6%8f%90%e4%ba%a4" class="header-mark"></a>什么是两阶段提交</h2><p>MySQL 的 bin log 只能用于归档，不足以实现<strong><ruby>崩溃恢复<rt>crash-safe</rt></ruby></strong>，需要借助 InnoDB 引擎的 redo log 才能拥有崩溃恢复的能力。所谓崩溃恢复就是，即使在数据库宕机的情况下，也不会出现操作一半的情况。</p>
<p><strong>bin log 和 redo log 的区别</strong>👇</p>
<p>bin log 是 MySQL 的 Server 层实现的，对所有引擎都可以使用，而 redo log 是 InnoDB 引擎特有的。</p>
<p>bin log 是可以追加写入的。“追加写” 是指 bin log 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志，保存的是全量的日志。但是这就会导致一个问题，就是没有标志能让 InnoDB 从 bin log 中判断哪些数据已经刷入磁盘了，哪些数据还没有。</p>
<p>redo log 是循环写的，redo log 只会记录未刷入磁盘的日志，已经刷入磁盘的数据都会从 redo log 这个有限大小的日志文件里删除。</p>
<p>bin log 因为是全量日志，所以可以作为恢复数据使用，主从复制搭建。redo log 可以作为异常宕机或者故障后的数据恢复使用。</p>
<p>以下面的 SQL 语句为例，来解释下执行器和 InnoDB 存储引擎在更新时做了哪些事情：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">update table <span class="nb">set</span> <span class="nv">age</span> <span class="o">=</span> age + <span class="m">1</span> where <span class="nv">id</span> <span class="o">=</span> 1<span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221206/0fa9678f6b214a63bfdd8506cabe8a28.png" title="两阶段提交" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221206/0fa9678f6b214a63bfdd8506cabe8a28.png" data-sub-html="<h2>两阶段提交</h2><p>两阶段提交</p>">
        
    </a><figcaption class="image-caption">两阶段提交</figcaption>
    </figure></p>
<p>所谓两阶段提交，其实就是把 redo log 的写入拆分成了两个步骤<code>prepare</code>和<code>commit</code>。根据两阶段提交，崩溃恢复时的判断规则是这样的：</p>
<p>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交。</p>
<p>如果 redo log 里面的事务处于 prepare 状态，则判断对应的事务 binlog 是否存在并完整。</p>
<ol>
<li>如果 binlog 存在并完整，则提交事务；</li>
<li>否则，回滚事务。</li>
</ol>
<h2 id="为什么需要两阶段提交" class="headerLink">
    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e4%b8%a4%e9%98%b6%e6%ae%b5%e6%8f%90%e4%ba%a4" class="header-mark"></a>为什么需要两阶段提交</h2><p>两阶段提交主要是<strong>为了解决主从数据同步的问题</strong>。如果没有两阶段提交，那么 binlog 和 redolog 的提交，无非就是两种形式👇</p>
<ol>
<li>先写 bin-log 再写 redo-log</li>
<li>先写 redo-log 再写 bin-log</li>
</ol>
<p>假设我们要向表中插入一条记录 R，如果是先写 bin-log 再写 redo-log，那么假设 bin-log 写完后崩溃了，此时 redo-log 还没写。那么重启恢复的时候就会出问题：bin-log 中已经有 R 的记录了，当从机从主机同步数据的时候或者我们使用 bin-log 恢复数据的时候，就会同步到 R 这条记录；但是 redo-log 中没有关于 R 的记录，所以崩溃恢复之后，插入 R 记录的这个事务是无效的，即数据库中没有该行记录，这就造成了数据不一致。</p>
<p>相反，假设我们要向表中插入一条记录 R，如果是先写 redo-log 再写 bin-log，那么假设 redo-log 写完后崩溃了，此时 bin-log 还没写。那么重启恢复的时候也会出问题：redo-log 中已经有 R 的记录了，所以崩溃恢复之后，插入 R 记录的这个事务是有效的，通过该记录将数据恢复到数据库中；但是 bin-log 中还没有关于 R 的记录，所以当从机从主机同步数据的时候或者我们使用 bin-log 恢复数据的时候，就不会同步到 R 这条记录，这就造成了数据不一致。</p>
<h2 id="四种隔离级别" class="headerLink">
    <a href="#%e5%9b%9b%e7%a7%8d%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab" class="header-mark"></a>四种隔离级别</h2><ol>
<li>Read uncommitted/RU：读未提交，处于该隔离级别的数据库，脏读、不可重复读、幻读问题都有可能发生。</li>
<li>Read committed/RC：读已提交，处于该隔离级别的数据库，解决了脏读问题，不可重复读、幻读问题依旧存在。</li>
<li>Repeatable read/RR：可重复读，处于该隔离级别的数据库，解决了脏读、不可重复读、幻读问题。</li>
<li>Serializable：序列化/串行化，处于该隔离级别的数据库，解决了脏读、不可重复读、幻读问题都不存在。</li>
</ol>
<p>数据库事务的隔离级别，<strong>由低到高</strong>依次为 Read uncommitted 、Read committed、Repeatable read 、Serializable。</p>
<p>上述四个级别，越靠后并发控制度越高，也就是在多线程并发操作的情况下，出现问题的几率越小，但对应的也性能越差，MySQL 的事务隔离级别， 默认为第三级别：<code>Repeatable read</code>可重复读。</p>
<p>首先来看下<strong><ruby>read uncommitted<rt>读未提交</rt></ruby></strong>。比如说：A 向 B 转账，A 执行了转账语句，但 A 还没有提交事务，B 读取数据，发现自己账户钱变多了！B 跟 A 说，我已经收到钱了。A 回滚事务【rollback】，等 B 再查看账户的钱时，发现钱并没有多。</p>
<p>简单的定义就是：事务 B 读取到了事务 A 还没提交的数据，这种用专业术语来说叫做「<strong>脏读</strong>」。</p>
<p>对于锁的维度而言，其实就是在 read uncommitted 隔离级别下，读不会加任何锁，而写会加排他锁。读什么锁都不加，这就让排他锁无法排它了。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/06ccfe53f21143e8a3a9093f0864ac46.png" title="读未提交" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/06ccfe53f21143e8a3a9093f0864ac46.png" data-sub-html="<h2>读未提交</h2><p>读未提交</p>">
        
    </a><figcaption class="image-caption">读未提交</figcaption>
    </figure></p>
<p>而我们知道，对于更新操作而言，InnoDB 是肯定会加写锁的（数据库是不可能允许在同一时间，更新同一条记录的）。而读操作，如果不加任何锁，那就会造成上面的脏读。</p>
<p>脏读在生产环境下肯定是无法接受的，那如果读加锁的话，那意味着：当更新数据的时，就没办法读取了，这会极大地降低数据库性能。</p>
<p>在 MySQL InnoDB 引擎层面，有新的解决方案，解决加锁后读写性能问题，叫做<strong><ruby>MVCC<rt>Multi-Version Concurrency Control</rt></ruby></strong>多版本并发控制。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/0e52740b759b4aa490ef6e37497de964.png" title="MVCC" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/0e52740b759b4aa490ef6e37497de964.png" data-sub-html="<h2>MVCC</h2><p>MVCC</p>">
        
    </a><figcaption class="image-caption">MVCC</figcaption>
    </figure></p>
<p>在 MVCC 下，就可以做到读写不阻塞，且避免了类似脏读这样的问题。那 MVCC 是怎么做的呢❓</p>
<p>MVCC 通过生成数据<strong><ruby>快照<rt>Snapshot</rt></ruby></strong>，并用这个快照来提供一定级别（语句级或事务级）的一致性读取。</p>
<p>回到事务隔离级别下，针对于<strong><ruby>read committed<rt>读已提交</rt></ruby></strong> 隔离级别，它生成的就是<strong>语句级快照</strong>，而针对于<strong><ruby>repeatable read<rt>可重复读</rt></ruby></strong>，它生成的就是<strong>事务级的快照</strong>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/00282fd01288429b8b03a1407b7c5227.png" title="MVCC2" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/00282fd01288429b8b03a1407b7c5227.png" data-sub-html="<h2> </h2><p>MVCC2</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<p>前面提到过 read uncommitted 隔离级别下会产生脏读，而<strong><ruby>read committed<rt>读已提交</rt></ruby></strong> 隔离级别解决了脏读。思想其实很简单：在读取的时候生成一个 “版本号”，等到其他事务 commit 了之后，才会读取最新已 commit 的 “版本号” 数据。</p>
<p>比如说：事务 A 读取了记录（生成版本号），事务 B 修改了记录，此时加了写锁，事务 A 再读取的时候，是依据最新的版本号来读取的（当事务 B 执行 commit 了之后，会生成一个新的版本号），如果事务 B 还没有 commit，那事务 A 读取的还是之前版本号的数据。</p>
<p>通过「版本」的概念，这样就解决了脏读的问题，而「版本」其实就是对应快照的数据。</p>
<p><strong><ruby>read committed<rt>读已提交</rt></ruby></strong> 解决了脏读，但也会有其他并发的问题。「不可重复读」：一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改。</p>
<p>不可重复读的例子：A 查询数据库得到数据，B 去修改数据库的数据，导致 A 多次查询数据库的结果都不一样【危害：A 每次查询的结果都是受 B 的影响的】</p>
<p>了解 MVCC 之后，就很容易想到<strong><ruby>repeatable read<rt>可重复复读</rt></ruby></strong> 隔离级别是怎么避免不可重复读的问题了。</p>
<p><strong><ruby>repeatable read<rt>可重复复读</rt></ruby></strong>隔离级别是「事务级别」的快照！每次读取的都是「当前事务的版本」，即使当前数据被其他事务修改了（commit），也只会读取当前事务版本的数据。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/c8d49279d79f4b5fb09d26aba8a809bd.png" title="MVCC3" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/c8d49279d79f4b5fb09d26aba8a809bd.png" data-sub-html="<h2> </h2><p>MVCC3</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<p>而<strong><ruby>repeatable read<rt>可重复复读</rt></ruby></strong> 隔离级别会存在幻读的问题，「幻读」指的是指在一个事务内读取到了别的事务<strong>插入</strong>的数据，导致前后读取不一致。</p>
<p>在 InnoDB 引擎下的的<strong><ruby>repeatable read<rt>可重复复读</rt></ruby></strong>隔离级别下，快照读 MVCC 影响下，已经解决了幻读的问题（因为它是读历史版本的数据）。</p>
<p>而如果是当前读（指的是<code>select * from table for update</code>），则需要配合间隙锁来解决幻读的问题。</p>
<p>剩下的就是<strong><ruby>serializable<rt>串行</rt></ruby></strong>隔离级别了，它的最高的隔离级别，相当于不允许事务的并发，事务与事务之间执行是串行的，它的效率最低，但同时也是最安全的。</p>
<h2 id="事务隔离机制的底层实现" class="headerLink">
    <a href="#%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb%e6%9c%ba%e5%88%b6%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0" class="header-mark"></a>事务隔离机制的底层实现</h2><p>每种隔离级别都是基于锁和 MVCC 机制实现的👇</p>
<ul>
<li>读未提交/RU：写操作加排他锁，读操作不加锁。</li>
<li>读已提交/RC：写操作加排他锁，读操作使用 MVCC，但每次 select 都生成读视图。</li>
<li>可重复读/RR：写操作加排他锁，读操作依旧采用 MVCC 机制，但一次事务中只生成一个读视图。</li>
<li>序列化/Serializable：所有写操作加临键锁（具备互斥特性），所有读操作加共享锁。</li>
</ul>
<h2 id="mvcc原理" class="headerLink">
    <a href="#mvcc%e5%8e%9f%e7%90%86" class="header-mark"></a>MVCC原理</h2><p>MVCC 的主要是通过 read view 和 undo log 来实现的。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/3f80906689ea4930bbf75288bd905d3c.png" title="mvcc原理" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/3f80906689ea4930bbf75288bd905d3c.png" data-sub-html="<h2>mvcc原理</h2><p>mvcc原理</p>">
        
    </a><figcaption class="image-caption">mvcc原理</figcaption>
    </figure></p>
<p>undo log 会记录修改数据之前的信息，事务中的原子性就是通过 undo log 来实现的。所以有 undo log 可以帮我们找到「版本」的数据。</p>
<p>而 read view 实际上就是在查询时，InnoDB 会生成一个 read view，read view 有几个重要的字段，分别是：</p>
<ul>
<li><code>trx_ids</code> 尚未提交 commit 的事务版本号集合</li>
<li><code>up_limit_id</code> 下一次要生成的事务 ID 值</li>
<li><code>low_limit_id</code> 尚未提交版本号的事务 ID 最小值</li>
<li><code>creator_trx_id</code> 当前的事务版本号</li>
</ul>
<p>在每行数据有两列隐藏的字段，分别是<code>DB_TRX_ID</code>（记录着当前 ID）以及<code>DB_ROLL_PTR</code> 指向上一个版本数据在 undo log 里的位置指针，到这里，很容易就发现，MVCC 其实就是靠「比对版本」来实现读写不阻塞，而版本的数据存在于 undo log 中。</p>
<p>而针对于不同的隔离级别 read committed 和 repeatable read，无非就是 read committed 隔离级别下，每次都获取一个新的 read view，repeatable read 隔离级别则每次事务只获取一个 read view。</p>
<h2 id="工作中如何建索引" class="headerLink">
    <a href="#%e5%b7%a5%e4%bd%9c%e4%b8%ad%e5%a6%82%e4%bd%95%e5%bb%ba%e7%b4%a2%e5%bc%95" class="header-mark"></a>工作中如何建索引</h2><p>如果表有一定的数据量，那就应该要创建对应的索引，创建索引需要注意的点，比如说👇</p>
<ol>
<li>
<p>是否能使用「覆盖索引」，减少「回表」所消耗的时间。意味着，我们在 select 的时候，一定要指明对应的列，而不是<code>select *</code></p>
</li>
<li>
<p>考虑是否组建「联合索引」，如果组建「联合索引」，尽量将区分度最高的放在最左边，并且需要考虑「最左匹配原则」</p>
</li>
<li>
<p>对索引进行函数操作或者表达式计算会导致索引失效</p>
</li>
<li>
<p>利用子查询优化超多分页场景。比如<code>limit offset</code>, n 在 MySQL 是获取 offset + n 的记录，再返回 n 条。而利用子查询则是查出 n 条，通过 ID 检索对应的记录出来，提高查询效率。</p>
</li>
<li>
<p>通过 explain 命令来查看 SQL 的执行计划，看看自己写的 SQL 是否走了索引，走了什么索引。通过 show profile 来查看 SQL 对系统资源的损耗情况（不过一般还是比较少用到）</p>
</li>
<li>
<p>在开启事务后，在事务内尽可能只操作数据库，并有意识地减少锁的持有时间。比如在事务内需要插入和修改数据，那可以先插入后修改。因为修改是更新操作，会加行锁。如果先更新，那并发下可能会导致多个事务的请求等待行锁释放。</p>
</li>
</ol>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/7a6c78d1a5ac42e587ffd82ced372440.png" title="索引" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/7a6c78d1a5ac42e587ffd82ced372440.png" data-sub-html="<h2>索引</h2><p>索引</p>">
        
    </a><figcaption class="image-caption">索引</figcaption>
    </figure></p>
<h2 id="线上用的是什么隔离级别" class="headerLink">
    <a href="#%e7%ba%bf%e4%b8%8a%e7%94%a8%e7%9a%84%e6%98%af%e4%bb%80%e4%b9%88%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab" class="header-mark"></a>线上用的是什么隔离级别</h2><p>我们这边用的是<strong><ruby>Read committed<rt>读已提交</rt></ruby></strong>，MySQL 默认用的是 <strong><ruby>Repeatable read<rt>可重复读</rt></ruby></strong>。</p>
<p>选用什么隔离级别，主要看应用场景，因为隔离级别越低，事务并发性能越高。一般互联网公司都选择 Read committed 作为主要的隔离级别。</p>
<p>像<strong><ruby>Repeatable read<rt>可重复读</rt></ruby></strong>隔离级别，就有可能因为「间隙锁」导致的死锁问题。</p>
<p>MySQL 默认的隔离级别为 Repeatable read。很大一部分原因是在最开始的时候，MySQL 的 binlog 没有 row 模式（记录具体出现变更的数据，也会包含数据所在的分区以及所位于的数据页），在 read committed 隔离级别下会存在「主从数据不一致」的问题。binlog 记录了数据库表结构和表数据「变更」，比如<code>update/delete/insert/truncate/create</code>。在 MySQL 中，主从同步实际上就是应用了 binlog 来实现的。有了该历史原因，所以 MySQL 就将默认的隔离级别设置为 Repeatable read。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/acbe1fc753c84d1e9a9ccbd047f8afc9.png" title="隔离级别" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/acbe1fc753c84d1e9a9ccbd047f8afc9.png" data-sub-html="<h2>隔离级别</h2><p>隔离级别</p>">
        
    </a><figcaption class="image-caption">隔离级别</figcaption>
    </figure></p>
<h2 id="为什么走了索引查询还是慢" class="headerLink">
    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%b5%b0%e4%ba%86%e7%b4%a2%e5%bc%95%e6%9f%a5%e8%af%a2%e8%bf%98%e6%98%af%e6%85%a2" class="header-mark"></a>为什么走了索引查询还是慢</h2><p>如果走对了索引，但查询还是慢，那一般来说就是表的数据量实在是太大了。</p>
<p>首先，考虑能不能把「旧的数据」给 “删掉” 😢 如果「旧的数据」已经没有查询的业务了，那最简单的办法肯定是 “删掉” 部分数据咯。数据量降低了，那自然，检索速度就快了&hellip;.</p>
<p>其实，只有极少部分业务可以删掉数据&hellip;</p>
<p>那么，就考虑另一种情况，能不能在查询之前，直接走一层缓存（Redis）。</p>
<p>而走缓存的话，又要看业务能不能忍受读取的「非真正实时」的数据（毕竟 Redis 和 MySQL 的数据一致性需要保证），如果查询条件相对复杂且多变的话（涉及各种 group by 和 sum ），那走缓存也不是一种好的办法，维护起来就不方便了…</p>
<p>再看看是不是有「字符串」检索的场景导致查询低效，如果是的话，可以考虑把表的数据导入至 Elasticsearch 类的搜索引擎，后续的线上查询就直接走 Elasticsearch 了。</p>
<p><code>MySQL-&gt;Elasticsearch</code> 需要有对应的同步程序（一般就是监听 MySQL 的 binlog，解析 binlog 后导入到 Elasticsearch)。</p>
<p>如果还不是的话，那考虑要不要根据查询条件的维度，做相对应的聚合表，线上的请求就查询聚合表的数据，不走原表。</p>
<p>比如，用户下单后，有一份订单明细，而订单明细表的量级太大。但在产品侧（前台）透出的查询功能是以「天」维度来展示的，那就可以将每个用户的每天数据聚合起来，在聚合表就是一个用户一天只有一条汇总后的数据。查询走聚合后的表，那速度肯定很快的（聚合后的表数据量肯定比原始表要少很多）。</p>
<p>思路大致的就是「以空间换时间」，相同的数据换别的地方也存储一份，提高查询效率。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/9861ea4c29cb40a583593ce747b146d6.png" title="空间换时间" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/9861ea4c29cb40a583593ce747b146d6.png" data-sub-html="<h2>空间换时间</h2><p>空间换时间</p>">
        
    </a><figcaption class="image-caption">空间换时间</figcaption>
    </figure></p>
<h2 id="写性能的瓶颈如何处理" class="headerLink">
    <a href="#%e5%86%99%e6%80%a7%e8%83%bd%e7%9a%84%e7%93%b6%e9%a2%88%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86" class="header-mark"></a>写性能的瓶颈如何处理</h2><p>如果在 MySQL 读写都有瓶颈，那首先看下目前 MySQL 的架构是怎么样的。</p>
<p>如果是单库的，那是不是可以考虑升级至主从架构，实现读写分离。</p>
<p>简单理解就是：主库接收写请求，从库接收读请求。从库的数据由主库发送的 binlog 进而更新，实现主从数据一致（在一般场景下，主从的数据是通过异步来保证最终一致性的）。</p>
<p>如果在主从架构下，读写仍存在瓶颈，那就要考虑是否要分库分表了。</p>
<p>我这里讲的分库分表的含义是：在原来的某个库的某个表进而拆分。</p>
<p>比如，现在我有一张业务订单表，这张订单表在广告库中，假定这张业务订单表已经有 1 亿数据量了，现在我要分库分表，那就会将这张表的数据分至多个广告库以及多张表中。</p>
<p>分库分表的最明显的好处就是把请求进行均摊（本来单个库单个表有一亿的数据，那假设我分开 8 个库，那每个库 1200+W 的数据量，每个库下分 8 张表，那每张表就 150W 的数据量）。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/6583d2b4aed24774a316bced6d17e38b.png" title="分库分表" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/6583d2b4aed24774a316bced6d17e38b.png" data-sub-html="<h2>分库分表</h2><p>分库分表</p>">
        
    </a><figcaption class="image-caption">分库分表</figcaption>
    </figure></p>
<h2 id="常以什么作为分库键" class="headerLink">
    <a href="#%e5%b8%b8%e4%bb%a5%e4%bb%80%e4%b9%88%e4%bd%9c%e4%b8%ba%e5%88%86%e5%ba%93%e9%94%ae" class="header-mark"></a>常以什么作为分库键</h2><p>一般来说是按照<code>userId</code>，因为按照用户的维度查询比较多，如果要按照其他的维度进行查询，那还是参照上面的的思路（以空间换时间）。</p>
<h2 id="分库分表后的id是怎么生成的" class="headerLink">
    <a href="#%e5%88%86%e5%ba%93%e5%88%86%e8%a1%a8%e5%90%8e%e7%9a%84id%e6%98%af%e6%80%8e%e4%b9%88%e7%94%9f%e6%88%90%e7%9a%84" class="header-mark"></a>分库分表后的ID是怎么生成的</h2><p>这就涉及到分布式 ID 生成的方式了，思路有很多。有借助 MySQL 自增的，有借助 Redis 自增的，有基于「雪花算法」自增的。具体使用哪种方式，那就看公司的技术栈了，一般使用 Redis 和基于「雪花算法」实现用得比较多。</p>
<blockquote>
<p>至于为什么强调自增，还是跟索引是有序有关，可以看前面</p>
</blockquote>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/059ac16a9707417a91f9342bb8f9330c.png" title="分库分表的主键" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/059ac16a9707417a91f9342bb8f9330c.png" data-sub-html="<h2>分库分表的主键</h2><p>分库分表的主键</p>">
        
    </a><figcaption class="image-caption">分库分表的主键</figcaption>
    </figure></p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/74lPw8-keqM_niBDoOXSCQ" target="_blank" rel="noopener noreferrer">MySQL 索引</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5Mg==&amp;mid=2247485997&amp;idx=1&amp;sn=b05b4a56d0248e9c7108bd01eb95438d" target="_blank" rel="noopener noreferrer">MySQL 事务、锁和MVCC</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5Mg==&amp;mid=2247486035&amp;idx=1&amp;sn=7878dd9b45bc79e210eca1478ac2d9be" target="_blank" rel="noopener noreferrer">MySQL 调优</a></li>
<li><a href="https://juejin.cn/post/6844904199952531463" target="_blank" rel="noopener noreferrer">redo log/binlog/两阶段提交</a></li>
</ul>
]]></description>
</item><item>
    <title>MySQL 为什么使用 B&#43; 树索引</title>
    <link>https://www.xiaobinqt.cn/why-mysql-index-use-btree/</link>
    <pubDate>Fri, 20 May 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/why-mysql-index-use-btree/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221127/8018e68746b147a8bba7dac0c65ae308.png" referrerpolicy="no-referrer">
            </div><!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="前言" class="headerLink">
    <a href="#%e5%89%8d%e8%a8%80" class="header-mark"></a>前言</h2><p>为什么 MySQL 采用 B+ 树作为索引？</p>
<p>如果纯粹的猜测 MySQL 数据库索引为什么使用 B+ 树？那么围绕这个问题的回答通常一定是围绕 B+ 树本身是什么，有什么优势这两点去解释这个问题。</p>
<p>这不是我开始这么去想的，看了很多文章都是从这一维度问答，这些回答让我失望。直到那天问了坐在我旁边那个整天摸鱼的 5 年程序员；他慵懒的回答：你想为什么是使用的是树结构呢？咦，听到这回答，一下打开了我的思绪，有点意思！</p>
<p>先抛开 B+ 树是什么，有什么优势，这些先入为主的答案。我想要的是为什么❓</p>
<p>为什么 MySQL 的索引有那么多的数据结构可选，偏偏选树结构？为什么那么多的树结构？为什么又偏偏采用 B+ 树作为索引?</p>
<p>这才是我要想明白的！我想要的是不只是答案，还要答案背后的脉络！我想要的不仅是要知其然，更想要知其所以然。</p>
<h2 id="那么多数据结构为什么选树结构" class="headerLink">
    <a href="#%e9%82%a3%e4%b9%88%e5%a4%9a%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%ba%e4%bb%80%e4%b9%88%e9%80%89%e6%a0%91%e7%bb%93%e6%9e%84" class="header-mark"></a>那么多数据结构，为什么选树结构？</h2><p>众多的数据结构在逻辑层面可分为：<strong>线性结构</strong>和<strong>非线性结构</strong>。</p>
<p>线性结构有：<strong>数组</strong>、<strong>链表</strong>，基于它们衍生出的有<strong>哈希表</strong>（哈希表也称散列表）、<strong>栈</strong>、<strong>队列</strong>等。</p>
<p>非线性结构有：<strong>树</strong>、<strong>图</strong>。</p>
<p>还有其他数据结构如：<strong>跳表</strong>、<strong>位图</strong> 也都由基础数据结构演化而来，不同的数据结构存在即都是为了解决某些场景问题。</p>
<p>如果要知道索引适合什么数据结构，那我们得先来回答索引需要来解决什么样的问题（痛点）？和发挥着什么样的作用？其次再才是选择什么样的数据结构。后者只是果，前者才是因。</p>
<p>我们都知道 MySQL 存储的数据是在磁盘里，因为即使设备断电，放在磁盘的数据是不会有影响的，保障了数据不丢失，这意味着 MySQL 在磁盘上的数据是持久化的。</p>
<p>但数据存储在磁盘得到保障的同时也是有代价的，这代价就是磁盘的处理速度是毫秒级别的，相比<strong>内存纳秒级别</strong>的速度，简直是小巫见大巫。</p>
<p>你可能对时间单位没什么概念，可以看 1 毫秒能慢上纳秒几万倍。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/f12d0ec3934f47c49269efd3c57283a0.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/f12d0ec3934f47c49269efd3c57283a0.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/f12d0ec3934f47c49269efd3c57283a0.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>索引虽然存储在磁盘上，但使用索引查找数据时，可以从磁盘先读取索引放到内存中，再通过索引从磁盘找到数据；再然后将磁盘读取到的数据也放到内存里。索引就让磁盘和内存强强联手，趁机搭上了内存的车，感受了一把纳秒级别速度的推背感。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/134c7c03e62d4c8bbc867daa00cbc789.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/134c7c03e62d4c8bbc867daa00cbc789.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/134c7c03e62d4c8bbc867daa00cbc789.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>但是不管查询的过程中怎么优化，只要根还在磁盘，就避免不了会发生多次磁盘 I/O ，而磁盘 I/O 次数越多，消耗的时间也越多。聪明的你这会儿可以看出这其实就是个需要考虑解决的痛点了。</p>
<ul>
<li><strong>要尽少在磁盘做 I/O 操作</strong></li>
</ul>
<p>但还有那么多的数据结构可选呢。其实索引需要发挥的目的已经决定了有哪些数据结构可选，那么就可以缩小选择其他数据结构的范围。从为什么要建索引本身的首要目的出发。</p>
<ul>
<li><strong>要能尽快的按照区间高效地范围查找</strong></li>
</ul>
<p>当然索引首要目的<strong>能支持高效范围查询，还要有插入更新等操作的动态数据结构</strong>。</p>
<p>所以有满足以这两条主要条件的除了树结构你还会想到其他什么数据结构？还有就是哈希表、跳表</p>
<h3 id="哈希表" class="headerLink">
    <a href="#%e5%93%88%e5%b8%8c%e8%a1%a8" class="header-mark"></a>哈希表</h3><p>哈希表的物理存储是一个数组⚠️，而数组在内存中是<strong>连续地址</strong>的空间。</p>
<p>数据以 <code>Key</code>、<code>Value</code> 的方式存储。哈希表拥有精确的查询，所以时间复杂度是 <code>O(1)</code>。</p>
<p>而哈希表之所以能这么快是通过 <code>Key </code>计算数组下标来快速找到 <code>Value</code>。</p>
<p>最简单的计算的方式是 <strong>余数法</strong>，通过先计算<code>key</code>的 <code>HashCode</code>，再通过<strong>哈希表的数组长度</strong>对 <code>HashCode</code> 求余，求余得出的余数就是数组下标，最后由下标访问到哈希表中存的<code>Key、Value</code>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/c9364955db264236a436b221756a1a1a.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/c9364955db264236a436b221756a1a1a.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/c9364955db264236a436b221756a1a1a.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>但是 <code>Key</code> 计算出的下标<strong>可能会有相同</strong>的情况，例如 <code>HashCode 1010</code> 对 <code>6</code> 取余是 <code>2</code>，但是 <code>HashCode 1112</code> 对 <code>6</code> 取余也是 <code>2</code>。</p>
<p>哈希算法随机计算出 HashCode 取余数组长度可能出现数组下标相同的情况，就是所谓的 <strong><code>哈希冲突</code></strong>。</p>
<p>而 <code>哈希冲突</code> 常用 <code>链表</code> 的方法解决。当发生 <code>哈希冲突</code>，相同下标的数据元素会替换成存储指针，而不同 <code>Key</code> 的数据元素添加到链表中。查找时通过指针遍历这个链表，再匹配出正确的 <code>Key</code> 就可以。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/7cdd6369532c417a9843dcf83fcfa584.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/7cdd6369532c417a9843dcf83fcfa584.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/7cdd6369532c417a9843dcf83fcfa584.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>如上图所示，<code>Key</code> 是 &ldquo;一颗剽悍的种子&rdquo; 的字符串 ，<code>Value</code> 是 &ldquo;不要忘了关注、点赞、评论&rdquo;。我们通过计算<code>key</code>为 <code>HashCode（1010）</code> 的整数型值<code>int</code>。然后用 <code>HashCode（1010）</code> 对长度为 <code>6</code> 的哈希表数组长度做取余得出 <code>2</code>，这 <code>2</code> 的值元素就是 ( Key = &ldquo;一颗剽悍的种子&rdquo;,Value = &ldquo;不要忘了关注、点赞、评论&rdquo;) 。</p>
<p>虽然哈希表虽然可以高效的等值查询。例如SQL：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">select * from weixin where username = &#34;一颗剽悍的种子&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是<strong>不支持区间查询</strong>。例如SQL：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">select * from weixin where age &lt; 18
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么如果哈希表用来做成索引，当进行范围查询时意味着要全部扫描。类似 Redis 存储形式是 KV 的 NoSQL 数据库，会适合等值查询的场景。</p>
<h3 id="跳表" class="headerLink">
    <a href="#%e8%b7%b3%e8%a1%a8" class="header-mark"></a>跳表</h3><p>跳表似乎对于我们来说是一个比较陌生的数据结构，但是在 Redis 中却是比较常用的数据结构之一。跳表底层实质就是可以进行二分查找的<strong>有序链表</strong>，他在链表基础加上索引层，即能支持插入、删除等动态操作，也支持按区间高效查询。而且不管是查找、插入、删除对应的时间复杂度都是 <code>O(logn)</code>。</p>
<p>要理解跳表，先来看链表，假设链表存储是有序的数据，我们要想查询某一个数据，在最差的情况下要从头全遍历整个链表，时间复杂度是 <code>O(n)</code>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/8b760ec0cec045aea1302676ec385eaf.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/8b760ec0cec045aea1302676ec385eaf.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/8b760ec0cec045aea1302676ec385eaf.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>如下图所示，跳表是在链表基础上加了索引层。可以起到支持区间查询的作用。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/de330e29044d428c93fcaa5b6f1669d8.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/de330e29044d428c93fcaa5b6f1669d8.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/de330e29044d428c93fcaa5b6f1669d8.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>从上图所示，我们如果要查询一个 <code>26</code> 的节点，跳表就可以先从索引层遍历，当遍历到在索引层的 <code>21</code> 节点，会发现下一个索引层的节点是 <code>36</code> 节点时，很明显要找的 <code>26</code>
的节点就在这区间。此时我们只要再通过索引层指向原始链表的指针往下移到原始链这一层遍历，只要遍历 <code>2</code> 个节点即可找到 <code>26</code> 了。<del>如果用原来的链表需要遍历 <code>10</code> 个节点，现在只要遍历 <code>8</code> 个节点</del>。如果用原来的链表需要遍历 <code>8</code> 个节点，现在也只要遍历 <code>8</code> 个节点（<code>5-&gt;10-&gt;16-&gt;21-&gt;36-&gt;21-&gt;21-&gt;26</code>
），但是对于大量数据来说，是可以节省查询时间的。（原文应该是有误，这是按照我的理解写的，具体可以参看<a href="https://juejin.cn/post/7081065180301361183#heading-3:~:text=%E5%A6%82%E6%9E%9C%E7%94%A8%E5%8E%9F%E6%9D%A5%E7%9A%84%E9%93%BE%E8%A1%A8%E9%9C%80%E8%A6%81%E9%81%8D%E5%8E%86%2010%20%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%8F%AA%E8%A6%81%E9%81%8D%E5%8E%86%208%20%E4%B8%AA%E8%8A%82%E7%82%B9%E3%80%82" target="_blank" rel="noopener noreferrer">原文</a>）。</p>
<p>如下图中，一图胜千言。当数据量大时，一个包含多个结点的链表，在建立了五级索引后可以突显的看到索引层的优势。同时注意道这样一个规律 <strong>“加一层索引，查询所需要遍历的节点个数减少，查询效率也就提高了。”</strong></p>
<p>从用户的角度就是，跳表这家伙其实就是在告诉链表从什么地方开始找比较快。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/03cc278b5ef545138f52074efec2999b.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/03cc278b5ef545138f52074efec2999b.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/03cc278b5ef545138f52074efec2999b.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>看到这，跳表似乎也很适合用来作为索引的数据结构。但是不要忘了还有首个条件没满足，就是 <strong>&ldquo;要尽少在磁盘做 I/O 操作。&rdquo;</strong>
而跳表显然没能满足这一条件，<strong>跳表在随数据量增多的情况，索引层也会随着增高，相应的就会增加读取I/O的次数，从而影响性能</strong>。</p>
<p>那么回到 “那么多数据结构，为什么选树结构的问题？”，我们发现哈希表和跳表并不能很好的满足解决磁盘痛点和索引目的的这两个主要条件。那么我们来看为什么要来选树结构。</p>
<h3 id="树结构" class="headerLink">
    <a href="#%e6%a0%91%e7%bb%93%e6%9e%84" class="header-mark"></a>树结构</h3><p>我们先来看现实中一颗树都有哪些部分组成，首先要有根、树枝、还有树叶。那抽象成树结构也是一样的，树结构的顶端是 <code>根节点（root）</code>，左侧的节点称为 <code>左子树</code>，右子树对应的在右侧的节点，树的末端没有节点的称为 <code>叶子节点</code>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/06fe0d461c284c218f616c98b0d14dff.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/06fe0d461c284c218f616c98b0d14dff.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/06fe0d461c284c218f616c98b0d14dff.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>从树的层级关系可以分为上下级和同级节点，如下图，<code>D、E</code>是<code>B</code>节点的子节点，那么<code>B</code> 节点就是它们的父节点，跟<code>B</code>节点在同一层级的<code>C</code>节点是<code>B</code>节点的兄弟节点。</p>
<p>同时树的最大层级数，称为树的高度（深度），图下的树高度是<strong>3</strong>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/316bcf4e06bd4b15a480b56eb5665b99.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/316bcf4e06bd4b15a480b56eb5665b99.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/316bcf4e06bd4b15a480b56eb5665b99.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>从树结构的层级角度看，其实树结构是不是跟前面的跳表还有点相似。而跳表之所以这么快是因为有能按区间高效查询的索引层。</p>
<p>而树结构其特性决定了遍历数据方式本身就纯天然的支持按区间查询。再加上树是非线性结构的优势相比于线性结构的数组，不必像数组的数据是连续存放的。那么当树结构在插入新数据时就不用像数组插入数据前时，需要将数据所在往后的所有数据节点都得往后挪动的开销。所以树结构更适合插入更新等动态操作的数据结构。</p>
<p>树结构在满足了索引目的和其他条件的情况下，至于减少磁盘查询操作的痛点其实我们就可以在基于树结构的数据结构中去选择。</p>
<h2 id="那么多的树结构为什么偏偏采用-b-树作为索引" class="headerLink">
    <a href="#%e9%82%a3%e4%b9%88%e5%a4%9a%e7%9a%84%e6%a0%91%e7%bb%93%e6%9e%84%e4%b8%ba%e4%bb%80%e4%b9%88%e5%81%8f%e5%81%8f%e9%87%87%e7%94%a8-b-%e6%a0%91%e4%bd%9c%e4%b8%ba%e7%b4%a2%e5%bc%95" class="header-mark"></a>那么多的树结构？为什么偏偏采用 B+ 树作为索引?</h2><p>那么多的树结构中，除了B+树，你还会想到哪些树结构？二叉树查找树、自平衡二叉树、B树。</p>
<h3 id="二叉树" class="headerLink">
    <a href="#%e4%ba%8c%e5%8f%89%e6%a0%91" class="header-mark"></a>二叉树</h3><p>在了解二叉查找树或者自平衡二叉树前需要先简单知道什么是二叉树，什么是二分查找树。因为你看二叉查找树不就是这两棵树的合并吗。</p>
<p>我们先来看看二叉树，二叉树的树结构中定义的是每个节点的可以是<code>0个子节</code>或<code>1个子节点</code>，但是最多不超<code>2个子节点</code>。</p>
<p>而二叉树还有两个形式：<strong>满二叉树、完全二叉树</strong></p>
<p><strong>满二叉树</strong></p>
<p>满二叉树的定义是一棵二叉树的所有非叶子节点都存在左右子节点，并且所有子节点在同一层级。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/a5ecaccfda4246f086a976cdd3988a54.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/a5ecaccfda4246f086a976cdd3988a54.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/a5ecaccfda4246f086a976cdd3988a54.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p><strong>完全二叉树</strong></p>
<p>完全二叉树是指从左至右填充节点，直到最后一层，且最后一层的节点都靠左对齐。因此，满二叉树的所有层都可能被填充满，而完全二叉树虽然最后一层不一定满，但是尽可能填充到最左侧。如下图。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/90538ecd70fc4c439054eed2e33b93c6.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/90538ecd70fc4c439054eed2e33b93c6.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/90538ecd70fc4c439054eed2e33b93c6.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<h3 id="二叉查找树" class="headerLink">
    <a href="#%e4%ba%8c%e5%8f%89%e6%9f%a5%e6%89%be%e6%a0%91" class="header-mark"></a>二叉查找树</h3><p>此二叉查找树的 “二” 非彼二，因为此 “二” 既可以说是表示二叉的树，也可以表示二分查找，因为二叉查找树既是二叉也融合了二分查找。</p>
<p>先简单的看看二分查找，二分查找可以避免有序的数组从头依次的遍历查询，因为我们知道这种情况如果要查找一个数最差的情况时间复杂就是<code>O(n)</code>
，整体查询效率不高。而如果数组是<strong>有序</strong>的，就可以通过二分查找将每次的查询范围减半，时间复杂度自然就是<code>O(logn)</code>。如下图所示。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/1689be2bb3d24f7da12fbf2d4ec37736.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/1689be2bb3d24f7da12fbf2d4ec37736.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/1689be2bb3d24f7da12fbf2d4ec37736.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>所以说，二叉查找树不同于普通二叉查找树，是将小于根节点的元素放在左子树，而右子树正好相反是放大于根节点的元素。说白了就是根节点是左子树和右子树的中位数，左边放小于中位数的，右边放大于中位数，这不就是二分查找算法的奥义。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/cbb74bc84a5c4c88abde473347b77dd6~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.gif" title="640.gif" data-thumbnail="https://cdn.xiaobinqt.cn/cbb74bc84a5c4c88abde473347b77dd6~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.gif" data-sub-html="<h2>图片</h2><p>640.gif</p>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>如上动图所示，二分查找树在查找数据时，只需要将需要查找的元素与树节点元素进行比较，当元素大于根节点则往右子树中查找，元素小于根节点则往左子树中查找，元素如果正好是中位数那么就是正好是根节点，所以二叉查找树具备高效查询。</p>
<p>但是二叉树也有明显<strong>弊端</strong>，在极端情况下，如果每次插入的数据都是最小或者都是最大的元素，那么树结构会退化成一条链表。查询数据是的时间复杂度就会是<code>O(n)</code>，如下图所示。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/2fa9c648547f4c15a87959a2b3459dfa.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/2fa9c648547f4c15a87959a2b3459dfa.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/2fa9c648547f4c15a87959a2b3459dfa.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>当二分查找树退化成链表时，我们知道链表不仅不能高效查询而且也增加了磁盘 IO 操作，所以我们得划向下一个树型数据结构。</p>
<h3 id="自平衡二叉树avl树" class="headerLink">
    <a href="#%e8%87%aa%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%a0%91avl%e6%a0%91" class="header-mark"></a>自平衡二叉树/AVL树</h3><p>自平衡二叉树就是来解决二叉查找树极端下退化成链表的问题，自平衡二叉树也称<strong>平衡二叉查找树</strong>（AVL树）。</p>
<blockquote>
<p>可以看到从简单的二叉树，一步步演化到二分查找树再到现在的自平衡二叉树。一个简单的东西慢慢的逐渐走向复杂。如果只知道答案，我们是不会知道来龙去脉的。</p>
</blockquote>
<p>平衡二叉查找树其实主要就是在二叉查找树的基础上加上约束：<strong>让每个节点的左右子树高度差不能超过 1</strong>。那么这样让可以让左右子树都保持平衡，让查询数据操作的时间复杂度在 <code>O(logn)</code>。</p>
<p>如下图所示，平衡二叉查找树将每次插入的元素数据都会维持自平衡。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/202308053871d3e8b2e34eaa8253be7643052ae1~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.gif" title="640.gif" data-thumbnail="https://cdn.xiaobinqt.cn/202308053871d3e8b2e34eaa8253be7643052ae1~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.gif" data-sub-html="<h2>图片</h2><p>640.gif</p>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>如下图所示，普通非平衡二叉树和平衡二叉树的对比。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/87466af324fb41dbae9f8bd27e91ecfc.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/87466af324fb41dbae9f8bd27e91ecfc.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/87466af324fb41dbae9f8bd27e91ecfc.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>还有在 Java 中集合类常见的红黑树，也是自平衡二叉树中的一种。</p>
<p>但是不管自平衡树是平衡二叉查找树还是红黑树，都会<strong>随着插入的元素增多，而导致树的高度变高</strong>，这同样意味着磁盘 I/O 操作次数多，影响到整体查询的效率。</p>
<h3 id="b树" class="headerLink">
    <a href="#b%e6%a0%91" class="header-mark"></a>B树</h3><p>我们平时看到<code>B+树</code>还有<code>B-树</code>，不免就会将<code>B-树</code>读成<code>B减树</code> ，但<code>B-树</code>其<code>-</code>横线只是连接符，所以<code>B-树</code>就是称为<code>B树</code>。</p>
<p>自平衡二叉树虽然查找的时间复杂度在<code>O(logn)</code>，前面也说过它本身是一个二叉树，每个节点只能有2个子节点，那么随着数据量增大的时候，节点个数越多，树高度也会增高（也就是树的深度越深），增加磁盘 I/O 次数，影响查询效率。</p>
<p>那么你如果从树形结构的二叉树这一路的进阶过程中可以看到，二叉树每一次为了解决一个新的问题都会创造出新的<code>bug</code>或者创造一个又个的痛点。看到这就不难猜到，B树的出现可以解决树高度的问题。</p>
<p>之所以是 B 树，而并不是名称中 “xxx二叉树”，就是它<strong>不再限制一个父节点中只能有两个子节点</strong>，而是允许 <code>M</code> 个子节点<code>（M &gt; 2）</code>。不仅如此，<strong>B树的一个节点可以存储多个元素</strong>，相比较于前面的那些二叉树数据结构又将整体的树高度降低了。</p>
<p>B 树的节点可以包含有多个子节点，所以<strong>B树是一棵多叉树</strong>，它的每一个节点包含的最多子节点数量的称为B树的<strong>阶</strong>。如下图是一颗 3 阶的 B 树。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/e0c9903e46ab49558dd38d7e803da058.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/e0c9903e46ab49558dd38d7e803da058.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/e0c9903e46ab49558dd38d7e803da058.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<blockquote>
<p>上图中每一个节点称为页，在 mysql 中数据读取的基本单位是页，而页就是我们上面所说的磁盘块。磁盘块中的 p 节点是指向子节点的指针。</p>
<p>指针在树结构中都有，在前面的二叉树中也都是有的。</p>
</blockquote>
<p>那我们来看一下上图所示，当一颗 3 阶的B树查找 <code>90</code> 这个的元素时的流程是怎么样的？</p>
<p>先从根节点出发，也就是 <code>磁盘块1</code>，判断 <code>90</code> 在<code>17 ~ 35</code>之间，通过<code>磁盘块1</code>中的指针 <code>p3</code> 找到<code>磁盘块4</code>。还是按照原来的步骤，在<code>磁盘块4</code>中的<code>65 ~ 87</code>之间相比较，最后<code>磁盘4</code>的指针<code>p3</code>找到<code>磁盘块11</code>。也就找到有匹配<code>90</code>的键值。</p>
<p>可以发现一颗 3 阶的 B 树在查找叶子节点时，由于树高度只有 <code>3</code>，所以查找过程最多只需要<code>3次</code>的磁盘 I/O 操作。</p>
<p>数据量不大时可能不太真切。但当数据量大时，节点也会随着增多；此时如果还是前面的自平衡二叉树的场景下，由于二叉树只能最多<code>2</code>个叶子节点的约束，也只能纵向去的去扩展子节点，树的高度会很高，意味着需要更多的操作磁盘 I/O 次数。而 B 树则可以通过横向扩展节点从而降低树的高度，所以效率自然要比二叉树效率更高。直白说就是变矮胖了。</p>
<p>看到这，相信你也知道如果 B 树这么适合，也就没有接下来 B+ 树的什么事了。</p>
<p>接着，那为什么不用 B 树，而用 了B+ 树呢？</p>
<p>其实，B 树其实已经满足了我们最前面所要满足的条件，减少磁盘 I/O 操作，同时支持按区间查找。但注意，虽然 <strong>B 树支持按区间查找，但并不高效</strong>。</p>
<p>例如上面的例子中，B树能高效的通过<strong>等值查询</strong> <code>90</code>这个值，但不方便查询出一个区间内比如，<code>3 ~ 10</code> 区间内所有数的结果。因为当B树做范围查询时需要使用中序遍历，那么父节点和子节点也就需要不断的来回切换涉及了多个节点会给磁盘 I/O 带来很多负担。</p>
<h3 id="b树-1" class="headerLink">
    <a href="#b%e6%a0%91-1" class="header-mark"></a>B+树</h3><p>B+ 树从<code>+</code>的符号可以看出是 B 树的升级版，MySQL 中 innoDB 引擎中的索引底层数据结构采用的正是 B+ 树。</p>
<p>B+ 树相比于 B 树，做了这样的升级：<strong>B+ 树中的非叶子节点都不存储数据，而是只作为索引</strong>。</p>
<p>由叶子节点存放整棵树的所有数据。而叶子节点之间构成一个从小到大有序的链表互相指向相邻的叶子节点，也就是叶子节点之间形成了有序的双向链表。如下图 B+ 树的结构。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/f8eec821424f49598a2d62e82f63e711.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/f8eec821424f49598a2d62e82f63e711.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/f8eec821424f49598a2d62e82f63e711.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>B+ 树是不是有点像前面的跳表，数据底层是数据，上层都是按底层区间构成的索引层，只不过它不像跳表是纵向扩展，而是横向扩展的 “跳表”。这么做的好处即减少磁盘的 IO 操作又提高了范围查找的效率。</p>
<p>接着再来看 B+ 树的插入和删除，B+ 树做了大量冗余节点，从上面可以发现父节点的所有元素都会在子节点中出现，这样当删除一个节点时，可以直接从叶子节点中删除，这样效率更快。</p>
<p>B 树相比于 B+ 树，B 树没有冗余节点，删除节点时会发生复杂的<strong>树变形</strong>，而 B+ 树有冗余节点，不会涉及到复杂的树变形。而且 B+ 树的插入也是如此，最多只涉及树的一条分支路径。B+ 树也不用更多复杂算法，可以类似黑红树的旋转去自动平衡。</p>
<h2 id="总结" class="headerLink">
    <a href="#%e6%80%bb%e7%bb%93" class="header-mark"></a>总结</h2><p>从文章的题目开始就是一个问题，我们并没有直接回答为什么MySQL 采用 B+ 树作为索引的答案，而是相反的问出了两个问题，一个问题是那么多数据结构，为什么选树结构？另一个问题是那么多的树结构，又为什么偏偏采用 B+ 树？</p>
<p>要得到果，得先知道因，我们从两个方面开始出发，因为 MySQL 的数据是放在磁盘的，而磁盘的处理速度是毫秒级别的，如果在磁盘 IO 做过多查询操作，会给查询带来负担，所以要尽少在磁盘 I/O 操作中做查询。另一个是从索引本身的首要目的，要能按区间高效地范围查找。</p>
<p>有了因，我们就开始去探索果，我们就可以先来回答第一个问题，<strong>“那么多数据结构，为什么选树结构？”</strong>
在其他数据结构中按逻辑结构的线性结构有哈希表和跳表。哈希表底层基于数组，虽然可以高效查询，但是只能等值查询，而不能支持范围查询。而跳表底层是链表，通过索引层可以实现高效的区间查询，但是随着数据量的递增，索引层也随着数据量的增多而增加。所以采用树的数据结构，树结构其特性决定了遍历数据方式本身就纯天然的支持按区间查询。树结构在插入等操作不用线性结构数组的开销，所以更适合插入更新等动态操作的数据结构。</p>
<p>接着我们另一个问题，<strong>“那么多的树结构，又为什么偏偏采用B+树？”</strong> 我们从树结构中父节点最多只能有两个子节点的二叉树，再从二叉树加上二分查找的二叉查找树，二叉树展现了高效的查询能力；但二叉查找树在<strong>极端情况下会退化成链表</strong>，所以进阶到自平衡二叉树，自平衡二叉树约束了每个节点的左右子树相差不能大于 1，但是二叉树因为只能最多是两个子节点，所以树的高度过高会导致磁盘做过多 I/O 的查询操作负担。</p>
<p>所以最后真正到了 B 树，B 树是多叉树，但只能高效单查询，并不能高效区间查询。所以才有 B+ 树，B+ 树是 B 树的升级，所有非叶子节点都用来做索引，只有叶子节点存储数据而且是有序双向的链表，树节点做了冗余，相比于 B 树既能支持高效的区间查询，插入和删除都比 B 树更加出色。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/zzti_erlie/article/details/82973742" target="_blank" rel="noopener noreferrer">MySQL索引为什么要用B+树实现</a></li>
<li><a href="https://www.cnblogs.com/cqqfboy/p/15323462.html" target="_blank" rel="noopener noreferrer">MySQL 为什么使用 B+ 树来作索引？MySQL 为什么使用 B+ 树来作索引？</a></li>
<li><a href="https://ivanzz1001.github.io/records/post/data-structure/2018/06/16/ds-bplustree" target="_blank" rel="noopener noreferrer">B+树详解</a></li>
<li><a href="https://www.bilibili.com/video/BV1HX4y1N7v6/" target="_blank" rel="noopener noreferrer">【干货】数据库索引为什么使用B+Tree？</a></li>
<li><a href="https://juejin.cn/post/7081065180301361183" target="_blank" rel="noopener noreferrer">MySQL 为什么采用 B+树作为索引？5年经验程序员回答让我悟了</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/152285749" target="_blank" rel="noopener noreferrer">满二叉树和完全二叉树的区别</a></li>
</ul>
]]></description>
</item><item>
    <title>Redis 缓存击穿、缓存穿透、缓存雪崩</title>
    <link>https://www.xiaobinqt.cn/redis-break-pierce-avalanche/</link>
    <pubDate>Wed, 13 Apr 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/redis-break-pierce-avalanche/</guid>
    <description><![CDATA[<h2 id="缓存击穿" class="headerLink">
    <a href="#%e7%bc%93%e5%ad%98%e5%87%bb%e7%a9%bf" class="header-mark"></a>缓存击穿</h2><p>高并发流量，访问的这个数据是热点数据，请求的数据在 DB 中存在，但是 Redis 存的那一份已经过期，后端需要从 DB 从加载数据并写到 Redis。</p>
<p>总结起来就是：单一热点数据、高并发、数据失效。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220413/10c8c8557c8b41ea967c82617bef1814.png" title="缓存击穿" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220413/10c8c8557c8b41ea967c82617bef1814.png" data-sub-html="<h2>缓存击穿</h2><p>缓存击穿</p>">
        
    </a><figcaption class="image-caption">缓存击穿</figcaption>
    </figure></p>
<h3 id="解决方案" class="headerLink">
    <a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" class="header-mark"></a>解决方案</h3><h4 id="过期时间随机值" class="headerLink">
    <a href="#%e8%bf%87%e6%9c%9f%e6%97%b6%e9%97%b4%e9%9a%8f%e6%9c%ba%e5%80%bc" class="header-mark"></a>过期时间➕随机值</h4><p>对于热点数据，我们不设置过期时间，这样就可以把请求都放在缓存中处理，充分把 Redis 高吞吐量性能利用起来。或者过期时间再加一个随机值。</p>
<p>设计缓存的过期时间时，使用公式：<strong>过期时间 = baes 时间 + 随机时间</strong>。</p>
<p>即相同业务数据写缓存时，在基础过期时间之上，再加一个随机的过期时间，让数据在未来一段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过大压力。</p>
<h4 id="预热" class="headerLink">
    <a href="#%e9%a2%84%e7%83%ad" class="header-mark"></a>预热</h4><p>预先把热门数据提前存入 Redis 中，并设热门数据的过期时间超大值。</p>
<h4 id="使用锁" class="headerLink">
    <a href="#%e4%bd%bf%e7%94%a8%e9%94%81" class="header-mark"></a>使用锁</h4><p>当发现缓存失效的时候，不是立即从数据库加载数据。</p>
<p>而是先获取分布式锁，获取锁成功才执行数据库查询和写数据到缓存的操作，获取锁失败，则说明当前有线程在执行数据库查询操作，当前线程睡眠一段时间再重试。这样只让一个请求去数据库读取数据。</p>
<h2 id="缓存穿透" class="headerLink">
    <a href="#%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f" class="header-mark"></a>缓存穿透</h2><p>数据库本就没有这个数据，请求直奔数据库，缓存系统形同虚设。</p>
<p>大量请求的 key 根本<font color="red"><strong>不存在于缓存中也不存在数据库</strong></font>，导致请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成压力而影响正常服务。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220413/19352698c9c047d4a635c3e561b8293b.png" title="缓存穿透" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220413/19352698c9c047d4a635c3e561b8293b.png" data-sub-html="<h2>缓存穿透</h2><p>缓存穿透</p>">
        
    </a><figcaption class="image-caption">缓存穿透</figcaption>
    </figure></p>
<h3 id="解决方案-1" class="headerLink">
    <a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88-1" class="header-mark"></a>解决方案</h3><p>最基本的首先就是做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。</p>
<h4 id="缓存无效的-key" class="headerLink">
    <a href="#%e7%bc%93%e5%ad%98%e6%97%a0%e6%95%88%e7%9a%84-key" class="header-mark"></a>缓存无效的 key</h4><p>如果<strong>缓存和数据库都查不到</strong>
某个 key 的数据就写一个到 Redis 中去并设置过期时间。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，应该尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<h4 id="布隆过滤器" class="headerLink">
    <a href="#%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8" class="header-mark"></a>布隆过滤器</h4><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地<strong>判断一个给定数据是否存在于海量数据中</strong>。我们需要的仅仅就是判断 key 是否合法。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话再走其他的判断流程。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/c81922434bf5420c94e349e07980054b.png" title="布隆过滤器" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/c81922434bf5420c94e349e07980054b.png" data-sub-html="<h2>布隆过滤器</h2><p>布隆过滤器</p>">
        
    </a><figcaption class="image-caption">布隆过滤器</figcaption>
    </figure></p>
<p>需要注意的是布隆过滤器可能会存在误判的情况。</p>
<p><strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，这个元素一定不在</strong>。</p>
<p>这是因为，当一个元素加入布隆过滤器中的时候，会进行如下操作：</p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在数组中把对应下标的值置为 1。</li>
</ol>
<p>当需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>然而，一定会出现这样一种情况：不同的字符串可能哈希出来的位置相同。我们可以适当增加位数组大小或者调整我们的哈希函数来降低概率。</p>
<h2 id="缓存雪崩" class="headerLink">
    <a href="#%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9" class="header-mark"></a>缓存雪崩</h2><p>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。或是有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</p>
<p>而出现该原因主要有两种：</p>
<ul>
<li>大量热点数据同时过期，导致大量请求需要查询数据库并写到缓存。</li>
<li>Redis 故障宕机，缓存系统异常。</li>
</ul>
<h3 id="缓存大量数据同时过期" class="headerLink">
    <a href="#%e7%bc%93%e5%ad%98%e5%a4%a7%e9%87%8f%e6%95%b0%e6%8d%ae%e5%90%8c%e6%97%b6%e8%bf%87%e6%9c%9f" class="header-mark"></a>缓存大量数据同时过期</h3><p>数据保存在缓存系统并设置了过期时间，但是由于在同时一刻，大量数据同时过期。系统就把请求全部打到数据库获取数据，并发量大的话就会导致数据库压力激增。</p>
<p><font color="red"><strong>缓存雪崩是发生在大量数据同时失效的场景，而缓存击穿是在某个热点数据失效的场景，这是他们最大的区别</strong>
</font>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220413/12a33b5773ef4e36be2c71a94b93df11.png" title="缓存大量数据同时过期" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220413/12a33b5773ef4e36be2c71a94b93df11.png" data-sub-html="<h2>缓存大量数据同时过期</h2><p>缓存大量数据同时过期</p>">
        
    </a><figcaption class="image-caption">缓存大量数据同时过期</figcaption>
    </figure></p>
<h4 id="过期时间添加随机值" class="headerLink">
    <a href="#%e8%bf%87%e6%9c%9f%e6%97%b6%e9%97%b4%e6%b7%bb%e5%8a%a0%e9%9a%8f%e6%9c%ba%e5%80%bc" class="header-mark"></a>过期时间添加随机值</h4><p>要避免给大量的数据设置一样的过期时间，过期时间 = baes 时间+ 随机时间（较小的随机数，比如随机增加 1~5 分钟）。</p>
<p>这样一来，就不会导致同一时刻热点数据全部失效，同时过期时间差别也不会太大，既保证了相近时间失效，又能满足业务需求。</p>
<h4 id="接口限流" class="headerLink">
    <a href="#%e6%8e%a5%e5%8f%a3%e9%99%90%e6%b5%81" class="header-mark"></a>接口限流</h4><p>当访问的不是核心数据的时候，在查询的方法上加上接口限流保护。比如设置 10000 req/s。如果访问的是核心数据接口，缓存不存在允许从数据库中查询并设置到缓存中。这样的话，只有部分请求会发送到数据库，减少了压力。</p>
<p><strong>限流，就是指，我们在业务系统的请求入口前端控制每秒进入系统的请求数，避免过多的请求被发送到数据库</strong>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220413/340401972fac48f391fa6906a9444eac.png" title="限流" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220413/340401972fac48f391fa6906a9444eac.png" data-sub-html="<h2>限流</h2><p>限流</p>">
        
    </a><figcaption class="image-caption">限流</figcaption>
    </figure></p>
<h3 id="redis-故障" class="headerLink">
    <a href="#redis-%e6%95%85%e9%9a%9c" class="header-mark"></a>Redis 故障</h3><p>一旦 Redis 故障或宕机，会导致大量请求打到数据库，从而发生缓存雪崩。对于 Redis 故障，主要有以下两种解决方案。</p>
<h4 id="服务熔断和限流" class="headerLink">
    <a href="#%e6%9c%8d%e5%8a%a1%e7%86%94%e6%96%ad%e5%92%8c%e9%99%90%e6%b5%81" class="header-mark"></a>服务熔断和限流</h4><p>在业务系统中，针对高并发的使用服务熔断来有损提供服务从而保证系统的可用性。</p>
<p>服务熔断就是当从缓存获取数据发现异常，则直接返回错误数据给前端，防止所有流量打到数据库导致宕机。</p>
<p>服务熔断和限流属于在发生了缓存雪崩，如何<strong>降低雪崩对数据库造成的影响</strong>的方案。</p>
<h4 id="高可用缓存集群" class="headerLink">
    <a href="#%e9%ab%98%e5%8f%af%e7%94%a8%e7%bc%93%e5%ad%98%e9%9b%86%e7%be%a4" class="header-mark"></a>高可用缓存集群</h4><p>缓存系统一定要构建一套 Redis 高可用集群，比如 <a href="" rel="">Redis 哨兵集群 TODO</a> 或者 <a href="" rel="">Redis Cluster 集群 TODO</a>，如果 Redis 的主节点故障宕机了，从节点还可以切换成为主节点，继续提供缓存服务，避免了由于缓存实例宕机而导致的缓存雪崩问题。</p>
<h2 id="总结" class="headerLink">
    <a href="#%e6%80%bb%e7%bb%93" class="header-mark"></a>总结</h2><ul>
<li>缓存穿透指的是数据库本就没有这个数据，请求直奔数据库，缓存系统形同虚设。</li>
<li>缓存击穿（失效）指的是数据库有数据，缓存本应该也有数据，但是缓存过期了，Redis 这层流量防护屏障被击穿了，请求直奔数据库。</li>
<li>缓存雪崩指的是大量的热点数据无法在 Redis 缓存中处理（大面积热点数据缓存失效、Redis 宕机），流量全部打到数据库，导致数据库极大压力。</li>
</ul>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NDY2MDk4Mw==&amp;mid=2247488270&amp;idx=1&amp;sn=03674abcaa78b027bd12aaafd5a2f6e2" target="_blank" rel="noopener noreferrer">Redis 缓存击穿（失效）、缓存穿透、缓存雪崩怎么解决？</a></li>
</ul>
]]></description>
</item><item>
    <title>Go GC 垃圾回收</title>
    <link>https://www.xiaobinqt.cn/go-gc/</link>
    <pubDate>Wed, 06 Apr 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/go-gc/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221118/74f00ad9b278426887ea4348fd7a0e1c.png" referrerpolicy="no-referrer">
            </div><p>垃圾回收（Garbage Collection，GC）是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC 过程中无需程序员手动执行。</p>
<p>GC 机制在现代很多编程语言都支持，GC 能力的性能与优劣也是不同语言之间对比度指标之一。</p>
<h2 id="gc-变革" class="headerLink">
    <a href="#gc-%e5%8f%98%e9%9d%a9" class="header-mark"></a>GC 变革</h2><p>// TODO</p>
<h2 id="堆和栈" class="headerLink">
    <a href="#%e5%a0%86%e5%92%8c%e6%a0%88" class="header-mark"></a>堆和栈</h2><p><strong>栈</strong>：由操作系统自动分配释放，存放函数的参数值，局部变量的值等。</p>
<p><strong>堆</strong>：一般由程序员分配和释放，若程序员不释放，程序结束时可能由 OS 回收。</p>
<p>栈使用的是一级缓存，他们通常都是被调用时处于存储空间中，<strong>调用完毕立即释放</strong>。</p>
<p>堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定，但并不是一旦成为孤儿对象就能被回收。</p>
<p>申请到栈内存好处：函数返回直接释放，不会引起垃圾回收，对性能没有影响。</p>
<h2 id="标记清除算法" class="headerLink">
    <a href="#%e6%a0%87%e8%ae%b0%e6%b8%85%e9%99%a4%e7%ae%97%e6%b3%95" class="header-mark"></a>标记清除算法</h2><p>Go V1.3 之前使用普通的<strong><ruby>标记-清除<rt>mark and sweep</rt></ruby></strong>算法，主要有两个主要的步骤：</p>
<ol>
<li>
<p>标记(Mark phase)，找出<strong>不可达</strong>的对象，然后做上标记。</p>
</li>
<li>
<p>清除(Sweep phase)，回收标记好的对象。</p>
</li>
</ol>
<h3 id="第一步" class="headerLink">
    <a href="#%e7%ac%ac%e4%b8%80%e6%ad%a5" class="header-mark"></a>第一步</h3><p><strong>暂停</strong>程序业务逻辑， 分类出可达和不可达的对象，然后做上标记。</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/692b1bd1669647518c96b6530c01b8a3.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/692b1bd1669647518c96b6530c01b8a3.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/692b1bd1669647518c96b6530c01b8a3.png" data-sub-html="<h2>程序与对象的可达关系</h2>">
        
    </a><figcaption class="image-caption">程序与对象的可达关系</figcaption>
    </figure>
<p>👆图中表示是程序与对象的可达关系，目前<strong>程序的可达</strong>对象有对象 1-2-3，对象 4-7 等五个对象。</p>
<h3 id="第二步" class="headerLink">
    <a href="#%e7%ac%ac%e4%ba%8c%e6%ad%a5" class="header-mark"></a>第二步</h3><p>开始标记，程序找出它所有可达的对象，并做上标记👇。</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/00d8aba1d229497c9cc907b359010178.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/00d8aba1d229497c9cc907b359010178.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/00d8aba1d229497c9cc907b359010178.png" data-sub-html="<h2>找出可达对象</h2>">
        
    </a><figcaption class="image-caption">找出可达对象</figcaption>
    </figure>
<p>对象 1-2-3 、对象 4-7 等五个对象被做上标记。</p>
<h3 id="第三步" class="headerLink">
    <a href="#%e7%ac%ac%e4%b8%89%e6%ad%a5" class="header-mark"></a>第三步</h3><p>标记完了之后，然后开始清除未标记的对象。</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/1a1ebfbd5c9b4f4183cb5bca704311e5.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/1a1ebfbd5c9b4f4183cb5bca704311e5.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/1a1ebfbd5c9b4f4183cb5bca704311e5.png" data-sub-html="<h2>清除对象</h2>">
        
    </a><figcaption class="image-caption">清除对象</figcaption>
    </figure>
<p>对象 5，6 不可达，被 GC 清除。</p>
<p>操作简单，但是 mark and sweep 算法在执行的时候，需要程序暂停！即 <strong><ruby>STW<rt>stop the world</rt></ruby></strong>，STW 的过程中，CPU 不执行用户代码，全部用于垃圾回收，这个过程的影响很大，所以 STW 也是一些回收机制最大的难题和希望优化的点。</p>
<p><strong>在执行第三步的这段时间，程序会暂定停止任何工作，卡在那等待回收执行完毕</strong>。</p>
<h3 id="第四步" class="headerLink">
    <a href="#%e7%ac%ac%e5%9b%9b%e6%ad%a5" class="header-mark"></a>第四步</h3><p>停止暂停，让程序继续执行。然后循环重复这个过程，直到 process 程序生命周期结束。</p>
<h3 id="缺点与优化" class="headerLink">
    <a href="#%e7%bc%ba%e7%82%b9%e4%b8%8e%e4%bc%98%e5%8c%96" class="header-mark"></a>缺点与优化</h3><p>标记清除算法明了，过程鲜明干脆，但是也有非常严重的问题，就是 STW，让程序暂停，程序出现卡顿。</p>
<p>Go V1.3 版本之前就是用这种方式来实施的。执行 GC 的基本流程就是首先启动 STW 暂停，然后执行标记，再执行数据回收，最后停止 STW ，如下图👇</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/7913f2957c4f4b5c9ba01013cb0c44fa.png" title="STW" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/7913f2957c4f4b5c9ba01013cb0c44fa.png" data-sub-html="<h2>STW</h2><p>STW</p>">
        
    </a><figcaption class="image-caption">STW</figcaption>
    </figure></p>
<p>从👆来看，全部的 GC 时间都是包裹在 STW 范围之内的，这样貌似程序暂停的时间过长，影响程序的运行性能。所以Go V1.3 做了简单的优化，将 STW 的步骤提前，减少 STW 暂停的时间范围
👇</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/2b64ccd849624544ae495ed36236a780.png" title="STW优化" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/2b64ccd849624544ae495ed36236a780.png" data-sub-html="<h2>STW优化</h2><p>STW优化</p>">
        
    </a><figcaption class="image-caption">STW优化</figcaption>
    </figure></p>
<p>主要是将 STW 的步骤提前了一步，因为在 Sweep 清除的时候，可以不需要 STW 停止，因为这些对象已经是不可达对象了，不会出现回收写冲突等问题，<strong>清除操作和用户逻辑可以并发</strong>。</p>
<p>但是无论怎么优化，Go v1.3 都面临这个一个重要问题，就是 mark-and-sweep 算法会暂停整个程序 。</p>
<h2 id="有stw的三色标记法" class="headerLink">
    <a href="#%e6%9c%89stw%e7%9a%84%e4%b8%89%e8%89%b2%e6%a0%87%e8%ae%b0%e6%b3%95" class="header-mark"></a>有STW的三色标记法</h2><p>Go 中的垃圾回收主要应用三色标记法，GC 过程和其他用户 goroutine 可并发运行，但需要一定时间的 STW。</p>
<p>所谓三色标记法实际上就是通过<strong>三个阶段的标记</strong>来确定需要清除的对象有哪些。</p>
<h3 id="第一步-1" class="headerLink">
    <a href="#%e7%ac%ac%e4%b8%80%e6%ad%a5-1" class="header-mark"></a>第一步</h3><p>每次新创建的对象，默认的颜色都是标记为 “白色”👇</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/3b601d5fc23247b4b05de52b7fb2ed52.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/3b601d5fc23247b4b05de52b7fb2ed52.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/3b601d5fc23247b4b05de52b7fb2ed52.png" data-sub-html="<h2>白色对象</h2>">
        
    </a><figcaption class="image-caption">白色对象</figcaption>
    </figure>
<p>上图所示，我们的程序可抵达的内存对象关系如左图所示，右边的标记表是用来记录目前每个对象的标记颜色分类。这里所谓 “程序”，是一些<strong>对象的根节点集合</strong>。如果我们将 “程序” 展开，会得到类似如下的表现形式：</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/25f6f7613a894569a426c70c6c8c2c10.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/25f6f7613a894569a426c70c6c8c2c10.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/25f6f7613a894569a426c70c6c8c2c10.png" data-sub-html="<h2>程序的根节点集合展开</h2>">
        
    </a><figcaption class="image-caption">程序的根节点集合展开</figcaption>
    </figure>
<h3 id="第二步-1" class="headerLink">
    <a href="#%e7%ac%ac%e4%ba%8c%e6%ad%a5-1" class="header-mark"></a>第二步</h3><p>每次 GC 回收开始， 会从根节点开始遍历所有对象，把遍历到的对象从白色集合放入 “灰色” 集合：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/c982dc0455cf437bace1b65454597995.png" title="遍历根对象" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/c982dc0455cf437bace1b65454597995.png" data-sub-html="<h2>遍历根对象</h2><p>遍历根对象</p>">
        
    </a><figcaption class="image-caption">遍历根对象</figcaption>
    </figure></p>
<p>本次遍历是<strong>一次遍历，非递归形式</strong>，是从程序初次可抵达的对象遍历一层，如上图所示，当前可抵达的对象是对象1和对象4，那么自然本轮遍历结束，对象1和对象4就会被标记为灰色，灰色标记表就会多出这两个对象。</p>
<h3 id="第三步-1" class="headerLink">
    <a href="#%e7%ac%ac%e4%b8%89%e6%ad%a5-1" class="header-mark"></a>第三步</h3><p>遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/f381a66d7e4944c998f7c893629accd4.png" title="遍历_2" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/f381a66d7e4944c998f7c893629accd4.png" data-sub-html="<h2>遍历_2</h2><p>遍历_2</p>">
        
    </a><figcaption class="image-caption">遍历_2</figcaption>
    </figure></p>
<p>这一次遍历是<strong>只扫描灰色对象</strong>，将灰色对象的第一层遍历可抵达的对象由白色变为灰色，如：对象2、对象7。 而之前的灰色对象1 和对象4 则会被标记为黑色，同时由灰色标记表移动到黑色标记表中。</p>
<h3 id="第四步-1" class="headerLink">
    <a href="#%e7%ac%ac%e5%9b%9b%e6%ad%a5-1" class="header-mark"></a>第四步</h3><p>重复第三步， 直到灰色中无任何对象，如图👇所示：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/3a751806772e445d813bee6344ab81d1.png" title="遍历_3" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/3a751806772e445d813bee6344ab81d1.png" data-sub-html="<h2>遍历_3</h2><p>遍历_3</p>">
        
    </a><figcaption class="image-caption">遍历_3</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/07f715dda56a4b6ab242367ce0e15e4b.png" title="遍历_4" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/07f715dda56a4b6ab242367ce0e15e4b.png" data-sub-html="<h2>遍历_4</h2><p>遍历_4</p>">
        
    </a><figcaption class="image-caption">遍历_4</figcaption>
    </figure></p>
<p>当我们全部的可达对象都遍历完后，<strong>灰色标记表将不再存在灰色对象</strong>。</p>
<p>目前全部内存的数据只有两种颜色，黑色和白色。那么，黑色对象就是我们程序逻辑可达（需要的）对象，这些数据是目前支撑程序正常业务运行的，是合法的有用数据，不可删除。白色的对象是全部不可达对象，目前程序逻辑并不依赖他们，那么白色对象就是内存中目前的垃圾数据，需要被清除。</p>
<h3 id="第五步" class="headerLink">
    <a href="#%e7%ac%ac%e4%ba%94%e6%ad%a5" class="header-mark"></a>第五步</h3><p>回收所有的白色标记表的对象，也就是回收垃圾，如图所示👇</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/f271ee96ace2416c8eaf808d3f45b8f0.png" title="GC 回收" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/f271ee96ace2416c8eaf808d3f45b8f0.png" data-sub-html="<h2>GC 回收</h2><p>GC 回收</p>">
        
    </a><figcaption class="image-caption">GC 回收</figcaption>
    </figure></p>
<p>将全部的白色对象进行删除回收，剩下的就是全部依赖的黑色对象。</p>
<p>这里面可能会有很多并发流程均会被扫描，执行并发流程的内存可能相互依赖，为了在 GC 过程中保证数据的安全，<strong>在开始三色标记之前就会加上 STW，在扫描确定黑白对象之后再放开 STW</strong>。但是很明显这样的 GC 扫描的性能实在是太低了。</p>
<p>所以现在的三色标记法还是会 STW。</p>
<h2 id="没有stw的三色标记法" class="headerLink">
    <a href="#%e6%b2%a1%e6%9c%89stw%e7%9a%84%e4%b8%89%e8%89%b2%e6%a0%87%e8%ae%b0%e6%b3%95" class="header-mark"></a>没有STW的三色标记法</h2><p>如果没有 STW，那么也就不会再存在性能上的问题，那么假设如果三色标记法不加入 STW 会发生什么事情❓</p>
<p>还是基于上述的三色标记法来分析，他是一定要依赖 STW 的，因为如果不暂停程序，程序的逻辑可能会改变对象的引用关系，这种动作如果在标记阶段做了修改，会影响标记结果的正确性。</p>
<p>来看看一个场景，如果三色标记法，标记过程不使用 STW 将会发生什么事情❓</p>
<p>我们把初始状态设置为已经经历了第一轮扫描，目前黑色的有对象 1 和对象 4，灰色的有对象 2 和对象 7，其他的为白色对象，且对象 2 是通过指针 p 指向对象 3 的，如下图所示。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/df4917c4b48d4e12857a5b8552cf3815.png" title="no ST2 01" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/df4917c4b48d4e12857a5b8552cf3815.png" data-sub-html="<h2>no ST2 01</h2><p>no ST2 01</p>">
        
    </a><figcaption class="image-caption">no ST2 01</figcaption>
    </figure></p>
<p>现在如果三色标记过程不启动 STW，那么在 GC 扫描过程中，<strong>任意的对象均可能发生读写操作</strong>
，如下图所示，在还没有扫描到对象 2 的时候，已经标记为黑色的对象 4，此时创建指针 q，并且指向白色的对象 3。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/c47b38d901dc46efb2ddc7b3d01fede4.png" title="no ST2 02" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/c47b38d901dc46efb2ddc7b3d01fede4.png" data-sub-html="<h2>no ST2 02</h2><p>no ST2 02</p>">
        
    </a><figcaption class="image-caption">no ST2 02</figcaption>
    </figure></p>
<p>与此同时灰色的对象 2 将指针 p 移除，那么白色的对象 3 实则是被挂在了已经扫描完成的黑色的对象 4 下，如下图所示。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/da651f3e078847ad8ba6ca0635301978.png" title="no ST2 03" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/da651f3e078847ad8ba6ca0635301978.png" data-sub-html="<h2>no ST2 03</h2><p>no ST2 03</p>">
        
    </a><figcaption class="image-caption">no ST2 03</figcaption>
    </figure></p>
<p>然后我们正常执行三色标记的算法逻辑，将所有灰色的对象标记为黑色，那么对象 2 和对象 7 就被标记成了黑色，如下图所示。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/2a00e38c265a4370923ed6b4bf4a7435.png" title="no ST2 04" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/2a00e38c265a4370923ed6b4bf4a7435.png" data-sub-html="<h2>no ST2 04</h2><p>no ST2 04</p>">
        
    </a><figcaption class="image-caption">no ST2 04</figcaption>
    </figure></p>
<p>那么就执行了三色标记的最后一步，将所有白色对象当做垃圾进行回收，如图所示。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/512e92ad527e4ac1871abb2a8df63e75.png" title="no ST2 05" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/512e92ad527e4ac1871abb2a8df63e75.png" data-sub-html="<h2>no ST2 05</h2><p>no ST2 05</p>">
        
    </a><figcaption class="image-caption">no ST2 05</figcaption>
    </figure></p>
<p>最后我们发现，本来是对象4合法引用的对象 3，却被GC给“误杀”回收掉了。</p>
<p>可以看出，有两种情况，在三色标记法中是不希望被发生的。</p>
<ul>
<li>👉 一个白色对象被黑色对象引用 <strong>（白色被挂在黑色下）</strong></li>
<li>👉 灰色对象与它之间可达关系的白色对象遭到破坏 <strong>（灰色同时丢了该白色）</strong></li>
</ul>
<p>如果当以上两个条件同时满足时，就会出现对象丢失现象！</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/f9e8dce78c274ccfb76bb491967d8fc2.png" title="三色标记对象丢失" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/f9e8dce78c274ccfb76bb491967d8fc2.png" data-sub-html="<h2>三色标记对象丢失</h2><p>三色标记对象丢失</p>">
        
    </a><figcaption class="image-caption">三色标记对象丢失</figcaption>
    </figure></p>
<p>并且，上面所示的场景中，如果示例中的白色对象3还有很多下游对象的话，也会一并都清理掉。</p>
<p>为了防止这种现象的发生，最简单的方式就是 STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是<strong>STW的过程有明显的资源浪费，对所有的用户程序都有很大影响</strong>。</p>
<p>那么是否可以在保证对象不丢失的情况下合理的尽可能的提高 GC 效率，减少 STW 时间呢❓</p>
<p>答案是可以的，我们只要使用一种机制，尝试去破坏上面的两个必要条件就可以了。</p>
<h2 id="屏障机制" class="headerLink">
    <a href="#%e5%b1%8f%e9%9a%9c%e6%9c%ba%e5%88%b6" class="header-mark"></a>屏障机制</h2><p>如果让 GC 回收器，满足下面两种情况之一时，即可保证对象不丢失。这两种方式就是<strong>强三色不变式</strong>和<strong>弱三色不变式</strong>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/95aefcee22ae4f72a04437582362e947.png" title="强/弱三色不变式" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/95aefcee22ae4f72a04437582362e947.png" data-sub-html="<h2>强/弱三色不变式</h2><p>强/弱三色不变式</p>">
        
    </a><figcaption class="image-caption">强/弱三色不变式</figcaption>
    </figure></p>
<h3 id="强三色不变式" class="headerLink">
    <a href="#%e5%bc%ba%e4%b8%89%e8%89%b2%e4%b8%8d%e5%8f%98%e5%bc%8f" class="header-mark"></a>强三色不变式</h3><p>强三色不变式实际上是强制性的<strong>不允许黑色对象引用白色对象</strong>，这样就不会出现有白色对象被误删的情况。</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230105/9f8f0337b20c475bbf637503e68b0766.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230105/9f8f0337b20c475bbf637503e68b0766.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230105/9f8f0337b20c475bbf637503e68b0766.png" data-sub-html="<h2>强三色不变式</h2>">
        
    </a><figcaption class="image-caption">强三色不变式</figcaption>
    </figure>
<h3 id="弱三色不变式" class="headerLink">
    <a href="#%e5%bc%b1%e4%b8%89%e8%89%b2%e4%b8%8d%e5%8f%98%e5%bc%8f" class="header-mark"></a>弱三色不变式</h3><p>所有被黑色对象引用的白色对象都处于灰色保护状态。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/9766a534c5244092b12e47a8255c7dc4.png" title="弱三色不变式" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/9766a534c5244092b12e47a8255c7dc4.png" data-sub-html="<h2>弱三色不变式</h2><p>弱三色不变式</p>">
        
    </a><figcaption class="image-caption">弱三色不变式</figcaption>
    </figure></p>
<p>弱三色不变式强调，黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。这样实则是黑色对象引用白色对象，白色对象处于一个危险被删除的状态，但是由于上游灰色对象的引用，可以保护该白色对象，使其安全。</p>
<p>为了遵循上述的两个方式，GC 算法演进到两种屏障方式，分别是<strong>插入屏障</strong>和<strong>删除屏障</strong>。</p>
<h3 id="插入屏障" class="headerLink">
    <a href="#%e6%8f%92%e5%85%a5%e5%b1%8f%e9%9a%9c" class="header-mark"></a>插入屏障</h3><p>具体操作： 在 A 对象引用 B 对象的时候，B 对象被标记为灰色。<strong>将 B 挂在 A 下游，B 必须被标记为灰色</strong>。</p>
<p>满足：<strong>强三色不变式</strong>。不存在黑色对象引用白色对象的情况了， 因为<strong>白色会强制变成灰色</strong>。</p>
<p>伪代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">添加下游对象(当前下游对象slot, 新下游对象ptr) {
</span></span><span class="line"><span class="cl">  //1
</span></span><span class="line"><span class="cl">  标记灰色(新下游对象ptr)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  //2
</span></span><span class="line"><span class="cl">  当前下游对象slot = 新下游对象ptr
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>场景：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">A.添加下游对象(nil, B)   //A 之前没有下游， 新添加一个下游对象B， B被标记为灰色
</span></span><span class="line"><span class="cl">A.添加下游对象(C, B)     //A 将下游对象C 更换为B，  B被标记为灰色
</span></span></code></pre></td></tr></table>
</div>
</div><p>这段伪代码逻辑就是写屏障，但是这里有个性能损耗的地方就是每次添加好插入对象都要去判断。</p>
<p>黑色对象的内存槽有两种位置，栈和堆。 栈空间的特点是容量小，但是要求响应速度快，因为函数调用弹出频繁使用，所以<strong>插入屏障机制，在栈空间的对象操作中不使用，而仅仅使用在堆空间对象的操作中</strong>。</p>
<p>接下来，我们用几张图，来模拟一下整个详细的过程，希望能更可观的看清整体流程。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/9d76191546e44252ac8edd0fae087465.png" title="插入屏障01" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/9d76191546e44252ac8edd0fae087465.png" data-sub-html="<h2>插入屏障01</h2><p>插入屏障01</p>">
        
    </a><figcaption class="image-caption">插入屏障01</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/3d4a215e1c8347e2a6ebf416617cb2ee.png" title="插入屏障02" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/3d4a215e1c8347e2a6ebf416617cb2ee.png" data-sub-html="<h2>插入屏障02</h2><p>插入屏障02</p>">
        
    </a><figcaption class="image-caption">插入屏障02</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/53f0850d9ca746668c9a8ebf9c628ca3.png" title="插入屏障03" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/53f0850d9ca746668c9a8ebf9c628ca3.png" data-sub-html="<h2>插入屏障03</h2><p>插入屏障03</p>">
        
    </a><figcaption class="image-caption">插入屏障03</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/2b66b768590b448f857a5dba72cd7146.png" title="插入屏障04" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/2b66b768590b448f857a5dba72cd7146.png" data-sub-html="<h2>插入屏障04</h2><p>插入屏障04</p>">
        
    </a><figcaption class="image-caption">插入屏障04</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/f0a379d3fd1d45df8dd20f7a68f615e0.png" title="插入屏障05" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/f0a379d3fd1d45df8dd20f7a68f615e0.png" data-sub-html="<h2>插入屏障05</h2><p>插入屏障05</p>">
        
    </a><figcaption class="image-caption">插入屏障05</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/c55625c54be54d848fb98ccfc88a76f9.png" title="插入屏障06" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/c55625c54be54d848fb98ccfc88a76f9.png" data-sub-html="<h2>插入屏障06</h2><p>插入屏障06</p>">
        
    </a><figcaption class="image-caption">插入屏障06</figcaption>
    </figure></p>
<p>但是如果栈不添加，当全部三色标记扫描之后，栈上有可能依然存在白色对象被引用的情况（如上图的对象9）。所以要对栈重新进行三色标记扫描，但这次为了对象不丢失，<strong>要对本次标记扫描启动 STW 暂停</strong>，直到栈空间的三色标记结束。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/80c67f3febd44156b71332b19172c2ec.png" title="插入屏障07" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/80c67f3febd44156b71332b19172c2ec.png" data-sub-html="<h2>插入屏障07</h2><p>插入屏障07</p>">
        
    </a><figcaption class="image-caption">插入屏障07</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/77edaf8cc2cb4fad9283b5eedd81d2cf.png" title="插入屏障08" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/77edaf8cc2cb4fad9283b5eedd81d2cf.png" data-sub-html="<h2>插入屏障08</h2><p>插入屏障08</p>">
        
    </a><figcaption class="image-caption">插入屏障08</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/268b613c2dbd44048b5fd32667957a6e.png" title="插入屏障09" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/268b613c2dbd44048b5fd32667957a6e.png" data-sub-html="<h2>插入屏障09</h2><p>插入屏障09</p>">
        
    </a><figcaption class="image-caption">插入屏障09</figcaption>
    </figure></p>
<p>最后将栈和堆空间扫描剩余的全部白色节点清除，这次 STW 大约的时间在 10~100ms 间。这也是插入写屏障的<strong>不足</strong>，因为还是需要 STW，虽然时间很短。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/c3fe1710d579448aa8b13f84cd2cd6f0.png" title="插入屏障10" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/c3fe1710d579448aa8b13f84cd2cd6f0.png" data-sub-html="<h2>插入屏障10</h2><p>插入屏障10</p>">
        
    </a><figcaption class="image-caption">插入屏障10</figcaption>
    </figure></p>
<h3 id="删除屏障" class="headerLink">
    <a href="#%e5%88%a0%e9%99%a4%e5%b1%8f%e9%9a%9c" class="header-mark"></a>删除屏障</h3><p>具体操作：被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p>
<p>满足：<strong>弱三色不变式</strong>，保护灰色对象到白色对象的路径不会断。</p>
<p>伪代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">添加下游对象(当前下游对象slot， 新下游对象ptr) {
</span></span><span class="line"><span class="cl">  //1
</span></span><span class="line"><span class="cl">  if (当前下游对象slot是灰色 || 当前下游对象slot是白色) {
</span></span><span class="line"><span class="cl">  		标记灰色(当前下游对象slot)     //slot为被删除对象， 标记为灰色
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  //2
</span></span><span class="line"><span class="cl">  当前下游对象slot = 新下游对象ptr
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>场景：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">A.添加下游对象(B, nil)   //A对象，删除B对象的引用。 B被A删除，被标记为灰(如果B之前为白)
</span></span><span class="line"><span class="cl">A.添加下游对象(B, C)         //A对象，更换下游B变成C。 B被A删除，被标记为灰(如果B之前为白)
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来，我们用几张图，来模拟一个详细的过程，希望能够更可观的看清楚整体流程。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/3ef46111cdca45b18626a0511f9b3df5.png" title="删除屏障01" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/3ef46111cdca45b18626a0511f9b3df5.png" data-sub-html="<h2>删除屏障01</h2><p>删除屏障01</p>">
        
    </a><figcaption class="image-caption">删除屏障01</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/e08ac9cd722c45ef98d9362fa5401c48.png" title="删除屏障02" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/e08ac9cd722c45ef98d9362fa5401c48.png" data-sub-html="<h2>删除屏障02</h2><p>删除屏障02</p>">
        
    </a><figcaption class="image-caption">删除屏障02</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/a8ad362faec241848935c82e1fa7e428.png" title="删除屏障03" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/a8ad362faec241848935c82e1fa7e428.png" data-sub-html="<h2>删除屏障03</h2><p>删除屏障03</p>">
        
    </a><figcaption class="image-caption">删除屏障03</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/e230f27d981248e1b4bfb254a776c038.png" title="删除屏障04" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/e230f27d981248e1b4bfb254a776c038.png" data-sub-html="<h2>删除屏障04</h2><p>删除屏障04</p>">
        
    </a><figcaption class="image-caption">删除屏障04</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/3887ebd09e204ec9932c0cfb10fb38fa.png" title="删除屏障05" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/3887ebd09e204ec9932c0cfb10fb38fa.png" data-sub-html="<h2>删除屏障05</h2><p>删除屏障05</p>">
        
    </a><figcaption class="image-caption">删除屏障05</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/65cdf09e3d3e454487a23e3e79c424ee.png" title="删除屏障06" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/65cdf09e3d3e454487a23e3e79c424ee.png" data-sub-html="<h2>删除屏障06</h2><p>删除屏障06</p>">
        
    </a><figcaption class="image-caption">删除屏障06</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/7d6c80f3eec34796ab3c3e333642de96.png" title="删除屏障07" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/7d6c80f3eec34796ab3c3e333642de96.png" data-sub-html="<h2>删除屏障07</h2><p>删除屏障07</p>">
        
    </a><figcaption class="image-caption">删除屏障07</figcaption>
    </figure></p>
<p>这种方式的<strong>不足是回收精度低</strong>，一个对象即使被删除了最后一个指向它的指针也<strong>依旧可以</strong>活过这一轮，在下一轮 GC 中被清理掉。</p>
<h2 id="混合写屏障" class="headerLink">
    <a href="#%e6%b7%b7%e5%90%88%e5%86%99%e5%b1%8f%e9%9a%9c" class="header-mark"></a>混合写屏障</h2><p>插入写屏障和删除写屏障的短板：</p>
<ul>
<li>插入写屏障：结束时需要 STW 来重新扫描栈，标记栈上引用的白色对象的存活，大约需要 10-100ms。</li>
<li>删除写屏障：回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮 GC 中被清理掉。GC 开始时 STW 扫描堆栈来记录初始快照（监控对象的内存修改，判断对象是否删除），这个过程会保护开始时刻的所有存活对象。</li>
</ul>
<p>Go v1.8 版本引入了<strong><ruby>混合写屏障机制<rt>hybrid write barrier</rt></ruby></strong>，避免了对栈 re-scan 的过程，极大的减少了 STW 的时间，结合了两者的优点。</p>
<h3 id="规则" class="headerLink">
    <a href="#%e8%a7%84%e5%88%99" class="header-mark"></a>规则</h3><p>具体操作：</p>
<ol>
<li>GC 开始将栈上的对象全部扫描并标记为黑色（之后不再进行第二次重复扫描，无需 STW ）。</li>
<li><strong>GC 期间，任何在栈上创建的新对象，均为黑色</strong>。</li>
<li>被删除的对象标记为灰色。</li>
<li>被添加的对象标记为灰色。</li>
</ol>
<p>满足：变形的弱三色不变式。</p>
<p>伪代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">添加下游对象(当前下游对象slot, 新下游对象ptr) {
</span></span><span class="line"><span class="cl">  	//1
</span></span><span class="line"><span class="cl">	标记灰色(当前下游对象slot)    //只要当前下游对象被移走，就标记灰色
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  	//2
</span></span><span class="line"><span class="cl">  	标记灰色(新下游对象ptr)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  	//3
</span></span><span class="line"><span class="cl">  	当前下游对象slot = 新下游对象ptr
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>屏障技术是不在栈上应用的，因为要保证栈的运行效率。</p>
</blockquote>
<h3 id="具体场景" class="headerLink">
    <a href="#%e5%85%b7%e4%bd%93%e5%9c%ba%e6%99%af" class="header-mark"></a>具体场景</h3><p>我们用几张图，来模拟一个详细的过程，希望能够更可观的看清楚整体流程。</p>
<p>混合写屏障是 GC 的一种屏障机制，所以只是当程序执行 GC 的时候，才会触发这种机制。</p>
<p>GC开始：优先扫描栈区，将可达对象全部标记为黑</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/d7aefd0f1c7e47fb94db02096fe857d9.png" title="混合写屏障01" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/d7aefd0f1c7e47fb94db02096fe857d9.png" data-sub-html="<h2>混合写屏障01</h2><p>混合写屏障01</p>">
        
    </a><figcaption class="image-caption">混合写屏障01</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/d674041682d940189041add754694bdf.png" title="混合写屏障02" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/d674041682d940189041add754694bdf.png" data-sub-html="<h2>混合写屏障02</h2><p>混合写屏障02</p>">
        
    </a><figcaption class="image-caption">混合写屏障02</figcaption>
    </figure></p>
<h4 id="场景一" class="headerLink">
    <a href="#%e5%9c%ba%e6%99%af%e4%b8%80" class="header-mark"></a>场景一</h4><p>对象被一个堆对象删除引用，成为栈对象的下游。</p>
<p>伪代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//前提：堆对象4-&gt;对象7 = 对象7；  //对象7 被 对象4引用
</span></span><span class="line"><span class="cl">栈对象1-&gt;对象7 = 堆对象7；  //将堆对象7 挂在 栈对象1 下游
</span></span><span class="line"><span class="cl">堆对象4-&gt;对象7 = null；    //对象4 删除引用 对象7
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/6eccf4b23f1044499d0bbf77c2069b21.png" title="场景1-01" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/6eccf4b23f1044499d0bbf77c2069b21.png" data-sub-html="<h2>场景1-01</h2><p>场景1-01</p>">
        
    </a><figcaption class="image-caption">场景1-01</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/03f8a2fc5bcc4d76a74f48495900d00f.png" title="场景1-02" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/03f8a2fc5bcc4d76a74f48495900d00f.png" data-sub-html="<h2>场景1-02</h2><p>场景1-02</p>">
        
    </a><figcaption class="image-caption">场景1-02</figcaption>
    </figure></p>
<h4 id="场景二" class="headerLink">
    <a href="#%e5%9c%ba%e6%99%af%e4%ba%8c" class="header-mark"></a>场景二</h4><p>对象被一个栈对象删除引用，成为另一个栈对象的下游。</p>
<p>伪代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">new 栈对象9；
</span></span><span class="line"><span class="cl">对象8-&gt;对象3 = 对象3；      //将栈对象3 挂在 栈对象9 下游
</span></span><span class="line"><span class="cl">对象2-&gt;对象3 = null；      //对象2 删除引用 对象3
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/da92001995cf4c8cbf2568c3bacd7fbd.png" title="场景2-01" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/da92001995cf4c8cbf2568c3bacd7fbd.png" data-sub-html="<h2>场景2-01</h2><p>场景2-01</p>">
        
    </a><figcaption class="image-caption">场景2-01</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/bc9ae45a820e4af682c58a25f96155e2.png" title="场景2-02" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/bc9ae45a820e4af682c58a25f96155e2.png" data-sub-html="<h2>场景2-02</h2><p>场景2-02</p>">
        
    </a><figcaption class="image-caption">场景2-02</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/310dda56e97f411bab5a2e5576fd4369.png" title="场景2-03" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/310dda56e97f411bab5a2e5576fd4369.png" data-sub-html="<h2>场景2-03</h2><p>场景2-03</p>">
        
    </a><figcaption class="image-caption">场景2-03</figcaption>
    </figure></p>
<h4 id="场景三" class="headerLink">
    <a href="#%e5%9c%ba%e6%99%af%e4%b8%89" class="header-mark"></a>场景三</h4><p>对象被一个堆对象删除引用，成为另一个堆对象的下游。</p>
<p>伪代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">堆对象10-&gt;对象7 = 堆对象7；       //将堆对象7 挂在 堆对象10 下游
</span></span><span class="line"><span class="cl">堆对象4-&gt;对象7 = null；         //对象4 删除引用 对象7
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/899ed05a51664c9eb09bfecce8b2945a.png" title="场景3-01" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/899ed05a51664c9eb09bfecce8b2945a.png" data-sub-html="<h2>场景3-01</h2><p>场景3-01</p>">
        
    </a><figcaption class="image-caption">场景3-01</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/cee749d8466d416f8a1ecb07d1c165de.png" title="场景3-02" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/cee749d8466d416f8a1ecb07d1c165de.png" data-sub-html="<h2>场景3-02</h2><p>场景3-02</p>">
        
    </a><figcaption class="image-caption">场景3-02</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/7d0257110cd2437dac1c7835c43b2a73.png" title="场景3-03" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/7d0257110cd2437dac1c7835c43b2a73.png" data-sub-html="<h2>场景3-03</h2><p>场景3-03</p>">
        
    </a><figcaption class="image-caption">场景3-03</figcaption>
    </figure></p>
<h4 id="场景四" class="headerLink">
    <a href="#%e5%9c%ba%e6%99%af%e5%9b%9b" class="header-mark"></a>场景四</h4><p>对象从一个栈对象删除引用，成为另一个堆对象的下游。</p>
<p>伪代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">堆对象10-&gt;对象7 = 堆对象7；       //将堆对象7 挂在 堆对象10 下游
</span></span><span class="line"><span class="cl">堆对象4-&gt;对象7 = null；         //对象4 删除引用 对象7
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/c1cc894d7bef4f1ba26e92c7427de8a5.png" title="场景4-01" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/c1cc894d7bef4f1ba26e92c7427de8a5.png" data-sub-html="<h2>场景4-01</h2><p>场景4-01</p>">
        
    </a><figcaption class="image-caption">场景4-01</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/0c64f5d24f674a90942170b8998deafa.png" title="场景4-02" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/0c64f5d24f674a90942170b8998deafa.png" data-sub-html="<h2>场景4-02</h2><p>场景4-02</p>">
        
    </a><figcaption class="image-caption">场景4-02</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/e25db1900a4d404189fdcb61d33ac5d2.png" title="场景4-03" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/e25db1900a4d404189fdcb61d33ac5d2.png" data-sub-html="<h2>场景4-03</h2><p>场景4-03</p>">
        
    </a><figcaption class="image-caption">场景4-03</figcaption>
    </figure></p>
<p>Go 中的混合写屏障满足<strong>弱三色不变式</strong>，结合了删除写屏障和插入写屏障的优点，<strong>只需要在开始时并发扫描各个 goroutine 的栈</strong>，使其变黑并一直保持，这个过程不需要 STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行 re-scan 操作了，减少了 STW 的时间。</p>
<h2 id="总结" class="headerLink">
    <a href="#%e6%80%bb%e7%bb%93" class="header-mark"></a>总结</h2><p>GoV1.3：普通标记清除法，整体过程需要启动 STW，效率极低。</p>
<p>GoV1.5：三色标记法，堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要 STW )，效率普通。</p>
<p>GoV1.8：三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://community.apinto.com/d/34057-golang-gc" target="_blank" rel="noopener noreferrer">一文弄懂 Golang GC、三色标记、混合写屏障机制</a></li>
<li><a href="https://www.kancloud.cn/aceld/golang/1958308" target="_blank" rel="noopener noreferrer">Golang三色标记+混合写屏障GC模式全分析</a></li>
<li><a href="https://www.bilibili.com/video/BV1wz4y1y7Kd/" target="_blank" rel="noopener noreferrer">Golang中GC回收机制三色标记与混合写屏障</a></li>
</ul>
]]></description>
</item><item>
    <title>互联网协议简述</title>
    <link>https://www.xiaobinqt.cn/net-protocol-glance/</link>
    <pubDate>Sun, 27 Mar 2022 00:00:00 &#43;0000</pubDate><author>
        <name>作者</name>
    </author><guid>https://www.xiaobinqt.cn/net-protocol-glance/</guid>
    <description><![CDATA[<h2 id="概述" class="headerLink">
    <a href="#%e6%a6%82%e8%bf%b0" class="header-mark"></a>概述</h2><h3 id="五层模型" class="headerLink">
    <a href="#%e4%ba%94%e5%b1%82%e6%a8%a1%e5%9e%8b" class="header-mark"></a>五层模型</h3><p>互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。</p>
<p>用户接触到的，只是最上面的一层，根本没有感觉到下面的层。理解互联网，需要从最下层开始，自下而上理解每一层的功能。</p>
<p>如何分层，有不同的模型，有的模型分七层，有的分四层。把互联网分成五层，比较容易解释。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/0b07f1e814384409a9a5f97a4bbc8196.png" title="五层模型" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/0b07f1e814384409a9a5f97a4bbc8196.png" data-sub-html="<h2>五层模型</h2><p>五层模型</p>">
        
    </a><figcaption class="image-caption">五层模型</figcaption>
    </figure></p>
<p>如上图所示，最底下的一层叫做<strong><ruby>实体层<rt>Physical Layer</rt></ruby></strong>，最上面的一层叫做<strong><ruby>应用层<rt>Application Layer</rt></ruby></strong>，中间的三层（自下而上）分别是<strong><ruby>链接层<rt>Link Layer</rt></ruby></strong>、<strong><ruby>网络层<rt>Network Layer</rt></ruby></strong>和<strong><ruby>传输层<rt>Transport Layer</rt></ruby></strong>。越下面的层，越靠近硬件；越上面的层，越靠近用户。</p>
<p>名字只是一个代号，它们叫什么名字，其实并不重要。只需要知道，互联网分成若干层就可以了。</p>
<h3 id="层与协议" class="headerLink">
    <a href="#%e5%b1%82%e4%b8%8e%e5%8d%8f%e8%ae%ae" class="header-mark"></a>层与协议</h3><p>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。</p>
<p>大家都遵守的规则，就叫做“协议”（protocol）。</p>
<p>互联网的每一层，都定义了很多协议。这些协议的总称，就叫做“互联网协议”（Internet Protocol Suite），它们是互联网的核心。</p>
<h2 id="实体层" class="headerLink">
    <a href="#%e5%ae%9e%e4%bd%93%e5%b1%82" class="header-mark"></a>实体层</h2><p>电脑要组网，第一件事是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。</p>
<p>这就叫做“实体层”，它就是<strong>把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送 0 和 1 的电信号</strong>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/008215cf196441ff891300b99ca05e41.png" title="实体层" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/008215cf196441ff891300b99ca05e41.png" data-sub-html="<h2>实体层</h2><p>实体层</p>">
        
    </a><figcaption class="image-caption">实体层</figcaption>
    </figure></p>
<h2 id="链接层" class="headerLink">
    <a href="#%e9%93%be%e6%8e%a5%e5%b1%82" class="header-mark"></a>链接层</h2><p>单纯的 0 和 1 没有任何意义，必须规定解读方式：多少个电信号算一组❓每个信号位有何意义❓</p>
<p>这就是“链接层”的功能，它在“实体层”的上方，<strong>确定了 0 和 1 的分组方式</strong>。</p>
<h3 id="以太网协议" class="headerLink">
    <a href="#%e4%bb%a5%e5%a4%aa%e7%bd%91%e5%8d%8f%e8%ae%ae" class="header-mark"></a>以太网协议</h3><p>早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做“以太网”（Ethernet）的协议，占据了主导地位。</p>
<p>以太网规定，<strong>一组电信号</strong>构成一个数据包，叫做“帧”（<code>Frame</code>）。每一帧分成两个部分：标头（<code>Head</code>）和数据（<code>Data</code>）。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/7faf60ba902f4f5dac74eae05aa46470.png" title="head-data" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/7faf60ba902f4f5dac74eae05aa46470.png" data-sub-html="<h2>head-data</h2><p>head-data</p>">
        
    </a><figcaption class="image-caption">head-data</figcaption>
    </figure></p>
<p>“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；“数据”则是数据包的具体内容。</p>
<p><strong>“标头”的长度，固定为 18 字节。“数据”的长度，最短为 46 字节，最长为 1500 字节</strong>
。因此，整个“帧”最短为 64 字节，最长为 1518 字节。如果数据很长，就必须分割成多个帧进行发送。</p>
<h3 id="mac-地址" class="headerLink">
    <a href="#mac-%e5%9c%b0%e5%9d%80" class="header-mark"></a>MAC 地址</h3><p><strong>以太网数据包的“标头”，包含了发送者和接受者的信息</strong>。那么，发送者和接受者是如何标识呢？</p>
<p>以太网规定，连入网络的所有设备，都必须具有“网卡”接口。
<strong>数据包必须是从一块网卡，传送到另一块网卡</strong>。网卡的地址，就是数据包的发送地址和接收地址，这叫做 MAC 地址。</p>
<p>每块网卡出厂的时候，都有一个全世界独一无二的 MAC 地址，长度是 48 个二进制位，通常用 12 个十六进制数表示。</p>
<p>前 6 个十六进制数是厂商编号，后 6 个是该厂商的网卡流水号。有了 MAC 地址，就可以定位网卡和数据包的路径了。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/210ac80feaab480c824906751e28b7cf.png" title="MAC address" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/210ac80feaab480c824906751e28b7cf.png" data-sub-html="<h2>MAC address</h2><p>MAC address</p>">
        
    </a><figcaption class="image-caption">MAC address</figcaption>
    </figure></p>
<p>上图的 MAC 地址的二进制位为 <code>00000000-10110000-11010000-10000110-10111011-11110111</code>。</p>
<h3 id="广播" class="headerLink">
    <a href="#%e5%b9%bf%e6%92%ad" class="header-mark"></a>广播</h3><p>以太网数据包必须知道接收方的 MAC 地址，然后才能发送，那么问题来了，</p>
<ul>
<li>一块网卡怎么会知道另一块网卡的MAC地址？</li>
<li>就算有了 MAC 地址，系统怎样才能把数据包准确送到接收方？</li>
</ul>
<p>回答是，以太网采用了一种很“原始”的方式，它不是把数据包准确送到接收方，而是向<strong>本网络内所有计算机</strong>发送，让每台计算机自己判断，是否为接收方。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/259a2bda03624c2c9381cfb244af47dd.png" title="广播" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/259a2bda03624c2c9381cfb244af47dd.png" data-sub-html="<h2>广播</h2><p>广播</p>">
        
    </a><figcaption class="image-caption">广播</figcaption>
    </figure></p>
<p>上图中，1 号计算机向 2 号计算机发送一个数据包，同一个子网络的 3 号、4 号、5 号计算机都会收到这个包。它们读取这个包的“标头”，找到接收方的 MAC 地址，然后与自身的 MAC 地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做<strong><ruby>广播<rt>broadcasting</rt></ruby></strong>。</p>
<p>有了数据包的定义、网卡的 MAC 地址、广播的发送方式，“链接层”就可以在多台计算机之间传送数据了。</p>
<h2 id="网络层" class="headerLink">
    <a href="#%e7%bd%91%e7%bb%9c%e5%b1%82" class="header-mark"></a>网络层</h2><h3 id="网络层的由来" class="headerLink">
    <a href="#%e7%bd%91%e7%bb%9c%e5%b1%82%e7%9a%84%e7%94%b1%e6%9d%a5" class="header-mark"></a>网络层的由来</h3><p>以太网协议，依靠 MAC 地址发送数据。理论上，单单依靠 MAC 地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。</p>
<p>但是，这样做有一个重大的缺点。<strong>以太网采用广播方式发送数据包</strong>，所有成员人手一“包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，
<strong>如果两台计算机不在同一个子网络，广播是传不过去的</strong>。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p>
<p><strong>互联网是无数子网络共同组成的一个巨型网络</strong>，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/cee93bcb3c2245d6a238a7074dd540ff.png" title="子网络" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/cee93bcb3c2245d6a238a7074dd540ff.png" data-sub-html="<h2>子网络</h2><p>子网络</p>">
        
    </a><figcaption class="image-caption">子网络</figcaption>
    </figure></p>
<p>因此，必须找到一种方法，能够区分哪些 MAC 地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用“路由”方式发送。（“路由”的意思，就是指如何向不同的子网络分发数据包。），MAC 地址本身无法做到这一点，它只与厂商有关，与所处网络无关。</p>
<p>这就导致了“网络层”的诞生。它的作用是 <strong>引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络</strong>
。这套地址就叫做“网络地址”，简称“网址”。</p>
<p>于是，“网络层”出现以后，每台计算机有了两种地址，一种是 MAC 地址，另一种是网络地址。
<strong>两种地址之间没有任何联系</strong>，MAC 地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p>
<p><strong>网络地址帮助我们确定计算机所在的子网络，MAC 地址则将数据包送到该子网络中的目标网卡</strong>。因此，从逻辑上可以推断，必定是
<strong>先处理网络地址，然后再处理 MAC 地址</strong>。</p>
<h3 id="ip协议和子网掩码" class="headerLink">
    <a href="#ip%e5%8d%8f%e8%ae%ae%e5%92%8c%e5%ad%90%e7%bd%91%e6%8e%a9%e7%a0%81" class="header-mark"></a>IP协议和子网掩码</h3><p>规定网络地址的协议，叫做 IP 协议。它所定义的地址，就被称为 IP 地址。</p>
<p>目前，广泛采用的是 IP 协议第四版，简称 IPv4。这个版本规定，网络地址由 32 个二进制位组成。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/a4ba02cbb01341ddbb0b75e979b61625.png" title="IP协议" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/a4ba02cbb01341ddbb0b75e979b61625.png" data-sub-html="<h2>IP协议</h2><p>IP协议</p>">
        
    </a><figcaption class="image-caption">IP协议</figcaption>
    </figure></p>
<p>习惯上，我们用分成四段的十进制数表示 IP 地址，从 <code>0.0.0.0</code> 一直到 <code>255.255.255.255</code>。</p>
<p>互联网上的每一台计算机，都会分配到一个 IP 地址。</p>
<p><strong>IP 地址分成两个部分，前一部分代表网络，后一部分代表主机</strong>。</p>
<p>比如，IP 地址 <code>172.16.254.1</code>，这是一个 32 位的地址，假定它的网络部分是前 24 位（<code>172.16.254</code>），那么主机部分就是后 8 位（最后的那个 1 ）。
<strong>处于同一个子网络的电脑，它们 IP 地址的网络部分必定是相同的</strong>，也就是说 <code>172.16.254.2</code> 应该与 <code>172.16.254.1</code> 处在同一个子网络。</p>
<p>单单从 IP 地址，我们无法判断网络部分。还是以 <code>172.16.254.1</code> 为例，它的网络部分，到底是前 24 位，还是前 16 位，甚至前 28 位，从 IP 地址上是看不出来的。</p>
<p>那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢❓这就要用到另一个参数<strong><ruby>子网掩码<rt>subnet mask</rt></ruby></strong>。</p>
<p>所谓 <strong>“子网掩码”，就是表示子网络特征的一个参数</strong>。它在形式上等同于 IP 地址，也是一个 32 位二进制数字，它的<strong>网络部分全部为
1，主机部分全部为 0</strong> 。比如，IP 地址 <code>172.16.254.1</code>
，如果已知网络部分是前 24 位，主机部分是后 8 位，那么子网络掩码就是 <code>11111111.11111111.11111111.00000000</code>，写成十进制就是 <code>255.255.255.0</code>。</p>
<p>知道&quot;子网掩码&quot;，我们就能判断，任意两个 IP 地址是否处在同一个子网络。方法是将两个 IP 地址与子网掩码
<strong>分别</strong>进行 AND 运算（两个数位都为 1 ，运算结果为 1，否则为 0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p>
<p>比如，已知IP地址 <code>172.16.254.1</code> 和 <code>172.16.254.233</code> 的子网掩码都是 <code>255.255.255.0</code>，请问它们是否在同一个子网络？两者与子网掩码分别进行 AND 运算，结果都是
<code>172.16.254.0</code>，因此它们在同一个子网络。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">10101100.00010000.11111110.00000001 <span class="c1"># 172.16.254.1</span>
</span></span><span class="line"><span class="cl">11111111.11111111.11111111.00000000 <span class="c1"># 255.255.255.0</span>
</span></span><span class="line"><span class="cl">10101100.00010000.11111110.00000000 <span class="c1"># AND 结果二进制位</span>
</span></span><span class="line"><span class="cl">172.16.254.0                        <span class="c1"># AND 结果转成十进制</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以，<strong>IP 协议的作用主要有两个，一个是为每一台计算机分配 IP 地址，另一个是确定哪些地址在同一个子网络</strong>。</p>
<h3 id="ip数据包" class="headerLink">
    <a href="#ip%e6%95%b0%e6%8d%ae%e5%8c%85" class="header-mark"></a>IP数据包</h3><p>根据 IP 协议发送的数据，就叫做 IP 数据包。不难想象，其中必定包括 IP 地址信息。</p>
<p>但是前面说过，以太网数据包只包含 MAC 地址，并没有 IP 地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？</p>
<p>回答是不需要，我们可以把 IP 数据包直接放进以太网数据包的“数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。</p>
<p>具体来说，IP 数据包也分为“标头”和“数据”两个部分。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/a13ff01efe0e4053ae1e8d126404a619.png" title="IP数据包1" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/a13ff01efe0e4053ae1e8d126404a619.png" data-sub-html="<h2>IP数据包1</h2><p>IP数据包1</p>">
        
    </a><figcaption class="image-caption">IP数据包1</figcaption>
    </figure></p>
<p>“标头”部分主要包括版本、长度、IP 地址等信息，“数据”部分则是 IP 数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/14bf0cdc38654770bb9a6f0d58c0175f.png" title="IP数据包2" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/14bf0cdc38654770bb9a6f0d58c0175f.png" data-sub-html="<h2>IP数据包2</h2><p>IP数据包2</p>">
        
    </a><figcaption class="image-caption">IP数据包2</figcaption>
    </figure></p>
<p>IP 数据包的“标头”部分的长度为 20 到 60 字节，整个数据包的总长度最大为 65,535 字节。因此，理论上，一个 IP 数据包的“数据”部分，最长为 65,515 字节。前面说过，以太网数据包的“数据”部分，最长只有 1500 字节。因此，如果 IP 数据包超过了 1500 字节（上图红色部分），它就需要分割成几个以太网数据包，分开发送了。</p>
<h3 id="arp协议" class="headerLink">
    <a href="#arp%e5%8d%8f%e8%ae%ae" class="header-mark"></a>ARP协议</h3><p>由于 IP 数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的 MAC 地址，另一个是对方的 IP 地址。通常情况下，对方的 IP 地址是已知的，但是我们不知道它的 MAC 地址。</p>
<p>所以，我们需要一种机制，能够从 IP 地址得到 MAC 地址。</p>
<p>这里又可以分成两种情况。</p>
<p>第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的 MAC 地址，只能把数据包传送到两个子网络连接处的<strong><ruby>网关<rt>gateway</rt></ruby></strong>，让网关去处理。</p>
<p>第二种情况，如果两台主机在同一个子网络，那么我们可以用 ARP 协议，得到对方的 MAC 地址。ARP 协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的 IP 地址，在对方的 MAC 地址这一栏，填的是<code>FF:FF:FF:FF:FF:FF</code>，表示这是一个&quot;广播&quot;
地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出 IP 地址，与自身的 IP 地址进行比较。如果两者相同，都做出回复，向对方报告自己的 MAC 地址，否则就丢弃这个包。</p>
<p>有了 ARP 协议之后，我们就可以得到<strong>同一个子网络内的主机 MAC 地址，可以把数据包发送到任意一台主机之上</strong>。</p>
<h2 id="传输层" class="headerLink">
    <a href="#%e4%bc%a0%e8%be%93%e5%b1%82" class="header-mark"></a>传输层</h2><h3 id="传输层的由来" class="headerLink">
    <a href="#%e4%bc%a0%e8%be%93%e5%b1%82%e7%9a%84%e7%94%b1%e6%9d%a5" class="header-mark"></a>传输层的由来</h3><p>有了 MAC 地址和 IP 地址，我们已经可以在互联网上任意两台主机上建立通信。</p>
<p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p>
<p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做<strong><ruby>端口<rt>port</rt></ruby></strong>，它其实
<strong>是每一个使用网卡的程序的编号</strong>。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>
<p>“端口”是 0 到 65535 之间的一个整数，正好 16 个二进制位。
<strong>0 到 1023 的端口被系统占用</strong>，用户只能选用大于 1023 的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p>
<p><strong>“传输层”的功能，就是建立“端口到端口”的通信。相比之下，“网络层”的功能是建立“主机到主机”的通信。只要确定主机和端口，
我们就能实现程序之间的交流</strong>。因此，Unix系统就把主机+端口，叫做<strong><ruby>套接字<rt>socket</rt></ruby></strong>。有了它，就可以进行网络应用程序开发了。</p>
<h3 id="udp-协议" class="headerLink">
    <a href="#udp-%e5%8d%8f%e8%ae%ae" class="header-mark"></a>UDP 协议</h3><p>我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做 UDP 协议，它的格式几乎就是在数据前面，加上端口号。</p>
<p>UDP 数据包，也是由“标头”和“数据”两部分组成。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/f22b3c1122804019a03f91c5a3efa31d.png" title="UDP数据格式_1" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/f22b3c1122804019a03f91c5a3efa31d.png" data-sub-html="<h2>UDP数据格式_1</h2><p>UDP数据格式_1</p>">
        
    </a><figcaption class="image-caption">UDP数据格式_1</figcaption>
    </figure></p>
<p>“标头”部分主要定义了发出端口和接收端口，“数据”部分就是具体的内容。然后，把整个 UDP 数据包放入 IP 数据包的“数据”部分，而前面说过，IP 数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/4d0af7444c9b437297c362dbbbdb67ca.png" title="UDP数据格式_2" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/4d0af7444c9b437297c362dbbbdb67ca.png" data-sub-html="<h2>UDP数据格式_2</h2><p>UDP数据格式_2</p>">
        
    </a><figcaption class="image-caption">UDP数据格式_2</figcaption>
    </figure></p>
<p>UDP 数据包非常简单，“标头”部分一共只有 8 个字节，总长度不超过 65,535 字节，正好放进一个IP数据包。</p>
<h3 id="tcp-协议" class="headerLink">
    <a href="#tcp-%e5%8d%8f%e8%ae%ae" class="header-mark"></a>TCP 协议</h3><p>UDP 协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p>
<p>为了解决这个问题，提高网络可靠性，TCP 协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的 UDP 协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p>
<p>因此，TCP 协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p>
<p>TCP 数据包和 UDP 数据包一样，都是内嵌在 IP 数据包的“数据”部分。TCP 数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，
<strong>通常 TCP 数据包的长度不会超过 IP 数据包的长度，以确保单个 TCP 数据包不必再分割</strong>。</p>
<h2 id="应用层" class="headerLink">
    <a href="#%e5%ba%94%e7%94%a8%e5%b1%82" class="header-mark"></a>应用层</h2><p>应用程序收到&quot;传输层&quot;的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p>
<p><strong>“应用层”的作用，就是规定应用程序的数据格式。</strong></p>
<p>举例来说，TCP 协议可以为各种各样的程序传递数据，比如 Email、WWW、FTP 等等。那么，必须有不同协议（比如 http 协议）规定电子邮件、网页、FTP 数据的格式，这些应用程序协议就构成了&quot;应用层&quot;。</p>
<p>这是最高的一层，直接面对用户。它的数据就放在 TCP 数据包的“数据”部分。因此，现在的以太网的数据包就变成下面这样。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/935efc2ef36e4928bab08c8609c67935.png" title="应用层数据包" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220328/935efc2ef36e4928bab08c8609c67935.png" data-sub-html="<h2>应用层数据包</h2><p>应用层数据包</p>">
        
    </a><figcaption class="image-caption">应用层数据包</figcaption>
    </figure></p>
<h2 id="小结" class="headerLink">
    <a href="#%e5%b0%8f%e7%bb%93" class="header-mark"></a>小结</h2><p>网络通信就是交换数据包。电脑 A 向电脑 B 发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/05cd964675504c5697dcca0b27fcbc4a.png" title="数据包" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/05cd964675504c5697dcca0b27fcbc4a.png" data-sub-html="<h2>数据包</h2><p>数据包</p>">
        
    </a><figcaption class="image-caption">数据包</figcaption>
    </figure></p>
<p>发送这个包，需要知道两个地址：</p>
<ul>
<li>对方的 MAC 地址</li>
<li>对方的 IP 地址</li>
</ul>
<p>有了这两个地址，数据包才能准确送到接收者手中。但是，MAC 地址有局限性，<strong>如果两台电脑不在同一个子网络，就无法知道对方的 MAC
地址，必须通过网关（gateway）转发</strong>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/14a9089e17c94a1eb8a1215dd31a2b40.png" title="网关" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/14a9089e17c94a1eb8a1215dd31a2b40.png" data-sub-html="<h2>网关</h2><p>网关</p>">
        
    </a><figcaption class="image-caption">网关</figcaption>
    </figure></p>
<p>上图☝️中，1 号电脑要向 4 号电脑发送一个数据包。它先判断 4 号电脑是否在同一个子网络，结果发现不是，于是就把这个数据包发到网关 A。网关 A 通过路由协议，发现 4 号电脑位于子网络 B，又把数据包发给网关 B，网关 B 再转发到 4 号电脑。</p>
<p>1 号电脑把数据包发到网关 A，必须知道网关 A 的 MAC 地址。所以，数据包的目标地址，实际上分成两种情况：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>数据包地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一个子网络</td>
<td>对方的 MAC 地址，对方的 IP 地址</td>
</tr>
<tr>
<td>非同一个子网络</td>
<td>网关的 MAC 地址，对方的 IP 地址</td>
</tr>
</tbody>
</table>
<p>发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的 MAC 地址。</p>
<h2 id="上网设置" class="headerLink">
    <a href="#%e4%b8%8a%e7%bd%91%e8%ae%be%e7%bd%ae" class="header-mark"></a>上网设置</h2><h3 id="静态ip地址" class="headerLink">
    <a href="#%e9%9d%99%e6%80%81ip%e5%9c%b0%e5%9d%80" class="header-mark"></a>静态IP地址</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/d0cf31e76b2046d89c4053cf9e7bc541.png" title="computer" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/d0cf31e76b2046d89c4053cf9e7bc541.png" data-sub-html="<h2>new computer</h2><p>computer</p>">
        
    </a><figcaption class="image-caption">new computer</figcaption>
    </figure></p>
<p>通常你必须做一些设置。有时，管理员会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：</p>
<ul>
<li>本机的IP地址</li>
<li>子网掩码</li>
<li>网关的IP地址</li>
<li>DNS的IP地址</li>
</ul>
<p>下图是Windows系统的设置窗口。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/feb7f5ebde2d4f63992aa9779ca55262.png" title="系统设置" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/feb7f5ebde2d4f63992aa9779ca55262.png" data-sub-html="<h2>系统设置</h2><p>系统设置</p>">
        
    </a><figcaption class="image-caption">系统设置</figcaption>
    </figure></p>
<p>这四个参数缺一不可。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作“静态IP地址上网”。</p>
<p>但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用“动态IP地址上网”。</p>
<h3 id="动态ip地址" class="headerLink">
    <a href="#%e5%8a%a8%e6%80%81ip%e5%9c%b0%e5%9d%80" class="header-mark"></a>动态IP地址</h3><p>所谓“动态IP地址”，是指计算机开机后，会自动分配到一个 IP 地址，不用人为设定。它使用的协议叫做 DHCP 协议。</p>
<p>这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做“DHCP服务器”。新的计算机加入网络，必须向“DHCP服务器”发送一个“DHCP请求”数据包，申请IP地址和相关的网络参数。</p>
<p>前面说过，如果两台计算机在同一个子网络，必须知道对方的 MAC 地址和 IP 地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？</p>
<p>DHCP协议做了一些巧妙的规定。</p>
<h3 id="dhcp协议" class="headerLink">
    <a href="#dhcp%e5%8d%8f%e8%ae%ae" class="header-mark"></a>DHCP协议</h3><p>首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/93b546648e6640ea97c1e8709280708d.png" title="HDCP协议数据包" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/93b546648e6640ea97c1e8709280708d.png" data-sub-html="<h2>HDCP协议数据包</h2><p>HDCP协议数据包</p>">
        
    </a><figcaption class="image-caption">HDCP协议数据包</figcaption>
    </figure></p>
<ol>
<li>
<p>最前面的“以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：<code>FF-FF-FF-FF-FF-FF</code>。</p>
</li>
<li>
<p>后面的“IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为<code>0.0.0.0</code>，接收方的IP地址设为<code>255.255.255.255</code>。</p>
</li>
<li>
<p>最后的“UDP标头”，设置发出方的端口和接收方的端口。这一部分是 DHCP 协议规定好的，发出方是 68 端口，接收方是 67 端口。</p>
</li>
</ol>
<p>这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是<code>FF-FF-FF-FF-FF-FF</code>
，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的 IP 地址，才能确定是不是发给自己的。当看到发出方 IP 地址是<code>0.0.0.0</code>，接收方是<code>255.255.255.255</code>，于是 DHCP 服务器知道“这个包是发给我的”，而其他计算机就可以丢弃这个包。</p>
<p>接下来，DHCP 服务器读出这个包的数据内容，分配好 IP 地址，发送回去一个“DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的 MAC 地址是双方的网卡地址，IP 标头的 IP 地址是 DHCP 服务器的 IP 地址（发出方）和<code>255.255.255.255</code>（接收方），UDP 标头的端口是 67（发出方）和 68（接收方），分配给请求端的 IP 地址和本网络的具体参数则包含在 Data 部分。</p>
<p>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS 服务器等等参数。</p>
<h3 id="小结-1" class="headerLink">
    <a href="#%e5%b0%8f%e7%bb%93-1" class="header-mark"></a>小结</h3><p>不管是“静态IP地址”还是“动态IP地址”，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍：</p>
<ul>
<li>本机的IP地址</li>
<li>子网掩码</li>
<li>网关的IP地址</li>
<li>DNS的IP地址</li>
</ul>
<p>有了这几个数值，电脑就可以上网&quot;冲浪&quot;了。</p>
<h2 id="一个实例" class="headerLink">
    <a href="#%e4%b8%80%e4%b8%aa%e5%ae%9e%e4%be%8b" class="header-mark"></a>一个实例</h2><h3 id="本机参数" class="headerLink">
    <a href="#%e6%9c%ac%e6%9c%ba%e5%8f%82%e6%95%b0" class="header-mark"></a>本机参数</h3><p>我们假定，用户设置好了自己的网络参数：</p>
<ul>
<li>本机的IP地址：<code>192.168.1.100</code></li>
<li>子网掩码：<code>255.255.255.0</code></li>
<li>网关的IP地址：<code>192.168.1.1</code></li>
<li>DNS的IP地址：<code>8.8.8.8</code></li>
</ul>
<p>然后他打开浏览器，想要访问 Google，在地址栏输入了网址：<a href="https://www.google.com/" target="_blank" rel="noopener noreferrer">www.google.com</a>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/4c713bfb8027455aa671d16c55a58d2f.png" title="访问google" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/4c713bfb8027455aa671d16c55a58d2f.png" data-sub-html="<h2>访问google</h2><p>访问google</p>">
        
    </a><figcaption class="image-caption">访问google</figcaption>
    </figure></p>
<p>这意味着，浏览器要向 Google 发送一个网页请求的数据包。</p>
<h3 id="dns协议" class="headerLink">
    <a href="#dns%e5%8d%8f%e8%ae%ae" class="header-mark"></a>DNS协议</h3><p>我们知道，发送数据包，必须要知道对方的 IP 地址。但是，现在，我们只知道网址 <a href="https://www.google.com/" target="_blank" rel="noopener noreferrer">www.google.com</a>，不知道它的 IP 地址。</p>
<p>DNS 协议可以帮助我们，将这个网址转换成 IP 地址。已知DNS服务器为<code>8.8.8.8</code>，于是我们向这个地址发送一个 DNS 数据包（53端口）。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/2dc987c9aea7402591d054ea660235e9.png" title="DNS数据包" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/2dc987c9aea7402591d054ea660235e9.png" data-sub-html="<h2>DNS数据包</h2><p>DNS数据包</p>">
        
    </a><figcaption class="image-caption">DNS数据包</figcaption>
    </figure></p>
<p>然后，DNS 服务器做出响应，告诉我们 Google 的 I P地址是<code>172.194.72.105</code>。于是，我们知道了对方的 IP 地址。</p>
<h3 id="子网掩码" class="headerLink">
    <a href="#%e5%ad%90%e7%bd%91%e6%8e%a9%e7%a0%81" class="header-mark"></a>子网掩码</h3><p>接下来，我们要判断，这个 IP 地址是不是在同一个子网络，这就要用到子网掩码。</p>
<p>已知子网掩码是<code>255.255.255.0</code>，本机用它对自己的 IP 地址<code>192.168.1.100</code>，做一个二进制的<code>AND</code>运算（两个数位都为1，结果为1，否则为0），计算结果为<code>192.168.1.0</code>；然后对 Google 的 IP 地址<code>172.194.72.105</code>也做一个<code>AND</code>运算，计算结果为<code>172.194.72.0</code>。这两个结果不相等，所以结论是，Google 与本机不在同一个子网络。</p>
<p>因此，我们要向 Google 发送数据包，必须通过网关<code>192.168.1.1</code>转发，也就是说，接收方的 MAC 地址将是网关的 MAC 地址。</p>
<h3 id="应用层协议" class="headerLink">
    <a href="#%e5%ba%94%e7%94%a8%e5%b1%82%e5%8d%8f%e8%ae%ae" class="header-mark"></a>应用层协议</h3><p>浏览网页用的是 HTTP 协议，它的整个数据包构造是这样的：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/d64d5794254341dc98a40bd6dd4b3893.png" title="HTTP协议数据包" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/d64d5794254341dc98a40bd6dd4b3893.png" data-sub-html="<h2>HTTP协议数据包</h2><p>HTTP协议数据包</p>">
        
    </a><figcaption class="image-caption">HTTP协议数据包</figcaption>
    </figure></p>
<p>HTTP部分的内容，类似于下面这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-http" data-lang="http"><span class="line"><span class="cl"><span class="err">　　</span><span class="nf">GET</span> <span class="nn">/</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
</span></span><span class="line"><span class="cl"><span class="err">　　</span><span class="n">Host</span><span class="o">:</span> <span class="l">www.google.com</span>
</span></span><span class="line"><span class="cl"><span class="err">　　</span><span class="n">Connection</span><span class="o">:</span> <span class="l">keep-alive</span>
</span></span><span class="line"><span class="cl"><span class="err">　　</span><span class="n">User-Agent</span><span class="o">:</span> <span class="l">Mozilla/5.0 (Windows NT 6.1) ......</span>
</span></span><span class="line"><span class="cl"><span class="err">　　</span><span class="n">Accept</span><span class="o">:</span> <span class="l">text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
</span></span><span class="line"><span class="cl"><span class="err">　　</span><span class="n">Accept-Encoding</span><span class="o">:</span> <span class="l">gzip,deflate,sdch</span>
</span></span><span class="line"><span class="cl"><span class="err">　　</span><span class="n">Accept-Language</span><span class="o">:</span> <span class="l">zh-CN,zh;q=0.8</span>
</span></span><span class="line"><span class="cl"><span class="err">　　</span><span class="n">Accept-Charset</span><span class="o">:</span> <span class="l">GBK,utf-8;q=0.7,*;q=0.3</span>
</span></span><span class="line"><span class="cl"><span class="err">　　</span><span class="n">Cookie</span><span class="o">:</span> <span class="l">... ...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们假定这个部分的长度为 4960 字节，它会被嵌在 TCP 数据包之中。</p>
<h3 id="tcp协议" class="headerLink">
    <a href="#tcp%e5%8d%8f%e8%ae%ae" class="header-mark"></a>TCP协议</h3><p>TCP 数据包需要设置端口，接收方（Google）的 HTTP 端口默认是 80，发送方（本机）的端口是一个随机生成的 1024-65535 之间的整数，假定为 51775。TCP 数据包的标头长度为 20 字节，加上嵌入 HTTP 的数据包，总长度变为 4980 字节。</p>
<h3 id="ip协议" class="headerLink">
    <a href="#ip%e5%8d%8f%e8%ae%ae" class="header-mark"></a>IP协议</h3><p>然后，TCP 数据包再嵌入 IP 数据包。IP 数据包需要设置双方的 IP 地址，这是已知的，发送方是<code>192.168.1.100</code>（本机），接收方是<code>172.194.72.105</code>（Google）。IP 数据包的标头长度为 20 字节，加上嵌入的 TCP 数据包，总长度变为 5000 字节。</p>
<h3 id="以太网协议-1" class="headerLink">
    <a href="#%e4%bb%a5%e5%a4%aa%e7%bd%91%e5%8d%8f%e8%ae%ae-1" class="header-mark"></a>以太网协议</h3><p>最后，IP 数据包嵌入以太网数据包。以太网数据包需要设置双方的 MAC 地址，发送方为本机的网卡 MAC 地址，接收方为网关<code>192.168.1.1</code>的 MAC 地址（通过 ARP 协议得到）。</p>
<p>以太网数据包的数据部分，最大长度为 1500 字节，而现在的 IP 数据包长度为 5000 字节。因此，IP 数据包必须分割成四个包。因为每个包都有自己的 IP 标头（20字节），所以四个包的 IP 数据包的长度分别为 1500、1500、1500、560。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/fb5d47e23bf84f62bc189df69bfdd991.png" title="以太网协议" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/fb5d47e23bf84f62bc189df69bfdd991.png" data-sub-html="<h2>以太网协议</h2><p>以太网协议</p>">
        
    </a><figcaption class="image-caption">以太网协议</figcaption>
    </figure></p>
<h3 id="服务器端响应" class="headerLink">
    <a href="#%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%ab%af%e5%93%8d%e5%ba%94" class="header-mark"></a>服务器端响应</h3><p>经过多个网关的转发，Google 的服务器<code>172.194.72.105</code>，收到了这四个以太网数据包。</p>
<p>根据IP标头的序号，Google 将四个包拼起来，取出完整的 TCP 数据包，然后读出里面的“HTTP请求”，接着做出“HTTP响应”，再用 TCP 协议发回来。</p>
<p>本机收到 HTTP 响应以后，就可以将网页显示出来，完成一次网络通信。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/9935c287faa04dd1aa107864273e8a27.png" title="服务器相应" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220329/9935c287faa04dd1aa107864273e8a27.png" data-sub-html="<h2>服务器相应</h2><p>服务器相应</p>">
        
    </a><figcaption class="image-caption">服务器相应</figcaption>
    </figure></p>
<p>上面的例子，虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener noreferrer">互联网协议入门</a></li>
</ul>
]]></description>
</item><item>
    <title>OAuth2.0的理解与应用</title>
    <link>https://www.xiaobinqt.cn/oauth2.0/</link>
    <pubDate>Tue, 22 Mar 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/oauth2.0/</guid>
    <description><![CDATA[<h2 id="什么是-oauth20" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-oauth20" class="header-mark"></a>什么是 OAuth2.0</h2><p><strong>OAuth 的核心就是向第三方应用颁发令牌</strong>，比如网站A想用Github的信息，那么对于Github来说，网站A就是第三方应用。</p>
<p>第三方应用申请令牌之前，都必须先到系统备案，比如申请Github的令牌，得先到<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener noreferrer">github备案登记</a>， 说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。</p>
<p>关于 OAuth2.0 是什么可以参考一下文章：</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html" target="_blank" rel="noopener noreferrer">OAuth 2.0 的一个简单解释</a></li>
<li><a href="https://learnku.com/articles/20082" target="_blank" rel="noopener noreferrer">[简易图解]『 OAuth2.0』 『进阶』 授权模式总结</a></li>
</ul>
<h2 id="第三方登录github" class="headerLink">
    <a href="#%e7%ac%ac%e4%b8%89%e6%96%b9%e7%99%bb%e5%bd%95github" class="header-mark"></a>第三方登录Github</h2><p>所谓第三方登录，实质就是 OAuth 授权。用户想要登录 A 网站，A 网站让用户提供第三方网站的数据，证明自己的身份。获取第三方网站的身份数据，就需要 OAuth 授权。</p>
<p>比如，A 网站允许 GitHub 登录，背后就是下面的流程：</p>
<ol>
<li>A 网站让用户跳转到 GitHub。</li>
<li>GitHub 要求用户登录，然后询问&quot;A 网站要求获得 xx 权限，你是否同意？&quot;</li>
<li>用户同意，GitHub 就会重定向回 A 网站，同时发回一个授权码。</li>
<li>A 网站使用授权码，向 GitHub 请求令牌。</li>
<li>GitHub 返回令牌.</li>
<li>A 网站使用令牌，向 GitHub 请求用户数据。</li>
</ol>
<h3 id="注册-oauth-应用" class="headerLink">
    <a href="#%e6%b3%a8%e5%86%8c-oauth-%e5%ba%94%e7%94%a8" class="header-mark"></a>注册 OAuth 应用</h3><p>现在在 Github 上<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener noreferrer">注册</a>一个 OAuth 应用。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220322/0db45fb787184c9e8321202da1758937.png?imageView2/0/interlace/1/q/50%7cimageslim" title="github注册oauth应用" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220322/0db45fb787184c9e8321202da1758937.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2> </h2><p>github注册oauth应用</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Application name</td>
<td>应用名称</td>
</tr>
<tr>
<td>Homepage URL</td>
<td>首页URL，如<code>https://www.xiaobinqt.cn</code></td>
</tr>
<tr>
<td>Authorization callback URL</td>
<td>用户在 Github 登录成功后重定向回的 URL</td>
</tr>
</tbody>
</table>
<p>注册成功后会生成 <code>Client ID</code> 和 <code>Client Secret</code>，这两个是用来请求令牌的。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220322/0c69a51ee31842b5979dce762e7dfede.png?imageView2/0/interlace/1/q/50%7cimageslim" title="生成的Client信息" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220322/0c69a51ee31842b5979dce762e7dfede.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2> </h2><p>生成的Client信息</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<h3 id="通过-oauth-获取用户信息" class="headerLink">
    <a href="#%e9%80%9a%e8%bf%87-oauth-%e8%8e%b7%e5%8f%96%e7%94%a8%e6%88%b7%e4%bf%a1%e6%81%af" class="header-mark"></a>通过 OAuth 获取用户信息</h3><p>前端界面 oauth.html</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="cp">&lt;!DOCTYPE html&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;UTF-8&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Title<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://github.com/login/oauth/authorize?client_id={{.ClientId}}&amp;redirect_uri={{.RedirectUrl}}&#34;</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    Github 第三方授权登录<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>go 代码通过OAuth获取用户信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;encoding/json&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;flag&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;html/template&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;io/ioutil&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;net/http&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;os&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">clientSecret</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;cs&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;github oauth client secret&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">clientID</span>     <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;ci&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;github oauth client id&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Conf</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ClientId</span>     <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ClientSecret</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">RedirectUrl</span>  <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Token</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">AccessToken</span> <span class="kt">string</span> <span class="s">`json:&#34;access_token&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 认证并获取用户信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">OAuth</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 获取 code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">code</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">Query</span><span class="p">().</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;code&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 通过 code, 获取 token
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">tokenAuthUrl</span> <span class="p">=</span> <span class="nf">GetTokenAuthURL</span><span class="p">(</span><span class="nx">code</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">token</span> <span class="o">*</span><span class="nx">Token</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">token</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">GetToken</span><span class="p">(</span><span class="nx">tokenAuthUrl</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 通过token，获取用户信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">userInfo</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">userInfo</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">GetUserInfo</span><span class="p">(</span><span class="nx">token</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;获取用户信息失败，错误信息为:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//  将用户信息返回前端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">userInfoBytes</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">userInfoBytes</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">userInfo</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;在将用户信息(map)转为用户信息([]byte)时发生错误，错误信息为:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">w</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">,</span> <span class="s">&#34;application/json&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">userInfoBytes</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;在将用户信息([]byte)返回前端时发生错误，错误信息为:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 通过code获取token认证url
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">GetTokenAuthURL</span><span class="p">(</span><span class="nx">code</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;https://github.com/login/oauth/access_token?client_id=%s&amp;client_secret=%s&amp;code=%s&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="o">*</span><span class="nx">clientID</span><span class="p">,</span> <span class="o">*</span><span class="nx">clientSecret</span><span class="p">,</span> <span class="nx">code</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 获取 token
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">GetToken</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Token</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 形成请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewRequest</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodGet</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="kc">nil</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;accept&#34;</span><span class="p">,</span> <span class="s">&#34;application/json&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 发送请求并获得响应
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="nx">httpClient</span> <span class="p">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">res</span>        <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Response</span>
</span></span><span class="line"><span class="cl">		<span class="nx">respBody</span>   <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">token</span>      <span class="nx">Token</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">httpClient</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">req</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">respBody</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;token: %s&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">respBody</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 将响应体解析为 token，并返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">err</span> <span class="p">=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">respBody</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">token</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">token</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 获取用户信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">GetUserInfo</span><span class="p">(</span><span class="nx">token</span> <span class="o">*</span><span class="nx">Token</span><span class="p">)</span> <span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 形成请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">userInfoUrl</span> <span class="p">=</span> <span class="s">&#34;https://api.github.com/user&#34;</span> <span class="c1">// github用户信息获取接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewRequest</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodGet</span><span class="p">,</span> <span class="nx">userInfoUrl</span><span class="p">,</span> <span class="kc">nil</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;accept&#34;</span><span class="p">,</span> <span class="s">&#34;application/json&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Authorization&#34;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;token %s&#34;</span><span class="p">,</span> <span class="nx">token</span><span class="p">.</span><span class="nx">AccessToken</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 发送请求并获取响应
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">client</span> <span class="p">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Response</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">req</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 将响应的数据写入 userInfo 中，并返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">userInfo</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">Body</span><span class="p">).</span><span class="nf">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">userInfo</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">userInfo</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Html</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 解析指定文件生成模板对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="nx">temp</span> <span class="o">*</span><span class="nx">template</span><span class="p">.</span><span class="nx">Template</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span>  <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">dir</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getwd</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">temp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">ParseFiles</span><span class="p">(</span><span class="nx">dir</span> <span class="o">+</span> <span class="s">&#34;/oauth.html&#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;读取文件失败，错误信息为:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 利用给定数据渲染模板(html页面)，并将结果写入w，返回给前端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">temp</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">Conf</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ClientId</span><span class="p">:</span>     <span class="o">*</span><span class="nx">clientID</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ClientSecret</span><span class="p">:</span> <span class="o">*</span><span class="nx">clientSecret</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">RedirectUrl</span><span class="p">:</span>  <span class="s">&#34;http://127.0.0.1:9000/oauth/callback&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">});</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;读取渲染html页面失败，错误信息为:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">UserInfo</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">token</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">Query</span><span class="p">().</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;token&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;UserInfo token: %s&#34;</span><span class="p">,</span> <span class="nx">token</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span>      <span class="kt">error</span>
</span></span><span class="line"><span class="cl">		<span class="nx">userInfo</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">userInfo</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">GetUserInfo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Token</span><span class="p">{</span><span class="nx">AccessToken</span><span class="p">:</span> <span class="nx">token</span><span class="p">});</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;获取用户信息失败，错误信息为:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//  将用户信息返回前端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">userInfoBytes</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">userInfoBytes</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">userInfo</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;在将用户信息(map)转为用户信息([]byte)时发生错误，错误信息为:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">w</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">,</span> <span class="s">&#34;application/json&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">userInfoBytes</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;在将用户信息([]byte)返回前端时发生错误，错误信息为:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;clientSecrets: %s,clientID: %s&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">clientSecret</span><span class="p">,</span> <span class="o">*</span><span class="nx">clientID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="o">*</span><span class="nx">clientSecret</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="o">||</span> <span class="o">*</span><span class="nx">clientID</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;clientSecrets or clientID is required&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">Html</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/oauth/callback&#34;</span><span class="p">,</span> <span class="nx">OAuth</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/getUserInfo&#34;</span><span class="p">,</span> <span class="nx">UserInfo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:9000&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;监听失败，错误信息为:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>执行脚本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"> go run main.go -ci<span class="o">=</span><span class="nv">$CLIENT_ID</span> -cs<span class="o">=</span><span class="nv">$CLIENT_SECRET</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>github 返回的token格式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;access_token&#34;</span><span class="p">:</span> <span class="s2">&#34;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&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;token_type&#34;</span><span class="p">:</span> <span class="s2">&#34;bearer&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;scope&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="效果" class="headerLink">
    <a href="#%e6%95%88%e6%9e%9c" class="header-mark"></a>效果</h2><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220322/bfadd1f3ff8e43409b50985f99bc23ea.png?imageView2/0/interlace/1/q/50%7cimageslim" title="前端界面" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220322/bfadd1f3ff8e43409b50985f99bc23ea.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2>前端界面</h2><p>前端界面</p>">
        
    </a><figcaption class="image-caption">前端界面</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220322/9bd65bc08fdc4c899d4b0def1ecdc2da.png?imageView2/0/interlace/1/q/50%7cimageslim" title="授权页面" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220322/9bd65bc08fdc4c899d4b0def1ecdc2da.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2>授权页面</h2><p>授权页面</p>">
        
    </a><figcaption class="image-caption">授权页面</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220322/895795367370407592caa400eba1b3a0.png?imageView2/0/interlace/1/q/50%7cimageslim" title="github返回的用户信息" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220322/895795367370407592caa400eba1b3a0.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2>github返回的用户信息</h2><p>github返回的用户信息</p>">
        
    </a><figcaption class="image-caption">github返回的用户信息</figcaption>
    </figure></p>
<h2 id="源码" class="headerLink">
    <a href="#%e6%ba%90%e7%a0%81" class="header-mark"></a>源码</h2><p><a href="https://github.com/xiaobinqt/go.src/tree/master/dev/github.oauth" target="_blank" rel="noopener noreferrer">源码地址</a></p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://docs.github.com/en/developers/apps/building-oauth-apps/creating-an-oauth-app" target="_blank" rel="noopener noreferrer">Building OAuth Apps</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html" target="_blank" rel="noopener noreferrer">OAuth 2.0 的一个简单解释</a></li>
<li><a href="https://blog.csdn.net/qq_19018277/article/details/104935403" target="_blank" rel="noopener noreferrer">Go语言实现第三方登录Github (通过OAuth2.0)</a></li>
<li><a href="https://docs.github.com/en/rest/guides/basics-of-authentication" target="_blank" rel="noopener noreferrer">basics of authentication</a></li>
<li><a href="https://learnku.com/articles/20031" target="_blank" rel="noopener noreferrer">[简易图解]『 OAuth2.0』 猴子都能懂的图解</a></li>
<li><a href="https://learnku.com/articles/20082" target="_blank" rel="noopener noreferrer">[简易图解]『 OAuth2.0』 『进阶』 授权模式总结</a></li>
</ul>
]]></description>
</item><item>
    <title>http入门笔记</title>
    <link>https://www.xiaobinqt.cn/http-glance/</link>
    <pubDate>Thu, 17 Mar 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/http-glance/</guid>
    <description><![CDATA[<p>该笔记是在学习《透视 HTTP 协议》时整理，还参考了网上的其他资料。鄙人只是网络世界的搬运整理工😂。</p>
<h2 id="总览" class="headerLink">
    <a href="#%e6%80%bb%e8%a7%88" class="header-mark"></a>总览</h2><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/6935d109cbc64fa58c3177a90fd33098.png?imageView2/0/interlace/1/q/50%7cimageslim" title="http总览" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/6935d109cbc64fa58c3177a90fd33098.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2> </h2><p>http总览</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<h2 id="http-协议" class="headerLink">
    <a href="#http-%e5%8d%8f%e8%ae%ae" class="header-mark"></a>http 协议</h2><p>http（超文本传输协议）是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</p>
<p>http 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。</p>
<p>http 不是编程语言，但是可以用编程语言去实现 HTTP，告诉计算机如何用 HTTP 来与外界通信。</p>
<p>在互联网世界里，HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。</p>
<blockquote>
<p>HTTP 传输的不是 TCP/UDP 这些底层协议里被切分的杂乱无章的二进制包（datagram），而是完整的、有意义的数据，可以被浏览器、服务器这样的上层应用程序处理。</p>
</blockquote>
<h3 id="互联网和万维网的区别" class="headerLink">
    <a href="#%e4%ba%92%e8%81%94%e7%bd%91%e5%92%8c%e4%b8%87%e7%bb%b4%e7%bd%91%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-mark"></a>互联网和万维网的区别</h3><p>我们通常所说的“上网”实际上访问的只是互联网的一个子集“万维网”（World Wide Web），它基于 HTTP 协议，传输 HTML 等超文本资源，能力被限制在 HTTP 协议之内。</p>
<p>互联网上还有许多万维网之外的资源，例如常用的电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等，它们需要用各自的专有协议来访问。</p>
<p>不过由于 HTTP 协议非常灵活、易于扩展，而且“超文本”的表述能力很强，所以很多其他原本不属于 HTTP 的资源也可以“包装”成 HTTP 来访问，这就是我们为什么能够总看到各种“网页应用”——例如“微信网页版”“邮箱网页版”——的原因。</p>
<h3 id="tcpip" class="headerLink">
    <a href="#tcpip" class="header-mark"></a>TCP/IP</h3><p>TCP/IP 协议实际上是一系列网络通信协议的统称， 其中最核心的两个协议是TCP（Transmission Control Protocol/传输控制协议）和IP（Internet Protocol），其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。</p>
<blockquote>
<p>HTTP 是超文本传输协议，TCP 是传输控制协议，都是传输，区别是，HTTP 传输的是完整的、有意义的数据，可以被浏览器、
服务器这样的上层应用程序处理，HTTP 不关心寻址、路由、数据完整性等传输细节，而要求这些工作都由下层（基本都由 TCP）来处理。 TCP 传输的是可靠的、字节流和二进制包。</p>
</blockquote>
<p>TCP 是 HTTP 得以实现的基础，HTTP 协议运行在 TCP/IP 上，HTTP 可以更准确地称为 “HTTP over TCP/IP”。</p>
<h3 id="uriurl" class="headerLink">
    <a href="#uriurl" class="header-mark"></a>URI/URL</h3><p>URI（Uniform Resource Identifier），中文名称是 统一资源标识符，使用它就能够唯一地标记互联网上资源。</p>
<p>URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，这两者几乎是相同的，差异不大，除非写论文，否则不用特意区分。</p>
<h3 id="ssltsl" class="headerLink">
    <a href="#ssltsl" class="header-mark"></a>SSL/TSL</h3><p>SSL 的全称是“Secure Socket Layer”，网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“Transport Layer Security”。 所以 TLS 跟 SSL 是一个东西，相当于张君宝的 2.0 版本是张三丰。</p>
<p>SSL 是一个负责加密通信的安全协议，建立在 TCP/IP 之上，在 HTTP 协议之下。</p>
<h3 id="proxy-代理" class="headerLink">
    <a href="#proxy-%e4%bb%a3%e7%90%86" class="header-mark"></a>proxy 代理</h3><ul>
<li>匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；</li>
<li>透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；</li>
<li>正向代理：靠近客户端，代理的对象是客户端，代表客户端向服务器发送请求；</li>
</ul>
<p>正向代理是一个位于客户端和原始服务器（origin server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器，比如 Google），然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/22475408cd734b9c861b345040e356f4.png?imageView2/0/interlace/1/q/50%7cimageslim" title="正向代理" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/22475408cd734b9c861b345040e356f4.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2>正向代理</h2><p>正向代理</p>">
        
    </a><figcaption class="image-caption">正向代理</figcaption>
    </figure></p>
<ul>
<li>反向代理：靠近服务器端，代理代理的对象是服务端，代表服务器响应客户端的请求</li>
</ul>
<p>反向代理指的是代理服务器根据客户端的请求，从其关系的一组或多组后端服务器（如 Web 服务器）上获取资源，然后再将这些资源返回给客户端的过程，客户端只会得知代理服务器的 IP 地址，而不知道在代理服务器后面的服务器集群的存在。</p>
<p>当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/6a2b4d26c0bf43cd9494df793c48a814.png?imageView2/0/interlace/1/q/50%7cimageslim" title="反向代理" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/6a2b4d26c0bf43cd9494df793c48a814.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2>反向代理</h2><p>反向代理</p>">
        
    </a><figcaption class="image-caption">反向代理</figcaption>
    </figure></p>
<h2 id="http-版本" class="headerLink">
    <a href="#http-%e7%89%88%e6%9c%ac" class="header-mark"></a>http 版本</h2><p>万维网关键技术</p>
<ul>
<li>URI：即统一资源标识符，作为互联网上资源的唯一身份；</li>
<li>HTML：即超文本标记语言，描述超文本文档；</li>
<li>HTTP：即超文本传输协议，用来传输超文本。</li>
</ul>
<p>基于这三项关键技术就可以把超文本系统完美地运行在互联网上，让各地的人们能够自由地共享信息，这个系统称为“万维网”（World Wide Web），也就是我们现在所熟知的 Web。</p>
<h3 id="http09" class="headerLink">
    <a href="#http09" class="header-mark"></a>http/0.9</h3><p>结构简单，设置之初设想系统里的文档都是只读的，所以只允许用 GET 动作从服务器上获取 HTML 纯文本格式的文档，并且在响应请求之后立即关闭连接，功能非常有限。</p>
<h3 id="http10" class="headerLink">
    <a href="#http10" class="header-mark"></a>http/1.0</h3><p>HTTP/1.0 并不是一个标准，只是记录已有实践和模式的一份参考文档，不具有实际的约束力，相当于一个备忘录。</p>
<p>在多方面增强了 0.9 版，形式上已经和我们现在的 HTTP 差别不大了，例如：</p>
<ul>
<li>增加了 HEAD、POST 等新方法；</li>
<li>增加了响应状态码，标记可能的错误原因；</li>
<li>引入了协议版本号概念；</li>
<li>引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</li>
<li>传输的数据不再仅限于文本。</li>
</ul>
<h3 id="http11" class="headerLink">
    <a href="#http11" class="header-mark"></a>http/1.1</h3><p>是一个正式的标准，而不是一份可有可无的参考文档，只要用到 HTTP 协议，就必须严格遵守这个标准。</p>
<p>主要变更：</p>
<ul>
<li>增加了 PUT、DELETE 等新的方法；</li>
<li>增加了缓存管理和控制；</li>
<li>明确了连接管理，允许持久连接；</li>
<li>允许响应数据分块（chunked），利于传输大文件；</li>
<li>强制要求 Host 头，让互联网主机托管成为可能。</li>
</ul>
<h3 id="http2" class="headerLink">
    <a href="#http2" class="header-mark"></a>http/2</h3><p>由 google 主导，基于 google 的 SPDY 协议为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2。</p>
<p>主要特点：</p>
<ul>
<li>二进制协议，不再是纯文本；</li>
<li>可发起多个请求，废弃了 1.1 里的管道；</li>
<li>使用专用算法压缩头部，减少数据传输量；</li>
<li>允许服务器主动向客户端推送数据；</li>
<li>增强了安全性，“事实上”要求加密通信。</li>
</ul>
<h3 id="http3" class="headerLink">
    <a href="#http3" class="header-mark"></a>http/3</h3><p>由 google 主导，基于 google 的 QUIC 协议为基础开始制定新版本的 HTTP 协议。</p>
<h2 id="网络分层模型" class="headerLink">
    <a href="#%e7%bd%91%e7%bb%9c%e5%88%86%e5%b1%82%e6%a8%a1%e5%9e%8b" class="header-mark"></a>网络分层模型</h2><h3 id="tcpip-1" class="headerLink">
    <a href="#tcpip-1" class="header-mark"></a>TCP/IP</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/87869e9a3d0d4eaba7c9d6fe0798674f.png?imageView2/0/interlace/1/q/50%7cimageslim" title="tcp/ip分层模型" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/87869e9a3d0d4eaba7c9d6fe0798674f.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2>TCP/IP分层模型</h2><p>tcp/ip分层模型</p>">
        
    </a><figcaption class="image-caption">TCP/IP分层模型</figcaption>
    </figure></p>
<p>这里的层次顺序是“从下往上”数的，所以第一层就是最下面的一层。</p>
<h4 id="链接层" class="headerLink">
    <a href="#%e9%93%be%e6%8e%a5%e5%b1%82" class="header-mark"></a>链接层</h4><p>第一层叫“链接层”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。</p>
<h4 id="网络互联层" class="headerLink">
    <a href="#%e7%bd%91%e7%bb%9c%e4%ba%92%e8%81%94%e5%b1%82" class="header-mark"></a>网络互联层</h4><p>第二层叫“网际层”或者“网络互连层”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。</p>
<h4 id="传输层" class="headerLink">
    <a href="#%e4%bc%a0%e8%be%93%e5%b1%82" class="header-mark"></a>传输层</h4><p>第三层叫“传输层”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。</p>
<p>TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。</p>
<h4 id="应用层" class="headerLink">
    <a href="#%e5%ba%94%e7%94%a8%e5%b1%82" class="header-mark"></a>应用层</h4><p>协议栈的第四层叫“应用层”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP，HTTP 等等。</p>
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>Tip<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">MAC 层（链接层）的传输单位是帧（frame），IP 层（网络互联层）的传输单位是包（packet），TCP 层传输层的传输单位是段（segment）， HTTP （应用层）的传输单位则是消息或报文（message）。这些名词并没有什么本质的区分，可以统称为数据包。</div>
        </div>
    </div>
<h3 id="osi-网络分层模型" class="headerLink">
    <a href="#osi-%e7%bd%91%e7%bb%9c%e5%88%86%e5%b1%82%e6%a8%a1%e5%9e%8b" class="header-mark"></a>OSI 网络分层模型</h3><p>OSI 分层模型在发布的时候就明确地表明是一个“参考”，不是强制标准。这是因为 TCP/IP 等协议已经在许多网络上实际运行，不可能推翻重来。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/4ddd78194c284518a2ce2db4cfab2a3c.png?imageView2/0/interlace/1/q/50%7cimageslim" title="OSI模型" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/4ddd78194c284518a2ce2db4cfab2a3c.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2>OSI网络模型</h2><p>OSI模型</p>">
        
    </a><figcaption class="image-caption">OSI网络模型</figcaption>
    </figure></p>
<ul>
<li>第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；</li>
<li>第二层：数据链路层，它基本相当于 TCP/IP 的链接层；</li>
<li>第三层：网络层，相当于 TCP/IP 里的网际层；</li>
<li>第四层：传输层，相当于 TCP/IP 里的传输层；</li>
<li>第五层：会话层，维护网络中的连接状态，即保持会话和同步；</li>
<li>第六层：表示层，把数据转换为合适、可理解的语法和语义；</li>
<li>第七层：应用层，面向具体的应用传输数据。</li>
</ul>
<p>对比一下就可以发现，TCP/IP 是一个纯软件的栈，没有网络应有的最根基的电缆、网卡等物理设备的位置。而 OSI 则补足了这个缺失， 在理论层面上描述网络更加完整。</p>
<p>OSI 还为每一层标记了明确了编号，最底层是一层，最上层是七层，而 TCP/IP 的层次从来只有名字而没有编号。</p>
<h3 id="两个分层模型的对应关系" class="headerLink">
    <a href="#%e4%b8%a4%e4%b8%aa%e5%88%86%e5%b1%82%e6%a8%a1%e5%9e%8b%e7%9a%84%e5%af%b9%e5%ba%94%e5%85%b3%e7%b3%bb" class="header-mark"></a>两个分层模型的对应关系</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/539751215a0b45ada0a373f8289ca232.png?imageView2/0/interlace/1/q/50%7cimageslim" title="对应关系" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/539751215a0b45ada0a373f8289ca232.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2>两个分层模型的对应关系</h2><p>对应关系</p>">
        
    </a><figcaption class="image-caption">两个分层模型的对应关系</figcaption>
    </figure></p>
<p>所谓的“四层负载均衡”就是指工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡。</p>
<p>所谓的“七层负载均衡”就是指工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器。</p>
<p>有一个辨别四层和七层比较好的（但不是绝对的）小窍门，“两个凡是”：<strong>凡是由操作系统负责处理的就是四层或四层以下</strong>，否则，<strong>凡是需要由应用程序（也就是你自己写代码）负责处理的就是七层</strong>。</p>
<h2 id="http协议核心" class="headerLink">
    <a href="#http%e5%8d%8f%e8%ae%ae%e6%a0%b8%e5%bf%83" class="header-mark"></a>http协议核心</h2><p>由于 HTTP 是在 TCP/IP 协议之上的，而 TCP/IP 协议负责底层的具体传输工作，所以 http 在传输方面不用太操心，TCP/IP 会去解决，所以 HTTP 关心的就只有他所传输的报文内容，又因为 HTTP 是“纯文本”的，包括头信息都是 ASCII 码的文本，不用借助程序解析可以直接阅读。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220321/619a6b063a5e4ced936d156d155f3fed.png?imageView2/0/interlace/1/q/50%7cimageslim" title="http报文" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220321/619a6b063a5e4ced936d156d155f3fed.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2> </h2><p>http报文</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<h3 id="常用头字段" class="headerLink">
    <a href="#%e5%b8%b8%e7%94%a8%e5%a4%b4%e5%ad%97%e6%ae%b5" class="header-mark"></a>常用头字段</h3><h4 id="注意事项" class="headerLink">
    <a href="#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9" class="header-mark"></a>注意事项</h4><ul>
<li>字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</li>
<li>字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；</li>
<li>字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；</li>
</ul>
<h4 id="分类" class="headerLink">
    <a href="#%e5%88%86%e7%b1%bb" class="header-mark"></a>分类</h4><ul>
<li>通用字段：在请求头和响应头里都可以出现；</li>
<li>请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；</li>
<li>响应字段：仅能出现在响应头里，补充说明响应报文的信息；</li>
<li>实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。</li>
</ul>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Host</code></td>
<td>请求字段</td>
<td>唯一一个 HTTP/1.1 规范里要求<strong>必须出现</strong>的字段，如果请求头里没有 Host，那这就是一个错误的报文。Host 字段告诉服务器这个请求应该由哪个主机来处理</td>
</tr>
<tr>
<td><code>User-Agent</code></td>
<td>请求字段</td>
<td>描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面</td>
</tr>
<tr>
<td><code>Date</code></td>
<td>通用字段</td>
<td>表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略</td>
</tr>
<tr>
<td><code>Server</code></td>
<td>响应字段</td>
<td>告诉客户端当前正在提供 Web 服务的软件名称和版本号</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>实体字段</td>
<td>报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输</td>
</tr>
</tbody>
</table>
<h3 id="请求方式" class="headerLink">
    <a href="#%e8%af%b7%e6%b1%82%e6%96%b9%e5%bc%8f" class="header-mark"></a>请求方式</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220321/c113e062fccf4d18959dc52d90e59c1b.png?imageView2/0/interlace/1/q/50%7cimageslim" title="请求方式" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220321/c113e062fccf4d18959dc52d90e59c1b.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2> </h2><p>请求方式</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>获取资源，可以理解为读取或者下载数据</td>
</tr>
<tr>
<td>HEAD</td>
<td>获取资源的元信息，不会返回请求的实体数据，只会传回响应头</td>
</tr>
<tr>
<td>POST</td>
<td>向资源提交数据，相当于写入或上传数据</td>
</tr>
<tr>
<td>PUT</td>
<td>类似 POST</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除资源</td>
</tr>
<tr>
<td>CONNECT</td>
<td>建立特殊的连接隧道</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>列出可对资源实行的方法</td>
</tr>
<tr>
<td>TRACE</td>
<td>追踪请求 - 响应的传输路径</td>
</tr>
</tbody>
</table>
<h3 id="状态码" class="headerLink">
    <a href="#%e7%8a%b6%e6%80%81%e7%a0%81" class="header-mark"></a>状态码</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>1×x</code></td>
<td>提示信息，表示目前是协议处理的中间状态，还需要后续的操作</td>
</tr>
<tr>
<td><code>2××</code></td>
<td>成功，报文已经收到并被正确处理</td>
</tr>
<tr>
<td><code>3××</code></td>
<td>重定向，资源位置发生变动，需要客户端重新发送请求</td>
</tr>
<tr>
<td><code>4××</code></td>
<td>客户端错误，请求报文有误，服务器无法处理</td>
</tr>
<tr>
<td><code>5××</code></td>
<td>服务器错误，服务器在处理请求时内部发生了错误</td>
</tr>
</tbody>
</table>
<p>一些常用状态码说明</p>
<table>
<thead>
<tr>
<th>status code</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>301</td>
<td>永久重定向，含义是此次请求的资源已经不存在了，需要改用改用新的 URI 再次访问</td>
</tr>
<tr>
<td>302</td>
<td>临时重定向，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是“永久”的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS。 再比如，今天夜里网站后台要系统维护，服务暂时不可用，这就属于“临时”的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）</td>
</tr>
<tr>
<td>405</td>
<td>不允许使用某些方法操作资源，例如不允许 POST 只能 GET</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable 资源无法满足客户端请求的条件，例如请求中文但只有英文</td>
</tr>
<tr>
<td>408</td>
<td>Request Timeout：请求超时，服务器等待了过长的时间</td>
</tr>
<tr>
<td>409</td>
<td>Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large：请求报文里的 body 太大</td>
</tr>
<tr>
<td>414</td>
<td>Request-URI Too Long：请求行里的 URI 太大</td>
</tr>
<tr>
<td>429</td>
<td>Too Many Requests 客户端发送了太多的请求，通常是由于服务器的限连策略</td>
</tr>
<tr>
<td>431</td>
<td>Request Header Fields Too Large 请求头某个字段或总体太大</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error 与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented 表示客户端请求的功能还不支持，这个错误码比 500 要温和一些，和“即将开业，敬请期待”的意思差不多，不过具体什么时候“开业”就不好说了</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable 表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503</td>
</tr>
</tbody>
</table>
<h3 id="http-特点" class="headerLink">
    <a href="#http-%e7%89%b9%e7%82%b9" class="header-mark"></a>http 特点</h3><ul>
<li>HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能。</li>
<li>HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达。</li>
<li>HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据。</li>
<li>HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求。</li>
<li>HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。</li>
</ul>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://baijiahao.baidu.com/s?id=1738680012806649947" target="_blank" rel="noopener noreferrer">什么是反向代理，反向代理是如何工作的？</a></li>
<li><a href="https://blog.csdn.net/weixin_45775963/article/details/104440190" target="_blank" rel="noopener noreferrer">什么是正向代理和反向代理</a></li>
<li><a href="https://www.jianshu.com/p/23b6775fbb91" target="_blank" rel="noopener noreferrer">如何理解反向代理服务器</a></li>
</ul>]]></description>
</item><item>
    <title>Go GMP 调度模型</title>
    <link>https://www.xiaobinqt.cn/gmp-model/</link>
    <pubDate>Wed, 16 Mar 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/gmp-model/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221118/555f4905eb1c4615b9702ead116731d1.png" referrerpolicy="no-referrer">
            </div><h2 id="进程线程协程的区别" class="headerLink">
    <a href="#%e8%bf%9b%e7%a8%8b%e7%ba%bf%e7%a8%8b%e5%8d%8f%e7%a8%8b%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-mark"></a>进程、线程、协程的区别</h2><p><strong>进程</strong>：进程是操作系统为应用程序分配资源的最小单元。每个进程有独立的内存空间和状态。</p>
<p><strong>线程</strong>：线程是进程中的一个独立执行单元。在 Go 中，一个进程可以启动多个线程，以并行执行任务。</p>
<p><strong>协程</strong>：协程是 Go 语言中的一种轻量级的并发技术。它是<strong>用户态的，不需要操作系统的支持</strong>，可以在单个线程中启动多个协程，并行执行任务。协程共享同一个线程的资源，但拥有自己的栈和寄存器。</p>
<p>总的来说，进程和线程是操作系统级别的并发技术，用于在多核处理器上利用资源；而协程是 Go 语言提供的一种高效、轻量级的并发技术，用于实现程序内部的并发任务。</p>
<h3 id="进程" class="headerLink">
    <a href="#%e8%bf%9b%e7%a8%8b" class="header-mark"></a>进程</h3><p>进程是操作系统对一个正在运行的程序的一种抽象，<strong>进程是资源分配的最小单位</strong>，每一个进程都有一个自己的地址空间。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/c0032558db4249a0a8ce4d6473327d38.png" title="进程在操作系统中的抽象表现" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/c0032558db4249a0a8ce4d6473327d38.png" data-sub-html="<h2>进程在操作系统中的抽象表现</h2><p>进程在操作系统中的抽象表现</p>">
        
    </a><figcaption class="image-caption">进程在操作系统中的抽象表现</figcaption>
    </figure></p>
<p>通俗的说，<strong>进程就是一个正在执行的程序</strong>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221118/19ae7497830b4301831fe13d24a30f5f.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="Windows任务管理器" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221118/19ae7497830b4301831fe13d24a30f5f.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>Windows任务管理器</h2><p>Windows任务管理器</p>">
        
    </a><figcaption class="image-caption">Windows任务管理器</figcaption>
    </figure></p>
<p>进程存在的意义是为了<strong>合理压榨 CPU 的性能和分配运行的时间片，让 CPU 不能 “闲着“</strong>。</p>
<p>在计算机中，其计算核心是 CPU，负责所有计算相关的工作和资源。单个 CPU 一次只能运行一个任务。如果一个进程跑着，就把唯一一个 CPU 给完全占住，那是非常不合理的。</p>
<p>如果总是在运行一个进程上的任务，就会出现一个现象，就是任务不一定总是在执行 “计算型” 的任务，会有很大可能是在执行网络调用阻塞了，那么 CPU 岂不就浪费了？</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/a406c795e40e4b7395a0228b299dd6bd.png" title="进程上下文切换" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/a406c795e40e4b7395a0228b299dd6bd.png" data-sub-html="<h2>进程上下文切换</h2><p>进程上下文切换</p>">
        
    </a><figcaption class="image-caption">进程上下文切换</figcaption>
    </figure></p>
<p>所以出现了多进程，多个 CPU，多个进程。多进程就是指计算机系统可以同时执行多个进程，从一个进程到另外一个进程的转换是由操作系统内核管理的，一般是同时运行多个软件。</p>
<h3 id="线程" class="headerLink">
    <a href="#%e7%ba%bf%e7%a8%8b" class="header-mark"></a>线程</h3><p>有了多进程，在操作系统上可以同时运行多个进程。那么为什么有了进程，还要线程呢？这是因为：</p>
<ul>
<li>进程间的信息难以共享数据，父子进程并未共享内存，需要通过进程间通信（IPC），在进程间进行信息交换，性能开销较大。</li>
<li>创建进程（一般是调用 <code>fork</code> 方法）的性能开销较大。</li>
</ul>
<p>所以大家又把目光转向了进程内，能不能在进程里做点什么呢？</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/9462880ac1eb4cdeb5288716a15bac4d.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/9462880ac1eb4cdeb5288716a15bac4d.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/9462880ac1eb4cdeb5288716a15bac4d.png" data-sub-html="<h2>进程由多个线程组成</h2>">
        
    </a><figcaption class="image-caption">进程由多个线程组成</figcaption>
    </figure>
<p>一个进程可以由多个称为线程的执行单元组成。每个线程都运行在进程的上下文中，共享着同样的代码和全局数据。</p>
<p>多个进程，就可以有更多的线程。<strong>多线程比多进程之间更容易共享数据，在上下文切换中线程一般比进程更高效</strong>。这是因为，</p>
<ul>
<li>线程之间能够非常方便、快速地共享数据。 只需将数据复制到进程中的共享区域就可以了，但需要注意避免多个线程修改同一份内存。</li>
<li>创建线程比创建进程要快 10 倍甚至更多。 线程都是同一个进程下自家的孩子，像是内存页、页表等就不需要了。</li>
</ul>
<h3 id="协程" class="headerLink">
    <a href="#%e5%8d%8f%e7%a8%8b" class="header-mark"></a>协程</h3><p>协程（Co-routine）是用户态的线程。通常创建协程时，会从进程的堆中分配一段内存作为协程的栈。</p>
<p>线程的栈有 8MB，而协程栈的大小通常只有 KB 级别，而 Go 语言的协程更夸张，只有 2-4KB，非常的轻巧。</p>
<p>协程有以下优势👋：</p>
<ul>
<li>
<p>👉节省 CPU：避免系统内核级的线程频繁切换，造成的 CPU 资源浪费。而协程是用户态的线程，用户可以自行控制协程的创建于销毁，极大程度避免了系统级线程上下文切换造成的资源浪费。</p>
</li>
<li>
<p>👉节约内存：在 64 位的 Linux 中，一个线程需要分配 8MB 栈内存和 64MB 堆内存，系统内存的制约导致我们无法开启更多线程实现高并发。而在协程编程模式下，可以轻松有十几万协程，这是线程无法比拟的。</p>
</li>
<li>
<p>👉稳定性：线程之间通过内存来共享数据，这也导致了一个问题，任何一个线程出错时，进程中的所有线程都会跟着一起崩溃。</p>
</li>
<li>
<p>👉开发效率：使用协程在开发程序之中，可以很方便的将一些耗时的 IO 操作异步化，例如写文件、耗时 IO 请求等。</p>
</li>
</ul>
<h2 id="goroutine-是什么" class="headerLink">
    <a href="#goroutine-%e6%98%af%e4%bb%80%e4%b9%88" class="header-mark"></a>goroutine 是什么</h2><p>Goroutine 是一个由 Go 运行时管理的轻量级线程，我们称为 “协程”。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go f(x, y, z)
</span></span></code></pre></td></tr></table>
</div>
</div><p>操作系统本身是无法明确感知到 Goroutine 的存在的，Goroutine 的操作和切换归属于 “用户态” 中。</p>
<p>Goroutine 由特定的调度模式来控制，以 “多路复用” 的形式运行在操作系统为 Go 程序分配的几个系统线程上。</p>
<p>同时创建 Goroutine 的开销很小，初始只需要 2-4k 的栈空间。Goroutine 本身会根据实际使用情况进行自伸缩，非常轻量。</p>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>Tips<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>Go 程序中没有语言级的关键字让你去创建一个内核线程，你只能创建 goroutine，内核线程只能由 runtime 根据实际情况去创建。</p>
<p>Go 运行时系统并没有内核调度器的中断能力，内核调度器会发起抢占式调度将长期运行的线程中断并让出 CPU 资源，让其他线程获得执行机会。</p>
</div>
        </div>
    </div>
<h2 id="调度器的由来" class="headerLink">
    <a href="#%e8%b0%83%e5%ba%a6%e5%99%a8%e7%9a%84%e7%94%b1%e6%9d%a5" class="header-mark"></a>调度器的由来</h2><p>在多进程/多线程的操作系统中，解决了早期的单进程操作系统进程阻塞的问题，因为一个进程阻塞 CPU 可以立刻切换到其他进程中去执行，而且调度 CPU 的算法可以保证在运行的进程都可以被分配到 CPU 的运行时间片，这样从宏观来看，似乎多个进程是在同时被运行。</p>
<p>但新的问题就出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间。CPU 虽然利用起来了，但如果进程过多，CPU 有很大的一部分都被用来进行进程调度。为了能提高 CPU 的利用率，这里就需要用到调度。</p>
<p>CPU 调度切换的是进程和线程，CPU 对进程和线程的态度是一样的，虽然线程看起来很好，但实际上多线程开发设计会变得很复杂，要考虑很多同步竞争的问题，比如锁、竞争冲突等。</p>
<p>一个线程其实分为 “内核态“ 线程和 “用户态” 线程。一个 “用户态线程” 必须要绑定一个 “内核态线程”，但是 CPU 并不知道有 “用户态线程” 的存在，CPU 只知道它运行的是一个 “内核态线程”。这里我们可以把内核线程依然叫<strong>线程</strong>，用户线程叫<strong>协程</strong>。既然一个协程可以绑定一个线程，那么能不能多个协程绑定在一个或者多个线程上呢！</p>
<h2 id="协程和线程的映射" class="headerLink">
    <a href="#%e5%8d%8f%e7%a8%8b%e5%92%8c%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%98%a0%e5%b0%84" class="header-mark"></a>协程和线程的映射</h2><h3 id="n1-关系" class="headerLink">
    <a href="#n1-%e5%85%b3%e7%b3%bb" class="header-mark"></a>N:1 关系</h3><p>N 个协程绑定 1 个线程。</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/32ca2352460442e1b75aed52373558a0.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/32ca2352460442e1b75aed52373558a0.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/32ca2352460442e1b75aed52373558a0.png" data-sub-html="<h2>N:1</h2>">
        
    </a><figcaption class="image-caption">N:1</figcaption>
    </figure>
<p><strong>优点</strong>：</p>
<p>协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。但也有很大的缺点，1 个进程的所有协程都绑定在 1 个线程上。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>某个程序用不了硬件的多核加速能力</li>
<li>一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</li>
</ul>
<h3 id="11-关系" class="headerLink">
    <a href="#11-%e5%85%b3%e7%b3%bb" class="header-mark"></a>1:1 关系</h3><p>1 个协程绑定 1 个线程，协程的调度都由 CPU 完成了，不存在<code>N:1</code>的缺点，但是协程的创建、删除和切换的代价都由 CPU 完成，略显昂贵。</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/48726c7c54854150a7088dba1bc78860.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/48726c7c54854150a7088dba1bc78860.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/48726c7c54854150a7088dba1bc78860.png" data-sub-html="<h2>1:1</h2>">
        
    </a><figcaption class="image-caption">1:1</figcaption>
    </figure>
<h3 id="mn-关系" class="headerLink">
    <a href="#mn-%e5%85%b3%e7%b3%bb" class="header-mark"></a>M:N 关系</h3><p>M 个协程绑定 N 个线程，是<code>N:1</code>和<code>1:1</code>类型的结合，克服了以上 2 种模型的缺点，但实现复杂。</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/042a666564f44407a0efe47b5ffeaa7d.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/042a666564f44407a0efe47b5ffeaa7d.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/042a666564f44407a0efe47b5ffeaa7d.png" data-sub-html="<h2>M:N</h2>">
        
    </a><figcaption class="image-caption">M:N</figcaption>
    </figure>
<h2 id="go-的调度" class="headerLink">
    <a href="#go-%e7%9a%84%e8%b0%83%e5%ba%a6" class="header-mark"></a>Go 的调度</h2><p><strong>用户态的 Goroutine，操作系统看不到它</strong>
，必然需要有某个东西去管理他，才能更好的运作起来。这就是 Go 语言中的调度，也就是 GMP 模型。</p>
<p>Go scheduler<code> /ˈskedʒuːlər/</code> 的主要功能是针对在处理器上运行的 OS 线程分发可运行的 Goroutine，而我们一提到调度器，就离不开三个经常被提到的缩写，他们分别是：</p>
<ul>
<li>
<p>G：Goroutine，实际上我们每次调用<code>go func</code>就是生成了一个 G。</p>
</li>
<li>
<p>P：Processor，处理器，一般 P 的数量就是处理器的核数，可以通过<code>runtime.GOMAXPROCS(n)</code>进行修改。P 包含了运行 goroutine 的资源，如果线程 M 想运行 goroutine，必须先获取 P ，一个 M 在与一个 P 关联之后形成了一个有效的 G 运行环境「内核线程 + 上下文环境」。P 中还包含了可运行的本地 G 队列，本地 G 队列不超过 256 个 G，优先会将新创建的 G 放到某个 P 的本地队列中，如果本地队列满了会放到全局队列中。</p>
</li>
<li>
<p>M：Machine，系统/内核线程，是运行 goroutine 的实体，每个 M 都代表了 1 个内核线程。<strong>M 可以运行 2 种代码，当 M 运行 go 代码一定需要一个P，当 M 运行原生代码, 例如阻塞的<code>syscall</code>, 此时 M 不需要 P</strong>。</p>
</li>
</ul>
<p>M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，<strong>即使 P 的默认数量是 1，也有可能会创建很多个 M 出来</strong>。</p>
<p>这三者交互实际来源于 Go 的<code>M:N</code>调度模型，也就是 <strong>M 必须与 P 进行绑定</strong>，然后不断地在 M 上循环寻找可运行的 G 来执行相应的任务。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221119/849f150e61d6472ea2099f1097c581fa.png" title="GMP调度" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221119/849f150e61d6472ea2099f1097c581fa.png" data-sub-html="<h2>GMP调度</h2><p>GMP调度</p>">
        
    </a><figcaption class="image-caption">GMP调度</figcaption>
    </figure></p>
<h3 id="p和m何时被创建" class="headerLink">
    <a href="#p%e5%92%8cm%e4%bd%95%e6%97%b6%e8%a2%ab%e5%88%9b%e5%bb%ba" class="header-mark"></a>P和M何时被创建</h3><p><strong>P 何时创建</strong>：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。</p>
<p><strong>M 何时创建</strong>
：没有足够的 M 来关联 P 并运行其中的可运行的 G。比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，runtime 运行时就会去创建新的 M。当 M 有空闲就会被回收或是睡眠。</p>
<h2 id="调度流程" class="headerLink">
    <a href="#%e8%b0%83%e5%ba%a6%e6%b5%81%e7%a8%8b" class="header-mark"></a>调度流程</h2><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221119/945c94520e1b40c5adb516f58a0c2f30.png" title="调度流程" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221119/945c94520e1b40c5adb516f58a0c2f30.png" data-sub-html="<h2>调度流程</h2><p>调度流程</p>">
        
    </a><figcaption class="image-caption">调度流程</figcaption>
    </figure></p>
<ol>
<li>
<p>当我们执行 <code>go func()</code> 时，实际上就是创建一个全新的 Goroutine，我们称它为 G。</p>
</li>
<li>
<p>新创建的 G 会被放入 P 的本地队列（Local Queue）或全局队列（Global Queue）中，准备下一步的动作。需要注意的一点，这里的 P 指的是创建 G 的 P，如果 P 的本地队列已经满了就会保存在全局的队列中。</p>
</li>
<li>
<p>唤醒或创建 M 以便执行 G。G 只能运行在 M 中，一个 M 必须持有一个 P，M 与 P 是<code>1:1</code>的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会想其他的<code>MP</code>组合偷取一个可执行的 G 来执行。</p>
</li>
<li>
<p>一个 M 调度 G 执行的过程是一个循环机制。</p>
</li>
<li>
<p>当 M 执行某一个 G 的时候如果发生了<code>syscall</code>或者其余的阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除（detach），然后再创建一个新的操作系统的线程（如果有空闲的线程可用就复用空闲线程）来服务于这个 P。</p>
</li>
<li>
<p>当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态，加入到空闲线程中，然后这个 G 会被放入全局队列中。</p>
</li>
</ol>
<p>在描述中有提到全局和本地这两类队列，其实在功能上来讲都是用于存放正在等待运行的 G，但是不同点在于，<strong>本地队列有数量限制，不允许超过 256 个</strong>。</p>
<p>并且在新建 G 时，会优先选择 P 的本地队列，如果本地队列满了，则将 P 的本地队列的一半的 G 移动到全局队列。 可以理解为调度资源的共享和再平衡。</p>
<h2 id="m0和g0" class="headerLink">
    <a href="#m0%e5%92%8cg0" class="header-mark"></a>M0和G0</h2><p><code>M0</code>是启动程序后编号为 0 的主线程，这个 M 对应的实例会在全局变量<code>runtime.m0</code>中，<code>M0</code>负责执行初始化操作和启动第一个 G， 在之后<code>M0</code>就和其他的 M 一样。</p>
<p><code>G0</code>是每次启动一个 M 都会第一个创建的 gourtine，<code>G0</code>仅用于负责调度 G，<code>G0</code>不指向任何可执行的函数, 每个 M 都会有一个自己的<code>G0</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello world&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>☝️上面代码会经历如下过程：</p>
<ol>
<li>runtime 创建最初的线程 m0 和 goroutine g0，并把 2 者关联。</li>
<li>调度器初始化：初始化 m0、栈、垃圾回收，以及创建和初始化由<code>GOMAXPROCS</code>个 P 构成的 P 列表。</li>
<li>示例代码中的 main 函数是<code>main.main</code>，runtime 中也有 1 个 main 函数<code>runtime.main</code>，代码经过编译后，<code>runtime.main</code>会调用<code>main.main</code>，程序启动时会为<code>runtime.main</code>创建 goroutine，可以称它为 main goroutine，然后把 main goroutine 加入到 P 的本地队列。</li>
<li>启动 m0，m0 已经绑定了 P，会从 P 的本地队列获取 G，获取到 main goroutine。</li>
<li>M 根据 G 中的栈信息和调度信息设置运行环境，M 运行 G。</li>
<li>G 退出，再次回到 M 获取可运行的 G，这样重复下去，直到<code>main.main</code>退出，<code>runtime.main</code>执行 Defer 和 Panic 处理，或调用<code>runtime.exit</code>退出程序。</li>
</ol>
<p>调度器的生命周期几乎占满了一个 Go 程序的一生，<code>runtime.main</code>的 goroutine 执行之前都是为调度器做准备工作，<code>runtime.main</code>的 goroutine 运行，才是调度器的真正开始，直到<code>runtime.main</code>结束而结束。</p>
<h2 id="窃取行为" class="headerLink">
    <a href="#%e7%aa%83%e5%8f%96%e8%a1%8c%e4%b8%ba" class="header-mark"></a>窃取行为</h2><p>当创建新的 G 或者 G 变成可运行状态时，它会被推送加入到当前 P 的本地队列中。当 P 执行 G 完毕后，P 会将 G 从本地队列中弹出，同时会检查当前本地队列是否为空，如果为空不会立刻销毁线程，而是会随机的从其他 P 的本地队列中尝试
<strong>窃取一半</strong>可运行的 G 到自己的名下。</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/a378474165e94b908f8fc7b44812cc4c.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/a378474165e94b908f8fc7b44812cc4c.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/a378474165e94b908f8fc7b44812cc4c.png" data-sub-html="<h2>窃取行为</h2>">
        
    </a><figcaption class="image-caption">窃取行为</figcaption>
    </figure>
<p>上图中👆，P2 在本地队列中找不到可以运行的 G，它会执行 <code>work-stealing</code> 调度算法，随机选择其它的处理器 P1，并从 P1 的本地队列中窃取了三个 G 到它自己的本地队列中去。至此，P1、P2 都拥有了可运行的 G，P1 多余的 G 也不会被浪费，调度资源将会更加平均的在多个处理器中流转。</p>
<h2 id="限制条件" class="headerLink">
    <a href="#%e9%99%90%e5%88%b6%e6%9d%a1%e4%bb%b6" class="header-mark"></a>限制条件</h2><h3 id="m-的限制" class="headerLink">
    <a href="#m-%e7%9a%84%e9%99%90%e5%88%b6" class="header-mark"></a>M 的限制</h3><p>在协程的执行中，真正干活的是 GPM 中的 M（系统线程） ，因为 G 是用户态上的东西，最终执行都是得映射，对应到 M 这一个系统线程上去运行。</p>
<p>那么 M 有没有限制呢？</p>
<p>答案是：有的。在 Go 语言中，<strong>M 的默认数量限制是 10000</strong>，如果超出则会报错：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">GO: runtime: program exceeds 10000-thread limit
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是通常只有在 Goroutine 出现阻塞操作的情况下，才会遇到这种情况。这可能也预示着你的程序有问题。</p>
<p>若确切是需要那么多，还可以通过 <code>debug.SetMaxThreads</code> 方法进行设置。</p>
<h3 id="g-的限制" class="headerLink">
    <a href="#g-%e7%9a%84%e9%99%90%e5%88%b6" class="header-mark"></a>G 的限制</h3><p>Goroutine 的创建数量是否有限制？</p>
<p>答案是：没有。但理论上会受内存的影响，假设一个 Goroutine 创建需要 4k 的<strong>连续的内存块</strong>：</p>
<p>4k * 80,000 = 320,000k ≈ 0.3G内存</p>
<p>4k * 1,000,000 = 4,000,000k ≈ 4G内存</p>
<p>以此就可以相对计算出来一台单机在通俗情况下，所能够创建 Goroutine 的大概数量级别。</p>
<h3 id="p-的限制" class="headerLink">
    <a href="#p-%e7%9a%84%e9%99%90%e5%88%b6" class="header-mark"></a>P 的限制</h3><p>P 的数量是否有限制，受什么影响？</p>
<p>答案是：有限制。<strong>P 的数量受环境变量 <code>GOMAXPROCS</code> 的直接影响</strong>。</p>
<p>环境变量 <code>GOMAXPROCS</code> 又是什么？在 Go 语言中，通过设置 <code>GOMAXPROCS</code>，用户可以调整调度中 P（Processor）的数量。</p>
<p>另一个重点在于，与 P 相关联的的 M（系统线程），是需要绑定 P 才能进行具体的任务执行的，因此<strong>P 的多少会影响到 Go 程序的运行表现</strong>。</p>
<p>P 的数量基本是受本机的核数影响，没必要太过度纠结他。</p>
<p>那 P 的数量是否会影响 Goroutine 的数量创建呢？</p>
<p>答案是：不影响。且 Goroutine 多了少了，P 也该干嘛干嘛，不会带来灾难性问题。</p>
<h3 id="小结" class="headerLink">
    <a href="#%e5%b0%8f%e7%bb%93" class="header-mark"></a>小结</h3><ul>
<li>M：有限制，默认数量限制是 10000，可调整。</li>
<li>G：没限制，但受内存影响。</li>
<li>P：受本机的核数影响，可大可小，不影响 G 的数量创建。</li>
</ul>
<p>所以<strong>Goroutine 数量怎么预算，才叫合理？</strong></p>
<p>在真实的应用场景中，如果你 Goroutine：</p>
<ul>
<li>在频繁请求 HTTP，MySQL，打开文件等，那假设短时间内有几十万个协程在跑，那肯定就不大合理了（可能会导致 too many files open）。</li>
<li>常见的 Goroutine 泄露所导致的 CPU、Memory 上涨等，还是得看你的 Goroutine 里具体在跑什么东西。</li>
</ul>
<p>跑的如果是 “资源怪兽”，只运行几个 Goroutine 都可以跑死。</p>
<h2 id="为什么要有-p" class="headerLink">
    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%9c%89-p" class="header-mark"></a>为什么要有 P</h2><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/bdcbfb4a788d477b991c0179a7180c3c.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/bdcbfb4a788d477b991c0179a7180c3c.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/bdcbfb4a788d477b991c0179a7180c3c.png" data-sub-html="<h2>早期调度器</h2>">
        
    </a><figcaption class="image-caption">早期调度器</figcaption>
    </figure>
<p>Go 早期的调度器是没有 P 的，只有 M 和 G。M 想要执行和放回 G 都必须访问全局 G 队列，并且 M 有多个，多线程访问同一资源需要加锁进行保证互斥/同步，所以全局 G 队列是有互斥锁进行保护的。</p>
<p>所以早期的调度器存在这样几个缺点：</p>
<ul>
<li>创建、销毁、调度 G 都需要每个 M 获取锁，这就形成了激烈的<strong>锁竞争</strong>。</li>
<li>M 转移 G 会造成延迟和额外的系统负载。比如当 G 中包含创建新协程的时候，M 创建了<code>G'</code>，为了继续执行 G，需要把<code>G'</code>交给<code>M'</code>执行，也造成了很差的局部性，因为<code>G'</code>和 G 是相关的，最好放在 M 上执行，而不是其他<code>M'</code>。</li>
<li>系统调用（CPU 在 M 之间的切换）导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li>
</ul>
<h2 id="faq" class="headerLink">
    <a href="#faq" class="header-mark"></a>FAQ</h2><ol>
<li><strong>hand off 机制</strong></li>
</ol>
<p>当本线程上执行的 G 阻塞时，线程会释放绑定的 P，把 P 和 M 分离，把 P 转移给其他空闲的线程执行。</p>
<ol start="2">
<li><strong>利用并行</strong></li>
</ol>
<p>可以通过<code>GOMAXPROCS</code>设置 P 的数量，最多有<code>GOMAXPROCS</code>个线程分布在多个 CPU 上同时运行，因为 P 是绑定在 M 上的，M 想要运行 G 必须先获取 P。<code>GOMAXPROCS</code>也限制了并发的程度，比如<code>GOMAXPROCS = 核数/2</code>，则最多利用了一半的 CPU 核进行并行。</p>
<ol start="3">
<li><strong>抢占</strong></li>
</ol>
<p>一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死。</p>
<ol start="4">
<li><strong>自旋线程</strong></li>
</ol>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/f6015c66c0b946e5a775ee6928f4d9a7.png" title="自旋线程" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/f6015c66c0b946e5a775ee6928f4d9a7.png" data-sub-html="<h2>自旋线程</h2><p>自旋线程</p>">
        
    </a><figcaption class="image-caption">自旋线程</figcaption>
    </figure></p>
<p>假定 G2 唤醒了 M2，M2 绑定了 P2，M2 调用并运行<code>G0</code>，但 P2 本地队列没有 G，M2 此时的状态称为自旋线程（没有 G 但为运行状态的线程，不断寻找 G）。自旋线程<strong>优先</strong>会从全局队列里获取 G，当全局队列里没有了时，会去其他的<code>MP</code>组合中偷取 G。</p>
<p>自旋线程的最大限制符合公式：<code>自旋线程 + 执行线程 &lt;= GOMAXPROCS</code></p>
<ol start="5">
<li><strong>如何从全局队列取 G 的数量</strong></li>
</ol>
<p>某个 M 尝试从全局队列（简称 “GQ”）取一批 G 放到自己 P 的本地队列，从全局队列取的 G 数量符合下面的公式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">n =  min(len(GQ) / GOMAXPROCS +  1,  cap(LQ) / 2 )
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://www.yuque.com/aceld/golang/srxd6d" target="_blank" rel="noopener noreferrer">Golang的协程调度器原理及GMP设计思想</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/111346689" target="_blank" rel="noopener noreferrer">Go 为什么这么“快”</a></li>
<li><a href="https://blog.csdn.net/weixin_38054045/article/details/104098072" target="_blank" rel="noopener noreferrer">让你很快就能理解-go的协程调度原理</a></li>
<li><a href="https://mp.weixin.qq.com/s/uWP2X6iFu7BtwjIv5H55vw" target="_blank" rel="noopener noreferrer">Goroutine 数量控制在多少合适，会影响 GC 和调度？</a></li>
<li><a href="https://studygolang.com/articles/9211" target="_blank" rel="noopener noreferrer">Golang goroutine与调度器</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener noreferrer">进程与线程的一个简单解释</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;mid=2247488604&amp;idx=1&amp;sn=83219ea874b1345debc65904cd7f025a" target="_blank" rel="noopener noreferrer">Go 面试官：什么是协程，协程和线程的区别和联系？</a></li>
<li><a href="https://blog.csdn.net/genziisme/article/details/124324755" target="_blank" rel="noopener noreferrer">golang高级进阶（一）：进程、线程、并发、并行、goroutine协程</a></li>
</ul>
]]></description>
</item></channel>
</rss>
