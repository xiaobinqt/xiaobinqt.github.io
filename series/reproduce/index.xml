<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>转载 - 系列 - xiaobinqt 博客 - 技术改变生活</title>
        <link>https://www.xiaobinqt.cn/series/reproduce/</link>
        <description>转载 - 系列 - xiaobinqt 博客 - 技术改变生活</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaobinqt@163.com (xiaobinqt)</managingEditor>
            <webMaster>xiaobinqt@163.com (xiaobinqt)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><atom:link href="https://www.xiaobinqt.cn/series/reproduce/" rel="self" type="application/rss+xml" /><item>
    <title>Go sync.Map 解读</title>
    <link>https://www.xiaobinqt.cn/go-sync-map/</link>
    <pubDate>Wed, 14 Sep 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/go-sync-map/</guid>
    <description><![CDATA[背景项目中遇到了需要使用高并发的 map 的场景，众所周知 Go 官方的原生 map 是不支持并发读写的，直接并发的读写很容易触发 panic。 解决的办法有两个： 自己配一把锁sync.Mutex或者更加考究一点配一把读写锁s]]></description>
</item><item>
    <title>高并发分布式架构演进</title>
    <link>https://www.xiaobinqt.cn/highly-concurrent-architecture-evolution/</link>
    <pubDate>Mon, 29 Aug 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/highly-concurrent-architecture-evolution/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/89de4f7569e845ad91eab0a8857d5afb.png" referrerpolicy="no-referrer">
            </div>原文链接：https://segmentfault.com/a/1190000018626163 0. 目录和说明文章在介绍一些基本概念后，按照以下过程阐述了整个架构的演进过程： 单机架构 第一次演进：Tomc]]></description>
</item><item>
    <title>session cookie token 的区别</title>
    <link>https://www.xiaobinqt.cn/session-cookie-token-difference/</link>
    <pubDate>Sat, 11 Jun 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/session-cookie-token-difference/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220824/ee39a9cb19524d918d984db89b1661a5.png" referrerpolicy="no-referrer">
            </div>Cookie 和 SessionHTTP 协议是一种无状态协议，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录；Session 和 Cookie 的主要目的就是为了弥补 HTTP 的无状态特性。 Session 是什么客户端请求服务端，]]></description>
</item><item>
    <title>MySQL 常见问题（二）</title>
    <link>https://www.xiaobinqt.cn/mysql-faq-2/</link>
    <pubDate>Sat, 21 May 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/mysql-faq-2/</guid>
    <description><![CDATA[索引数据结构为什么不使用红黑树或B树在 InnoDB 引擎中，索引的底层数据结构是 B+ 树。MySQL 的数据是存储在硬盘的，在查询时一般是不能「一次性」把全部数据加载到内存中。红黑树是「二叉查找树」的变种，一个 Node 节点只]]></description>
</item><item>
    <title>MySQL 为什么使用 B&#43; 树索引</title>
    <link>https://www.xiaobinqt.cn/why-mysql-index-use-btree/</link>
    <pubDate>Fri, 20 May 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/why-mysql-index-use-btree/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221127/8018e68746b147a8bba7dac0c65ae308.png" referrerpolicy="no-referrer">
            </div>前言为什么 MySQL 采用 B+ 树作为索引？ 如果纯粹的猜测 MySQL 数据库索引为什么使用 B+ 树？那么围绕这个问题的回答通常一定是围绕 B+ 树本身是什么，有什么优势这两点去解释这个问题。 这不是我开始这么去想的，看了很多文章都是从这]]></description>
</item><item>
    <title>Redis 缓存击穿、缓存穿透、缓存雪崩</title>
    <link>https://www.xiaobinqt.cn/redis-break-pierce-avalanche/</link>
    <pubDate>Wed, 13 Apr 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/redis-break-pierce-avalanche/</guid>
    <description><![CDATA[缓存击穿高并发流量，访问的这个数据是热点数据，请求的数据在 DB 中存在，但是 Redis 存的那一份已经过期，后端需要从 DB 从加载数据并写到 Redis。 总结起来就是：单一热点数据、高并发、数据失效。 缓存击穿 解决方案 过期]]></description>
</item><item>
    <title>Go GC 垃圾回收</title>
    <link>https://www.xiaobinqt.cn/go-gc/</link>
    <pubDate>Wed, 06 Apr 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/go-gc/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221118/74f00ad9b278426887ea4348fd7a0e1c.png" referrerpolicy="no-referrer">
            </div>垃圾回收（Garbage Collection，GC）是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC 过程中无需程序员手动执行。 GC 机制在现代很多编程语言都支持，GC 能]]></description>
</item><item>
    <title>互联网协议简述</title>
    <link>https://www.xiaobinqt.cn/net-protocol-glance/</link>
    <pubDate>Sun, 27 Mar 2022 00:00:00 &#43;0000</pubDate><author>
        <name>作者</name>
    </author><guid>https://www.xiaobinqt.cn/net-protocol-glance/</guid>
    <description><![CDATA[概述 五层模型互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。 用户接触到的，只是最上面的一层，根本没有感觉到下面的层。理解互联网，需要从最下层开始，自下而上理解每一]]></description>
</item><item>
    <title>OAuth2.0的理解与应用</title>
    <link>https://www.xiaobinqt.cn/oauth2.0/</link>
    <pubDate>Tue, 22 Mar 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/oauth2.0/</guid>
    <description><![CDATA[什么是 OAuth2.0OAuth 的核心就是向第三方应用颁发令牌，比如网站A想用Github的信息，那么对于Github来说，网站A就是第三方应用。 第三方应用申请令牌之前，都必须先到系统备案，比如申请Github的令牌，得先到]]></description>
</item><item>
    <title>http入门笔记</title>
    <link>https://www.xiaobinqt.cn/http-glance/</link>
    <pubDate>Thu, 17 Mar 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/http-glance/</guid>
    <description><![CDATA[<p>该笔记是在学习《透视 HTTP 协议》时整理，还参考了网上的其他资料。鄙人只是网络世界的搬运整理工😂。</p>]]></description>
</item></channel>
</rss>
