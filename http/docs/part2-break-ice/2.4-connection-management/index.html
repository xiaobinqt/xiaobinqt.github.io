<!DOCTYPE html>
<html lang="zh" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="2.4 连接管理 # 2.4.1 短连接与长连接 # HTTP 协议最初（0.9/1.0）是个非常简单的协议，通信过程也采用了简单的 “请求 - 应答” 方式。它底层的数据传输基于 TCP/IP，每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接。因为客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为 “短连接”（short-lived connections）。
早期的 HTTP 协议也被称为是 “无连接” 的协议。短连接的缺点相当严重，因为在 TCP 协议里，建立连接和关闭连接都是非常 “昂贵” 的操作
针对短连接暴露出的缺点，HTTP 协议就提出了 “长连接” 的通信方式，也叫 “持久连接”（persistent connections）、“连接保活”（keep alive）、“连接复用”（connection reuse）。
长连接使用的 “成本均摊” 的思路，既然 TCP 的连接和关闭非常耗时间，那么就把这个时间成本由原来的一个 “请求 - 应答” 均摊到多个 “请求 - 应答” 上。这样虽然不能改善 TCP 的连接效率，但基于 “分母效应”，每个 “请求 - 应答” 的无效时间就会降低不少，整体传输效率也就提高了。
由于长连接对性能的改善效果非常显著，所以在 HTTP/1.1 中的连接都会默认启用长连接。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。
2.4.2 关闭连接 # 因为 TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。所以，长连接也需要在恰当的时间关闭，不能永远保持与服务器的连接，这在客户端或者服务器都可以做到。
在客户端，可以在请求头里加上 “Connection: close” 字段，告诉服务器：“这次通信后就关闭连接”。服务器看到这个字段，就知道客户端要主动关闭连接，于是在响应报文里也加上这个字段，发送之后就调用 Socket API 关闭 TCP 连接。">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://example.com/http/docs/part2-break-ice/2.4-connection-management/">
  <meta property="og:site_name" content="HTTP 协议学习笔记">
  <meta property="og:title" content="2.4 连接管理">
  <meta property="og:description" content="2.4 连接管理 # 2.4.1 短连接与长连接 # HTTP 协议最初（0.9/1.0）是个非常简单的协议，通信过程也采用了简单的 “请求 - 应答” 方式。它底层的数据传输基于 TCP/IP，每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接。因为客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为 “短连接”（short-lived connections）。
早期的 HTTP 协议也被称为是 “无连接” 的协议。短连接的缺点相当严重，因为在 TCP 协议里，建立连接和关闭连接都是非常 “昂贵” 的操作
针对短连接暴露出的缺点，HTTP 协议就提出了 “长连接” 的通信方式，也叫 “持久连接”（persistent connections）、“连接保活”（keep alive）、“连接复用”（connection reuse）。
长连接使用的 “成本均摊” 的思路，既然 TCP 的连接和关闭非常耗时间，那么就把这个时间成本由原来的一个 “请求 - 应答” 均摊到多个 “请求 - 应答” 上。这样虽然不能改善 TCP 的连接效率，但基于 “分母效应”，每个 “请求 - 应答” 的无效时间就会降低不少，整体传输效率也就提高了。
由于长连接对性能的改善效果非常显著，所以在 HTTP/1.1 中的连接都会默认启用长连接。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。
2.4.2 关闭连接 # 因为 TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。所以，长连接也需要在恰当的时间关闭，不能永远保持与服务器的连接，这在客户端或者服务器都可以做到。
在客户端，可以在请求头里加上 “Connection: close” 字段，告诉服务器：“这次通信后就关闭连接”。服务器看到这个字段，就知道客户端要主动关闭连接，于是在响应报文里也加上这个字段，发送之后就调用 Socket API 关闭 TCP 连接。">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
    <meta property="article:modified_time" content="2023-05-08T13:45:29+08:00">
<title>2.4 连接管理 | HTTP 协议学习笔记</title>
<link rel="manifest" href="/http/manifest.json">
<link rel="icon" href="/http/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/http/book.min.cad59a3be22b32d901c8b99a5bf0c00f01535383d8d0e86742e5449f598d17af.css" integrity="sha256-ytWaO&#43;IrMtkByLmaW/DADwFTU4PY0OhnQuVEn1mNF68=" crossorigin="anonymous">
  <script defer src="/http/flexsearch.min.js"></script>
  <script defer src="/http/zh.search.min.c41b7b3e573836b0f4b3108c02d007d52493aefbb6b115ff51db6150998a31ea.js" integrity="sha256-xBt7Plc4NrD0sxCMAtAH1SSTrvu2sRX/UdthUJmKMeo=" crossorigin="anonymous"></script>

  <script defer src="/http/sw.min.ec0a06eafc9cbe0e763898565619289d1cc6675fd3e61b207a2fb42ee592dca0.js" integrity="sha256-7AoG6vycvg52OJhWVhkonRzGZ1/T5hsgei&#43;0LuWS3KA=" crossorigin="anonymous"></script>

  

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/http/"><span>HTTP 协议学习笔记</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>




<ul>
    <li>
        <a href="javascript:void(0)" onclick="hrefIndex()" rel="noopener">主页</a>
    </li>
    <li>
        <a href="https://github.com/xiaobinqt" target="_blank" rel="noopener">GitHub</a>
    </li>
</ul>

<hr>

<script>
    function hrefIndex() {
        window.location = window.location.origin;
    }
</script>


  
<ul>
  
  <li>
    <a href=""  target="_blank" rel="noopener">
        
      </a>
  </li>
  
</ul>







  



  
  <ul>
    
      
        <li>
          
  
  

  
    <span>第一部分 总览</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/http/docs/part1-overview/1.1-basic-concept/" class="">1.1 基础概念</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/http/docs/part1-overview/1.2-net-overview/" class="">1.2 概述</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/http/docs/part1-overview/1.3-physical-layer/" class="">1.3 物理层</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/http/docs/part1-overview/1.4-link-layer/" class="">1.4 链路层</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/http/docs/part1-overview/1.5-network-layer/" class="">1.5 网络层</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/http/docs/part1-overview/1.6-transport-layer/" class="">1.6 传输层</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/http/docs/part1-overview/1.7-application-layer/" class="">1.7 应用层</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/http/docs/part1-overview/1.8-socket/" class="">1.8 Socket</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>第二部分 破冰</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/http/docs/part2-break-ice/2.1-proxy/" class="">2.1 代理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/http/docs/part2-break-ice/2.2-network-layer-model/" class="">2.2 网络分层模型</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/http/docs/part2-break-ice/2.3-entity-data/" class="">2.3 实体数据</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/http/docs/part2-break-ice/2.4-connection-management/" class="active">2.4 连接管理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/http/docs/part2-break-ice/2.5-cookie/" class="">2.5 Cookie</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/http/docs/part2-break-ice/2.6-cache/" class="">2.6 Cache</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/http/docs/part2-break-ice/2.7-https/" class="">2.7 HTTPS</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/http/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>2.4 连接管理</strong>

  <label for="toc-control">
    
    <img src="/http/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#24-连接管理">2.4 连接管理</a>
      <ul>
        <li><a href="#241-短连接与长连接">2.4.1 短连接与长连接</a></li>
        <li><a href="#242-关闭连接">2.4.2 关闭连接</a></li>
        <li><a href="#243-队头阻塞">2.4.3 队头阻塞</a>
          <ul>
            <li><a href="#优化">优化</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="24-连接管理">
  2.4 连接管理
  <a class="anchor" href="#24-%e8%bf%9e%e6%8e%a5%e7%ae%a1%e7%90%86">#</a>
</h1>
<h2 id="241-短连接与长连接">
  2.4.1 短连接与长连接
  <a class="anchor" href="#241-%e7%9f%ad%e8%bf%9e%e6%8e%a5%e4%b8%8e%e9%95%bf%e8%bf%9e%e6%8e%a5">#</a>
</h2>
<p>HTTP 协议最初（0.9/1.0）是个非常简单的协议，通信过程也采用了简单的 “请求 - 应答” 方式。它底层的数据传输基于 TCP/IP，每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接。因为客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为 “短连接”（short-lived connections）。</p>
<p>早期的 HTTP 协议也被称为是 “无连接” 的协议。短连接的缺点相当严重，因为在 TCP 协议里，建立连接和关闭连接都是非常 “昂贵” 的操作</p>
<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230504/caa7ecae49c84f708aa2f2759c771e7c.png" width=800  /></div>
<p>针对短连接暴露出的缺点，HTTP 协议就提出了 “长连接” 的通信方式，也叫 “持久连接”（persistent connections）、“连接保活”（keep alive）、“连接复用”（connection reuse）。</p>
<p>长连接使用的 “成本均摊” 的思路，既然 TCP 的连接和关闭非常耗时间，那么就把这个时间成本由原来的一个 “请求 - 应答” 均摊到多个 “请求 - 应答” 上。这样虽然不能改善 TCP 的连接效率，但基于 “分母效应”，每个 “请求 - 应答” 的无效时间就会降低不少，整体传输效率也就提高了。</p>
<p>由于长连接对性能的改善效果非常显著，所以<strong>在 HTTP/1.1 中的连接都会默认启用长连接</strong>。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。</p>
<h2 id="242-关闭连接">
  2.4.2 关闭连接
  <a class="anchor" href="#242-%e5%85%b3%e9%97%ad%e8%bf%9e%e6%8e%a5">#</a>
</h2>
<p>因为 TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。所以，长连接也需要在恰当的时间关闭，不能永远保持与服务器的连接，这在客户端或者服务器都可以做到。</p>
<p>在客户端，可以在请求头里加上 “Connection: close” 字段，告诉服务器：“这次通信后就关闭连接”。服务器看到这个字段，就知道客户端要主动关闭连接，于是在响应报文里也加上这个字段，发送之后就调用 Socket API 关闭 TCP 连接。</p>
<p>服务器端通常不会主动关闭连接，但也可以使用一些策略。拿 Nginx 来举例，它有两种方式：</p>
<ul>
<li>
<p>使用 “keepalive_timeout” 指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。</p>
</li>
<li>
<p>使用 “keepalive_requests” 指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。</p>
</li>
</ul>
<h2 id="243-队头阻塞">
  2.4.3 队头阻塞
  <a class="anchor" href="#243-%e9%98%9f%e5%a4%b4%e9%98%bb%e5%a1%9e">#</a>
</h2>
<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230504/c4388a2d78a546619fcb1e4d9525fe57.png" width=600  /></div>
<p>“队头阻塞” 与短连接和长连接无关，而是由 HTTP 基本的 “请求 - 应答” 模型所导致的。</p>
<p>因为 HTTP 规定报文必须是 “一发一收”，这就形成了一个先进先出的 “串行” 队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。</p>
<p>如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。</p>
<h3 id="优化">
  优化
  <a class="anchor" href="#%e4%bc%98%e5%8c%96">#</a>
</h3>
<p>因为 “请求 - 应答” 模型不能变，所以 “队头阻塞” 问题在 HTTP/1.1 里无法解决，只能缓解。</p>
<h4 id="并发连接">
  并发连接
  <a class="anchor" href="#%e5%b9%b6%e5%8f%91%e8%bf%9e%e6%8e%a5">#</a>
</h4>
<p>同时对一个域名发起多个长连接，用数量来解决质量的问题。但这种方式也存在缺陷。如果每个客户端都想自己快，建立很多个连接，用户数×并发数就会是个天文数字。服务器的资源根本就扛不住，或者被服务器认为是恶意攻击，反而会造成 “拒绝服务”。</p>
<h4 id="域名分片">
  域名分片
  <a class="anchor" href="#%e5%9f%9f%e5%90%8d%e5%88%86%e7%89%87">#</a>
</h4>
<p>HTTP 协议和浏览器不是限制并发连接数量吗？好，那就多开几个域名，比如 shard1.example.com、shard2.example.com，而这些域名都指向 example.com 域名对应的 ip 地址。这样实际长连接的数量就又上去了。</p>
<p>域名分片解决的是客户端并发的问题，可以创建更多的连接。比如浏览器限制一个域名最多 6 个连接，域名分 3 片，那么浏览器就可以同时建立 3*6=18 个连接，显然就能够并发更多请求，获取数据也就快了。</p>
<blockquote>
<p>利用HTTP的长连接特性对服务器发起大量请求，导致服务器最终耗尽资源 “拒绝服务”，这就是常说的 DoS。</p>
</blockquote>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/xiaobinqt/xiaobinqt.github.io/commit/ba8a30b8d6abfe51debdc97391189c173c1203b8" title='最后修改者 weibin | May 8, 2023' target="_blank" rel="noopener">
      <img src="/http/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>May 8, 2023</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/xiaobinqt/xiaobinqt.github.io/tree/main/content/docs/part2-break-ice/2.4-connection-management.md" target="_blank" rel="noopener">
      <img src="/http/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>编辑本页</span>
    </a>
  </div>


</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#24-连接管理">2.4 连接管理</a>
      <ul>
        <li><a href="#241-短连接与长连接">2.4.1 短连接与长连接</a></li>
        <li><a href="#242-关闭连接">2.4.2 关闭连接</a></li>
        <li><a href="#243-队头阻塞">2.4.3 队头阻塞</a>
          <ul>
            <li><a href="#优化">优化</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












