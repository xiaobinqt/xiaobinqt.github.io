<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>第二部分 破冰 on HTTP 协议学习笔记</title>
    <link>https://example.com/http/docs/part2-break-ice/</link>
    <description>Recent content in 第二部分 破冰 on HTTP 协议学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <atom:link href="https://example.com/http/docs/part2-break-ice/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2.1 代理</title>
      <link>https://example.com/http/docs/part2-break-ice/2.1-proxy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/http/docs/part2-break-ice/2.1-proxy/</guid>
      <description>2.1 代理 # 代理最基本的一个功能是负载均衡。因为在面向客户端时屏蔽了源服务器，客户端看到的只是代理服务器，源服务器究竟有多少台、是哪些 IP 地址都不知道。于是代理服务器就可以掌握请求分发的 “大权”，决定由后面的哪台服务器来响应请求。
在负载均衡的同时，代理服务还可以执行更多的功能，比如：
健康检查：使用“心跳”等机制监控后端服务器，发现有故障就及时“踢出”集群，保证服务高可用；
安全防护：保护被代理的后端服务器，限制 IP 地址或流量，抵御网络攻击和过载；
加密卸载：对外网使用 SSL/TLS 加密通信认证，而在安全的内网不加密，消除加解密成本；
数据过滤：拦截上下行的数据，任意指定策略修改请求或者响应；
内容缓存：暂存、复用服务器响应。
2.1.1 匿名代理 # 匿名代理（Anonymous Proxy）用于隐藏客户端的真实 IP 地址，使客户端在互联网上的活动难以被追踪。匿名代理通常是由第三方提供的，客户端需要将网络流量转发给代理服务器，代理服务器会替代客户端向目标服务器发送请求，并将响应返回给客户端。
匿名代理的主要功能是隐藏客户端的真实 IP 地址，使客户端在互联网上的活动更加隐秘和安全。因为许多网站和服务都会记录访问者的 IP 地址，如果客户端使用匿名代理进行访问，就可以避免自己的真实 IP 地址被记录和追踪。匿名代理也可以用于访问被封锁的网站和服务，因为代理服务器的 IP 地址通常不会被封锁。
需要注意的是，匿名代理并不能完全保障客户端的隐私和安全，因为代理服务器仍然可以访问客户端的真实 IP 地址和网络流量。此外，一些不良的匿名代理可能会收集客户端的个人信息或恶意篡改网络流量，导致客户端的网络安全受到威胁。因此，使用匿名代理时应该选择可靠的服务提供商，并保持警惕。
2.1.2 透明代理 # 透明代理（Transparent Proxy）在转发客户端请求时不会修改任何请求头信息，目标服务器可以获取到客户端的真实 IP 地址和其他相关信息。透明代理通常是由 ISP（Internet Service Provider，互联网服务提供商）或公司内部网络部署的。
与匿名代理和高匿代理不同，透明代理不会对客户端的请求进行任何加密或隐藏，客户端无法隐匿自己的真实身份和位置。这种代理的主要作用是提高访问速度、节约带宽和监控网络流量。例如，ISP 可以通过透明代理实现流量控制、缓存加速、防火墙过滤等功能，公司可以通过透明代理实现员工网络访问的管理和监控。
需要注意的是，透明代理在传输数据时不会加密，因此在使用透明代理时，用户应该注意保护自己的数据安全。另外，一些不良的透明代理可能会篡改用户的网络流量或收集用户的个人信息，因此用户需要选择可靠的代理服务提供商，并保持警惕。
2.1.3 正向代理 # 正向代理的代理服务器是部署在客户端，而对服务端来说，它以为对它发起请求的是代理服务器，而真正请求的客户端对服务端来说是不可见的。
2.1.4 反向代理 # 反向代理的代理服务器是部署在服务端，而对客户端来说，它以为对它做出响应的是代理服务器，而真正响应的服务端对客户端来说是不可见的。
2.1.5 头字段 # Via # Via 是一个通用字段，请求头或响应头里都可以出现。每当报文经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾，就像是经手人盖了一个章。如果通信链路中有很多中间代理，就会在 Via 里形成一个链表，这样就可以知道报文究竟走过了多少个环节才到达了目的地。
X-Forwarded-For # “X-Forwarded-For” 的字面意思是 “为谁而转发”，形式上和 “Via” 差不多，也是每经过一个代理节点就会在字段里追加一个信息。但 “Via” 追加的是代理主机名（或者域名），而 “X-Forwarded-For” 追加的是请求方的 IP 地址。所以，在字段里最左边的 IP 地址就是客户端的地址。</description>
    </item>
    <item>
      <title>2.2 网络分层模型</title>
      <link>https://example.com/http/docs/part2-break-ice/2.2-network-layer-model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/http/docs/part2-break-ice/2.2-network-layer-model/</guid>
      <description>2.2 网络分层模型 # 2.2.1 TCP/IP 网络分层模型 # TCP/IP 协议总共有四层，每一层需要下层的支撑，同时又支撑着上层，任何一层被抽掉都可能会导致整个协议栈坍塌。
第一层叫 “链接层”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。
第二层叫 “网际层 ”或者 “网络互连层”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了 “IP 地址” 的概念，所以就可以在 “链接层” 的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再 “翻译” 成 MAC 地址就可以了。
第三层叫 “传输层”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP/UDP 协议工作的层次。TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的 “字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。
协议栈的第四层叫 “应用层”（application layer），由于有了下面的三层的基础，在这一层有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有 HTTP。
MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。
2.2.2 OSI 网络分层模型 # OSI，全称是“开放式系统互联通信参考模型”（Open System Interconnection Reference Model）。由于 TCP/IP 诞生于 1970 年代，当时除了它还有很多其他的网络协议，整个网络世界比较混乱。这个时候国际标准组织（ISO）注意到了这种现象，感觉 “野路子” 太多，就想要来个 “大一统”。于是设计出了一个新的网络分层模型，想用这个新框架来统一既存的各种网络协议，这就是 OSI 模型的来历。OSI 模型分成了七层，部分层次与 TCP/IP 很像，从下到上分别是：</description>
    </item>
    <item>
      <title>2.3 实体数据</title>
      <link>https://example.com/http/docs/part2-break-ice/2.3-entity-data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/http/docs/part2-break-ice/2.3-entity-data/</guid>
      <description>2.3 实体数据 # 2.3.1 MIME # “多用途互联网邮件扩展”（Multipurpose Internet Mail Extensions），简称为 MIME。
HTTP 用 MIME 标准规范来标记 body 的数据类型，这就是 “MIME type”。MIME 把数据分成了八大类，每个大类下再细分出多个子类，形式是“type/subtype” 的字符串。
简单列举一下在 HTTP 里经常遇到的几个类别：
text：文本格式的可读数据，最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。
image：图像文件，有 image/gif、image/jpeg、image/png 等。audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。
application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，像刚才说的 “黑盒”，就会是 application/octet-stream，即不透明的二进制数据。
HTTP 在传输时为了节约带宽，有时候还会压缩数据，为了不要让浏览器 “猜”，还需要有一个 “Encoding type”，告诉数据是用的什么编码格式，这样对方才能正确解压缩，还原出原始的数据。比起 MIME type 来说，Encoding type 就少了很多，常用的只有下面三种：
gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；
deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；
br：一种专门为 HTTP 优化的新压缩算法（Brotli）。
Accept 字段标记的是客户端可理解的 MIME type，可以用 “,” 做分隔符列出多个类型，让服务器有更多的选择余地，例如下面的这个头：
Accept: text/html,application/xml,image/webp,image/png 这就是告诉服务器：“我能够看懂 HTML、XML 的文本，还有 webp 和 png 的图片，请给我这四类格式的数据”。相应的，服务器会在响应报文里用头字段 Content-Type 告诉实体数据的真实类型：</description>
    </item>
    <item>
      <title>2.4 连接管理</title>
      <link>https://example.com/http/docs/part2-break-ice/2.4-connection-management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/http/docs/part2-break-ice/2.4-connection-management/</guid>
      <description>2.4 连接管理 # 2.4.1 短连接与长连接 # HTTP 协议最初（0.9/1.0）是个非常简单的协议，通信过程也采用了简单的 “请求 - 应答” 方式。它底层的数据传输基于 TCP/IP，每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接。因为客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为 “短连接”（short-lived connections）。
早期的 HTTP 协议也被称为是 “无连接” 的协议。短连接的缺点相当严重，因为在 TCP 协议里，建立连接和关闭连接都是非常 “昂贵” 的操作
针对短连接暴露出的缺点，HTTP 协议就提出了 “长连接” 的通信方式，也叫 “持久连接”（persistent connections）、“连接保活”（keep alive）、“连接复用”（connection reuse）。
长连接使用的 “成本均摊” 的思路，既然 TCP 的连接和关闭非常耗时间，那么就把这个时间成本由原来的一个 “请求 - 应答” 均摊到多个 “请求 - 应答” 上。这样虽然不能改善 TCP 的连接效率，但基于 “分母效应”，每个 “请求 - 应答” 的无效时间就会降低不少，整体传输效率也就提高了。
由于长连接对性能的改善效果非常显著，所以在 HTTP/1.1 中的连接都会默认启用长连接。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。
2.4.2 关闭连接 # 因为 TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。所以，长连接也需要在恰当的时间关闭，不能永远保持与服务器的连接，这在客户端或者服务器都可以做到。
在客户端，可以在请求头里加上 “Connection: close” 字段，告诉服务器：“这次通信后就关闭连接”。服务器看到这个字段，就知道客户端要主动关闭连接，于是在响应报文里也加上这个字段，发送之后就调用 Socket API 关闭 TCP 连接。</description>
    </item>
    <item>
      <title>2.5 Cookie</title>
      <link>https://example.com/http/docs/part2-break-ice/2.5-cookie/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/http/docs/part2-break-ice/2.5-cookie/</guid>
      <description>2.5 Cookie # 2.5.1 什么是 Cookie # 当用户通过浏览器第一次访问服务器的时候，服务器肯定是不知道他的身份的。所以，就要创建一个独特的身份标识数据，格式是 “key=value”，然后放进 Set-Cookie 字段里，随着响应报文一同发给浏览器。
浏览器收到响应报文，看到里面有 Set-Cookie，知道这是服务器给的身份标识，于是就保存起来，下次再请求的时候就自动把这个值放进 Cookie 字段里发给服务器。因为第二次请求里面有了 Cookie 字段，服务器就知道这个用户不是新人，之前来过，就可以拿出 Cookie 里的值，识别出用户的身份，然后提供个性化的服务。服务器有时会在响应头里添加多个 Set-Cookie，存储多个 “key=value”。但浏览器这边发送时不需要用多个 Cookie 字段，只要在一行里用 “;” 隔开就行。
2.5.2 Cookie 的属性 # 生存周期 # Cookie 的生存周期，也就是它的有效期，让它只能在一段时间内可用，一旦超过这个期限浏览器就认为是 Cookie 失效，在存储里删除，也不会发送给服务器。
Cookie 的有效期可以使用 Expires 和 Max-Age 两个属性来设置。Expires 俗称过期时间，用的是绝对时间点，可以理解为截止日期（deadline）。Max-Age 用的是相对时间，单位是秒，浏览器用收到报文的时间点再加上 Max-Age，就可以得到失效的绝对时间。
Expires 和 Max-Age 可以同时出现，两者的失效时间可以一致，也可以不一致，但浏览器会优先采用 Max-Age 计算失效期。
如果不指定 Expires 或 Max-Age 属性，那么 Cookie 仅在浏览器运行时有效，一旦浏览器关闭就会失效，这被称为会话 Cookie (session cookie) 或内存 Cookie (in-memory cookie), 在 Chrome 浏览器里过期时间会显示为 “Session” 或 “N/A”。</description>
    </item>
    <item>
      <title>2.6 Cache</title>
      <link>https://example.com/http/docs/part2-break-ice/2.6-cache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/http/docs/part2-break-ice/2.6-cache/</guid>
      <description>2.6 Cache # 2.6.1 服务端缓存控制 # 服务器标记资源有效期使用的头字段是 “Cache-Control”，里面的值 “max-age=30” 就是资源的有效时间，相当于告诉浏览器，“这个页面只能缓存 30 秒，之后就算是过期，不能用。”
除了 “Cache-Control&amp;rsquo;”，服务器也可以用 “Expires” 字段来标记资源的有效期，它的形式和 Cookie 的差不多，同样属于 “过时” 的属性，优先级低于 “Cache-Control&amp;rsquo;”。 还有一个历史遗留字段 “Pragma:no-cache”，它相当于 “Cache-Control: no-cache”，除非为了兼容HTTP/1.0 否则不建议使用。
这里的 max-age 是 “生存时间”（又叫“新鲜度” “缓存寿命”，类似 TTL，Time-To-Live），时间的计算起点是响应报文的创建时刻（即 Date 字段，也就是离开服务器的时刻），而不是客户端收到报文的时刻，也就是说包含了在链路传输过程中所有节点所停留的时间。
“max-age” 是 HTTP 缓存控制最常用的属性，此外在响应报文里还可以用其他的属性来更精确地指示浏览器应该如何使用缓存：
no-store：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面；
no-cache：它的字面含义容易与 no-store 搞混，实际的意思并不是不允许缓存，而是可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本；
must-revalidate：又是一个和 no-cache 相似的词，它的意思是如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。
可以拿生鲜速递来举例说明一下：
no-store：买来的西瓜不允许放进冰箱，要么立刻吃，要么立刻扔掉；
no-cache：可以放进冰箱，但吃之前必须问超市有没有更新鲜的，有就吃超市里的；
must-revalidate：可以放进冰箱，保鲜期内可以吃，过期了就要问超市让不让吃。
2.6.2 客户端缓存控制 # 其实不止服务器可以发 “Cache-Control” 头，浏览器也可以发 “Cache-Control”，也就是说请求 - 应答的双方都可以用这个字段进行缓存控制，互相协商缓存的使用策略。
当点 “刷新” 按钮的时候，浏览器会在请求头里加一个 “Cache-Control: max-age=0”。因为 max-age 是 “生存时间”，max-age=0 的意思就是拿到最新的数据，而本地缓存里的数据至少保存了几秒钟，所以浏览器就不会使用缓存，而是向服务器发请求。服务器看到 max-age=0，也就会用一个最新生成的报文回应浏览器。
浏览器用 “Cache-Control” 做缓存控制只能是刷新数据，不能很好地利用缓存数据，又因为缓存会失效，使用前还必须要去服务器验证是否是最新版。所以 HTTP 协议就定义了一系列 “If” 开头的 “条件请求” 字段，专门用来检查验证资源是否过期，验证的责任交给服务器，浏览器只需 “坐享其成”。</description>
    </item>
    <item>
      <title>2.7 HTTPS</title>
      <link>https://example.com/http/docs/part2-break-ice/2.7-https/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/http/docs/part2-break-ice/2.7-https/</guid>
      <description>2.7 HTTPS # 2.7.1 什么是 https # 如果通信过程具备了四个特性，就可以认为是 “安全” 的，这四个特性是：机密性、完整性，身份认证和不可否认。HTTPS 为 HTTP 增加了这四大安全特性。
机密性由对称加密 AES 保证，完整性由 SHA384 摘要算法保证，身份认证和不可否认由RSA非对称加密保证
HTTPS 规定了新的协议名 “https”，默认端口号 443，至于其他的什么请求 - 应答模式、报文结构、请求方法、URI、头字段、连接管理等等都完全沿用 HTTP，没有任何新的东西。也就是说，除了协议名 “http” 和端口号 80 这两点不同，HTTPS 协议在语法、语义上和 HTTP 完全一样，优缺点也 “照单全收”（当然要除去 “明文” 和 “不安全”）。
HTTPS 把 HTTP 下层的传输协议由 TCP/IP 换成了 SSL/TLS，由 “HTTP over TCP/IP” 变成了 “HTTP over SSL/TLS”，让 HTTP 运行在了安全的 SSL/TLS 协议上，收发报文不再使用 Socket API，而是调用专门的安全接口。
2.7.2 SSL/TLS # SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层），由网景公司于 1994 年发明，有 v2 和 v3 两个版本，而 v1 因为有严重的缺陷从未公开过。SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化，版本号从 1.</description>
    </item>
  </channel>
</rss>
