{"./":{"url":"./","title":"简介","keywords":"","body":"简介 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"resume.html":{"url":"resume.html","title":"resume","keywords":"","body":"个人信息 姓 名：卫彬            年 龄：28 手 机：15209272743        邮 箱：15209272743@163.com 专 业：通信工程           岗 位：研发工程师 个人技能 熟悉 Golang 语法，并发编程，协程，管道的使用。有 Golang 开发的相关经验。 熟悉 Linux 常用命令。 熟练使用 Mysql 数据库；可编写和优化 SQL 语句。 熟悉 git 版本控制软件，具有良好的编码风格和习惯。 熟悉 php 的 Laravel，Thinkphp，CI 框架，可熟练使用。 熟悉 Redis 的使用。熟悉第三方接口调用，微信公众平台、微信小程序，企业微信开发。 了解 Docker 容器的基本使用。 了解 JavaScript、 jQuery、 CSS+DIV 等 web 前端技术和 wordpress 的基本使用。 （个人前端学习网站示例）。 工作经历 法本信息技术股份有限公司外派腾讯 （ 2019.4 ~ 2021.4 ） 看点快报 push 运营后台 本项目是看点快报 App push 运营后台。项目接口使用 golang 开发，包含文章入池，编辑送审，发文，报表等功能。入池包括接收腾讯新闻文章，视频等乐高池文章。 有文章自动送审功能，通过配置配置实现需要的文章自动入池，使项目实现自动化。监控平台接口耗时，实时优化调用情况。 星盘数据平台 星盘是由 PCG 兴趣阅读产品部设计并研发的综合型数据平台，面向产品，运营，业务研发和数据发等各类需求方， 提供数据生产消费各个环节的相关服务。平台主要功能有数据分析，数据管理和专题工具几大类。主要功能有仪表盘、实时数据， 元数据，数据模型和权限等功能。 西安维客软件科技有限公司 （ 2017年4月 ~ 2019年3月 ） 西安鹏程金属容器管理系统 本项目使用 php 开发，是西安鹏程金属容器的管理系统，一期包括员工管理，物品管理，角色管理，仓库管理，类别管理， 物品入库、出库，物品临借，库房盘点等功能。 该项目使用 Laravel5.5 开发，使用了框架的队列，任务调度等功能。集成了企业微信部分功能，将员工信息与企业微信后台相连， 同步员工信息到企业微信后台并将员工头像上传到七牛云，其中用到了 EasyWeChat SDK。 聚美医后台 本项目使用 php 开发，是一个医学器材租借管理系统。采用前后端分离，后端利用 Lumen 提供 Api 支持。 项目分为商务部，运营部，财务部，仓储部，总裁办等部门，分工各不相同。项目工作流为商务部新建合同，合同转到财务交租， 交租成功后仓储部发货，运营负责数据的报表管理。 潘帕斯 pop 商城 使用 php 进行开发，网上商城功能包括用户管理，商品分类，商品搜索，购物车功能。平台端可以管理健身房和教练， 查看教练的销售业绩和销售提成；供应商端可以对平台端的订单进行管理和发货，对商品进行管理操作。 西班牙旅游网站 该项目是西班牙旅游景点介绍的网站。项目利用 Wordpress 进行开发维护。在开发过程中用到了 Advanced Custom Fields， Contact Form 7， Export Users to CSV， Math Captcha， WP Mail Smtp 等 Wordpress 插件。 个人账号 个人网站 博客 CSDN Github console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"go/new_make_difference.html":{"url":"go/new_make_difference.html","title":"new 和 make 的区别","keywords":"","body":"make 和 new 的区别 总结 make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配。 new返回指针，指向新分配的类型 T 的零值。 make返回初始化后的（非零）值。 参考 make、new操作 Go make 和 new的区别 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"go/gmp_model.html":{"url":"go/gmp_model.html","title":"GMP 模型","keywords":"","body":"go GMP 模型 进程、线程、协程的区别 协程的上下文切换比线程的上下文切换代价小 go 调度器机制 知识点 Go程序中没有语言级的关键字让你去创建一个内核线程，你只能创建 goroutine，内核线程只能由 runtime 根据实际情况去创建。 Go运行时系统并没有内核调度器的中断能力，内核调度器会发起抢占式调度将长期运行的线程中断并让出CPU资源，让其他线程获得执行机会。 参考 https://zhuanlan.zhihu.com/p/111346689 https://blog.csdn.net/weixin_38054045/article/details/104098072 https://studygolang.com/articles/9211 https://www.golangroadmap.com/class/goadvanced/3-4.html#_1-2-%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"go/break_continue_goto_label.html":{"url":"go/break_continue_goto_label.html","title":"break,goto,continue label 区别","keywords":"","body":"break，continue，goto label 的区别 在 php 中可以直接在 break 和 continue 后加 num ，比如 break 2或 continue 2。 break num 是结束外层第 num 层整个循环体，continue num 是结束外层第 num 层单次循环。 类比 php ，go 中不能直接在关键字后加 num ，但是可以用 label 关键字代替 num。 continue label package main import ( \"fmt\" \"math\" ) func main() { // 找出 int 切片的最小值 var matrix = []int{10, 2, 4, 0} var min = math.MinInt64 next: for _, v := range matrix { for _, v1 := range matrix { if v > v1 { continue next // 终止当前循环，跳到 label 继续下一次循环 } } min = v } fmt.Println(\"最小值为: \", min) } break label package main import ( \"fmt\" \"math\" ) func main() { // 获取 index 2 的值，这里使用 2 层循环主要是为了说明问题 var matrix = []int{10, 2, 4, 0} var index2Val = math.MinInt64 next: for _, v := range matrix { fmt.Println(v) for index, v1 := range matrix { index2Val = v1 if index == 2 { break next // 跳出循环到 label 处 } } } fmt.Println(\"index 3 值为: \", index2Val) } goto label 非必要不使用，可以跳到任何地方。 package main import ( \"fmt\" \"math\" ) func main() { var matrix = []int{10, 2, 4, 0} var index2Val = math.MinInt64 for _, v := range matrix { fmt.Println(v) for index, v1 := range matrix { index2Val = v1 if index == 2 { goto next } } } fmt.Println(\"index 3 值为: \", index2Val) next: fmt.Println(\"goto this....\") } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"go/gobuild常用命令.html":{"url":"go/gobuild常用命令.html","title":"gobuild常用命令","keywords":"","body":"go build 常用命令 常用编译参数 参数 说明 -o 指定输出可执行文件名 -v 编译时显示包名，可以理解成输出详细编译信息 -race 开启竞态检测 *.go 编译当前目录下的所有go文件，也可以写成 f2.go f2.go ... -a 强制重新构建 -w 去掉DWARF调试信息，得到的程序就不能用gdb调试了 -s 去掉符号表,panic时候的stack trace就没有任何文件名/行号信息了，这个等价于普通C/C++程序被strip的效果 -X 设置包中的变量值 -gcflags \"-N -l\" 编译目标程序的时候会嵌入运行时(runtime)的二进制，禁止优化和内联可以让运行时(runtime)中的函数变得更容易调试。gcflags 其实是给go编译器传入参数，也就是传给go tool compile的参数，因此可以用go tool compile --help查看所有可用的参数 -ldflags 给go链接器传入参数，实际是给go tool link的参数，可以用go tool link --help查看可用的参数。 -ldflags '-extldflags \"-static\"' 静态编译 交叉编译 参数 说明 GOOS GOARCH linux 386 / amd64 / arm darwin 386 / amd64 feedbsd 386 / amd64 windows 386 / amd64 对于编译给ARM使用的Go程序，需要根据实际情况配置$GOARM，这是用来控制CPU的浮点协处理器的参数。 $GOARM默认是6，对于不支持VFP使用软件运算的老版本ARM平台要设置成5，支持VFPv1的设置成6，支持VFPv3的设置成7。 示例 GOARM= 7 GOARCH = arm GOOS = linux go build -v -o fca 参考 golang编译时的参数传递（gcflags, ldflags） Golang交叉编译（跨平台编译）简述 交叉编译Go程序 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"go/grpc_demo.html":{"url":"go/grpc_demo.html","title":"grpc简单入门示例","keywords":"","body":"grpc 入门应用 RPC 是一种跨语言的协议，它可以让我们在不同的语言之间进行通信。 远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个 地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。 RPC是一种服务器-客户端（Client/Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。 安装 go install github.com/golang/protobuf/protoc-gen-go@v1.4.0 go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1 不推荐使用 google.golang.org/protobuf/cmd/protoc-gen-go@v1.26 这个版本太高了，可能会遇到以下这个问题， --go_out: protoc-gen-go: plugins are not supported; use 'protoc --go-grpc_out=...' to generate gRPC See https://grpc.io/docs/languages/go/quickstart/#regenerate-grpc-code for more information. 参考解决方案记一次奇妙的go-protobuf包升级之旅 protoc 工具安装 下载地址，下载解压将 bin 目录添加到环境变量中。 定义 proto 文件 syntax = \"proto3\"; // 使用protobuf版本3 option go_package = \"./protobuf\"; // 这个影响生成的目录及go的package命名 // 定义一个计算服务, 输入为CalcRequest, 输出为CalcResponse service CalculatorService { rpc calc(CalcRequest) returns (CalcResponse) {}; } // 计算两个数某种运算(如加法)的参数 message CalcRequest { double a = 1; double b = 2; string op = 3; } // 计算结果 message CalcResponse { double r = 1; } 生成 .pb.go 文件 protoc --go_out=plugins=grpc:. calculator.proto rpc server package main import ( \"context\" \"fmt\" \"net\" \"go.src/grpc/calculator/protobuf\" \"google.golang.org/grpc\" ) // 实现: CalculatorServiceServer接口, 在calculator.pb.go中定义 type server struct{} func (s server) Calc(ctx context.Context, req *protobuf.CalcRequest) (resp *protobuf.CalcResponse, err error) { a := req.GetA() b := req.GetB() op := req.GetOp() resp = &protobuf.CalcResponse{} switch op { case \"+\": resp.R = a + b case \"-\": resp.R = a - b case \"*\": resp.R = a * b case \"/\": if b == 0 { err = fmt.Errorf(\"divided by zero\") return } resp.R = a / b } return } // 启动rpc server func main() { listener, err := net.Listen(\"tcp\", \"localhost:3233\") if err != nil { panic(err) } s := grpc.NewServer() protobuf.RegisterCalculatorServiceServer(s, &server{}) fmt.Println(\"server start\") err = s.Serve(listener) if err != nil { panic(err) } } rpc client package main import ( \"context\" \"fmt\" \"log\" \"go.src/grpc/calculator/protobuf\" \"google.golang.org/grpc\" \"google.golang.org/grpc/credentials/insecure\" ) func main() { // 连上grpc server //conn, err := grpc.Dial(\"localhost:3233\", grpc.WithInsecure()) conn, err := grpc.Dial(\"localhost:3233\", grpc.WithTransportCredentials(insecure.NewCredentials())) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() c := protobuf.NewCalculatorServiceClient(conn) // 调用远程方法 resp, err := c.Calc(context.Background(), &protobuf.CalcRequest{ A: 1, B: 2, Op: \"+\", }) if err != nil { fmt.Println(\"calc err: \", err.Error()) return } fmt.Println(\"calc success,respR: \", resp.GetR()) // 3 } 运行测试 server client 示例下载 示例源码地址 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"go/build_running_gcc_failed.html":{"url":"go/build_running_gcc_failed.html","title":"running gcc failed","keywords":"","body":"running gcc failed: exit status 1 今天在编译 go 项目时出现了如下错误： /usr/local/go/pkg/tool/linux_amd64/link: running gcc failed: exit status 1 /usr/bin/ld: cannot find -lpthread /usr/bin/ld: cannot find -lc collect2: error: ld returned 1 exit status 解决办法： yum install glibc-static.x86_64 -y console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"c/定义字符串的方法.html":{"url":"c/定义字符串的方法.html","title":"C语言定义字符串的方法","keywords":"","body":"C 语言定义字符串的方法 #include int main(void) { char a[6] = {'F', 'i', 's', 'h', 'C', '\\0'}; // 需要主动加上 \\0 char a1[] = {'F', 'i', 's', 'h', 'C', '\\0'}; // 需要主动加上 \\0 char a2[] = {\"FishC\"}; char a3[] = \"FishC\"; printf(\"a: %s \\n\", a); printf(\"a1: %s \\n\", a1); printf(\"a2: %s \\n\", a2); printf(\"a3: %s \\n\", a3); return 0; } 运行结果： console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"c/常量与指针.html":{"url":"c/常量与指针.html","title":"C语言常量与指针","keywords":"","body":"C语言常量与指针 常量 变量和常量最大的区别就是变量的值可以被修改，但是常量的值不能被修改。 在C语言中，可以将变量变成具有常量一样的特性，那就是利用const关键字： const int cnum = 880; 在const关键字的修饰下，变量cnum就会失去可修改的特性，也就是变成只读的属性。 指向常量的指针 指针可以指向被const修饰过的变量，这就意味着不能通过指针来修改它所引用的值。但是指针本身是可以修改的。 #include int main() { int num = 520; const int cnum = 880; const int *pc = &cnum; printf(\"cnum: %d, &cnum: %p \\n\", cnum, &cnum); printf(\"*pc: %d, pc:%p \\n\", *pc, pc); // 尝试修改 *pc 的值是不允许的 *pc = 1024; // &#x2715; // 但是可以修改指针的指向，之前是指向 cnum，现在指向 num pc = &num ; // &#x2705; // 可以通过变量名来修改变量的值 num = 1235; // &#x2705; // 无法通过解引用指针来修改 *pc = 1111; // &#x2715; printf(\"*pc: %d \\n\", *pc); return 0; } 指向非常量的常量指针 指针自身不可以被修改。 指针指向的值可以被修改。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"c/数组和指针的关系.html":{"url":"c/数组和指针的关系.html","title":"C语言中指针和数组的关系","keywords":"","body":"C语言中指针和数组的关系 指针就是内存地址 字符串和数组的关系 C语言没有字符串的概念，字符串就是一串字符，所以只需要在内存中找一块空间，存放一串字符类型的变量就可以了。 c语言中字符串的定义语法可以参考，所以可以理解成字符串就是一维字节数组。 在C语言中，数组的数组名就是数组第一个元素的地址，所以数组名是一个地址常量，而常量是不能改变的。数组名不是变量，更不是指针。 为什么可以用一个指针指向数组呢，这是因为指针指向的不是数组，而是数组的第一个元素的地址。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"c/数组指针和二维数组.html":{"url":"c/数组指针和二维数组.html","title":"C 语言数组指针和二维数组","keywords":"","body":"C 语言数组指针和二维数组 #include int main() { int array[2][3] = { {0, 1, 2}, {3, 4, 5} }; int (*p)[3] = array; printf(\"**p: %d \\n\", **p); printf(\"**array: %d \\n\", **array); printf(\"*(*p+1): %d \\n\", *(*p + 0)); printf(\"**(p+1): %d \\n\", **(p + 1)); printf(\"**(array+1): %d \\n\", **(array + 1)); printf(\"array[1][0]: %d \\n\", array[1][0]); return 0; } console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"frontend/node_oom.html":{"url":"frontend/node_oom.html","title":"JavaScript heap out of memory","keywords":"","body":"JavaScript heap out of memory 刚在打包项目时执行 yarn run build 时出现了 oom 的情况，具体报错信息如下： 我的环境是 win10 专业版 WSL。 解决办法，设置 export NODE_OPTIONS=--max_old_space_size=4096，设置完之后重新执行 yarn run build 即可。 参考 https://stackoverflow.com/questions/38558989/node-js-heap-out-of-memory console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"frontend/ajax_req_add_cookie.html":{"url":"frontend/ajax_req_add_cookie.html","title":"ajax 请求携带 cookie 信息","keywords":"","body":"ajax 在请求时携带 cookie 信息 最近有个需求在使用 $.ajax 时需要把 cookie 信息也带着，google 下发现可以这么写： $.ajax({ url: \"/nodered/nodes\", headers: { Accept: \"text/html\", }, xhrFields: { withCredentials: true // 携带 cookie 信息 }, success: function (data) { console.log(data) $(\"#red-ui-palette-container\").html(data) }, error: function (jqXHR) { console.log(jqXHR) } }); console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"data_structures_and_algorithms/tree_definition.html":{"url":"data_structures_and_algorithms/tree_definition.html","title":"树的一些概念","keywords":"","body":"Explanation 平衡二叉树 左右子树的高度相差不超过 1 的树为平衡二叉树。 二叉搜索树 若左子树不空，则左子树上所有节点的值均小于它的根节点的值，若右子树不空，则右子树上所有节点的值均大于它的根节点的值。 二叉搜索树在最好的情况下搜索的时间复杂度为 O(logN)。 B 数 B树是一种多路平衡查找树。我们描述一颗B树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点，一般用字母 m 表示阶数。当 m 取2时，就是我们常见的二叉搜索树，m为 3 时是 2-3 树。 其设计思路主要是通过节点中存储不止一个key，来降低树的高度。同等比较次数下，树的高度小保证磁盘IO次数相对较少，提高查找效率。 B树的查找操作的时间复杂度为 O(mlogmn)。其中m为B树的阶数，n为B树中key的数目。 B树的删除操作同样需要执行查找过程，时间复杂度为O(m\\log_m n)。 B+ 树 B+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。 参考：https://xiaozhuanlan.com/topic/9781043652 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"data_structures_and_algorithms/binary_tree.html":{"url":"data_structures_and_algorithms/binary_tree.html","title":"二叉树的遍历","keywords":"","body":"二叉树的遍历 将如图的二叉树按前中序和按层遍历 前中后序遍历 package main import \"fmt\" type TreeNode struct { Value byte Left *TreeNode Right *TreeNode } // 前序遍历 func preorderTraversal(node *TreeNode, values []string) []string { if node != nil { values = append(values, string(node.Value)) values = preorderTraversal(node.Left, values) values = preorderTraversal(node.Right, values) } return values } // 中序遍历 func midOrderTraversal(node *TreeNode, values []string) []string { if node != nil { values = preorderTraversal(node.Left, values) values = append(values, string(node.Value)) values = preorderTraversal(node.Right, values) } return values } // 后序遍历 func postOrderTraversal(node *TreeNode, values []string) []string { if node != nil { values = preorderTraversal(node.Left, values) values = preorderTraversal(node.Right, values) values = append(values, string(node.Value)) } return values } func main() { node := &TreeNode{ Value: 'A', Left: &TreeNode{ Value: 'B', Left: &TreeNode{ Value: 'D', Left: &TreeNode{ Value: 'H', Left: nil, Right: nil, }, Right: &TreeNode{ Value: 'I', Left: nil, Right: nil, }, }, Right: &TreeNode{ Value: 'E', Left: &TreeNode{ Value: 'J', Left: nil, Right: nil, }, Right: nil, }, }, Right: &TreeNode{ Value: 'C', Left: &TreeNode{ Value: 'F', Left: nil, Right: nil, }, Right: &TreeNode{ Value: 'G', Left: nil, Right: nil, }, }, } values := make([]string, 0) fmt.Println(\"前序: \", preorderTraversal(node, values)) fmt.Println(\"中序: \", midOrderTraversal(node, values)) fmt.Println(\"后序: \", postOrderTraversal(node, values)) } 结果为： 按层遍历 package main import \"fmt\" type TreeNode struct { Value byte Left *TreeNode Right *TreeNode } // 按层遍历 func LevelOrderTraversal(node *TreeNode, values []string) []string { if node != nil { // 采用队列实现 queue := make([]*TreeNode, 0) queue = append(queue, node) // queue push for len(queue) > 0 { node = queue[0] //fmt.Printf(\"%d -> \", tree.Value) values = append(values, string(node.Value)) queue = queue[1:] // queue pop if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } return values } func main() { node := &TreeNode{ Value: 'A', Left: &TreeNode{ Value: 'B', Left: &TreeNode{ Value: 'D', Left: &TreeNode{ Value: 'H', Left: nil, Right: nil, }, Right: &TreeNode{ Value: 'I', Left: nil, Right: nil, }, }, Right: &TreeNode{ Value: 'E', Left: &TreeNode{ Value: 'J', Left: nil, Right: nil, }, Right: nil, }, }, Right: &TreeNode{ Value: 'C', Left: &TreeNode{ Value: 'F', Left: nil, Right: nil, }, Right: &TreeNode{ Value: 'G', Left: nil, Right: nil, }, }, } values := make([]string, 0) fmt.Println(\"按层: \", LevelOrderTraversal(node, values)) } 结果为： console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"data_structures_and_algorithms/consistent_hash.html":{"url":"data_structures_and_algorithms/consistent_hash.html","title":"consistency_hash","keywords":"","body":"一致性 hash 解决的问题 一致性哈希算法解决了普通余数 Hash 算法伸缩性差的问题，可以保证在上线、下线服务器的情况下尽量有多的请求命中原来路由到的服务器。 优化 一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。可以通过通过增加虚拟节点来解决数据倾斜问题。 如果存在大量的虚拟节点，节点的查找性能就成为必须考虑的因数。可以使用红黑树 来加快查找速度， 参考 https://blog.csdn.net/suifeng629/article/details/81567777 https://segmentfault.com/a/1190000021199728 http://jintang.zone/2018/08/20/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%8E%AF%E5%8F%8A%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95.html console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"data_structures_and_algorithms/常见缓存淘汰策略.html":{"url":"data_structures_and_algorithms/常见缓存淘汰策略.html","title":"常见缓存淘汰策略","keywords":"","body":"常见缓存淘汰策略 FIFO First In First Out(FIFO)，先进先出，也就是淘汰缓存中最老(最早添加)的记录。FIFO 认为，最早添加的记录，其不再被使用的可能性比刚添加的可能性大。这种算法的实现也非常简单，创建一个队列，新增记录添加到队尾， 每次内存不够时，淘汰队首。但是很多场景下，部分记录虽然是最早添加但也最常被访问，而不得不因为呆的时间太长而被淘汰。这类数据会被频繁地添加进缓存，又被淘汰出去，导致缓存命中率降低。 LFU Least Frequently Used(LFU)，最少使用，也就是淘汰缓存中访问频率最低的记录。LFU 认为，如果数据过去被访问多次， 那么将来被访问的频率也更高。LFU 的实现需要维护一个按照访问次数排序的队列，每次访问，访问次数加1，队列重新排序， 淘汰时选择访问次数最少的即可。LFU 算法的命中率是比较高的，但缺点也非常明显，维护每个记录的访问次数，对内存的消耗是很高的； 另外，如果数据的访问模式发生变化，LFU 需要较长的时间去适应，也就是说 LFU 算法受历史数据的影响比较大。例如某个数据历史上访问次数奇高，但在某个时间点之后几乎不再被访问，但因为历史访问次数过高，而迟迟不能被淘汰。 LRU Least Recently Used(LRU)，最近最少使用，相对于仅考虑时间因素的 FIFO 和仅考虑访问频率的 LFU，LRU 算法可以认为是相对平衡的 一种淘汰算法。LRU 认为，如果数据最近被访问过，那么将来被访问的概率也会更高。LRU 算法的实现非常简单，维护一个队列，如果某条记录被访问了， 则移动到队尾，那么队首则是最近最少访问的数据，淘汰该条记录即可。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"memo.html":{"url":"memo.html","title":"备忘","keywords":"","body":"备忘录 在线书籍 build-web-application-with-golang Mastering_Go golang 修养之路 工具收藏 navicat premium15破解教程 文章收藏 go1.16 embed 用法 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"developer_manual/googe-plugin-download.html":{"url":"developer_manual/googe-plugin-download.html","title":"google浏览器插件下载到本地","keywords":"","body":"将google浏览器插件下载到本地 国内的网络太复杂了，在不能访问 google 的情况下，甚至都不能打开网上应用商店，所以我们需要一个方便的方式来下载google浏览器插件并分享 给需要的小伙伴。 我们打开任意一个浏览器插件，如： URL 地址栏中有一串字符串，这是唯一的，通过这个字符串可以获取到插件的下载地址，如： 下载地址为： https://clients2.google.com/service/update2/crx?response=redirect&os=win&arch=x64&os_arch=x86_64&nacl_arch=x86-64&prod=chromecrx&prodchannel=&prodversion=77.0.3865.90&lang=zh-CN&acceptformat=crx2,crx3&x=id%3D{XXXX}%26installsource%3Dondemand%26uc 将以上的 {XXXX} 替换为插件的 ID，就可以下载到本地了。 以下这个地址是Mote：语音笔记和反馈插件的下载地址，成功下载的插件是 .crx 结尾的文件。直接拖到浏览器中就会自动安装。 https://clients2.google.com/service/update2/crx?response=redirect&os=win&arch=x64&os_arch=x86_64&nacl_arch=x86-64&prod=chromecrx&prodchannel=&prodversion=77.0.3865.90&lang=zh-CN&acceptformat=crx2,crx3&x=id%3Dajphlblkfpppdpkgokiejbjfohfohhmk%26installsource%3Dondemand%26uc console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}