<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法与数学 on xiaobinqt 博客 - 技术改变生活</title>
    <link>https://www.xiaobinqt.cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/</link>
    <description>Recent content in 算法与数学 on xiaobinqt 博客 - 技术改变生活</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <managingEditor>xiaobinqt@163.com (xiaobinqt)</managingEditor>
    <webMaster>xiaobinqt@163.com (xiaobinqt)</webMaster>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sat, 03 Dec 2022 00:04:55 +0800</lastBuildDate>
    <atom:link href="https://www.xiaobinqt.cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>一致性哈希算法</title>
      <link>https://www.xiaobinqt.cn/consistent-hash/</link>
      <pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/consistent-hash/</guid>
      <description>&lt;!-- author： xiaobinqt --&gt;&#xA;&lt;!-- email： xiaobinqt@163.com --&gt;&#xA;&lt;!-- https://xiaobinqt.github.io --&gt;&#xA;&lt;!-- https://www.xiaobinqt.cn --&gt;&#xA;&lt;h2 id=&#34;如何分配请求&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#%e5%a6%82%e4%bd%95%e5%88%86%e9%85%8d%e8%af%b7%e6%b1%82&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;1 如何分配请求&lt;/h2&gt;&lt;p&gt;大多数网站背后肯定不是只有一台服务器提供服务，因为单机的并发量和数据量都是有限的，所以都会用多台服务器构成集群来对外提供服务。但是这样的话，问题就来了，现在有那么多个节点（后文统称服务器为节点），要如何分配客户端的请求呢&amp;#x2753;&lt;/p&gt;</description>
    </item>
    <item>
      <title>常见缓存淘汰策略</title>
      <link>https://www.xiaobinqt.cn/common-cache-strategies/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/common-cache-strategies/</guid>
      <description>&lt;h2 id=&#34;fifo&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#fifo&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;1 FIFO&lt;/h2&gt;&lt;p&gt;First In First Out(FIFO)，先进先出，也就是淘汰缓存中最老(最早添加)的记录。FIFO 认为，最早添加的记录，其不再被使用的可能性比刚添加的可能性大。这种算法的实现也非常简单，创建一个队列，新增记录添加到队尾， 每次内存不够时，淘汰队首。但是很多场景下，部分记录虽然是最早添加但也最常被访问，而不得不因为呆的时间太长而被淘汰。这类数据会被频繁地添加进缓存，又被淘汰出去，导致缓存命中率降低。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
