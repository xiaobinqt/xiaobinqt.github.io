<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - xiaobinqt 博客 - 技术改变生活</title>
        <link>https://www.xiaobinqt.cn/posts/</link>
        <description>所有文章 | xiaobinqt 博客 - 技术改变生活</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaobinqt@163.com (xiaobinqt)</managingEditor>
            <webMaster>xiaobinqt@163.com (xiaobinqt)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 01 Jun 2024 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://www.xiaobinqt.cn/posts/" rel="self" type="application/rss+xml" /><item>
    <title>纪念一位老友</title>
    <link>https://www.xiaobinqt.cn/old-pal/</link>
    <pubDate>Wed, 16 Mar 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/old-pal/</guid>
    <description><![CDATA[<p>几年前，一位好朋友去世了，九零后，跟我年纪一样。我跟他从小就认识，我们一起上的小学，一起上的初中，高中之后便联系的少了，后来我去外地读书，联系的就更少了。</p>
<p>那还是二零一九，那时我刚从西安来北京。一天夜里，都很晚了，我妈打电话跟我说，他去世了，好像是心梗，让我在外面多注意身体。天啊，当我听到这个消息的时候，我简直不敢相信，我反复确认了几次，无疑的确是他。</p>
<p>那晚我很难过，因为我不久之前还见过他。二零一九的春节，那天应该是初二的早晨，我骑着电瓶车去外公家拜年，外公家跟他老家离的不远，就几步路，那天早晨我在路边看到了他，我没有停下来，心想就几步路，我回来的时候再去找他，但是等我再往回走的时候他就不在家了。如今听到噩耗，再想起这件事，我真的特别后悔当时应该停下来见他一面。后来，我把这件事说给我女朋友听，她也特别感慨的说，想做什么事一定要赶紧去做。是啊，一定要赶紧去做，毕竟世事无常。</p>
<p>我跟他太久没有联系了，没有他的电话，也没有他的微信，后来在QQ 里找到他的联系方式。我尝试着发了一条消息过去，QQ 的那边，他媳妇回了一条消息，说他人已经不在了。后来有个初中同学联系到了我，是他班上的，建了一个微信群，想尽点绵薄之力，我们一人凑了点钱，由一个在老家的同学给他家里送了去，但他妈妈只是领了我们的心意。他实在是太年轻了，而且新婚不久，孩子才一岁。</p>
<blockquote>
<p>这张照片是上初中时我们一起去皖南事变烈士陵园拍的，也是我跟他唯一的一张合影。
<br>2020 年时家里发大水，家里的东西都泡水了，这张照片后来也不知所踪。</p>
</blockquote>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220319/e2f71ad4eb9f47b5a2d753c8686271a6.jpg?imageView2/0/interlace/1/q/50%7cimageslim" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220319/e2f71ad4eb9f47b5a2d753c8686271a6.jpg?imageView2/0/interlace/1/q/50|imageslim" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220319/e2f71ad4eb9f47b5a2d753c8686271a6.jpg?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2>左三是他</h2>">
        
    </a><figcaption class="image-caption">左三是他</figcaption>
    </figure></p>
<p>有一次我回家，我爸还跟我说在一次婚宴上见过他。他过世后，一次在我大舅家吃饭的时候，他家的一个亲戚也在，在聊起他的时候，直夸他在外面干活能吃苦，人不错。</p>
<p>我跟他从小相识，一起在村小学读书，一起在田埂上疯跑，他教我掏鸟窝，网知了，在我眼里，他好像什么都会，他教了我很多技能，带给我很多快乐。上初中的时候，我跟他一起骑车上学，放学也一起回家。他每天早上都是骑着车来我外婆家等我，等我吃完早饭一起走，一路上我们有好几个同学都一起。下午放学他有时也在我外婆家跟我一起做完作业才回家，这些事如今历历在目，但是他却永远不在了。</p>
<p>也许是年纪大了，不知不觉对有些事越来越伤感。几次提笔想写点什么，但是每次都写不出来，心里总记挂这件事，可能是那次我没有停下来见他吧。</p>
<br>
<div id="id-1">2021年10月15日完</div>
]]></description>
</item><item>
    <title>老表，这是一个家具测试</title>
    <link>https://www.xiaobinqt.cn/furniture/</link>
    <pubDate>Sat, 01 Jun 2024 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/furniture/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<meting-js url="/music/Wavelength.mp3" name="Wavelength" artist="oldmanyoung" cover="/music/Wavelength.webp" theme="#448aff"></meting-js>
<p><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20240601/c27a69b7189c4eb485c021cf8587eef1.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="家具1" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20240601/c27a69b7189c4eb485c021cf8587eef1.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15">
        
    </a></p>
<p><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20240601/e168f29ff5394a6ba53bf3a536538631.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="家具2" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20240601/e168f29ff5394a6ba53bf3a536538631.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15">
        
    </a></p>
]]></description>
</item><item>
    <title>各种音乐文件格式转 MP3</title>
    <link>https://www.xiaobinqt.cn/multi-format-convert-mp3/</link>
    <pubDate>Mon, 16 Oct 2023 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/multi-format-convert-mp3/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="mgg" class="headerLink">
    <a href="#mgg" class="header-mark"></a>mgg</h2><p>我的 qq 音乐桌面播放器版本是 1951，下载下来的音乐格式是 mgg 格式的。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/256c0eddcd2e4f76a4e0f6215dd9455d.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/256c0eddcd2e4f76a4e0f6215dd9455d.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/256c0eddcd2e4f76a4e0f6215dd9455d.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>qq music version</h2>">
        
    </a><figcaption class="image-caption">qq music version</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/943f3b65ff8d4590b0796a8d9195435c.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/943f3b65ff8d4590b0796a8d9195435c.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/943f3b65ff8d4590b0796a8d9195435c.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>mgg</h2>">
        
    </a><figcaption class="image-caption">mgg</figcaption>
    </figure></p>
<p>如何将 mgg 格式转 mgg 格式转成 MP3 格式呢❓ mgg 文件暂时不支持直接转成 mp3，可以先把 mgg 文件转成 ogg 文件，再把 ogg 文件转成 mp3 文件。</p>
<ol>
<li>先用工具将 mgg 文件转成 ogg 文件，可以通过在线工具 <a href="https://openyyy.com/" target="_blank" rel="noopener noreferrer">OpenYYY - https://openyyy.com/</a></li>
</ol>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/4933322bfc504a7e82574c67472f533d.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/4933322bfc504a7e82574c67472f533d.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/4933322bfc504a7e82574c67472f533d.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>转 ogg</h2>">
        
    </a><figcaption class="image-caption">转 ogg</figcaption>
    </figure></p>
<ol start="2">
<li>下载 ogg 文件，通过 ffmpeg 将 ogg 转成 mp3，命令为 <code>ffmpeg -i ogg文件 输出mp3文件</code>，下面的示例中，将老鼠爱大米的 ogg 转成了 mp3 文件：</li>
</ol>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/587e2afcba774a5cba89c2d302568ef4.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/587e2afcba774a5cba89c2d302568ef4.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/587e2afcba774a5cba89c2d302568ef4.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>ogg convert mp3</h2>">
        
    </a><figcaption class="image-caption">ogg convert mp3</figcaption>
    </figure></p>
<p>转之后的 mp3 文件用播放器可以正常播放：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/004eaea8e54d47318ada684c393edf8c.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/004eaea8e54d47318ada684c393edf8c.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/004eaea8e54d47318ada684c393edf8c.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>正常播放</h2>">
        
    </a><figcaption class="image-caption">正常播放</figcaption>
    </figure></p>
<p><strong>ffmpeg 的在线工具</strong>可以使用 <a href="https://ffmpeg-online.vercel.app/" target="_blank" rel="noopener noreferrer">https://ffmpeg-online.vercel.app/</a></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/388e4e1179d9419393db7cf133dcb450.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/388e4e1179d9419393db7cf133dcb450.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/388e4e1179d9419393db7cf133dcb450.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>ffmpeg 在线工具</h2>">
        
    </a><figcaption class="image-caption">ffmpeg 在线工具</figcaption>
    </figure></p>
<h2 id="kgm" class="headerLink">
    <a href="#kgm" class="header-mark"></a>kgm</h2><p>可以使用在线工具 <a href="https://kgm.worthsee.com/" target="_blank" rel="noopener noreferrer">https://kgm.worthsee.com/</a></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231018/8ba18c7c22ef41ff8e2b3c52ccad0dd5.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231018/8ba18c7c22ef41ff8e2b3c52ccad0dd5.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231018/8ba18c7c22ef41ff8e2b3c52ccad0dd5.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>kgm</h2>">
        
    </a><figcaption class="image-caption">kgm</figcaption>
    </figure></p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://askubuntu.com/questions/442997/how-can-i-convert-audio-from-ogg-to-mp3" target="_blank" rel="noopener noreferrer">How can I convert audio from ogg to mp3?</a></li>
<li><a href="https://linuxhint.com/install-ffmpeg-ubuntu22-04/" target="_blank" rel="noopener noreferrer">How to Install FFmpeg on Ubuntu 22.04?</a></li>
</ul>
]]></description>
</item><item>
    <title>记一次 MySQL 8.0 JSON 查询</title>
    <link>https://www.xiaobinqt.cn/mysql-json-like-search/</link>
    <pubDate>Thu, 12 Oct 2023 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/mysql-json-like-search/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<p>有 2 张表，一张 tag 表，主要字段有 id，name。一张 channel 表，有个 tags 字段，存 tag 表中 id，如：<code>[1,5]</code>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/972fed7bb89b4b57824d8ac62c4f226e.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/972fed7bb89b4b57824d8ac62c4f226e.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/972fed7bb89b4b57824d8ac62c4f226e.png" data-sub-html="<h2>tags</h2>">
        
    </a><figcaption class="image-caption">tags</figcaption>
    </figure></p>
<p>现在的需求是，通过 channel 表可以支持模糊搜索 tag 的 name，比如 tag 表中的数据如下：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/753d023454524eb58b26a043e24c59ef.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/753d023454524eb58b26a043e24c59ef.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/753d023454524eb58b26a043e24c59ef.png" data-sub-html="<h2>tag</h2>">
        
    </a><figcaption class="image-caption">tag</figcaption>
    </figure></p>
<p>channel 表中的某条数据的 tags 字段的值是 <code>[5,6]</code>，那我就可以通过搜索 <code>测试系统</code> 找到这条 channel 数据。</p>
<p>首先，可以使用 JSON 函数来解析 <code>tags</code> 列，然后再连接 <code>tag</code> 表以匹配 <code>id</code>。以下是一个示例 SQL 查询：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="k">c</span><span class="p">.</span><span class="o">*</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">channel</span><span class="w"> </span><span class="k">c</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="k">INNER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">tag</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">JSON_CONTAINS</span><span class="p">(</span><span class="k">c</span><span class="p">.</span><span class="n">tags</span><span class="p">,</span><span class="w"> </span><span class="k">CAST</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">JSON</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;%your_search_query%&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个查询的步骤是：</p>
<ol>
<li><code>FROM channel c</code>：从 <code>channel</code> 表中选择数据。</li>
<li><code>INNER JOIN tag t ON JSON_CONTAINS(c.tags, CAST(t.id AS JSON))</code>：将 <code>channel</code> 表与 <code>tag</code> 表连接，其中 <code>JSON_CONTAINS</code> 用于检查 <code>tag</code> 是否在 <code>channel</code> 的 JSON 数组中。</li>
<li><code>WHERE t.name LIKE '%your_search_query%'</code>：在连接后的结果中，使用 <code>LIKE</code> 子句来执行模糊匹配。</li>
</ol>
<p>在上面的查询中，可以将 <code>%your_search_query%</code> 替换为想搜索的标签名称的部分。这将返回包含匹配的 <code>tag</code> 名称的结果集。</p>
<p>当在 SQL 中处理 JSON 数据时，可能需要将数据转换为 JSON 类型以进行比较或操作。在查询中，<code>JSON_CONTAINS(c.tags, CAST(t.id AS JSON))</code> 是一个用于检查 JSON 数组中是否包含特定值的 SQL 表达式。</p>
<p>以下是对这个表达式的详细解释：</p>
<ol>
<li>
<p><strong>CAST(t.id AS JSON)</strong>：这部分将 <code>t.id</code> 转换为 JSON 数据类型。在 SQL 中，<code>CAST</code> 函数用于将一个数据类型转换为另一个数据类型。在这里，<code>t.id</code> 是整数类型，通过 <code>CAST(t.id AS JSON)</code>，它被显式地转换为 JSON 类型。这是因为 <code>c.tags</code> 是一个 JSON 数据类型，所以需要确保进行比较的值也是 JSON 类型。</p>
</li>
<li>
<p><strong>JSON_CONTAINS(c.tags, CAST(t.id AS JSON))</strong>：这是主要的比较部分。<code>JSON_CONTAINS</code> 函数用于检查一个 JSON 数组（在这里是 <code>c.tags</code>）是否包含特定值（在这里是 <code>t.id</code> 的 JSON 表示）。如果 <code>c.tags</code> 包含 <code>t.id</code> 的 JSON 表示，它将返回 true；否则，返回 false。这就允许查找 <code>channel</code> 表中具有特定 <code>tag</code> 的记录。</p>
</li>
</ol>
<p>再用一个示例来解释这个过程：</p>
<p>假设 <code>channel</code> 表的某一行的 <code>tags</code> 列中包含 JSON 数组 <code>[1, 3, 5]</code>，想查找所有包含 <code>tag</code> 表中 <code>id</code> 为 3 的记录。</p>
<ul>
<li><code>CAST(t.id AS JSON)</code> 将 <code>t.id</code>（3）转换为 JSON 数据类型，变成 <code>3</code>。</li>
<li><code>JSON_CONTAINS(c.tags, 3)</code> 将检查 <code>tags</code> 列中是否包含值为 3 的元素。</li>
<li>因为 <code>[1, 3, 5]</code> 包含值 3，所以这个表达式将返回 true。</li>
</ul>
<p>这就是如何使用 <code>CAST</code> 函数和 <code>JSON_CONTAINS</code> 函数来进行 JSON 数据的比较和查询。在这个例子中，它允许在 <code>channel</code> 表中查找包含特定 <code>tag</code> 的记录。</p>
]]></description>
</item><item>
    <title>Go channel 使用分析</title>
    <link>https://www.xiaobinqt.cn/go-channel-principle/</link>
    <pubDate>Wed, 11 Oct 2023 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/go-channel-principle/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="概念" class="headerLink">
    <a href="#%e6%a6%82%e5%bf%b5" class="header-mark"></a>概念</h2><p>Go 中的 channel 是一个队列，遵循先进先出的原则，负责协程之间的通信。Go 语言提倡不要通过共享内存来通信，而要通过通信来实现内存共享，CSP（Communicating Sequential Process）并发模型，就是通过 goroutine 和 channel 来实现的。</p>
<p>channel 常用的使用场景有：</p>
<ul>
<li>
<p>停止信号监听</p>
</li>
<li>
<p>定时任务</p>
</li>
<li>
<p>生产方和消费方解耦</p>
</li>
<li>
<p>控制并发数</p>
</li>
</ul>
<h2 id="数据结构" class="headerLink">
    <a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="header-mark"></a>数据结构</h2><p>通过 var 声明或者 make 函数创建的 channel 变量是一个存储在函数栈帧上的指针，占用 8 个字节，指向堆上的 hchan 结构体。源码包中 src/runtime/chan.go 定义了 hchan 的数据结构：</p>
<div align="center"></div>
<p>hchan结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type hchan struct {
</span></span><span class="line"><span class="cl">	closed   uint32 // channel是否关闭的标志
</span></span><span class="line"><span class="cl">	elemtype *_type // channel中的元素类型，
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// channel分为无缓冲和有缓冲两种。
</span></span><span class="line"><span class="cl">	// 对于有缓冲的 channel 存储数据，使用了 ring buffer（环形缓冲区) 来缓存写入的数据，本质是循环数组
</span></span><span class="line"><span class="cl">	// 为啥是循环数组？普通数组不行吗，普通数组容量固定更适合指定的空间，弹出元素时，普通数组需要全部都前移
</span></span><span class="line"><span class="cl">	// 当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置
</span></span><span class="line"><span class="cl">	buf      unsafe.Pointer // 指向底层循环数组的指针（环形缓冲区）
</span></span><span class="line"><span class="cl">	qcount   uint           // 循环数组中的元素数量
</span></span><span class="line"><span class="cl">	dataqsiz uint           // 循环数组的长度
</span></span><span class="line"><span class="cl">	elemsize uint16         // 元素的大小
</span></span><span class="line"><span class="cl">	sendx    uint           // 下一次写下标的位置
</span></span><span class="line"><span class="cl">	recvx    uint           // 下一次读下标的位置
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// 尝试读取 channel 或向 channel 写入数据而被阻塞的goroutine
</span></span><span class="line"><span class="cl">	recvq waitq // 读等待队列
</span></span><span class="line"><span class="cl">	sendq waitq // 写等待队列
</span></span><span class="line"><span class="cl">	lock  mutex //互斥锁，保证读写 channel 时不存在并发竞争问题
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>等待队列：</p>
<p>双向链表，包含一个头结点和一个尾结点。每个节点是一个 sudog 结构体变量，记录哪个协程在等待，等待的是哪个 channel，等待发送/接收的数据在哪里。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type waitq struct {
</span></span><span class="line"><span class="cl">	first *sudog
</span></span><span class="line"><span class="cl">	last  *sudog
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">type sudog struct {
</span></span><span class="line"><span class="cl">	g    *g
</span></span><span class="line"><span class="cl">	next *sudog
</span></span><span class="line"><span class="cl">	prev *sudog
</span></span><span class="line"><span class="cl">	elem unsafe.Pointer
</span></span><span class="line"><span class="cl">	c    *hchan
</span></span><span class="line"><span class="cl">	// ...
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="创建" class="headerLink">
    <a href="#%e5%88%9b%e5%bb%ba" class="header-mark"></a>创建</h3><p>使用 make(chan T, cap) 来创建 channel，make 语法会在编译时，转换为 makechan64 和 makechan</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func makechan64(t *chantype, size int64) *hchan {
</span></span><span class="line"><span class="cl">	if int64(int(size)) != size {
</span></span><span class="line"><span class="cl">		panic(plainError(&#34;makechan: size out of range&#34;))
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	return makechan(t, int(size))
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建 channel 有两种，一种是带缓冲的 channel，一种是不带缓冲的 channel</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 带缓冲
</span></span><span class="line"><span class="cl">ch := make(chan int, 3)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 不带缓冲
</span></span><span class="line"><span class="cl">ch := make(chan int)
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建时会做一些检查:</p>
<ul>
<li>
<p>元素大小不能超过 64K</p>
</li>
<li>
<p>元素的对齐大小不能超过 maxAlign 也就是 8 字节</p>
</li>
<li>
<p>计算出来的内存是否超过限制</p>
</li>
</ul>
<p>创建时的策略:</p>
<ul>
<li>
<p>如果是无缓冲的 channel，会直接给 hchan 分配内存</p>
</li>
<li>
<p>如果是有缓冲的 channel，并且元素不包含指针，那么会为 hchan 和底层数组分配一段连续的地址</p>
</li>
<li>
<p>如果是有缓冲的 channel，并且元素包含指针，那么会为 hchan 和底层数组分别分配地址</p>
</li>
</ul>
<h3 id="发送" class="headerLink">
    <a href="#%e5%8f%91%e9%80%81" class="header-mark"></a>发送</h3><p>发送操作，编译时转换为 runtime.chansend 函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool
</span></span></code></pre></td></tr></table>
</div>
</div><p>阻塞式：</p>
<p>调用 chansend 函数，并且 block=true</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ch &lt;- 10
</span></span></code></pre></td></tr></table>
</div>
</div><p>非阻塞式：</p>
<p>调用 chansend 函数，并且 block=false</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">select {
</span></span><span class="line"><span class="cl">    case ch &lt;- 10:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    default:
</span></span><span class="line"><span class="cl"> }
</span></span></code></pre></td></tr></table>
</div>
</div><p>向 channel 中发送数据时大概分为两大块：检查和数据发送，数据发送流程如下：</p>
<ul>
<li>
<p>如果 channel 的读等待队列存在接收者goroutine</p>
<ul>
<li>将数据<strong>直接发送</strong>给第一个等待的 goroutine，<strong>唤醒接收的 goroutine</strong></li>
</ul>
</li>
<li>
<p>如果 channel 的读等待队列不存在接收者 goroutine</p>
<ul>
<li>
<p>如果循环数组 buf 未满，那么将会把数据发送到循环数组buf的队尾</p>
</li>
<li>
<p>如果循环数组 buf 已满，这个时候就会走阻塞发送的流程，将当前 goroutine 加入写等待队列，并<strong>挂起等待唤醒</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="接收" class="headerLink">
    <a href="#%e6%8e%a5%e6%94%b6" class="header-mark"></a>接收</h3><p>接收操作，编译时转换为 runtime.chanrecv 函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool)
</span></span></code></pre></td></tr></table>
</div>
</div><p>阻塞式：</p>
<p>调用 chanrecv 函数，并且 block=true</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&lt;-ch
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">v := &lt;-ch
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">v, ok := &lt;-ch
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 当 channel 关闭时，for 循环会自动退出，无需主动监测 channel 是否关闭，可以防止读取已经关闭的 channel,造成读到数据为通道所存储的数据类型的零值
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">for i := range ch {
</span></span><span class="line"><span class="cl">	fmt.Println(i)
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>非阻塞式：</p>
<p>调用 chanrecv 函数，并且 block=false</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">select {
</span></span><span class="line"><span class="cl">    case &lt;-ch:
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    default
</span></span><span class="line"><span class="cl">  }
</span></span></code></pre></td></tr></table>
</div>
</div><p>向 channel 中接收数据时大概分为两大块，检查和数据发送，而数据接收流程如下：</p>
<ul>
<li>
<p>如果 channel 的写等待队列存在发送者 goroutine</p>
<ul>
<li>
<p>如果是无缓冲 channel，<strong>直接</strong>从第一个发送者 goroutine 那里把数据拷贝给接收变量，<strong>唤醒发送的 goroutine</strong></p>
</li>
<li>
<p>如果是有缓冲 channel（已满），将循环数组buf的队首元素拷贝给接收变量，将第一个发送者 goroutine 的数据拷贝到 buf循 环数组队尾，<strong>唤醒发送的 goroutine</strong></p>
</li>
</ul>
</li>
<li>
<p>如果 channel 的写等待队列不存在发送者 goroutine</p>
<ul>
<li>
<p>如果循环数组 buf 非空，将循环数组 buf 的队首元素拷贝给接收变量</p>
</li>
<li>
<p>如果循环数组 buf 为空，这个时候就会走阻塞接收的流程，将当前 goroutine 加入读等待队列，并<strong>挂起等待唤醒</strong></p>
</li>
</ul>
</li>
</ul>
<p><strong>关闭</strong></p>
<p>关闭操作，调用 close 函数，编译时转换为 runtime.closechan 函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">close(ch)
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func closechan(c *hchan)
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>案例分析：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;unsafe&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ch 是长度为 4 的带缓冲的 channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//初始 hchan 结构体重的 buf 为空，sendx 和 recvx 均为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ch</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">ch</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">sendTask</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">receiveTask</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// G1 是发送者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 当 G1 向 ch 里发送数据时，首先会对 buf 加锁，然后将 task 存储的数据 copy 到 buf 中，然后 sendx++，然后释放对 buf 的锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">sendTask</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">taskList</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;this&#34;</span><span class="p">,</span> <span class="s">&#34;is&#34;</span><span class="p">,</span> <span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;demo&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">task</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">taskList</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">task</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//发送任务到 channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// G2 是接收者
</span></span></span><span class="line"><span class="cl"><span class="c1">// 当 G2 消费 ch 的时候，会首先对 buf 加锁，然后将 buf 中的数据 copy 到 task 变量对应的内存里，然后 recvx++,并释放锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">receiveTask</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">task</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//接收任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;received&#34;</span><span class="p">,</span> <span class="nx">task</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//处理任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>hchan 结构体的主要组成部分有四个：</p>
<ul>
<li>
<p>用来保存 goroutine 之间传递数据的循环数组：buf</p>
</li>
<li>
<p>用来记录此循环数组当前发送或接收数据的下标值：sendx 和 recvx</p>
</li>
<li>
<p>用于保存向该 chan 发送和从该 chan 接收数据被阻塞的 goroutine 队列： sendq 和 recvq</p>
</li>
<li>
<p>保证 channel 写入和读取数据时线程安全的锁：lock</p>
</li>
</ul>
<h2 id="特点" class="headerLink">
    <a href="#%e7%89%b9%e7%82%b9" class="header-mark"></a>特点</h2><p>channel 有 2 种类型：无缓冲、有缓冲</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/bfb659b1a9aa4a05b86ef43ae0090a86.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/bfb659b1a9aa4a05b86ef43ae0090a86.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/bfb659b1a9aa4a05b86ef43ae0090a86.png" data-sub-html="<h2>有无缓冲</h2>">
        
    </a><figcaption class="image-caption">有无缓冲</figcaption>
    </figure></p>
<p>channel 有 3 种模式：写操作模式（单向通道）、读操作模式（单向通道）、读写操作模式（双向通道）</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/77e1a773bb3c4b5cb64c2fea9ce00876.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/77e1a773bb3c4b5cb64c2fea9ce00876.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/77e1a773bb3c4b5cb64c2fea9ce00876.png" data-sub-html="<h2>模式</h2>">
        
    </a><figcaption class="image-caption">模式</figcaption>
    </figure></p>
<p>channel有 3 种状态：未初始化、正常、关闭</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/307a5fbdc807419db471dd49cbe3f920.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/307a5fbdc807419db471dd49cbe3f920.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/307a5fbdc807419db471dd49cbe3f920.png" data-sub-html="<h2>状态</h2>">
        
    </a><figcaption class="image-caption">状态</figcaption>
    </figure></p>
<p><strong>注意点</strong>：</p>
<ol>
<li>
<p>一个 channel不能多次关闭，会导致 panic</p>
</li>
<li>
<p>如果多个 goroutine 都监听同一个 channel，那么 channel 上的数据都<strong>可能随机被某一个 goroutine 取走进行消费</strong></p>
</li>
<li>
<p>如果多个 goroutine 监听同一个 channel，如果这个 channel 被关闭，则所有 goroutine <strong>都能收到退出信号</strong></p>
</li>
</ol>
<h3 id="线程安全" class="headerLink">
    <a href="#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8" class="header-mark"></a>线程安全</h3><p>不同协程通过 channel 进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全。</p>
<p>channel 的底层实现中，hchan 结构体中采用 Mutex 锁来保证数据读写安全。在对循环数组 buf 中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作 channel 数据。</p>
<h3 id="控制并发顺序" class="headerLink">
    <a href="#%e6%8e%a7%e5%88%b6%e5%b9%b6%e5%8f%91%e9%a1%ba%e5%ba%8f" class="header-mark"></a>控制并发顺序</h3><p>多个 goroutine 并发执行时，每一个 goroutine 抢到处理器的时间点不一致，goroutine 的执行本身不能保证顺序。goroutine 并不能保证先执行。</p>
<p>可以使用 channel 进行通信通知，用 channel 去传递信息，从而控制并发执行顺序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch3</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch1</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">myPrint</span><span class="p">(</span><span class="s">&#34;gorouine1&#34;</span><span class="p">,</span> <span class="nx">ch1</span><span class="p">,</span> <span class="nx">ch2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">myPrint</span><span class="p">(</span><span class="s">&#34;gorouine2&#34;</span><span class="p">,</span> <span class="nx">ch2</span><span class="p">,</span> <span class="nx">ch3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">myPrint</span><span class="p">(</span><span class="s">&#34;gorouine3&#34;</span><span class="p">,</span> <span class="nx">ch3</span><span class="p">,</span> <span class="nx">ch1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">end</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;duration:%d\n&#34;</span><span class="p">,</span> <span class="nx">end</span><span class="o">-</span><span class="nx">start</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">myPrint</span><span class="p">(</span><span class="nx">gorouine</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">inputchan</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="nx">outchan</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 模拟内部操作耗时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">inputchan</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">gorouine</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">outchan</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">gorouine1
</span></span><span class="line"><span class="cl">gorouine2
</span></span><span class="line"><span class="cl">gorouine3
</span></span><span class="line"><span class="cl">duration:1
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="死锁问题" class="headerLink">
    <a href="#%e6%ad%bb%e9%94%81%e9%97%ae%e9%a2%98" class="header-mark"></a>死锁问题</h2><p><strong>死锁：</strong></p>
<ul>
<li>
<p>单个协程永久阻塞</p>
</li>
<li>
<p>两个或两个以上的协程的执行过程中，由于竞争资源或由于彼此通信而造成的一种阻塞的现象。</p>
</li>
</ul>
<p><strong>channel 死锁场景：</strong></p>
<ul>
<li>
<p>非缓存 channel 只写不读</p>
</li>
<li>
<p>非缓存 channel 读在写后面</p>
</li>
<li>
<p>缓存 channel 写入超过缓冲区数量</p>
</li>
<li>
<p>空读</p>
</li>
<li>
<p>多个协程互相等待</p>
</li>
</ul>
<ol>
<li>非缓存 channel 只写不读</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func deadlock1() {
</span></span><span class="line"><span class="cl">	ch := make(chan int)
</span></span><span class="line"><span class="cl">	ch &lt;- 3 //  这里会发生一直阻塞的情况，执行不到下面一句
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>非缓存 channel 读在写后面</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func deadlock2() {
</span></span><span class="line"><span class="cl">	ch := make(chan int)
</span></span><span class="line"><span class="cl">	ch &lt;- 3 //  这里会发生一直阻塞的情况，执行不到下面一句
</span></span><span class="line"><span class="cl">	num := &lt;-ch
</span></span><span class="line"><span class="cl">	fmt.Println(&#34;num=&#34;, num)
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func deadlock2() {
</span></span><span class="line"><span class="cl">	ch := make(chan int)
</span></span><span class="line"><span class="cl">	ch &lt;- 100 //  这里会发生一直阻塞的情况，执行不到下面一句
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	go func() {
</span></span><span class="line"><span class="cl">		num := &lt;-ch
</span></span><span class="line"><span class="cl">		fmt.Println(&#34;num=&#34;, num)
</span></span><span class="line"><span class="cl">	}()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	time.Sleep(time.Second)
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>缓存 channel 写入超过缓冲区数量</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func deadlock3() {
</span></span><span class="line"><span class="cl">	ch := make(chan int, 3)
</span></span><span class="line"><span class="cl">	ch &lt;- 3
</span></span><span class="line"><span class="cl">	ch &lt;- 4
</span></span><span class="line"><span class="cl">	ch &lt;- 5
</span></span><span class="line"><span class="cl">	ch &lt;- 6 //  这里会发生一直阻塞的情况
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>空读</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func deadlock4() {
</span></span><span class="line"><span class="cl">	ch := make(chan int)
</span></span><span class="line"><span class="cl">	// ch := make(chan int, 1)
</span></span><span class="line"><span class="cl">	fmt.Println(&lt;-ch) //  这里会发生一直阻塞的情况
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="5">
<li><strong>多个协程互相等待</strong></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func deadlock5() {
</span></span><span class="line"><span class="cl">	ch1 := make(chan int)
</span></span><span class="line"><span class="cl">	ch2 := make(chan int)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// 互相等对方造成死锁
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	go func() {
</span></span><span class="line"><span class="cl">		for {
</span></span><span class="line"><span class="cl">			select {
</span></span><span class="line"><span class="cl">			case num := &lt;-ch1:
</span></span><span class="line"><span class="cl">				fmt.Println(&#34;num=&#34;, num)
</span></span><span class="line"><span class="cl">				ch2 &lt;- 100
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	for {
</span></span><span class="line"><span class="cl">		select {
</span></span><span class="line"><span class="cl">		case num := &lt;-ch2:
</span></span><span class="line"><span class="cl">			fmt.Println(&#34;num=&#34;, num)
</span></span><span class="line"><span class="cl">			ch1 &lt;- 300
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/weixin_45627369/article/details/127193703" target="_blank" rel="noopener noreferrer">golang——channel</a></li>
</ul>
]]></description>
</item></channel>
</rss>
