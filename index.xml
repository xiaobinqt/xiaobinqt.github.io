<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>xiaobinqt 博客 - 技术改变生活</title>
        <link>https://www.xiaobinqt.cn/</link>
        <description>xiaobinqt 博客,萧十一郎博客,php开发,go开发,服务器相关,Laravel等方面的知识,关注架构,elasticsearch,linux,php,mysql,redis,go领域,可以通过xiaobinqt.cn访问,可以通过 xiaobinqt.github.io 访问</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaobinqt@163.com (xiaobinqt)</managingEditor>
            <webMaster>xiaobinqt@163.com (xiaobinqt)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 16 Oct 2023 00:00:00 &#43;0000</lastBuildDate>
            <atom:link href="https://www.xiaobinqt.cn/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>纪念一位老友</title>
    <link>https://www.xiaobinqt.cn/old-pal/</link>
    <pubDate>Wed, 16 Mar 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/old-pal/</guid>
    <description><![CDATA[<p>几年前，一位好朋友去世了，九零后，跟我年纪一样。我跟他从小就认识，我们一起上的小学，一起上的初中，高中之后便联系的少了，后来我去外地读书，联系的就更少了。</p>
<p>那还是二零一九，那时我刚从西安来北京。一天夜里，都很晚了，我妈打电话跟我说，他去世了，好像是心梗，让我在外面多注意身体。天啊，当我听到这个消息的时候，我简直不敢相信，我反复确认了几次，无疑的确是他。</p>
<p>那晚我很难过，因为我不久之前还见过他。二零一九的春节，那天应该是初二的早晨，我骑着电瓶车去外公家拜年，外公家跟他老家离的不远，就几步路，那天早晨我在路边看到了他，我没有停下来，心想就几步路，我回来的时候再去找他，但是等我再往回走的时候他就不在家了。如今听到噩耗，再想起这件事，我真的特别后悔当时应该停下来见他一面。后来，我把这件事说给我女朋友听，她也特别感慨的说，想做什么事一定要赶紧去做。是啊，一定要赶紧去做，毕竟世事无常。</p>
<p>我跟他太久没有联系了，没有他的电话，也没有他的微信，后来在QQ 里找到他的联系方式。我尝试着发了一条消息过去，QQ 的那边，他媳妇回了一条消息，说他人已经不在了。后来有个初中同学联系到了我，是他班上的，建了一个微信群，想尽点绵薄之力，我们一人凑了点钱，由一个在老家的同学给他家里送了去，但他妈妈只是领了我们的心意。他实在是太年轻了，而且新婚不久，孩子才一岁。</p>
<blockquote>
<p>这张照片是上初中时我们一起去皖南事变烈士陵园拍的，也是我跟他唯一的一张合影。
<br>2020 年时家里发大水，家里的东西都泡水了，这张照片后来也不知所踪。</p>
</blockquote>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220319/e2f71ad4eb9f47b5a2d753c8686271a6.jpg?imageView2/0/interlace/1/q/50%7cimageslim" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220319/e2f71ad4eb9f47b5a2d753c8686271a6.jpg?imageView2/0/interlace/1/q/50|imageslim" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220319/e2f71ad4eb9f47b5a2d753c8686271a6.jpg?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2>左三是他</h2>">
        
    </a><figcaption class="image-caption">左三是他</figcaption>
    </figure></p>
<p>有一次我回家，我爸还跟我说在一次婚宴上见过他。他过世后，一次在我大舅家吃饭的时候，他家的一个亲戚也在，在聊起他的时候，直夸他在外面干活能吃苦，人不错。</p>
<p>我跟他从小相识，一起在村小学读书，一起在田埂上疯跑，他教我掏鸟窝，网知了，在我眼里，他好像什么都会，他教了我很多技能，带给我很多快乐。上初中的时候，我跟他一起骑车上学，放学也一起回家。他每天早上都是骑着车来我外婆家等我，等我吃完早饭一起走，一路上我们有好几个同学都一起。下午放学他有时也在我外婆家跟我一起做完作业才回家，这些事如今历历在目，但是他却永远不在了。</p>
<p>也许是年纪大了，不知不觉对有些事越来越伤感。几次提笔想写点什么，但是每次都写不出来，心里总记挂这件事，可能是那次我没有停下来见他吧。</p>
<br>
<div id="id-1">2021年10月15日完</div>
]]></description>
</item><item>
    <title>各种音乐文件格式转 MP3</title>
    <link>https://www.xiaobinqt.cn/multi-format-convert-mp3/</link>
    <pubDate>Mon, 16 Oct 2023 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/multi-format-convert-mp3/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="mgg" class="headerLink">
    <a href="#mgg" class="header-mark"></a>mgg</h2><p>我的 qq 音乐桌面播放器版本是 1951，下载下来的音乐格式是 mgg 格式的。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/256c0eddcd2e4f76a4e0f6215dd9455d.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/256c0eddcd2e4f76a4e0f6215dd9455d.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/256c0eddcd2e4f76a4e0f6215dd9455d.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>qq music version</h2>">
        
    </a><figcaption class="image-caption">qq music version</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/943f3b65ff8d4590b0796a8d9195435c.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/943f3b65ff8d4590b0796a8d9195435c.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/943f3b65ff8d4590b0796a8d9195435c.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>mgg</h2>">
        
    </a><figcaption class="image-caption">mgg</figcaption>
    </figure></p>
<p>如何将 mgg 格式转 mgg 格式转成 MP3 格式呢❓ mgg 文件暂时不支持直接转成 mp3，可以先把 mgg 文件转成 ogg 文件，再把 ogg 文件转成 mp3 文件。</p>
<ol>
<li>先用工具将 mgg 文件转成 ogg 文件，可以通过在线工具 <a href="https://openyyy.com/" target="_blank" rel="noopener noreferrer">OpenYYY - https://openyyy.com/</a></li>
</ol>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/4933322bfc504a7e82574c67472f533d.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/4933322bfc504a7e82574c67472f533d.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/4933322bfc504a7e82574c67472f533d.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>转 ogg</h2>">
        
    </a><figcaption class="image-caption">转 ogg</figcaption>
    </figure></p>
<ol start="2">
<li>下载 ogg 文件，通过 ffmpeg 将 ogg 转成 mp3，命令为 <code>ffmpeg -i ogg文件 输出mp3文件</code>，下面的示例中，将老鼠爱大米的 ogg 转成了 mp3 文件：</li>
</ol>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/587e2afcba774a5cba89c2d302568ef4.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/587e2afcba774a5cba89c2d302568ef4.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/587e2afcba774a5cba89c2d302568ef4.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>ogg convert mp3</h2>">
        
    </a><figcaption class="image-caption">ogg convert mp3</figcaption>
    </figure></p>
<p>转之后的 mp3 文件用播放器可以正常播放：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/004eaea8e54d47318ada684c393edf8c.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/004eaea8e54d47318ada684c393edf8c.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/004eaea8e54d47318ada684c393edf8c.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>正常播放</h2>">
        
    </a><figcaption class="image-caption">正常播放</figcaption>
    </figure></p>
<p><strong>ffmpeg 的在线工具</strong>可以使用 <a href="https://ffmpeg-online.vercel.app/" target="_blank" rel="noopener noreferrer">https://ffmpeg-online.vercel.app/</a></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/388e4e1179d9419393db7cf133dcb450.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/388e4e1179d9419393db7cf133dcb450.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231016/388e4e1179d9419393db7cf133dcb450.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>ffmpeg 在线工具</h2>">
        
    </a><figcaption class="image-caption">ffmpeg 在线工具</figcaption>
    </figure></p>
<h2 id="kgm" class="headerLink">
    <a href="#kgm" class="header-mark"></a>kgm</h2><p>可以使用在线工具 <a href="https://kgm.worthsee.com/" target="_blank" rel="noopener noreferrer">https://kgm.worthsee.com/</a></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231018/8ba18c7c22ef41ff8e2b3c52ccad0dd5.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231018/8ba18c7c22ef41ff8e2b3c52ccad0dd5.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231018/8ba18c7c22ef41ff8e2b3c52ccad0dd5.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>kgm</h2>">
        
    </a><figcaption class="image-caption">kgm</figcaption>
    </figure></p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://askubuntu.com/questions/442997/how-can-i-convert-audio-from-ogg-to-mp3" target="_blank" rel="noopener noreferrer">How can I convert audio from ogg to mp3?</a></li>
<li><a href="https://linuxhint.com/install-ffmpeg-ubuntu22-04/" target="_blank" rel="noopener noreferrer">How to Install FFmpeg on Ubuntu 22.04?</a></li>
</ul>
]]></description>
</item><item>
    <title>记一次 MySQL 8.0 JSON 查询</title>
    <link>https://www.xiaobinqt.cn/mysql-json-like-search/</link>
    <pubDate>Thu, 12 Oct 2023 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/mysql-json-like-search/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<p>有 2 张表，一张 tag 表，主要字段有 id，name。一张 channel 表，有个 tags 字段，存 tag 表中 id，如：<code>[1,5]</code>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/972fed7bb89b4b57824d8ac62c4f226e.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/972fed7bb89b4b57824d8ac62c4f226e.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/972fed7bb89b4b57824d8ac62c4f226e.png" data-sub-html="<h2>tags</h2>">
        
    </a><figcaption class="image-caption">tags</figcaption>
    </figure></p>
<p>现在的需求是，通过 channel 表可以支持模糊搜索 tag 的 name，比如 tag 表中的数据如下：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/753d023454524eb58b26a043e24c59ef.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/753d023454524eb58b26a043e24c59ef.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/753d023454524eb58b26a043e24c59ef.png" data-sub-html="<h2>tag</h2>">
        
    </a><figcaption class="image-caption">tag</figcaption>
    </figure></p>
<p>channel 表中的某条数据的 tags 字段的值是 <code>[5,6]</code>，那我就可以通过搜索 <code>测试系统</code> 找到这条 channel 数据。</p>
<p>首先，可以使用 JSON 函数来解析 <code>tags</code> 列，然后再连接 <code>tag</code> 表以匹配 <code>id</code>。以下是一个示例 SQL 查询：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="k">c</span><span class="p">.</span><span class="o">*</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">channel</span><span class="w"> </span><span class="k">c</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="k">INNER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">tag</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">JSON_CONTAINS</span><span class="p">(</span><span class="k">c</span><span class="p">.</span><span class="n">tags</span><span class="p">,</span><span class="w"> </span><span class="k">CAST</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">JSON</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;%your_search_query%&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个查询的步骤是：</p>
<ol>
<li><code>FROM channel c</code>：从 <code>channel</code> 表中选择数据。</li>
<li><code>INNER JOIN tag t ON JSON_CONTAINS(c.tags, CAST(t.id AS JSON))</code>：将 <code>channel</code> 表与 <code>tag</code> 表连接，其中 <code>JSON_CONTAINS</code> 用于检查 <code>tag</code> 是否在 <code>channel</code> 的 JSON 数组中。</li>
<li><code>WHERE t.name LIKE '%your_search_query%'</code>：在连接后的结果中，使用 <code>LIKE</code> 子句来执行模糊匹配。</li>
</ol>
<p>在上面的查询中，可以将 <code>%your_search_query%</code> 替换为想搜索的标签名称的部分。这将返回包含匹配的 <code>tag</code> 名称的结果集。</p>
<p>当在 SQL 中处理 JSON 数据时，可能需要将数据转换为 JSON 类型以进行比较或操作。在查询中，<code>JSON_CONTAINS(c.tags, CAST(t.id AS JSON))</code> 是一个用于检查 JSON 数组中是否包含特定值的 SQL 表达式。</p>
<p>以下是对这个表达式的详细解释：</p>
<ol>
<li>
<p><strong>CAST(t.id AS JSON)</strong>：这部分将 <code>t.id</code> 转换为 JSON 数据类型。在 SQL 中，<code>CAST</code> 函数用于将一个数据类型转换为另一个数据类型。在这里，<code>t.id</code> 是整数类型，通过 <code>CAST(t.id AS JSON)</code>，它被显式地转换为 JSON 类型。这是因为 <code>c.tags</code> 是一个 JSON 数据类型，所以需要确保进行比较的值也是 JSON 类型。</p>
</li>
<li>
<p><strong>JSON_CONTAINS(c.tags, CAST(t.id AS JSON))</strong>：这是主要的比较部分。<code>JSON_CONTAINS</code> 函数用于检查一个 JSON 数组（在这里是 <code>c.tags</code>）是否包含特定值（在这里是 <code>t.id</code> 的 JSON 表示）。如果 <code>c.tags</code> 包含 <code>t.id</code> 的 JSON 表示，它将返回 true；否则，返回 false。这就允许查找 <code>channel</code> 表中具有特定 <code>tag</code> 的记录。</p>
</li>
</ol>
<p>再用一个示例来解释这个过程：</p>
<p>假设 <code>channel</code> 表的某一行的 <code>tags</code> 列中包含 JSON 数组 <code>[1, 3, 5]</code>，想查找所有包含 <code>tag</code> 表中 <code>id</code> 为 3 的记录。</p>
<ul>
<li><code>CAST(t.id AS JSON)</code> 将 <code>t.id</code>（3）转换为 JSON 数据类型，变成 <code>3</code>。</li>
<li><code>JSON_CONTAINS(c.tags, 3)</code> 将检查 <code>tags</code> 列中是否包含值为 3 的元素。</li>
<li>因为 <code>[1, 3, 5]</code> 包含值 3，所以这个表达式将返回 true。</li>
</ul>
<p>这就是如何使用 <code>CAST</code> 函数和 <code>JSON_CONTAINS</code> 函数来进行 JSON 数据的比较和查询。在这个例子中，它允许在 <code>channel</code> 表中查找包含特定 <code>tag</code> 的记录。</p>
]]></description>
</item><item>
    <title>Go channel 使用分析</title>
    <link>https://www.xiaobinqt.cn/go-channel-principle/</link>
    <pubDate>Wed, 11 Oct 2023 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/go-channel-principle/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="概念" class="headerLink">
    <a href="#%e6%a6%82%e5%bf%b5" class="header-mark"></a>概念</h2><p>Go 中的 channel 是一个队列，遵循先进先出的原则，负责协程之间的通信。Go 语言提倡不要通过共享内存来通信，而要通过通信来实现内存共享，CSP（Communicating Sequential Process）并发模型，就是通过 goroutine 和 channel 来实现的。</p>
<p>channel 常用的使用场景有：</p>
<ul>
<li>
<p>停止信号监听</p>
</li>
<li>
<p>定时任务</p>
</li>
<li>
<p>生产方和消费方解耦</p>
</li>
<li>
<p>控制并发数</p>
</li>
</ul>
<h2 id="数据结构" class="headerLink">
    <a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="header-mark"></a>数据结构</h2><p>通过 var 声明或者 make 函数创建的 channel 变量是一个存储在函数栈帧上的指针，占用 8 个字节，指向堆上的 hchan 结构体。源码包中 src/runtime/chan.go 定义了 hchan 的数据结构：</p>
<div align="center"></div>
<p>hchan结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type hchan struct {
</span></span><span class="line"><span class="cl">	closed   uint32 // channel是否关闭的标志
</span></span><span class="line"><span class="cl">	elemtype *_type // channel中的元素类型，
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// channel分为无缓冲和有缓冲两种。
</span></span><span class="line"><span class="cl">	// 对于有缓冲的 channel 存储数据，使用了 ring buffer（环形缓冲区) 来缓存写入的数据，本质是循环数组
</span></span><span class="line"><span class="cl">	// 为啥是循环数组？普通数组不行吗，普通数组容量固定更适合指定的空间，弹出元素时，普通数组需要全部都前移
</span></span><span class="line"><span class="cl">	// 当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置
</span></span><span class="line"><span class="cl">	buf      unsafe.Pointer // 指向底层循环数组的指针（环形缓冲区）
</span></span><span class="line"><span class="cl">	qcount   uint           // 循环数组中的元素数量
</span></span><span class="line"><span class="cl">	dataqsiz uint           // 循环数组的长度
</span></span><span class="line"><span class="cl">	elemsize uint16         // 元素的大小
</span></span><span class="line"><span class="cl">	sendx    uint           // 下一次写下标的位置
</span></span><span class="line"><span class="cl">	recvx    uint           // 下一次读下标的位置
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// 尝试读取 channel 或向 channel 写入数据而被阻塞的goroutine
</span></span><span class="line"><span class="cl">	recvq waitq // 读等待队列
</span></span><span class="line"><span class="cl">	sendq waitq // 写等待队列
</span></span><span class="line"><span class="cl">	lock  mutex //互斥锁，保证读写 channel 时不存在并发竞争问题
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>等待队列：</p>
<p>双向链表，包含一个头结点和一个尾结点。每个节点是一个 sudog 结构体变量，记录哪个协程在等待，等待的是哪个 channel，等待发送/接收的数据在哪里。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type waitq struct {
</span></span><span class="line"><span class="cl">	first *sudog
</span></span><span class="line"><span class="cl">	last  *sudog
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">type sudog struct {
</span></span><span class="line"><span class="cl">	g    *g
</span></span><span class="line"><span class="cl">	next *sudog
</span></span><span class="line"><span class="cl">	prev *sudog
</span></span><span class="line"><span class="cl">	elem unsafe.Pointer
</span></span><span class="line"><span class="cl">	c    *hchan
</span></span><span class="line"><span class="cl">	// ...
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="创建" class="headerLink">
    <a href="#%e5%88%9b%e5%bb%ba" class="header-mark"></a>创建</h3><p>使用 make(chan T, cap) 来创建 channel，make 语法会在编译时，转换为 makechan64 和 makechan</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func makechan64(t *chantype, size int64) *hchan {
</span></span><span class="line"><span class="cl">	if int64(int(size)) != size {
</span></span><span class="line"><span class="cl">		panic(plainError(&#34;makechan: size out of range&#34;))
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	return makechan(t, int(size))
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建 channel 有两种，一种是带缓冲的 channel，一种是不带缓冲的 channel</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 带缓冲
</span></span><span class="line"><span class="cl">ch := make(chan int, 3)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 不带缓冲
</span></span><span class="line"><span class="cl">ch := make(chan int)
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建时会做一些检查:</p>
<ul>
<li>
<p>元素大小不能超过 64K</p>
</li>
<li>
<p>元素的对齐大小不能超过 maxAlign 也就是 8 字节</p>
</li>
<li>
<p>计算出来的内存是否超过限制</p>
</li>
</ul>
<p>创建时的策略:</p>
<ul>
<li>
<p>如果是无缓冲的 channel，会直接给 hchan 分配内存</p>
</li>
<li>
<p>如果是有缓冲的 channel，并且元素不包含指针，那么会为 hchan 和底层数组分配一段连续的地址</p>
</li>
<li>
<p>如果是有缓冲的 channel，并且元素包含指针，那么会为 hchan 和底层数组分别分配地址</p>
</li>
</ul>
<h3 id="发送" class="headerLink">
    <a href="#%e5%8f%91%e9%80%81" class="header-mark"></a>发送</h3><p>发送操作，编译时转换为 runtime.chansend 函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool
</span></span></code></pre></td></tr></table>
</div>
</div><p>阻塞式：</p>
<p>调用 chansend 函数，并且 block=true</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ch &lt;- 10
</span></span></code></pre></td></tr></table>
</div>
</div><p>非阻塞式：</p>
<p>调用 chansend 函数，并且 block=false</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">select {
</span></span><span class="line"><span class="cl">    case ch &lt;- 10:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    default:
</span></span><span class="line"><span class="cl"> }
</span></span></code></pre></td></tr></table>
</div>
</div><p>向 channel 中发送数据时大概分为两大块：检查和数据发送，数据发送流程如下：</p>
<ul>
<li>
<p>如果 channel 的读等待队列存在接收者goroutine</p>
<ul>
<li>将数据<strong>直接发送</strong>给第一个等待的 goroutine，<strong>唤醒接收的 goroutine</strong></li>
</ul>
</li>
<li>
<p>如果 channel 的读等待队列不存在接收者 goroutine</p>
<ul>
<li>
<p>如果循环数组 buf 未满，那么将会把数据发送到循环数组buf的队尾</p>
</li>
<li>
<p>如果循环数组 buf 已满，这个时候就会走阻塞发送的流程，将当前 goroutine 加入写等待队列，并<strong>挂起等待唤醒</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="接收" class="headerLink">
    <a href="#%e6%8e%a5%e6%94%b6" class="header-mark"></a>接收</h3><p>接收操作，编译时转换为 runtime.chanrecv 函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool)
</span></span></code></pre></td></tr></table>
</div>
</div><p>阻塞式：</p>
<p>调用 chanrecv 函数，并且 block=true</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&lt;-ch
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">v := &lt;-ch
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">v, ok := &lt;-ch
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 当 channel 关闭时，for 循环会自动退出，无需主动监测 channel 是否关闭，可以防止读取已经关闭的 channel,造成读到数据为通道所存储的数据类型的零值
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">for i := range ch {
</span></span><span class="line"><span class="cl">	fmt.Println(i)
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>非阻塞式：</p>
<p>调用 chanrecv 函数，并且 block=false</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">select {
</span></span><span class="line"><span class="cl">    case &lt;-ch:
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    default
</span></span><span class="line"><span class="cl">  }
</span></span></code></pre></td></tr></table>
</div>
</div><p>向 channel 中接收数据时大概分为两大块，检查和数据发送，而数据接收流程如下：</p>
<ul>
<li>
<p>如果 channel 的写等待队列存在发送者 goroutine</p>
<ul>
<li>
<p>如果是无缓冲 channel，<strong>直接</strong>从第一个发送者 goroutine 那里把数据拷贝给接收变量，<strong>唤醒发送的 goroutine</strong></p>
</li>
<li>
<p>如果是有缓冲 channel（已满），将循环数组buf的队首元素拷贝给接收变量，将第一个发送者 goroutine 的数据拷贝到 buf循 环数组队尾，<strong>唤醒发送的 goroutine</strong></p>
</li>
</ul>
</li>
<li>
<p>如果 channel 的写等待队列不存在发送者 goroutine</p>
<ul>
<li>
<p>如果循环数组 buf 非空，将循环数组 buf 的队首元素拷贝给接收变量</p>
</li>
<li>
<p>如果循环数组 buf 为空，这个时候就会走阻塞接收的流程，将当前 goroutine 加入读等待队列，并<strong>挂起等待唤醒</strong></p>
</li>
</ul>
</li>
</ul>
<p><strong>关闭</strong></p>
<p>关闭操作，调用 close 函数，编译时转换为 runtime.closechan 函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">close(ch)
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func closechan(c *hchan)
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>案例分析：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;unsafe&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ch 是长度为 4 的带缓冲的 channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//初始 hchan 结构体重的 buf 为空，sendx 和 recvx 均为 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ch</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">ch</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">sendTask</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">receiveTask</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// G1 是发送者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 当 G1 向 ch 里发送数据时，首先会对 buf 加锁，然后将 task 存储的数据 copy 到 buf 中，然后 sendx++，然后释放对 buf 的锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">sendTask</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">taskList</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;this&#34;</span><span class="p">,</span> <span class="s">&#34;is&#34;</span><span class="p">,</span> <span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;demo&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">task</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">taskList</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">task</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//发送任务到 channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// G2 是接收者
</span></span></span><span class="line"><span class="cl"><span class="c1">// 当 G2 消费 ch 的时候，会首先对 buf 加锁，然后将 buf 中的数据 copy 到 task 变量对应的内存里，然后 recvx++,并释放锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">receiveTask</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">task</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//接收任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;received&#34;</span><span class="p">,</span> <span class="nx">task</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//处理任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>hchan 结构体的主要组成部分有四个：</p>
<ul>
<li>
<p>用来保存 goroutine 之间传递数据的循环数组：buf</p>
</li>
<li>
<p>用来记录此循环数组当前发送或接收数据的下标值：sendx 和 recvx</p>
</li>
<li>
<p>用于保存向该 chan 发送和从该 chan 接收数据被阻塞的 goroutine 队列： sendq 和 recvq</p>
</li>
<li>
<p>保证 channel 写入和读取数据时线程安全的锁：lock</p>
</li>
</ul>
<h2 id="特点" class="headerLink">
    <a href="#%e7%89%b9%e7%82%b9" class="header-mark"></a>特点</h2><p>channel 有 2 种类型：无缓冲、有缓冲</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/bfb659b1a9aa4a05b86ef43ae0090a86.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/bfb659b1a9aa4a05b86ef43ae0090a86.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/bfb659b1a9aa4a05b86ef43ae0090a86.png" data-sub-html="<h2>有无缓冲</h2>">
        
    </a><figcaption class="image-caption">有无缓冲</figcaption>
    </figure></p>
<p>channel 有 3 种模式：写操作模式（单向通道）、读操作模式（单向通道）、读写操作模式（双向通道）</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/77e1a773bb3c4b5cb64c2fea9ce00876.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/77e1a773bb3c4b5cb64c2fea9ce00876.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/77e1a773bb3c4b5cb64c2fea9ce00876.png" data-sub-html="<h2>模式</h2>">
        
    </a><figcaption class="image-caption">模式</figcaption>
    </figure></p>
<p>channel有 3 种状态：未初始化、正常、关闭</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/307a5fbdc807419db471dd49cbe3f920.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/307a5fbdc807419db471dd49cbe3f920.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231012/307a5fbdc807419db471dd49cbe3f920.png" data-sub-html="<h2>状态</h2>">
        
    </a><figcaption class="image-caption">状态</figcaption>
    </figure></p>
<p><strong>注意点</strong>：</p>
<ol>
<li>
<p>一个 channel不能多次关闭，会导致 panic</p>
</li>
<li>
<p>如果多个 goroutine 都监听同一个 channel，那么 channel 上的数据都<strong>可能随机被某一个 goroutine 取走进行消费</strong></p>
</li>
<li>
<p>如果多个 goroutine 监听同一个 channel，如果这个 channel 被关闭，则所有 goroutine <strong>都能收到退出信号</strong></p>
</li>
</ol>
<h3 id="线程安全" class="headerLink">
    <a href="#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8" class="header-mark"></a>线程安全</h3><p>不同协程通过 channel 进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全。</p>
<p>channel 的底层实现中，hchan 结构体中采用 Mutex 锁来保证数据读写安全。在对循环数组 buf 中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作 channel 数据。</p>
<h3 id="控制并发顺序" class="headerLink">
    <a href="#%e6%8e%a7%e5%88%b6%e5%b9%b6%e5%8f%91%e9%a1%ba%e5%ba%8f" class="header-mark"></a>控制并发顺序</h3><p>多个 goroutine 并发执行时，每一个 goroutine 抢到处理器的时间点不一致，goroutine 的执行本身不能保证顺序。goroutine 并不能保证先执行。</p>
<p>可以使用 channel 进行通信通知，用 channel 去传递信息，从而控制并发执行顺序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch3</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch1</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">myPrint</span><span class="p">(</span><span class="s">&#34;gorouine1&#34;</span><span class="p">,</span> <span class="nx">ch1</span><span class="p">,</span> <span class="nx">ch2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">myPrint</span><span class="p">(</span><span class="s">&#34;gorouine2&#34;</span><span class="p">,</span> <span class="nx">ch2</span><span class="p">,</span> <span class="nx">ch3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">myPrint</span><span class="p">(</span><span class="s">&#34;gorouine3&#34;</span><span class="p">,</span> <span class="nx">ch3</span><span class="p">,</span> <span class="nx">ch1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">end</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;duration:%d\n&#34;</span><span class="p">,</span> <span class="nx">end</span><span class="o">-</span><span class="nx">start</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">myPrint</span><span class="p">(</span><span class="nx">gorouine</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">inputchan</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="nx">outchan</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 模拟内部操作耗时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">inputchan</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">gorouine</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">outchan</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">gorouine1
</span></span><span class="line"><span class="cl">gorouine2
</span></span><span class="line"><span class="cl">gorouine3
</span></span><span class="line"><span class="cl">duration:1
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="死锁问题" class="headerLink">
    <a href="#%e6%ad%bb%e9%94%81%e9%97%ae%e9%a2%98" class="header-mark"></a>死锁问题</h2><p><strong>死锁：</strong></p>
<ul>
<li>
<p>单个协程永久阻塞</p>
</li>
<li>
<p>两个或两个以上的协程的执行过程中，由于竞争资源或由于彼此通信而造成的一种阻塞的现象。</p>
</li>
</ul>
<p><strong>channel 死锁场景：</strong></p>
<ul>
<li>
<p>非缓存 channel 只写不读</p>
</li>
<li>
<p>非缓存 channel 读在写后面</p>
</li>
<li>
<p>缓存 channel 写入超过缓冲区数量</p>
</li>
<li>
<p>空读</p>
</li>
<li>
<p>多个协程互相等待</p>
</li>
</ul>
<ol>
<li>非缓存 channel 只写不读</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func deadlock1() {
</span></span><span class="line"><span class="cl">	ch := make(chan int)
</span></span><span class="line"><span class="cl">	ch &lt;- 3 //  这里会发生一直阻塞的情况，执行不到下面一句
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>非缓存 channel 读在写后面</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func deadlock2() {
</span></span><span class="line"><span class="cl">	ch := make(chan int)
</span></span><span class="line"><span class="cl">	ch &lt;- 3 //  这里会发生一直阻塞的情况，执行不到下面一句
</span></span><span class="line"><span class="cl">	num := &lt;-ch
</span></span><span class="line"><span class="cl">	fmt.Println(&#34;num=&#34;, num)
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func deadlock2() {
</span></span><span class="line"><span class="cl">	ch := make(chan int)
</span></span><span class="line"><span class="cl">	ch &lt;- 100 //  这里会发生一直阻塞的情况，执行不到下面一句
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	go func() {
</span></span><span class="line"><span class="cl">		num := &lt;-ch
</span></span><span class="line"><span class="cl">		fmt.Println(&#34;num=&#34;, num)
</span></span><span class="line"><span class="cl">	}()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	time.Sleep(time.Second)
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>缓存 channel 写入超过缓冲区数量</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func deadlock3() {
</span></span><span class="line"><span class="cl">	ch := make(chan int, 3)
</span></span><span class="line"><span class="cl">	ch &lt;- 3
</span></span><span class="line"><span class="cl">	ch &lt;- 4
</span></span><span class="line"><span class="cl">	ch &lt;- 5
</span></span><span class="line"><span class="cl">	ch &lt;- 6 //  这里会发生一直阻塞的情况
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>空读</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func deadlock4() {
</span></span><span class="line"><span class="cl">	ch := make(chan int)
</span></span><span class="line"><span class="cl">	// ch := make(chan int, 1)
</span></span><span class="line"><span class="cl">	fmt.Println(&lt;-ch) //  这里会发生一直阻塞的情况
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="5">
<li><strong>多个协程互相等待</strong></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func deadlock5() {
</span></span><span class="line"><span class="cl">	ch1 := make(chan int)
</span></span><span class="line"><span class="cl">	ch2 := make(chan int)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// 互相等对方造成死锁
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	go func() {
</span></span><span class="line"><span class="cl">		for {
</span></span><span class="line"><span class="cl">			select {
</span></span><span class="line"><span class="cl">			case num := &lt;-ch1:
</span></span><span class="line"><span class="cl">				fmt.Println(&#34;num=&#34;, num)
</span></span><span class="line"><span class="cl">				ch2 &lt;- 100
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	for {
</span></span><span class="line"><span class="cl">		select {
</span></span><span class="line"><span class="cl">		case num := &lt;-ch2:
</span></span><span class="line"><span class="cl">			fmt.Println(&#34;num=&#34;, num)
</span></span><span class="line"><span class="cl">			ch1 &lt;- 300
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/weixin_45627369/article/details/127193703" target="_blank" rel="noopener noreferrer">golang——channel</a></li>
</ul>
]]></description>
</item><item>
    <title>Go Slice 实现原理</title>
    <link>https://www.xiaobinqt.cn/go-slice-principle/</link>
    <pubDate>Tue, 10 Oct 2023 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/go-slice-principle/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="什么是-slice" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-slice" class="header-mark"></a>什么是 slice</h2><p>切片是基于数组实现的，它的底层是数组，可以理解为对底层数组的抽象。</p>
<p>源码包中 src/runtime/slice.go 定义了 slice 的数据结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type slice struct {
</span></span><span class="line"><span class="cl">	array unsafe.Pointer // ArbitraryType int
</span></span><span class="line"><span class="cl">	len   int
</span></span><span class="line"><span class="cl">	cap   int
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>array 是指向底层数组的指针，占用 8 个字节。len 是切片的长度，占用 8 个字节。cap 是切片的容量，cap 总是大于等于 len 的，占用 8 个字节。所以 slice 占用 24 个字节。</p>
<p>slice 有 4 种初始化方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">	// 初始化方式1：直接声明
</span></span><span class="line"><span class="cl">	var slice1 []int
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// 初始化方式2：使用字面量
</span></span><span class="line"><span class="cl">	slice2 := []int{1, 2, 3, 4}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// 初始化方式3：使用 make 创建slice
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	slice3 := make([]int, 3, 5)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// 初始化方式4: 从切片或数组截取
</span></span><span class="line"><span class="cl">	slcie4 := arr[1:3]
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以通过下面的代码，看下 slice 初始化调用的底层函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">slice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 <code>go tool compile -S main.go | grep CALL</code> 得到汇编代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">0x0032 00050 (main.go:6)        CALL    runtime.makeslice(SB)
</span></span><span class="line"><span class="cl">0x004b 00075 (main.go:7)        CALL    runtime.growslice(SB)
</span></span><span class="line"><span class="cl">0x0076 00118 (main.go:8)        CALL    runtime.convTslice(SB)
</span></span><span class="line"><span class="cl">0x0091 00145 (main.go:8)        CALL    runtime.convT64(SB)
</span></span><span class="line"><span class="cl">0x00ac 00172 (main.go:8)        CALL    runtime.convT64(SB)
</span></span><span class="line"><span class="cl">0x00e0 00224 ($GOROOT/src/fmt/print.go:274)     CALL    fmt.Fprintln(SB)
</span></span><span class="line"><span class="cl">0x00f5 00245 (main.go:5)        CALL    runtime.morestack_noctxt(SB)
</span></span></code></pre></td></tr></table>
</div>
</div><p>初始化 slice 调用的是 runtime.makeslice，makeslice 函数的工作主要就是计算 slice 所需内存大小，然后调用 mallocgc 进行内存的分配。</p>
<p>所需内存大小 = 切片中元素大小 * 切片的容量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">runtime</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">makeslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&gt;</span> <span class="nx">cap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// NOTE: Produce a &#39;len out of range&#39; error instead of a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// &#39;cap out of range&#39; error when someone does make([]T, bignumber).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// &#39;cap out of range&#39; is true too, but since the cap is only being
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// supplied implicitly, saying len is clearer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// See golang.org/issue/4085.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">len</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">panicmakeslicelen</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nf">panicmakeslicecap</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">et</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="array-和-slice-区别" class="headerLink">
    <a href="#array-%e5%92%8c-slice-%e5%8c%ba%e5%88%ab" class="header-mark"></a>array 和 slice 区别</h2><ol>
<li>
<p>数组初始化必须指定长度，并且长度就是固定的 切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大</p>
</li>
<li>
<p>数组是值类型，将一个数组赋值给另一个数组时，传递的是一份深拷贝，函数传参操作都会复制整个数组数据，会占用额外的内存，函数内对数组元素值的修改，不会修改原数组内容。切片是引用类型，将一个切片赋值给另一个切片时，传递的是一份浅拷贝，函数传参操作不会拷贝整个切片，只会复制 len 和 cap，底层共用同一个数组，不会占用额外的内存，函数内对数组元素值的修改，会修改原数组内容。</p>
</li>
<li>
<p>数组需要遍历计算数组长度，时间复杂度为 O(n) 切片底层包含 len 字段，可以通过 len() 计算切片长度，时间复杂度为 O(1)</p>
</li>
</ol>
<h2 id="slice-扩容机制" class="headerLink">
    <a href="#slice-%e6%89%a9%e5%ae%b9%e6%9c%ba%e5%88%b6" class="header-mark"></a>slice 扩容机制</h2><h3 id="旧规则存在的问题" class="headerLink">
    <a href="#%e6%97%a7%e8%a7%84%e5%88%99%e5%ad%98%e5%9c%a8%e7%9a%84%e9%97%ae%e9%a2%98" class="header-mark"></a>旧规则存在的问题</h3><p>在 1.17 及之前的版本中，扩容机制是这样的👇：</p>
<ul>
<li>
<p>当新切片需要的容量 cap 大于两倍扩容的容量，则直接按照新切片需要的容量扩容；</p>
</li>
<li>
<p>当原 slice 容量 &lt; 1024 的时候，新 slice 容量变成原来的 2 倍；</p>
</li>
<li>
<p>当原 slice 容量 &gt; 1024，进入一个循环，每次容量变成原来的1.25倍，直到大于期望容量。</p>
</li>
</ul>
<p>slice 扩容时会调用 <code>runtime.growslice</code>。这里只关注该函数 slice 计算容量部分的逻辑，计算方法如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 1.17及以前的版本中
</span></span><span class="line"><span class="cl">// old指切片的旧容量, cap指期望的新容量
</span></span><span class="line"><span class="cl">func growslice(old, cap int) int {
</span></span><span class="line"><span class="cl">    newcap := old
</span></span><span class="line"><span class="cl">    doublecap := newcap + newcap
</span></span><span class="line"><span class="cl">    // 如果期望容量大于旧容量的2倍，则直接使用期望容量作为最终容量
</span></span><span class="line"><span class="cl">    if cap &gt; doublecap {
</span></span><span class="line"><span class="cl">        newcap = cap
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        // 如果旧容量小于1024，则直接翻倍
</span></span><span class="line"><span class="cl">        if old &lt; 1024 {
</span></span><span class="line"><span class="cl">            newcap = doublecap
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            // 每次增长大约1.25倍
</span></span><span class="line"><span class="cl">            for 0 &lt; newcap &amp;&amp; newcap &lt; cap {
</span></span><span class="line"><span class="cl">                newcap += newcap / 4
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            if newcap &lt;= 0 {
</span></span><span class="line"><span class="cl">                newcap = cap
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 这里忽略了对齐操作
</span></span><span class="line"><span class="cl">    return newcap
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个扩容机制令一些人产生了<a href="https://groups.google.com/g/golang-nuts/c/UaVlMQ8Nz3o" target="_blank" rel="noopener noreferrer">一些困惑</a>，因为它会产生一些 “看起来不那么自然的行为”。比如<strong>它计算出来的新容量不是单调递增的</strong>，下面的程序会将不同容量 slice 的扩容结果打印出来:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2000</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">100</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nb">append</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">bool</span><span class="p">,</span> <span class="nx">i</span><span class="p">),</span> <span class="kc">true</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该程序的输出如下（旧版本的扩容规则）:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 第一列是切片的旧容量
</span></span><span class="line"><span class="cl">// 第二列是扩容后的容量
</span></span><span class="line"><span class="cl">0 8
</span></span><span class="line"><span class="cl">100 208
</span></span><span class="line"><span class="cl">200 416
</span></span><span class="line"><span class="cl">300 640
</span></span><span class="line"><span class="cl">400 896
</span></span><span class="line"><span class="cl">500 1024
</span></span><span class="line"><span class="cl">600 1280
</span></span><span class="line"><span class="cl">700 1408
</span></span><span class="line"><span class="cl">800 1792
</span></span><span class="line"><span class="cl">900 2048
</span></span><span class="line"><span class="cl">1000 2048
</span></span><span class="line"><span class="cl">1100 1408 &lt;-- 在这个点，扩容后的新容量比上面的容量要小
</span></span><span class="line"><span class="cl">1200 1536
</span></span><span class="line"><span class="cl">1300 1792
</span></span><span class="line"><span class="cl">1400 1792
</span></span><span class="line"><span class="cl">1500 2048
</span></span><span class="line"><span class="cl">1600 2048
</span></span><span class="line"><span class="cl">1700 2304
</span></span><span class="line"><span class="cl">1800 2304
</span></span><span class="line"><span class="cl">1900 2688
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，在 slice 的容量刚刚触发<strong>大于 1024 增长 1.25 倍</strong>这个条件的时候，计算出来的新容量要小于之前计算出的容量，这里绘制了一张图表，可以感受一下:</p>
<div align="center"></div>
<h3 id="更加平滑的扩容算法" class="headerLink">
    <a href="#%e6%9b%b4%e5%8a%a0%e5%b9%b3%e6%bb%91%e7%9a%84%e6%89%a9%e5%ae%b9%e7%ae%97%e6%b3%95" class="header-mark"></a>更加平滑的扩容算法</h3><p>从 <code>go1.18</code> 开始，slice 容量的计算方法被改为了这样:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 只关心扩容规则的简化版growslice
</span></span><span class="line"><span class="cl">func growslice(old, cap int) int {
</span></span><span class="line"><span class="cl">    newcap := old
</span></span><span class="line"><span class="cl">    doublecap := newcap + newcap
</span></span><span class="line"><span class="cl">    if cap &gt; doublecap {
</span></span><span class="line"><span class="cl">        newcap = cap
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        const threshold = 256 // 不同点1
</span></span><span class="line"><span class="cl">        if old &lt; threshold {
</span></span><span class="line"><span class="cl">            newcap = doublecap
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            for 0 &lt; newcap &amp;&amp; newcap &lt; cap {
</span></span><span class="line"><span class="cl">                newcap += (newcap + 3*threshold) / 4 // 不同点2
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            if newcap &lt;= 0 {
</span></span><span class="line"><span class="cl">                newcap = cap
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return newcap
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>新版的扩容算法相较于旧的有两处不同，首先是双倍容量扩容的最大阈值<strong>从 1024 降为了 256</strong>，只要超过了 256，就开始进行缓慢的增长。其次是增长比例的调整，之前超过了阈值之后，基本为恒定的 1.25 倍增长，而现在超过了阈值之后，增长比例是会动态调整的:</p>
<ul>
<li>
<p>当新切片需要的容量 cap 大于两倍扩容的容量，则直接按照新切片需要的容量扩容；</p>
</li>
<li>
<p>当原 slice 容量 &lt; threshold（256） 的时候，新 slice 容量变成原来的 2 倍；</p>
</li>
<li>
<p>当原 slice 容量 &gt; threshold（256），进入一个循环，每次容量增加 <code>(旧容量+3*threshold)/4</code>。</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">初始长度         增长比例
</span></span><span class="line"><span class="cl">256             2.0
</span></span><span class="line"><span class="cl">512             1.63
</span></span><span class="line"><span class="cl">1024            1.44
</span></span><span class="line"><span class="cl">2048            1.35
</span></span><span class="line"><span class="cl">4096            1.30
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，<strong>随着切片容量的变大，增长比例逐渐向着 1.25 进行靠拢</strong>。</p>
<p>这次更改之后，slice 扩容整体的增长曲线变得更加平滑：</p>
<div align="center"></div>
<p>关于更多信息，可以查看<a href="https://github.com/golang/go/commit/2dda92ff6f9f07eeb110ecbf0fc2d7a0ddd27f9d" target="_blank" rel="noopener noreferrer">#2dda92ff6f9f07eeb110ecbf0fc2d7a0ddd27f9d</a></p>
<h2 id="slice-是否是线程安全的" class="headerLink">
    <a href="#slice-%e6%98%af%e5%90%a6%e6%98%af%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84" class="header-mark"></a>slice 是否是线程安全的</h2><p>线程安全的定义是：</p>
<p>多个线程访问（读）同一个对象时，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。</p>
<p>若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
<p>Go 语言实现线程安全常用的方式有：</p>
<ol>
<li>互斥锁</li>
<li>读写锁</li>
<li>原子操作</li>
<li>sync.once</li>
<li>sync.atomic</li>
<li>channel</li>
</ol>
<p>slice 底层结构并没有使用加锁等方式，不支持并发读写，所以 slice 并不是线程安全的，使用多个 goroutine 对类型为 slice 的变量进行操作，每次输出的值大概率都不会一样，与预期值不一致，slice 在并发执行中不会报错，但是数据可能会丢失。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 切片非并发安全* 多次执行，每次得到的结果都不一样* 可以考虑使用 channel 本身的特性 (阻塞) 来实现安全的并发读写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">TestSliceConcurrencySafe</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">TestSliceConcurrencySafe</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span> <span class="c1">// 这里的值不是 10000
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://juejin.cn/post/7136774425415794719" target="_blank" rel="noopener noreferrer">Go slice新的扩容机制</a></li>
<li><a href="https://juejin.cn/post/7101928883280150558" target="_blank" rel="noopener noreferrer">Go 1.18 全新的切片扩容机制</a></li>
</ul>
]]></description>
</item><item>
    <title>Golang 内存逃逸</title>
    <link>https://www.xiaobinqt.cn/escape-heap/</link>
    <pubDate>Tue, 10 Oct 2023 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/escape-heap/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<p>在 C/C++ 开发中，动态分配内存（new/malloc）需要开发者手动释放资源。这样做的好处是，需要申请多少内存空间可以很好的掌握怎么分配。但是这有个缺点，如果忘记释放内存，则会导致内存泄漏。在很多高级语言中（python/Go/java）都加上了垃圾回收机制。</p>
<h2 id="堆和栈" class="headerLink">
    <a href="#%e5%a0%86%e5%92%8c%e6%a0%88" class="header-mark"></a>堆和栈</h2><p>栈可以简单得理解成一次函数调用内部申请到的内存，它们会随着函数的返回把内存还给系统。下面来看看一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func F() {
</span></span><span class="line"><span class="cl">    temp := make([]int, 0, 20)
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的例子，内函数内部申请的临时变量，即使是用 make 申请到的内存，如果发现在退出函数后没有用了，那么就把丢到栈上，毕竟栈上的内存分配比堆上快很多。</p>
<p>再看一个堆的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func F() []int{
</span></span><span class="line"><span class="cl">    a := make([]int, 0, 20)
</span></span><span class="line"><span class="cl">    return a
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面这段代码，申请的代码和上面的一模一样，但是申请后作为返回值返回了，编译器会认为在退出函数之后还有其他地方在引用，当函数返回之后并不会将其内存归还。那么就申请到堆里。</p>
<p>如果变量都分配到堆上，堆不像栈可以自动清理。它会引起 Go 频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销。</p>
<h3 id="堆和栈相比" class="headerLink">
    <a href="#%e5%a0%86%e5%92%8c%e6%a0%88%e7%9b%b8%e6%af%94" class="header-mark"></a>堆和栈相比</h3><p>堆适合不可预知的大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。</p>
<p>栈内存分配则会非常快，栈分配内存只需要两个 CPU 指令：PUSH 和 RELEASE 分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块。之后要通过垃圾回收才能释放。</p>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>内存碎片<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>内存碎片（Memory Fragmentation）是指计算机系统中存在的一种内存分配和释放的情况，它可能导致系统中的可用内存不连续、零散分布，使得系统效率下降或者无法有效地利用可用内存。内存碎片通常分为两种类型：外部碎片和内部碎片。</p>
<ol>
<li>
<p>外部碎片（External Fragmentation）：</p>
<ul>
<li>外部碎片指的是在可用内存中存在的未分配的小块内存空间，虽然总的可用内存大小足够，但是这些小块内存分散在不同的地方，无法被有效地利用。</li>
<li>外部碎片通常发生在动态内存分配和释放的过程中。当程序请求分配一块内存时，系统会找到一个足够大的连续内存块来满足需求，但是如果可用内存被分割成多个小块，就可能出现无法分配所需大小的内存块的情况。</li>
</ul>
</li>
<li>
<p>内部碎片（Internal Fragmentation）：</p>
<ul>
<li>内部碎片是指已经分配给程序的内存块中，有一部分内存没有被程序有效利用，造成了浪费。</li>
<li>内部碎片通常发生在内存分配时，分配了比实际需要更大的内存块，但程序没有充分利用这些额外的内存空间。</li>
</ul>
</li>
</ol>
<p>内存碎片的重要性和影响：</p>
<ul>
<li>内存碎片会导致系统性能下降，因为操作系统需要更多的时间来寻找足够大的连续内存块来满足程序的需求。</li>
<li>内存碎片也可能导致程序崩溃或运行不稳定，特别是当内存碎片积累到一定程度时。</li>
<li>为了减少内存碎片的影响，程序员和操作系统通常采用不同的策略，如内存合并、内存池等，以更有效地管理内存。</li>
</ul>
</div>
        </div>
    </div>
<h2 id="逃逸分析" class="headerLink">
    <a href="#%e9%80%83%e9%80%b8%e5%88%86%e6%9e%90" class="header-mark"></a>逃逸分析</h2><p>逃逸分析是一种确定指针动态范围的方法。简单来说就是分析在程序的哪些地方可以访问到该指针。编译器会根据变量是否被外部引用来决定是否逃逸：</p>
<ol>
<li>如果函数外部没有引用，则优先放到栈中；</li>
<li>如果函数外部存在引用，则必定放到堆中；</li>
</ol>
<p>对此可以理解为，逃逸分析是编译器用于决定变量分配到堆上还是栈上的一种行为。</p>
<p><strong>go 在编译阶段确立逃逸，并不是在运行时</strong>。</p>
<h2 id="指针逃逸" class="headerLink">
    <a href="#%e6%8c%87%e9%92%88%e9%80%83%e9%80%b8" class="header-mark"></a>指针逃逸</h2><p>提问：函数传递指针真的比传值效率高吗？</p>
<p>传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加 GC 的负担，所以传递指针不一定是高效的。</p>
<p>官网上上有一个关于变量分配的问题 <a href="https://go.dev/doc/faq#stack_or_heap:~:text=From%20a%20correctness,on%20the%20stack." target="_blank" rel="noopener noreferrer">How do I know whether a variable is allocated on the heap or the stack?</a></p>
<p>Go 可以返回局部变量指针，这其实是一个典型的变量逃逸案例，示例代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Student</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Age</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">StudentRegister</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">age</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Student</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Student</span><span class="p">)</span> <span class="c1">//局部变量s逃逸到堆
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="nx">name</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">Age</span> <span class="p">=</span> <span class="nx">age</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">StudentRegister</span><span class="p">(</span><span class="s">&#34;Jim&#34;</span><span class="p">,</span> <span class="mi">18</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然在函数 StudentRegister() 内部 s 为局部变量，其值通过函数返回值返回，s 本身为一指针，其指向的内存地址不会是栈而是堆，这就是典型的逃逸案例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">λ go build -gcflags=-m main.go
</span></span><span class="line"><span class="cl"># command-line-arguments
</span></span><span class="line"><span class="cl">.\main.go:8:6: can inline StudentRegister
</span></span><span class="line"><span class="cl">.\main.go:17:6: can inline main
</span></span><span class="line"><span class="cl">.\main.go:18:17: inlining call to StudentRegister
</span></span><span class="line"><span class="cl">.\main.go:8:22: leaking param: name
</span></span><span class="line"><span class="cl">.\main.go:9:10: new(Student) escapes to heap
</span></span><span class="line"><span class="cl">.\main.go:18:17: new(Student) does not escape
</span></span></code></pre></td></tr></table>
</div>
</div><p>指令集 -gcflags 用于将标识参数传递给 Go 编译器，-m 会打印出逃逸分析的优化策略。</p>
<p>可见在 StudentRegister() 函数中，也即代码第 9 行显示 escapes to heap，代表该行内存分配发生了逃逸现象。</p>
<h3 id="栈空间不足逃逸" class="headerLink">
    <a href="#%e6%a0%88%e7%a9%ba%e9%97%b4%e4%b8%8d%e8%b6%b3%e9%80%83%e9%80%b8" class="header-mark"></a>栈空间不足逃逸</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">=</span> <span class="nx">index</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面代码主函数中分配了一个 1000 个长度的切片，是否逃逸取决于栈空间是否足够大。直接查看编译提示，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">λ go build -gcflags=-m main.go
</span></span><span class="line"><span class="cl"># command-line-arguments
</span></span><span class="line"><span class="cl">.\main.go:3:6: can inline main
</span></span><span class="line"><span class="cl">.\main.go:5:11: make([]int, 1000, 1000) does not escape
</span></span></code></pre></td></tr></table>
</div>
</div><p>根据上面的信息，没有发生逃逸。分配了一个 1000 的长度还不足以发生逃逸现象。x10 倍后，再看看情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">=</span> <span class="nx">index</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">λ go build -gcflags=-m main.go
</span></span><span class="line"><span class="cl"># command-line-arguments
</span></span><span class="line"><span class="cl">.\main.go:3:6: can inline main
</span></span><span class="line"><span class="cl">.\main.go:5:11: make([]int, 10000, 10000) escapes to heap
</span></span></code></pre></td></tr></table>
</div>
</div><p>当切片长度扩大到 10000 时就会逃逸。实际上当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中。</p>
<h3 id="动态类型逃逸" class="headerLink">
    <a href="#%e5%8a%a8%e6%80%81%e7%b1%bb%e5%9e%8b%e9%80%83%e9%80%b8" class="header-mark"></a>动态类型逃逸</h3><p>很多函数参数为 interface 类型。比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func Printf(format string, a ...interface{}) (n int, err error)
</span></span><span class="line"><span class="cl">func Sprintf(format string, a ...interface{}) string
</span></span><span class="line"><span class="cl">func Fprint(w io.Writer, a ...interface{}) (n int, err error)
</span></span><span class="line"><span class="cl">func Print(a ...interface{}) (n int, err error)
</span></span><span class="line"><span class="cl">func Println(a ...interface{}) (n int, err error)
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译期间很难确定其参数的具体类型，也能产生逃逸。</p>
<p>如下代码所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello 123&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;hello 456&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">λ go build -gcflags=-m main.go
</span></span><span class="line"><span class="cl"># command-line-arguments
</span></span><span class="line"><span class="cl">.\main.go:6:13: inlining call to fmt.Println
</span></span><span class="line"><span class="cl">.\main.go:7:11: inlining call to fmt.Print
</span></span><span class="line"><span class="cl">.\main.go:6:13: ... argument does not escape
</span></span><span class="line"><span class="cl">.\main.go:6:14: &#34;hello 123&#34; escapes to heap
</span></span><span class="line"><span class="cl">.\main.go:7:11: ... argument does not escape
</span></span><span class="line"><span class="cl">.\main.go:7:12: &#34;hello 456&#34; escapes to heap
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="逃逸分析的作用" class="headerLink">
    <a href="#%e9%80%83%e9%80%b8%e5%88%86%e6%9e%90%e7%9a%84%e4%bd%9c%e7%94%a8" class="header-mark"></a>逃逸分析的作用</h2><ol>
<li>
<p>逃逸分析的好处是为了减少 gc 的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要 gc 标记清除。</p>
</li>
<li>
<p>逃逸分析完后可以确定哪些变量可以分配在栈上，栈的分配比堆快，性能好（逃逸的局部变量会在堆上分配，而没有发生逃逸的则有编译器在栈上分配）。</p>
</li>
<li>
<p>同步消除，如果定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。</p>
</li>
</ol>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>info<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>当涉及到同步锁（Mutex）以及只有一个线程在访问的情况时，逃逸分析可能会起到关键作用。下面是一个简单的示例来解释这个情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">data</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">data</span> <span class="p">=</span> <span class="mi">42</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 在这里，编译器会执行逃逸分析
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 如果编译器能够确定 data 不会逃逸到堆上，它可能会去除同步锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 因为只有一个线程在访问 data，不涉及并发竞争
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个示例中，虽然我们使用了同步锁来保护 <code>data</code> 的访问，但是在逃逸分析的过程中，编译器可以发现 <code>data</code> 没有逃逸到堆上，因此它可以选择去掉同步锁，因为只有一个线程在访问 <code>data</code>，不存在并发竞争的情况。</p>
<p>这种优化可以提高程序的性能，因为同步锁的获取和释放操作可能会引入一些开销。不过需要注意的是，编译器会根据具体情况进行判断，而不是简单地因为只有一个线程就去掉所有同步锁。在多线程情况下，同步锁是必要的，以确保数据的安全访问。因此，在编写多线程程序时，仍然需要谨慎使用同步锁以确保线程安全。</p>
</div>
        </div>
    </div>
<h2 id="总结" class="headerLink">
    <a href="#%e6%80%bb%e7%bb%93" class="header-mark"></a>总结</h2><ol>
<li>
<p>堆上动态分配内存比栈上静态分配内存，开销大很多。</p>
</li>
<li>
<p>变量分配在栈上需要能在编译期确定它的作用域，否则会分配到堆上。</p>
</li>
<li>
<p>Go 编译器会在编译期对考察变量的作用域，并作一系列检查，如果它的作用域在运行期间对编译器一直是可知的，那么就会分配到栈上。简单来说，<strong>编译器会根据变量是否被外部引用来决定是否逃逸</strong>。</p>
</li>
<li>
<p>编译器的这些逃逸分析规则其实不需要掌握，只需通过 <code>go build -gcflags=-m</code> 命令来观察变量逃逸情况就行了。</p>
</li>
<li>
<p>不要盲目使用变量的指针作为函数参数，虽然它会减少复制操作。但其实当参数为变量自身的时候，复制是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多。</p>
</li>
<li>
<p>逃逸分析在编译阶段完成的。</p>
</li>
</ol>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://colynn.github.io/2020-07-16-go-memory-allocation/" target="_blank" rel="noopener noreferrer">Golang 内存分配 - stack and heap</a></li>
</ul>
]]></description>
</item><item>
    <title>Docker 单机安装使用 Elasticsearch</title>
    <link>https://www.xiaobinqt.cn/docker-elastic-install/</link>
    <pubDate>Tue, 12 Sep 2023 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/docker-elastic-install/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="安装-es" class="headerLink">
    <a href="#%e5%ae%89%e8%a3%85-es" class="header-mark"></a>安装 ES</h2><p>当前 <code>ElasticSearch</code> 已经到了 <code>8.0+</code>，新版本都有很多新特性，性能和功能都有大幅提升，建议使用较高版本，这里采用 <code>7.12.1</code> 版本 👼</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/f7745775638b42829fd11821d4406420.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/f7745775638b42829fd11821d4406420.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/f7745775638b42829fd11821d4406420.png" data-sub-html="<h2>es 版本</h2>">
        
    </a><figcaption class="image-caption">es 版本</figcaption>
    </figure></p>
<p>安装 <code>ElasticSearch</code> 脚本如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run -d \
</span></span><span class="line"><span class="cl">--name elasticsearch \
</span></span><span class="line"><span class="cl">    -e &#34;discovery.type=single-node&#34; \
</span></span><span class="line"><span class="cl">    --privileged \
</span></span><span class="line"><span class="cl">    -p 9200:9200 \
</span></span><span class="line"><span class="cl">    -p 9300:9300 \
</span></span><span class="line"><span class="cl">elasticsearch:7.12.1
</span></span></code></pre></td></tr></table>
</div>
</div><p>常用命令说明：</p>
<ul>
<li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li>
<li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li>
<li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：内存大小</li>
<li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li>
<li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定<code>elasticsearch</code>的数据目录</li>
<li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定<code>elasticsearch</code>的日志目录</li>
<li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定<code>elasticsearch</code>的插件目录</li>
<li><code>--privileged</code>：授予逻辑卷访问权</li>
<li><code>-p 9200:9200</code>：端口映射配置</li>
</ul>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/ca407aeb5d044916b27673149b45ec26.png" title="安装 es" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/ca407aeb5d044916b27673149b45ec26.png" data-sub-html="<h2>docker 安装 es</h2><p>安装 es</p>">
        
    </a><figcaption class="image-caption">docker 安装 es</figcaption>
    </figure></p>
<p>安装完成后，在浏览器中输入：<code>http://172.27.46.132/:9200/</code> 即可看到 <code>elasticsearch</code> 的响应结果：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/a8b3f2fe7d164cb7a02bf8491bbc05cf.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/a8b3f2fe7d164cb7a02bf8491bbc05cf.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/a8b3f2fe7d164cb7a02bf8491bbc05cf.png" data-sub-html="<h2>es 响应结果</h2>">
        
    </a><figcaption class="image-caption">es 响应结果</figcaption>
    </figure></p>
<h2 id="kibana" class="headerLink">
    <a href="#kibana" class="header-mark"></a>Kibana</h2><p>我们可以基于 <code>http</code> 请求操作 <code>ElasticSearch</code>，但基于 <code>http</code> 操作比较麻烦，可以采用 <code>Kibana</code> 实现可视化操作。</p>
<p><code>Kibana</code> 是一个免费且开放的用户界面，能够对 <code>Elasticsearch</code> 数据进行可视化，并在 <code>Elastic Stack</code> 中进行导航，可以进行各种操作，从跟踪查询负载，到理解请求如何流经的整个应用，都能轻松完成。<code>Kibana</code> 让能够自由地选择如何呈现自己的数据。</p>
<h3 id="kibana-安装" class="headerLink">
    <a href="#kibana-%e5%ae%89%e8%a3%85" class="header-mark"></a>Kibana 安装</h3><p>使用 <code>Docker</code> 安装 <code>Kibana</code> 非常简单，但是执行命令需要注意 <code>Kibana</code> 操作的 <code>ElasticSearch</code> 地址，因为 <code>Kibana</code> 是需要连接 <code>ElasticSearch</code> 进行操作的，所以需要 es 和 <code>Kibana</code> 在同一网段，安装 <code>Kibana</code> 命令如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run -d \
</span></span><span class="line"><span class="cl">--name kibana \
</span></span><span class="line"><span class="cl">-e ELASTICSEARCH_HOSTS=http://172.27.46.132:9200 \
</span></span><span class="line"><span class="cl">-p 5601:5601  \
</span></span><span class="line"><span class="cl">kibana:7.12.1
</span></span></code></pre></td></tr></table>
</div>
</div><p>命令说明：</p>
<ul>
<li><code>-e ELASTICSEARCH_HOSTS=http://172.27.46.132:9200&quot;</code>：设置 <code>elasticsearch</code> 的地址，因为 <code>kibana</code> 已经与<code>elasticsearch</code>在一个网络，因此可以用容器名直接访问 <code>elasticsearch</code>，也可以写 IP 地址实现访问。</li>
<li><code>-p 5601:5601</code>：端口映射配置</li>
</ul>
<p>安装的时候如果没有镜像，会下载镜像，效果如下：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/8348436b33284bba88bb2efa43b298f1.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/8348436b33284bba88bb2efa43b298f1.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/8348436b33284bba88bb2efa43b298f1.png" data-sub-html="<h2>安装 Kibana</h2>">
        
    </a><figcaption class="image-caption">安装 Kibana</figcaption>
    </figure></p>
<p>安装成功后，可以访问 <code>http://172.27.46.132:5601/</code> 效果如下：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/53c75f9beec0482ba216e08af2e4d035.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/53c75f9beec0482ba216e08af2e4d035.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/53c75f9beec0482ba216e08af2e4d035.png" data-sub-html="<h2>Kibana 效果</h2>">
        
    </a><figcaption class="image-caption">Kibana 效果</figcaption>
    </figure></p>
<p>可以点击 <code>Add data</code>，添加示例数据，如下图，随意选一个即可，不选其实也是可以的。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/f74d72b57b544c6485d15de34417f89f.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/f74d72b57b544c6485d15de34417f89f.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/f74d72b57b544c6485d15de34417f89f.png" data-sub-html="<h2>添加数据</h2>">
        
    </a><figcaption class="image-caption">添加数据</figcaption>
    </figure></p>
<h3 id="kibana-中文配置" class="headerLink">
    <a href="#kibana-%e4%b8%ad%e6%96%87%e9%85%8d%e7%bd%ae" class="header-mark"></a>Kibana 中文配置</h3><p><code>Kibana</code> 支持中文配置，可以把 <code>Kibana</code> 配置成中文版，切换中文操作如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#进入容器
</span></span><span class="line"><span class="cl">docker exec -it kibana /bin/bash
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#进入配置文件目录
</span></span><span class="line"><span class="cl">cd /usr/share/kibana/config
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#编辑文件kibana.yml
</span></span><span class="line"><span class="cl">vi kibana.yml
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#在最后一行添加如下配置
</span></span><span class="line"><span class="cl">i18n.locale: zh-CN
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#保存退出
</span></span><span class="line"><span class="cl">exit
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#并重启容器
</span></span><span class="line"><span class="cl">docker restart kibana
</span></span></code></pre></td></tr></table>
</div>
</div><p>等待 <code>Kibana</code> 容器启动，再次访问 <code>http://172.27.46.132:5601/</code> 效果如下：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/43ffacffaff84394a12e7e741bcc8f65.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/43ffacffaff84394a12e7e741bcc8f65.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/43ffacffaff84394a12e7e741bcc8f65.png" data-sub-html="<h2>中文效果</h2>">
        
    </a><figcaption class="image-caption">中文效果</figcaption>
    </figure></p>
<h2 id="ik-分词器安装" class="headerLink">
    <a href="#ik-%e5%88%86%e8%af%8d%e5%99%a8%e5%ae%89%e8%a3%85" class="header-mark"></a>IK 分词器安装</h2><p>打开 <code>Kibana</code>，点击开发工具，操作如下：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/ef521d29bf764703adabe06108c6ef9f.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/ef521d29bf764703adabe06108c6ef9f.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/ef521d29bf764703adabe06108c6ef9f.png" data-sub-html="<h2>开发工具</h2>">
        
    </a><figcaption class="image-caption">开发工具</figcaption>
    </figure></p>
<p>在左边输入如下内容，用于查询分词：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">GET _analyze
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;analyzer&#34;: &#34;standard&#34;,
</span></span><span class="line"><span class="cl">  &#34;text&#34;: &#34;php 是世界上最好的语言&#34;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>效果如下：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/a8c86a3f5c8640108a32551ace6b8cad.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/a8c86a3f5c8640108a32551ace6b8cad.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/a8c86a3f5c8640108a32551ace6b8cad.png" data-sub-html="<h2>分词效果</h2>">
        
    </a><figcaption class="image-caption">分词效果</figcaption>
    </figure></p>
<p>使用 <code>standard</code> 对 <code>php 是世界上最好的语言</code> 进行分词。</p>
<p><code>分词</code>：提取一句话或者一篇文章中的词语。</p>
<p>我们在使用 <code>ElasticSearch</code> 的时候，默认用 <code>standard</code> 分词器，但 <code>standard</code> 分词器使用的是按空格分词，这种分词操作方法不符合中文分词标准，我们需要额外安装中文分词器。</p>
<h3 id="ik-分词器" class="headerLink">
    <a href="#ik-%e5%88%86%e8%af%8d%e5%99%a8" class="header-mark"></a>IK 分词器</h3><p><code>IK Analyzer</code> 是一个开源的，基于 java 语言开发的轻量级的中文分词工具包。可以直接在 <code>ElasticSearch</code> 中集成 IK 分词器，<code>IK</code> 分词器集成<code>ElasticSearch</code>下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases" target="_blank" rel="noopener noreferrer">elasticsearch-analysis-ik/releases</a>。IK 可以跟 es 的版本一致，我们 es 的版本是 7.12.1，IK 的版本也是用 7.12.1。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/89e1dba4c7fd481ba7183f764a9cb18f.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/89e1dba4c7fd481ba7183f764a9cb18f.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/89e1dba4c7fd481ba7183f764a9cb18f.png" data-sub-html="<h2>IK 分词器</h2>">
        
    </a><figcaption class="image-caption">IK 分词器</figcaption>
    </figure></p>
<h3 id="ik-分词器配置" class="headerLink">
    <a href="#ik-%e5%88%86%e8%af%8d%e5%99%a8%e9%85%8d%e7%bd%ae" class="header-mark"></a>IK 分词器配置</h3><p>下载安装包 <a href="https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip" target="_blank" rel="noopener noreferrer">elasticsearch-analysis-ik/releases/tag/v7.12.1</a> 后，，需要将 <code>elasticsearch-analysis-ik-7.12.1.zip</code> 拷贝到 <code>elasticSearch</code> 容器里的的 <code>/usr/share/elasticsearch/plugins</code> 目录中解压即可。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/ee221bb0e9424881b5ea8a687fa5d7bf.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/ee221bb0e9424881b5ea8a687fa5d7bf.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/ee221bb0e9424881b5ea8a687fa5d7bf.png" data-sub-html="<h2>cp elasticsearch-analysis-ik-7.12.1.zip</h2>">
        
    </a><figcaption class="image-caption">cp elasticsearch-analysis-ik-7.12.1.zip</figcaption>
    </figure></p>
<p>解压文件成功后，然后<strong>重启</strong> es 容器。</p>
<h3 id="分词测试" class="headerLink">
    <a href="#%e5%88%86%e8%af%8d%e6%b5%8b%e8%af%95" class="header-mark"></a>分词测试</h3><p><code>IK</code>分词器包含两种模式：</p>
<ul>
<li>
<p><code>ik_smart</code>：最少切分</p>
</li>
<li>
<p><code>ik_max_word</code>：最细切分</p>
</li>
</ul>
<p>前面使用默认的<code>standard</code>分词器，对中文分词非常难用，安装IK分词器后，我们可以使用IK分词器测试，测试代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">GET _analyze
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;analyzer&#34;: &#34;ik_max_word&#34;,
</span></span><span class="line"><span class="cl">  &#34;text&#34;: &#34;php 是世界上最好的语言&#34;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>测试效果如下：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/689f9549af6440e999bf83865dedbe54.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/689f9549af6440e999bf83865dedbe54.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/689f9549af6440e999bf83865dedbe54.png" data-sub-html="<h2>效果</h2>">
        
    </a><figcaption class="image-caption">效果</figcaption>
    </figure></p>
<p>可以发现对中文的分词效果是比较不错的，但也存在一些不足，比如 <code>最好的</code> 我们希望它是一个词，而 <code>上</code>我们希望它不被识别一个词，这种需求可以同过自定义词典解决。</p>
<h2 id="ik-自定义词典" class="headerLink">
    <a href="#ik-%e8%87%aa%e5%ae%9a%e4%b9%89%e8%af%8d%e5%85%b8" class="header-mark"></a>IK 自定义词典</h2><p>IK 分词器支持自定义词典，包括自定义分词，也包含自定义停用分词，操作起来非常简单。接下来实现一下自定义词典和停用词典。</p>
<h3 id="自定义词典" class="headerLink">
    <a href="#%e8%87%aa%e5%ae%9a%e4%b9%89%e8%af%8d%e5%85%b8" class="header-mark"></a>自定义词典</h3><p>自定义词典，需要先创建自己的词典，再引用自己的词典即可。</p>
<ol>
<li>创建词典</li>
</ol>
<p>在 es 容器目录 <code>/usr/share/elasticsearch/plugins/ik/config</code> 中创建自己的词典，例如叫 <code>custome.dic</code>，在文件中添加自定义的词语，操作如下：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/432e98e286cb4c3587caa0c35f2d6446.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/432e98e286cb4c3587caa0c35f2d6446.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/432e98e286cb4c3587caa0c35f2d6446.png" data-sub-html="<h2>创建词典</h2>">
        
    </a><figcaption class="image-caption">创建词典</figcaption>
    </figure></p>
<p>我们把自定义的词典 <code>最好的</code> 添加到了 <code>custome.dic</code> 中了，这就是创建词典，如果有多个自定义词，需要换行加入，这里一定要注意中文分词设置编码格式为 <code>UTF-8</code>。</p>
<ol start="2">
<li>引用词典</li>
</ol>
<p>修改 <code>config/IKAnalyzer.cfg.xml</code> 引用自己创建的 <code>custome.dic</code> 词典，配置如下:</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/ef379f05c79646f4b61bc964dfe17b07.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/ef379f05c79646f4b61bc964dfe17b07.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/ef379f05c79646f4b61bc964dfe17b07.png" data-sub-html="<h2>引用自定义字典</h2>">
        
    </a><figcaption class="image-caption">引用自定义字典</figcaption>
    </figure></p>
<p>再使用 <code>Kibana</code> 效果如下：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/71f95f67e34c4723b8923d3113b4951c.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/71f95f67e34c4723b8923d3113b4951c.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/71f95f67e34c4723b8923d3113b4951c.png" data-sub-html="<h2>效果</h2>">
        
    </a><figcaption class="image-caption">效果</figcaption>
    </figure></p>
<h3 id="自定义停用词汇" class="headerLink">
    <a href="#%e8%87%aa%e5%ae%9a%e4%b9%89%e5%81%9c%e7%94%a8%e8%af%8d%e6%b1%87" class="header-mark"></a>自定义停用词汇</h3><p>自定义停用词典和自定义词典一样，需要先创建自己的词典，再引用自己的词典即可。</p>
<ol>
<li>创建词典</li>
</ol>
<p>在 <code>config</code> 中创建自己的停用词典，例如叫 <code>stop.dic</code>，在文件中添加自定义的停用词语，操作如下：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/a389717b1b254a4199b0a08b334afd16.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/a389717b1b254a4199b0a08b334afd16.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/a389717b1b254a4199b0a08b334afd16.png" data-sub-html="<h2>停用词汇</h2>">
        
    </a><figcaption class="image-caption">停用词汇</figcaption>
    </figure></p>
<ol start="2">
<li>引用词典</li>
</ol>
<p>修改 <code>config/IKAnalyzer.cfg.xml</code> 引用自己创建的 <code>stop.dic</code> 停用词典，配置如下:</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/cc6cc42963ec4eed8da6f875c9220807.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/cc6cc42963ec4eed8da6f875c9220807.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/cc6cc42963ec4eed8da6f875c9220807.png" data-sub-html="<h2>停用词典配置</h2>">
        
    </a><figcaption class="image-caption">停用词典配置</figcaption>
    </figure></p>
<p>修改完成后，重启 <code>elasticsearch</code> 容器。</p>
<p>再使用 <code>Kibana</code> 测试效果如下：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/9bdadba012d049e4a9c34f2d3163b190.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/9bdadba012d049e4a9c34f2d3163b190.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230912/9bdadba012d049e4a9c34f2d3163b190.png" data-sub-html="<h2>停用分词效果</h2>">
        
    </a><figcaption class="image-caption">停用分词效果</figcaption>
    </figure></p>
<p>可以发现，不再有 <code>世界</code>，<code>的</code>，<code>是</code>，<code>上</code>，<code>语言</code> 的分词了，说明停用分词也生效了。</p>
<h2 id="一个例子" class="headerLink">
    <a href="#%e4%b8%80%e4%b8%aa%e4%be%8b%e5%ad%90" class="header-mark"></a>一个例子</h2><p>现在有个需求是向 mysql 中插入文章，但是同时需要向 es 中写入文章，通过 es 来分词，优化搜索，通过 es 搜索时，可以返回 mysql 中对应的 id。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">`</span><span class="n">article</span><span class="o">`</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="w">          </span><span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="n">unsigned</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="n">AUTO_INCREMENT</span><span class="w"> </span><span class="k">primary</span><span class="w"> </span><span class="k">key</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">title</span><span class="o">`</span><span class="w">       </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">comment</span><span class="w"> </span><span class="s1">&#39;文章标题&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">content</span><span class="o">`</span><span class="w">     </span><span class="nb">text</span><span class="w"> </span><span class="k">COMMENT</span><span class="w"> </span><span class="s1">&#39;文章内容&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">create_time</span><span class="o">`</span><span class="w"> </span><span class="k">timestamp</span><span class="w">    </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">update_time</span><span class="o">`</span><span class="w"> </span><span class="k">timestamp</span><span class="w">    </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">UPDATE</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w"> </span><span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span><span class="w"> </span><span class="k">COMMENT</span><span class="o">=</span><span class="s1">&#39;文章表&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>golang 代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;database/sql&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;encoding/json&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/elastic/go-elasticsearch/v7/esapi&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="s">&#34;github.com/go-sql-driver/mysql&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strings&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 初始化 MySQL 连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sql</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;mysql&#34;</span><span class="p">,</span> <span class="s">&#34;root:123456@tcp(localhost:3306)/wb-test&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 初始化 Elasticsearch 连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">esConfig</span> <span class="o">:=</span> <span class="nx">elasticsearch</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Addresses</span><span class="p">:</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;http://localhost:9200&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">esClient</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">elasticsearch</span><span class="p">.</span><span class="nf">NewClient</span><span class="p">(</span><span class="nx">esConfig</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 插入文章到 MySQL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">articleTitle</span> <span class="o">:=</span> <span class="s">&#34;蝶恋花&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">articleContent</span> <span class="o">:=</span> <span class="s">&#34;花褪残红注青杏小。燕子飞时，绿水人家绕。枝上柳绵注吹又少。天涯何处无芳草。墙里秋千墙外道。墙外行人，墙里佳人笑。笑渐不闻声渐悄。多情却被无情恼。&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="s">&#34;INSERT INTO article (title, content) VALUES (?, ?)&#34;</span><span class="p">,</span> <span class="nx">articleTitle</span><span class="p">,</span> <span class="nx">articleContent</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 获取插入文章的 MySQL ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">articleID</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">QueryRow</span><span class="p">(</span><span class="s">&#34;SELECT LAST_INSERT_ID()&#34;</span><span class="p">).</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">articleID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 在 Elasticsearch 中写入文章
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">esIndexName</span> <span class="o">:=</span> <span class="s">&#34;articles&#34;</span> <span class="c1">// Elasticsearch 索引名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">docID</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="nx">articleID</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//esDoc := map[string]interface{}{
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//	&#34;title&#34;:   articleTitle,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//	&#34;content&#34;: articleContent,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//	&#34;mysql_id&#34;: articleID, // 将 MySQL ID 存储在 Elasticsearch 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建 Elasticsearch 文档
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">esRequest</span> <span class="o">:=</span> <span class="nx">esapi</span><span class="p">.</span><span class="nx">IndexRequest</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Index</span><span class="p">:</span>      <span class="nx">esIndexName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">DocumentID</span><span class="p">:</span> <span class="nx">docID</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Body</span><span class="p">:</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">`{
</span></span></span><span class="line"><span class="cl"><span class="s">            &#34;title&#34;: &#34;%s&#34;,
</span></span></span><span class="line"><span class="cl"><span class="s">            &#34;content&#34;: &#34;%s&#34;,
</span></span></span><span class="line"><span class="cl"><span class="s">            &#34;mysql_id&#34;: %d
</span></span></span><span class="line"><span class="cl"><span class="s">        }`</span><span class="p">,</span> <span class="nx">articleTitle</span><span class="p">,</span> <span class="nx">articleContent</span><span class="p">,</span> <span class="nx">articleID</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Refresh</span><span class="p">:</span> <span class="s">&#34;true&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">esRequest</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">esClient</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">res</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 从 Elasticsearch 中查询文章，包括 MySQL ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//esQuery := map[string]interface{}{
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//	&#34;query&#34;: map[string]interface{}{
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//		&#34;match&#34;: map[string]interface{}{
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//			&#34;title&#34;: &#34;示例文章标题&#34;,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//		},
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//	},
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">esSearchRequest</span> <span class="o">:=</span> <span class="nx">esapi</span><span class="p">.</span><span class="nx">SearchRequest</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Index</span><span class="p">:</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">esIndexName</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Body</span><span class="p">:</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">`{
</span></span></span><span class="line"><span class="cl"><span class="s">            &#34;query&#34;: {
</span></span></span><span class="line"><span class="cl"><span class="s">                &#34;match&#34;: {
</span></span></span><span class="line"><span class="cl"><span class="s">                    &#34;title&#34;: &#34;示例文章标题&#34;
</span></span></span><span class="line"><span class="cl"><span class="s">                }
</span></span></span><span class="line"><span class="cl"><span class="s">            }
</span></span></span><span class="line"><span class="cl"><span class="s">        }`</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">esSearchRequest</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">esClient</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">res</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 处理 Elasticsearch 查询结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">res</span><span class="p">.</span><span class="nf">IsError</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Error: %s&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nf">Status</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 解析查询结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">response</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">Body</span><span class="p">).</span><span class="nf">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">response</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Error parsing the response body: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">hits</span> <span class="o">:=</span> <span class="nx">response</span><span class="p">[</span><span class="s">&#34;hits&#34;</span><span class="p">].(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})[</span><span class="s">&#34;hits&#34;</span><span class="p">].([]</span><span class="kd">interface</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">hit</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">hits</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">source</span> <span class="o">:=</span> <span class="nx">hit</span><span class="p">.(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})[</span><span class="s">&#34;_source&#34;</span><span class="p">].(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">		<span class="nx">title</span> <span class="o">:=</span> <span class="nx">source</span><span class="p">[</span><span class="s">&#34;title&#34;</span><span class="p">].(</span><span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">content</span> <span class="o">:=</span> <span class="nx">source</span><span class="p">[</span><span class="s">&#34;content&#34;</span><span class="p">].(</span><span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mysqlID</span> <span class="o">:=</span> <span class="nx">source</span><span class="p">[</span><span class="s">&#34;mysql_id&#34;</span><span class="p">].(</span><span class="kt">float64</span><span class="p">)</span> <span class="c1">// 从 Elasticsearch 中获取 MySQL ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;标题: %s内容: %sMySQL ID: %d&#34;</span><span class="p">,</span> <span class="nx">title</span><span class="p">,</span> <span class="nx">content</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">mysqlID</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 kibana 查看到 es 现在有 2 条数据：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230913/3212ca90f6c04a96884c59ca17524f8b.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230913/3212ca90f6c04a96884c59ca17524f8b.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230913/3212ca90f6c04a96884c59ca17524f8b.png" data-sub-html="<h2>结果数据</h2>">
        
    </a><figcaption class="image-caption">结果数据</figcaption>
    </figure></p>
<p>在 kibana 中通过查询接口搜索 content 内容包含 “绕” 的，展示效果如下：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230913/cd4487b3e4fd4c2f8e6e5bd830561b3e.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230913/cd4487b3e4fd4c2f8e6e5bd830561b3e.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230913/cd4487b3e4fd4c2f8e6e5bd830561b3e.png" data-sub-html="<h2>搜索结构</h2>">
        
    </a><figcaption class="image-caption">搜索结构</figcaption>
    </figure></p>
<p>查询 content 含有 “11111” <strong>或</strong> title 中含有 “悯” 的数据结果如下：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230913/2ef161f48f494c5aa4d4b50d46860ad7.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230913/2ef161f48f494c5aa4d4b50d46860ad7.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230913/2ef161f48f494c5aa4d4b50d46860ad7.png" data-sub-html="<h2>查询结果</h2>">
        
    </a><figcaption class="image-caption">查询结果</figcaption>
    </figure></p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/458011982" target="_blank" rel="noopener noreferrer">Elastic Search 入门</a></li>
<li><a href="https://juejin.cn/post/6936487066272432142" target="_blank" rel="noopener noreferrer">Elasticsearch 中 must, filter, should, must_not, constant_score 的区别</a></li>
</ul>
]]></description>
</item><item>
    <title>布雷顿森林体系</title>
    <link>https://www.xiaobinqt.cn/bretton-woods-system/</link>
    <pubDate>Fri, 07 Jul 2023 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/bretton-woods-system/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="来源" class="headerLink">
    <a href="#%e6%9d%a5%e6%ba%90" class="header-mark"></a>来源</h2><p>布雷顿森林体系（Bretton Woods system）是二战后建立的一套全球金融和货币体系，于 1944 年在美国新罕布什尔州的布雷顿森林酒店（Bretton Woods Hotel）会议上确立。该体系的目标是为世界各国提供稳定的货币和贸易体系，以促进国际合作和重建战后经济。</p>
<p>布雷顿森林体系的核心是建立固定汇率制度，其中美元被确定为主要储备货币，与黄金的兑换比率固定为 35 美元/盎司。其他国家的货币则与美元进行固定汇率的兑换，保持汇率的稳定。此外，成立了国际货币基金组织（IMF）和国际复兴开发银行（World Bank），以提供贷款和援助给战后重建的国家。</p>
<h2 id="加息和减息" class="headerLink">
    <a href="#%e5%8a%a0%e6%81%af%e5%92%8c%e5%87%8f%e6%81%af" class="header-mark"></a>加息和减息</h2><p>加息和减息是央行调整利率政策时采取的两种主要行动。</p>
<h3 id="加息" class="headerLink">
    <a href="#%e5%8a%a0%e6%81%af" class="header-mark"></a>加息</h3><p>加息指央行提高基准利率或政策利率的行为。央行通过加息来控制经济的热度和通胀压力。当央行认为经济过热或通胀压力上升时，它可能会加息以抑制消费和投资需求，减缓经济增长速度并控制通胀。</p>
<p>加息的影响包括：</p>
<ul>
<li>
<p>贷款成本上升：加息会导致商业银行借款成本上升，进而传导到借款人，使得贷款更加昂贵。这可以降低消费和投资支出，抑制经济增长。</p>
</li>
<li>
<p>投资收益下降：高利率使得储蓄和固定收益类投资更具吸引力，可能导致股票市场回报下降。</p>
</li>
<li>
<p>货币升值：高利率往往会吸引外国资本流入，推动货币升值，对出口企业造成压力，可能导致贸易顺差减少。</p>
</li>
</ul>
<p>当一个国家的央行提高利率时，这可能会使该国的货币更有吸引力，从而吸引更多的外国投资者将资金流入该国。这种外国资本流入会增加该国的需求，导致该国的货币升值。</p>
<p>货币升值对出口企业造成压力的原因在于，当国家的货币升值时，该国的出口商品价格在国际市场上变得更昂贵。这可能导致出口企业在竞争中失去价格竞争力，减少对外贸易的需求，进而可能减少该国的出口额度。因此，这可能导致该国的贸易顺差减少或贸易逆差增加。</p>
<p>举个例子，假设国家A的央行决定提高利率，这会使得国家A的货币更有吸引力。外国投资者可能会将资金流入国家A，因为他们可以获得更高的回报率。这种资本流入会导致国家A的货币升值。</p>
<p>由于货币升值，国家 A 的出口商品的价格在国际市场上变得更昂贵。假设国家A是一个出口导向型经济体，主要依赖出口来实现经济增长。然而，由于货币升值，国家 A 的出口商品相对于其他国家变得更昂贵，这可能导致其他国家购买国家 A 的商品减少。这可能减少了国家 A 的出口额度，可能导致贸易顺差减少或贸易逆差增加。</p>
<h3 id="减息" class="headerLink">
    <a href="#%e5%87%8f%e6%81%af" class="header-mark"></a>减息</h3><p>减息指央行降低基准利率或政策利率的行为。央行通过降息来刺激经济增长和提振通胀水平。当央行认为经济增长缓慢或通缩风险增加时，它可能会降息以刺激消费和投资需求，促进经济活动。</p>
<p>减息的影响包括：</p>
<ul>
<li>
<p>贷款成本下降：降息使得商业银行借款成本下降，推动贷款利率的下降。这可以促进消费和投资支出，刺激经济增长。</p>
</li>
<li>
<p>投资回报增加：低利率使得股票市场和风险资产更具吸引力，可能推动股市回报率上升。</p>
</li>
<li>
<p>货币贬值：降息可能导致资本外流，使货币贬值，对出口企业有利，可能提高贸易顺差。</p>
</li>
</ul>
<p>当央行降低利率时，银行的借贷成本下降，这意味着企业和个人可以以更低的成本借款。较低的借贷成本通常会刺激投资者寻求更高的回报率，因为他们可以以更低的成本进行借贷和投资。</p>
<p>在这种情况下，股票市场和其他风险资产，如股票基金或房地产投资信托（REITs）等，往往更具吸引力。投资者可能倾向于将资金投入到这些风险资产中，以追求更高的回报。这种投资需求可能推动股票市场的回报率上升。</p>
<p>例如，假设某国央行决定降低利率，这导致银行向企业和个人提供更便宜的贷款。企业和个人可以以更低的利率借款来扩大业务或进行投资。这可能促使一些投资者将资金投入到股票市场，购买股票。当投资者需求增加时，股票市场的股票价格可能上涨，并且投资者可能通过股息或股价上涨获得更高的回报率。</p>
<h2 id="瓦解" class="headerLink">
    <a href="#%e7%93%a6%e8%a7%a3" class="header-mark"></a>瓦解</h2><p>布雷顿森林体系在 20 世纪 70 年代面临了一系列挑战，最终导致了其瓦解。以下是一些导致布雷顿森林体系瓦解的主要原因：</p>
<ol>
<li>
<p>美元超发：由于美国在二战后是全球最大的经济体，并拥有最多的黄金储备，美元成为其他国家的主要储备货币。然而，美国的大规模贸易赤字和金融政策的宽松导致了美元的超发，进而削弱了美元的价值和国际信誉。</p>
</li>
<li>
<p>黄金供应问题：随着国际贸易的增长和美元超发，其他国家开始将美元兑换成黄金，使美国黄金储备减少。这引发了对黄金供应的担忧，使得美元与黄金的固定兑换比率难以维持。</p>
</li>
<li>
<p>汇率固定的不可持续性：由于全球经济发展不均衡和国家之间的经济差异，保持汇率固定变得越来越困难。一些国家面临经济困难时，无法通过调整汇率来恢复竞争力，而只能实施紧缩政策，导致经济衰退和高失业率。</p>
</li>
<li>
<p>外汇市场的自由化：1971 年，美国总统尼克松宣布取消美元与黄金的直接兑换，使美元脱离了黄金标准。这导致了外汇市场的自由化和浮动汇率制度的崛起，使得固定汇率制度失去了基础。</p>
</li>
</ol>
<h2 id="名词解释" class="headerLink">
    <a href="#%e5%90%8d%e8%af%8d%e8%a7%a3%e9%87%8a" class="header-mark"></a>名词解释</h2><h3 id="赤字" class="headerLink">
    <a href="#%e8%b5%a4%e5%ad%97" class="header-mark"></a>赤字</h3><p>赤字（Deficit）是指在财政上支出超过收入的情况。在政府财政领域，赤字通常是指政府的财政赤字，即政府支出超过政府收入的情况。</p>
<p>政府的收入主要来自税收、关税、国有企业利润等，而支出包括公共服务、基础设施建设、社会福利、国防开支等。当政府的支出超过其收入时，就会出现财政赤字。</p>
<p>财政赤字通常需要通过借款来弥补，政府发行债券以吸引借款者购买，从而筹集额外的资金来填补财政赤字。这些债券通常由政府承诺在未来偿还，并支付一定的利息。</p>
<p>赤字并不一定是负面的，政府可能出于某种经济或政策考虑有意选择实施财政赤字。例如，在经济衰退时，政府可能增加支出来刺激经济增长，即采取财政刺激政策。然而，长期持续的赤字可能会导致债务累积和财政可持续性问题，需要政府采取适当的措施来平衡收支，以确保财政稳定和可持续发展。</p>
<h3 id="紧缩政策" class="headerLink">
    <a href="#%e7%b4%a7%e7%bc%a9%e6%94%bf%e7%ad%96" class="header-mark"></a>紧缩政策</h3><p>紧缩政策（Austerity Policy）是指政府采取的一系列经济政策和财政措施，旨在削减政府支出、减少财政赤字、控制通胀和降低债务水平。紧缩政策通常包括以下方面：</p>
<ol>
<li>
<p>财政支出削减：政府削减各个领域的开支，包括公共服务、基础设施、教育、医疗保健等，以降低财政赤字和债务水平。</p>
</li>
<li>
<p>税收增加：政府可能增加税收，包括提高税率、扩大税基或引入新的税种，以增加财政收入。</p>
</li>
<li>
<p>社会福利削减：政府可能减少社会福利开支，包括减少失业救济金、养老金、医疗保险等福利项目，以减少财政负担。</p>
</li>
<li>
<p>公共部门裁员：政府可能削减公共部门的人员编制，以降低人力成本和财政支出。</p>
</li>
<li>
<p>货币紧缩：央行可能采取紧缩的货币政策，通过加息、收紧信贷等手段来控制通胀和抑制消费支出。</p>
</li>
</ol>
<p>紧缩政策通常在经济衰退、高通胀、债务危机等情况下实施。它的目标是通过削减支出、增加收入和提高财政纪律，使政府的财政状况得到改善，并恢复经济的可持续增长。然而，紧缩政策也可能导致经济活动减缓、失业率上升、社会福利下降等问题。</p>
<h3 id="高通胀" class="headerLink">
    <a href="#%e9%ab%98%e9%80%9a%e8%83%80" class="header-mark"></a>高通胀</h3><p>高通胀（High inflation）是指物价持续上涨的速度较高的情况。在高通胀环境下，货币购买力逐渐下降，人们需要支付更多的货币来购买相同数量的商品和服务。高通胀通常被认为是一种经济不稳定的现象，可能对经济和社会造成一系列影响。</p>
<p>高通胀通常由供求失衡、货币供应过剩、成本推动或需求推动等因素引起。以下是一些常见的原因：</p>
<ol>
<li>
<p>货币供应过剩：当货币供应增长速度超过经济增长速度时，会导致货币供应过剩，从而推动物价上涨。</p>
</li>
<li>
<p>成本推动：成本上涨，如劳动力成本、原材料成本等的增加，可能会导致生产成本上升，企业为了维持利润率，将成本上涨转嫁到产品价格上，推动物价上涨。</p>
</li>
<li>
<p>需求推动：当需求超过供应时，供应不能满足市场需求，商品和服务的价格上涨。这可能是由于人口增长、消费需求增加、投资增加等引起的。</p>
</li>
</ol>
<p>高通胀可能会带来一系列的经济和社会问题，包括以下几点：</p>
<ol>
<li>
<p>财务不稳定：高通胀会削弱货币的购买力，对个人、家庭和企业的财务状况造成不利影响，尤其是固定收入者和持有现金的人。</p>
</li>
<li>
<p>消费减弱：由于物价上涨，消费者购买力下降，导致消费减少，对经济增长产生负面影响。</p>
</li>
<li>
<p>投资不确定性：高通胀环境下，价格不稳定，增加了投资决策的不确定性，可能抑制投资活动。</p>
</li>
<li>
<p>社会不稳定：高通胀可能引发社会不满和不平等加剧，对社会稳定造成威胁。</p>
</li>
</ol>
<h3 id="经常账户" class="headerLink">
    <a href="#%e7%bb%8f%e5%b8%b8%e8%b4%a6%e6%88%b7" class="header-mark"></a>经常账户</h3><p>经常账户（Current Account）是国际收支表中的一个重要部分，用于记录一个国家与其他国家之间的货物、服务、收入和转移的交易。</p>
<p>经常账户包括以下几个主要组成部分：</p>
<ol>
<li>
<p>货物贸易：货物贸易是指一个国家的出口和进口物品的价值。出口物品的价值增加了经常账户的借项（收入），而进口物品的价值增加了经常账户的贷项（支出）。货物贸易通常占据经常账户最大的部分。</p>
</li>
<li>
<p>服务贸易：服务贸易是指一个国家的出口和进口服务的价值，如旅游、运输、保险、金融、咨询等。出口服务增加了经常账户的借项，而进口服务增加了经常账户的贷项。</p>
</li>
<li>
<p>收入：收入部分记录了一个国家从海外获得的收入，包括工资、利息、股息、利润等。收入的借项表示从海外获得的收入，而贷项表示国内向海外支付的收入。</p>
</li>
<li>
<p>转移支付：转移支付是指一个国家与其他国家之间的无对价的转移，如国际援助、移民汇款、赠款等。转移支付的借项表示从海外获得的转移支付，而贷项表示国内向海外支付的转移支付。</p>
</li>
</ol>
<p>经常账户的结余（顺差）或逆差反映了一个国家与其他国家之间的净贸易状况。经常账户顺差表示国家的收入超过支出，而逆差表示支出超过收入。</p>
<p>经常账户是国际收支表的一个重要指标，它反映了一个国家与世界其他国家之间的经济关系和交流。经常账户的变动可以受到多种因素的影响，如贸易政策、经济增长、汇率变动、国际投资等。对经常账户的监测和管理有助于了解一个国家的国际经济状况，并可以帮助政策制定者采取适当的措施来平衡国际收支和维护经济稳定。</p>
<h2 id="贸易逆差和贸易顺差" class="headerLink">
    <a href="#%e8%b4%b8%e6%98%93%e9%80%86%e5%b7%ae%e5%92%8c%e8%b4%b8%e6%98%93%e9%a1%ba%e5%b7%ae" class="header-mark"></a>贸易逆差和贸易顺差</h2><p>贸易逆差（Trade deficit）和贸易顺差（Trade surplus）是国际贸易中两个重要的概念，用于描述一个国家的出口和进口之间的差额。</p>
<p>贸易顺差：贸易顺差指一个国家在一定时间内的出口总值超过其进口总值的情况。换句话说，贸易顺差表示该国的出口收入大于其进口支出。贸易顺差是一个国家经济的一种正面指标，意味着该国在国际贸易中净获得了经济价值。</p>
<p>贸易顺差可能会带来以下影响：</p>
<ul>
<li>
<p>增加外汇储备：贸易顺差意味着该国获得了外币收入，增加了其外汇储备，使其在国际支付和应对外部经济冲击时更具弹性。</p>
</li>
<li>
<p>刺激就业和经济增长：贸易顺差可以促进国内产业和出口相关行业的发展，刺激就业和经济增长。</p>
</li>
<li>
<p>改善经常账户：贸易顺差对经常账户有积极的影响，因为它表示国家在商品和服务贸易方面的净收入。</p>
</li>
</ul>
<p>贸易逆差：贸易逆差指一个国家在一定时间内的进口总值超过其出口总值的情况。贸易逆差表示该国的进口支出超过了其出口收入。贸易逆差通常被视为一个国家经济的挑战，因为它意味着该国需要依赖外国供应来满足国内需求。</p>
<p>贸易逆差可能会带来以下影响：</p>
<ul>
<li>
<p>减少外汇储备：贸易逆差意味着该国需要支付更多的外汇来购买进口商品，可能会减少其外汇储备，使其在国际支付方面面临挑战。</p>
</li>
<li>
<p>潜在的失业风险：贸易逆差可能会导致国内产业的竞争力下降，进而对就业产生负面影响。</p>
</li>
<li>
<p>经常账户压力：贸易逆差对经常账户产生负面影响，因为它表示国家在商品和服务贸易方面的净支出。</p>
</li>
</ul>
]]></description>
</item><item>
    <title>windows 下 python virtualenvwrapper-win 使用</title>
    <link>https://www.xiaobinqt.cn/virtualenvwrapper-win/</link>
    <pubDate>Fri, 26 May 2023 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/virtualenvwrapper-win/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<p>Virtualenvwrapper 是一个用于管理 Python 虚拟环境的工具，它为创建、切换和删除虚拟环境提供了一组方便的命令，并通过简化管理多个虚拟环境的过程来提高开发效率。</p>
<h2 id="安装" class="headerLink">
    <a href="#%e5%ae%89%e8%a3%85" class="header-mark"></a>安装</h2><p>可以使用 pip 安装 Virtualenvwrapper：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">pip install virtualenvwrapper-win
</span></span></code></pre></td></tr></table>
</div>
</div><p>安装完成后，需要设置一些环境变量。创建一个名为<code>WORKON_HOME</code>的环境变量，用于指定虚拟环境的存储位置。例如，可以将其设置为<code>D:\python\venv</code>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/7e68bb0eecb1482b88a6ab962986487a.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/7e68bb0eecb1482b88a6ab962986487a.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/7e68bb0eecb1482b88a6ab962986487a.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>WORKON_HOME</h2>">
        
    </a><figcaption class="image-caption">WORKON_HOME</figcaption>
    </figure></p>
<p>在安装并配置好 Virtualenvwrapper 后，打开一个<strong>新的</strong>命令行窗口，以便新的环境变量生效。</p>
<h2 id="创建虚拟环境" class="headerLink">
    <a href="#%e5%88%9b%e5%bb%ba%e8%99%9a%e6%8b%9f%e7%8e%af%e5%a2%83" class="header-mark"></a>创建虚拟环境</h2><p>使用 mkvirtualenv 命令创建一个新的虚拟环境。例如，要创建一个名为 go.src 的虚拟环境，可以运行以下命令：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/9b1e834a1bff4c54b551bedd9b49e384.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/9b1e834a1bff4c54b551bedd9b49e384.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/9b1e834a1bff4c54b551bedd9b49e384.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>mkvirtualenv</h2>">
        
    </a><figcaption class="image-caption">mkvirtualenv</figcaption>
    </figure></p>
<h2 id="查看所有虚拟环境" class="headerLink">
    <a href="#%e6%9f%a5%e7%9c%8b%e6%89%80%e6%9c%89%e8%99%9a%e6%8b%9f%e7%8e%af%e5%a2%83" class="header-mark"></a>查看所有虚拟环境</h2><p>要列出所有可用的虚拟环境，可以使用 workon 命令，不带任何参数运行它：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/cce01cbdc5254cee8b9115e2bd2cb30d.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/cce01cbdc5254cee8b9115e2bd2cb30d.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/cce01cbdc5254cee8b9115e2bd2cb30d.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>workon</h2>">
        
    </a><figcaption class="image-caption">workon</figcaption>
    </figure></p>
<h2 id="激活虚拟环境" class="headerLink">
    <a href="#%e6%bf%80%e6%b4%bb%e8%99%9a%e6%8b%9f%e7%8e%af%e5%a2%83" class="header-mark"></a>激活虚拟环境</h2><p>创建虚拟环境后，可以使用 workon 命令来激活该环境。例如，要激活名为 go.src 的虚拟环境，可以运行以下命令：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/1109c7cf3de9479081bbf3aeafdf4c61.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/1109c7cf3de9479081bbf3aeafdf4c61.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/1109c7cf3de9479081bbf3aeafdf4c61.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>激活虚拟环境</h2>">
        
    </a><figcaption class="image-caption">激活虚拟环境</figcaption>
    </figure></p>
<h2 id="删除虚拟环境" class="headerLink">
    <a href="#%e5%88%a0%e9%99%a4%e8%99%9a%e6%8b%9f%e7%8e%af%e5%a2%83" class="header-mark"></a>删除虚拟环境</h2><p>如果要删除不再需要的虚拟环境，可以使用 rmvirtualenv 命令，后跟要删除的虚拟环境的名称。例如，要删除名为 myenv 的虚拟环境，可以运行以下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">rmvirtualenv myenv
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="退出虚拟环境" class="headerLink">
    <a href="#%e9%80%80%e5%87%ba%e8%99%9a%e6%8b%9f%e7%8e%af%e5%a2%83" class="header-mark"></a>退出虚拟环境</h2><p>可以使用 deactivate 命令退出虚拟环境：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/3a979dd3e94942f1aaeaa2a2d54a967e.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/3a979dd3e94942f1aaeaa2a2d54a967e.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/3a979dd3e94942f1aaeaa2a2d54a967e.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>退出虚拟环境</h2>">
        
    </a><figcaption class="image-caption">退出虚拟环境</figcaption>
    </figure></p>
<h2 id="pycharm-配置" class="headerLink">
    <a href="#pycharm-%e9%85%8d%e7%bd%ae" class="header-mark"></a>pycharm 配置</h2><p><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/856d78b8073b47dc9d57874624a7ea6b.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/856d78b8073b47dc9d57874624a7ea6b.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/856d78b8073b47dc9d57874624a7ea6b.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15">
        
    </a></p>
<p><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/4093998f664f4d47ad95d563cbfab817.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/4093998f664f4d47ad95d563cbfab817.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230526/4093998f664f4d47ad95d563cbfab817.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15">
        
    </a></p>
]]></description>
</item><item>
    <title>Docker bridge 网络与自定义 DNS 解析</title>
    <link>https://www.xiaobinqt.cn/docker-net-custom-dns/</link>
    <pubDate>Wed, 24 May 2023 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/docker-net-custom-dns/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="常见-dns-记录类型" class="headerLink">
    <a href="#%e5%b8%b8%e8%a7%81-dns-%e8%ae%b0%e5%bd%95%e7%b1%bb%e5%9e%8b" class="header-mark"></a>常见 DNS 记录类型</h2><ul>
<li>A 记录（Address Record）</li>
</ul>
<p>记录格式：<code>example.com. IN A 192.0.2.1</code>，将域名映射到 IPv4 地址，不包含端口信息。</p>
<ul>
<li>AAAA 记录（IPv6 Address Record）</li>
</ul>
<p>记录格式：<code>example.com. IN AAAA 2001:db8::1</code>，将域名映射到 IPv6 地址。</p>
<ul>
<li>CNAME 记录（Canonical Name Record）</li>
</ul>
<p>记录格式：<code>www.example.com. IN CNAME example.com.</code>，将一个域名指向另一个域名，实现域名的别名或重定向。</p>
<ul>
<li>TXT 记录（Text Record）</li>
</ul>
<p>记录格式：<code>example.com. IN TXT &quot;Some text here&quot;</code>，存储与域名相关的文本信息，常用于验证域名所有权、防止电子邮件欺诈等。</p>
<ul>
<li>SRV 记录（Service Record）</li>
</ul>
<p>记录格式：<code>_service._proto.name. IN SRV priority weight port target</code>。<code>priority</code>表示优先级，用于指定备用服务器的顺序。值越小，优先级越高。<code>weight</code>表示权重，用于在具有相同优先级的记录之间进行负载均衡。值越大，权重越高。<code>port</code>表示服务的端口号。<code>target</code>表示提供该服务的目标主机的域名。</p>
<p>SRV 用于指定特定服务的域名、端口和优先级等信息，它用于在 DNS 中提供服务发现的功能，让客户端能够通过域名查找到提供特定服务的目标主机和端口。</p>
<ul>
<li>PTR 记录（Pointer Record）</li>
</ul>
<p>记录格式：<code>1.2.0.192.in-addr.arpa. IN PTR example.com.</code>，用于进行反向 DNS 查找，将 IP 地址解析为域名。</p>
<blockquote>
<p>IN（表示Internet）在 DNS 记录中是可选的，可以省略。当省略 IN 时，默认为 IN，因为大多数 DNS 记录都是针对互联网的。</p>
</blockquote>
<h2 id="resolvconf-配置文件" class="headerLink">
    <a href="#resolvconf-%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6" class="header-mark"></a>resolv.conf 配置文件</h2><p>resolv.conf 配置文件，存储了用于解析域名的 DNS 服务器的相关信息，用于指定系统的 DNS 解析配置。</p>
<p>resolv.conf 文件通常位于 Linux 系统中的 /etc/resolv.conf。每行包含一个配置项，配置项由关键字和对应的值组成，以空格或制表符分隔。常见的配置项包括：</p>
<ul>
<li>nameserver：指定 DNS 服务器的 IP 地址。可以有多个 nameserver 行，按照优先级从上到下进行解析。</li>
<li>search：指定默认的搜索域名列表。当使用不完全限定的域名时，系统会自动尝试附加这些域名来进行解析。</li>
<li>domain：指定系统的默认域名。当使用不完全限定的主机名时，系统会自动尝试附加默认域名来进行解析。</li>
<li>options：指定其他的解析选项，如超时时间、转发等。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">nameserver 8.8.8.8
</span></span><span class="line"><span class="cl">nameserver 8.8.4.4
</span></span><span class="line"><span class="cl">search example.com
</span></span></code></pre></td></tr></table>
</div>
</div><p>比如以下的这个配置</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230529/8b4dd5e7b70a4e17870780c2f4708751.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230529/8b4dd5e7b70a4e17870780c2f4708751.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230529/8b4dd5e7b70a4e17870780c2f4708751.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>resolv.conf</h2>">
        
    </a><figcaption class="image-caption">resolv.conf</figcaption>
    </figure></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">search xae-zcbus-20230523.28e5df10.csphere.local csphere.local
</span></span></code></pre></td></tr></table>
</div>
</div><p>这条 search 配置表示系统默认的搜索域名列表包括两个域名：<code>xae-zcbus-20230523.28e5df10.csphere.local</code> 和 <code>csphere.local</code>。</p>
<p>当进行 DNS 解析时，如果使用一个不完全限定的域名（没有包含点号），系统会按照 search 配置中的顺序尝试逐个附加这些搜索域名，以尝试解析域名。例如，如果要解析的域名是 example，系统会依次尝试解析 <code>example.xae-zcbus-20230523.28e5df10.csphere.local</code> 和 <code>example.csphere.local</code>。</p>
<p>这样配置搜索域名列表可以简化 DNS 查询过程，特别是在本地网络内部使用内部域名时，通过设置合适的搜索域名，可以直接使用不完全限定的主机名进行解析，而无需每次都输入完整的域名。</p>
<p>ndots 参数控制着系统在进行 DNS 解析时是否自动追加搜索域名。它指定了一个域名中至少要包含的点号<code>.</code>的数量。点号在域名中的数量表示域名的层级结构，例如<code>example.com</code>有一个点号，而<code>www.example.com</code>有两个点号。当一个域名的层级结构中点号的数量达到或超过 ndots 参数指定的值时，系统将<strong>不再追加</strong>搜索域名。</p>
<p>如上的配置<code>options ndots:2</code>，表示当进行 DNS 解析时，如果域名中包含至少两个点号（层级结构至少为三级），系统将不会自动追加搜索域名。如果域名的层级结构不足三级（点号少于两个），系统会自动尝试使用 /etc/resolv.conf 中指定的搜索域名列表进行解析。</p>
<p><code>nameserver 172.17.0.1</code>用于指定 DNS 解析时要使用的 DNS 服务器的 IP 地址。这里的<code>172.17.0.1</code>是 Docker bridge 网络下虚拟网桥 docker0 的 IP 地址。</p>
<p>因为容器中没有 dns 解析服务，不管是 dnsmasq 还是 pdns 都是装在宿主机上的，所以最后肯定是到宿主机上来解析的域名，但是这里如果直接写宿主机 IP 会影响效率「TODO 待补充」。</p>
<h2 id="etchosts-配置文件" class="headerLink">
    <a href="#etchosts-%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6" class="header-mark"></a>/etc/hosts 配置文件</h2><p>/etc/hosts 是本地的主机名解析文件，用于将主机名映射到对应的 IP 地址。/etc/hosts 文件包含了主机名和对应 IP 地址的映射关系。每行的格式为 <code>&lt;IP 地址&gt; &lt;主机名&gt;</code> 或者 <code>&lt;IP 地址&gt; &lt;主机别名&gt; &lt;主机名&gt;</code>。</p>
<p>/etc/hosts 文件中的条目优先于 DNS（Domain Name System）解析，当系统需要解析主机名时，会首先查看 /etc/hosts 文件，如果找到匹配的主机名，则直接使用对应的 IP 地址进行通信，无需进行 DNS 查询。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230524/16561b7c30f74809822274beff9af838.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230524/16561b7c30f74809822274beff9af838.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230524/16561b7c30f74809822274beff9af838.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>hosts</h2>">
        
    </a><figcaption class="image-caption">hosts</figcaption>
    </figure></p>
<h2 id="pdns" class="headerLink">
    <a href="#pdns" class="header-mark"></a>PDNS</h2><p>PDNS 是 PowerDNS 的简称，它是一款开源的域名系统（DNS）服务器软件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 安装 pdns</span>
</span></span><span class="line"><span class="cl">yum install pdns pdns-backend-pipe -y
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># pdns 启动,停止和查看是否运行正常</span>
</span></span><span class="line"><span class="cl">systemctl start/stop/status pdns
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230525/fa40c2fa19674bd1a29c4edd0496ff5b.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230525/fa40c2fa19674bd1a29c4edd0496ff5b.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230525/fa40c2fa19674bd1a29c4edd0496ff5b.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>查看 dnsmasq 是否正常</h2>">
        
    </a><figcaption class="image-caption">查看 dnsmasq 是否正常</figcaption>
    </figure></p>
<p>如果有问题需要排查，可以使用如下命令让 pdns 在前台运行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">/usr/sbin/pdns_server --guardian<span class="o">=</span>no --daemon<span class="o">=</span>no --disable-syslog --log-timestamp<span class="o">=</span>no --write-pid<span class="o">=</span>no
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230527/fc4df6cc9be049929788893a037ccd6f.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230527/fc4df6cc9be049929788893a037ccd6f.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230527/fc4df6cc9be049929788893a037ccd6f.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>前台运行模式</h2>">
        
    </a><figcaption class="image-caption">前台运行模式</figcaption>
    </figure></p>
<p><code>--guardian=no</code>: 禁用 Guardian 模式。Guardian 模式是 PowerDNS 的守护进程管理机制，它负责监控和重启 PowerDNS 进程。通过将此参数设置为 no，禁用了 Guardian 模式。</p>
<p><code>--daemon=no</code>: 禁用守护进程模式。默认情况下，PowerDNS 以守护进程的形式运行，即在后台作为系统服务运行。通过将此参数设置为 no，PowerDNS 将在前台运行，输出日志和调试信息到终端。</p>
<p><code>--disable-syslog</code>: 禁用使用系统日志。默认情况下，PowerDNS 会将日志信息写入系统日志。通过使用此参数，禁用了将日志写入系统日志的功能。</p>
<p><code>--log-timestamp=no</code>: 禁用日志时间戳。默认情况下，PowerDNS 在日志中添加时间戳以指示每个日志条目的时间。通过将此参数设置为 no，禁用了时间戳的添加。</p>
<p><code>--write-pid=no</code>: 禁用写入 PID 文件。默认情况下，PowerDNS 会将其进程 ID 写入 PID 文件。通过将此参数设置为 no，禁用了 PID 文件的写入。</p>
<h3 id="pipe-backend" class="headerLink">
    <a href="#pipe-backend" class="header-mark"></a>pipe backend</h3><p>在 PowerDNS 中，pipe 是一种后端（Backend）类型，用于将 DNS 查询通过管道（Pipe）方式传递给外部程序进行处理。这种后端类型被称为 &ldquo;pipe backend&rdquo;。</p>
<p>使用 pipe backend，PowerDNS 可以将接收到的 DNS 查询通过管道发送给一个外部的自定义脚本或程序，然后由该脚本或程序处理查询并返回结果给 PowerDNS。这种方式允许用户根据自己的需求编写自定义逻辑来处理 DNS 查询，从而实现更灵活的功能。</p>
<p>在 PowerDNS 中配置 pipe backend 需要以下步骤：</p>
<ol>
<li>
<p>编写自定义脚本或程序：根据需求，编写一个能够接收 DNS 查询并返回结果的脚本或程序。该脚本或程序可以使用任何编程语言来实现，例如 Python、Perl、Shell 等。</p>
</li>
<li>
<p>配置 PowerDNS：在 PowerDNS 的配置文件中指定使用 pipe backend，并设置要执行的脚本或程序的路径。通常需要修改 PowerDNS 的配置文件（例如 pdns.conf）来进行配置。</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nv">launch</span><span class="o">=</span>pipe
</span></span><span class="line"><span class="cl">pipe-command<span class="o">=</span>/path/to/your/script.py
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述示例中，pipe-command 指定了自定义脚本或程序的路径。在修改完配置文件后，<strong>需要重新启动</strong> PowerDNS 服务，使配置生效。</p>
<p>当 PowerDNS 接收到 DNS 查询时，它将会将查询数据通过管道传递给指定的脚本或程序。脚本或程序可以处理查询并返回结果给 PowerDNS，然后由 PowerDNS 将结果返回给客户端。</p>
<p>通过配置 pipe backend，可以根据自己的需求编写自定义的逻辑来处理 DNS 查询，例如基于外部数据源、自定义策略、过滤等操作。</p>
<h2 id="dnsmasq" class="headerLink">
    <a href="#dnsmasq" class="header-mark"></a>dnsmasq</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 安装 dnsmasq</span>
</span></span><span class="line"><span class="cl">yum install dnsmasq
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 一些状态命令</span>
</span></span><span class="line"><span class="cl">systemctl start/stop/restart/status dnsmasq
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 检查配置文件语法是否正确</span>
</span></span><span class="line"><span class="cl">dnsmasq --test
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230529/21042ad8bf514e519d55c93d7431336d.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230529/21042ad8bf514e519d55c93d7431336d.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230529/21042ad8bf514e519d55c93d7431336d.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>dnsmasq 命令</h2>">
        
    </a><figcaption class="image-caption">dnsmasq 命令</figcaption>
    </figure></p>
<p>Dnsmasq 是一个轻量级的 DNS 和 DHCP 服务器软件，用于提供本地域名解析和网络地址分配功能，配置文件通常位于 /etc/dnsmasq.conf。下面是一些常用的配置文件字段说明：</p>
<ul>
<li>
<p>port（端口）：指定 Dnsmasq 监听的 DNS 查询端口。默认为 53，但可以根据需要进行更改。</p>
</li>
<li>
<p>cache-size（缓存大小）：指定DNS缓存的最大大小（以条目数量表示）。缓存可以提高解析性能，减少对上游 DNS 服务器的查询次数。例如，cache-size=1000 表示最多缓存 1000 条 DNS 解析记录。</p>
</li>
<li>
<p>server（服务器）：用于指定要使用的上游 DNS 服务器。可以配置多个 server 字段，每个字段后面跟随一个有效的 DNS 服务器地址。Dnsmasq 会按顺序向这些服务器发送 DNS 查询请求。</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nv">server</span><span class="o">=</span>8.8.8.8
</span></span><span class="line"><span class="cl"><span class="nv">server</span><span class="o">=</span>8.8.4.4
</span></span></code></pre></td></tr></table>
</div>
</div><p>server 的另一种写法是用来指定特定域名的 DNS 服务器映射。比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nv">server</span><span class="o">=</span>/domain.org/192.168.14.5
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个配置表示将域名 domain.org 解析到 IP 地址 192.168.14.5 上。当 Dnsmasq 收到对<code>domain.org</code>域名的解析请求时，它将使用指定的 IP 地址作为响应。这在本地网络中创建自定义的域名解析规则非常有用，可以用于内部域名解析或重定向特定域名到特定 IP 地址。</p>
<ul>
<li>address 参数用于指定域名解析的静态映射，将特定域名解析到指定的IP地址。它的语法如下：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nv">address</span><span class="o">=</span>/域名/IP地址
</span></span><span class="line"><span class="cl"><span class="nv">address</span><span class="o">=</span>/example.com/192.168.1.100
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个配置将域名 example.com 解析为 IP 地址 192.168.1.100。当 Dnsmasq 接收到关于 example.com 的解析请求时，它将使用指定的 IP 地址进行解析，而不会向上游 DNS 服务器发送查询请求。</p>
<h2 id="演练" class="headerLink">
    <a href="#%e6%bc%94%e7%bb%83" class="header-mark"></a>演练</h2><p>现在有 2 台机器，分别是<code>192.168.14.103</code>用来做控制器，安装有 powerDNS，作为上游 DNS，用来最后解析 DNS，<code>192.168.14.100</code>用来做 agent，安装有 dnsmasq 解析本地 DNS，通过配置 server 参数，将域名交给上游 DNS 服务器解析，也就是交给<code>192.168.14.103</code>解析处理。 pdns 通过 pipe backend 的 python 脚本，对所有的以<code>domain.org</code>结尾的域名请求都返回<code>192.168.40.223</code>的 IP，以下是 backend.py 的 python 脚本，python 版本是 python 3.6.8。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/env python</span>
</span></span><span class="line"><span class="cl"><span class="c1"># -*- coding: utf-8 -*-</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">random</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">time</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DNSLookup</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;Handle PowerDNS pipe-backend domain name lookups.&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ttl</span> <span class="o">=</span> <span class="mi">30</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34;parse DNS query and produce lookup result.
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">        query: a sequence containing the DNS query as per PowerDNS manual appendix A:
</span></span></span><span class="line"><span class="cl"><span class="s2">        http://downloads.powerdns.com/documentation/html/backends-detail.html#PIPEBACKEND-PROTOCOL
</span></span></span><span class="line"><span class="cl"><span class="s2">        &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="n">_type</span><span class="p">,</span> <span class="n">qname</span><span class="p">,</span> <span class="n">qclass</span><span class="p">,</span> <span class="n">qtype</span><span class="p">,</span> <span class="n">_id</span><span class="p">,</span> <span class="n">ip</span><span class="p">)</span> <span class="o">=</span> <span class="n">query</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">has_result</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># has a DNS query response</span>
</span></span><span class="line"><span class="cl">        <span class="n">qname_lower</span> <span class="o">=</span> <span class="n">qname</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34;List of servers to round-robin&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="n">servers</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;192.168.40.223&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">server</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">servers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># if (qtype == &#39;A&#39; or qtype == &#39;ANY&#39;) and qname_lower.endswith(&#39;domain.org&#39;):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">qtype</span> <span class="o">==</span> <span class="s1">&#39;ANY&#39;</span> <span class="ow">and</span> <span class="n">qname_lower</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;domain.org&#39;</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;DATA</span><span class="se">\t</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="se">\t</span><span class="s1">A</span><span class="se">\t</span><span class="si">%d</span><span class="se">\t</span><span class="s1">-1</span><span class="se">\t</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">qname</span><span class="p">,</span> <span class="n">qclass</span><span class="p">,</span> <span class="n">DNSLookup</span><span class="o">.</span><span class="n">ttl</span><span class="p">,</span> <span class="n">server</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">has_result</span> <span class="o">=</span> <span class="kc">True</span>
</span></span><span class="line"><span class="cl">        <span class="k">elif</span> <span class="n">qtype</span> <span class="o">==</span> <span class="s1">&#39;SOA&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="s1">&#39;DATA</span><span class="se">\t</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="se">\t</span><span class="s1">3600</span><span class="se">\t</span><span class="s1">-1</span><span class="se">\t</span><span class="s1">ns1.test.soa</span><span class="se">\t</span><span class="s1">admin.test.soa</span><span class="se">\t</span><span class="s1">2014032110</span><span class="se">\t</span><span class="s1">10800</span><span class="se">\t</span><span class="s1">3600</span><span class="se">\t</span><span class="s1">604800</span><span class="se">\t</span><span class="s1">3600&#39;</span>
</span></span><span class="line"><span class="cl">                <span class="o">%</span> <span class="p">(</span><span class="n">qname</span><span class="p">,</span> <span class="n">qclass</span><span class="p">,</span> <span class="n">qtype</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">has_result</span> <span class="o">=</span> <span class="kc">True</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">str_result</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34;return string result suitable for pipe-backend output to PowerDNS.&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_result</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="s1">&#39;&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Logger</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">logfile</span> <span class="o">=</span> <span class="s1">&#39;/tmp/backend.log&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34;self.logfile = &#39;/tmp/backend-</span><span class="si">%d</span><span class="s2">.log&#39; % pid&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">logline</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">|</span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">(),</span> <span class="n">msg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logfile</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">logline</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">debug_log</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">logger</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PowerDNSbackend</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;The main PowerDNS pipe backend process.&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filein</span><span class="p">,</span> <span class="n">fileout</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34;initialise and run PowerDNS pipe backend process.&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">filein</span> <span class="o">=</span> <span class="n">filein</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">fileout</span> <span class="o">=</span> <span class="n">fileout</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">_process_requests</span><span class="p">()</span>  <span class="c1"># main program loop</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">_process_requests</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34;main program loop&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="n">first_time</span> <span class="o">=</span> <span class="kc">True</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">rawline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filein</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">rawline</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">debug_log</span><span class="p">(</span><span class="s1">&#39;EOF&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span>  <span class="c1"># EOF detected</span>
</span></span><span class="line"><span class="cl">            <span class="n">line</span> <span class="o">=</span> <span class="n">rawline</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">debug_log</span><span class="p">(</span><span class="s1">&#39;received from pdns:</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">line</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">first_time</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="s1">&#39;HELO</span><span class="se">\t</span><span class="s1">1&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="bp">self</span><span class="o">.</span><span class="n">_fprint</span><span class="p">(</span><span class="s1">&#39;OK</span><span class="se">\t</span><span class="s1">Python backend firing up&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="bp">self</span><span class="o">.</span><span class="n">_fprint</span><span class="p">(</span><span class="s1">&#39;FAIL&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="n">debug_log</span><span class="p">(</span><span class="s1">&#39;HELO input not received - execution aborted&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="n">rawline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filein</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>  <span class="c1"># as per docs - read another line before aborting</span>
</span></span><span class="line"><span class="cl">                    <span class="n">debug_log</span><span class="p">(</span><span class="s1">&#39;calling sys.exit()&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">first_time</span> <span class="o">=</span> <span class="kc">False</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">query</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="bp">self</span><span class="o">.</span><span class="n">_fprint</span><span class="p">(</span><span class="s1">&#39;LOG</span><span class="se">\t</span><span class="s1">PowerDNS sent unparseable line&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="bp">self</span><span class="o">.</span><span class="n">_fprint</span><span class="p">(</span><span class="s1">&#39;FAIL&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">debug_log</span><span class="p">(</span><span class="s1">&#39;Performing DNSLookup(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">query</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                    <span class="n">lookup</span> <span class="o">=</span> <span class="n">DNSLookup</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="n">lookup</span><span class="o">.</span><span class="n">has_result</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                        <span class="n">pdns_result</span> <span class="o">=</span> <span class="n">lookup</span><span class="o">.</span><span class="n">str_result</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                        <span class="bp">self</span><span class="o">.</span><span class="n">_fprint</span><span class="p">(</span><span class="n">pdns_result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="n">debug_log</span><span class="p">(</span><span class="s1">&#39;DNSLookup result(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">pdns_result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="bp">self</span><span class="o">.</span><span class="n">_fprint</span><span class="p">(</span><span class="s1">&#39;END&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">_fprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34;Print the given message with newline and flushing.&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">fileout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">message</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">fileout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="n">debug_log</span><span class="p">(</span><span class="s1">&#39;sent to pdns:</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">logger</span> <span class="o">=</span> <span class="n">Logger</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">infile</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># sys.stdout.close()</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># outfile = os.fdopen(1, &#39;w&#39;, 1)</span>
</span></span><span class="line"><span class="cl">    <span class="n">outfile</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">PowerDNSbackend</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">debug_log</span><span class="p">(</span><span class="s1">&#39;execution failure:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">0</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">        <span class="k">raise</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230529/a1a644dcf7bb425e9cd4eb4606c554a9.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230529/a1a644dcf7bb425e9cd4eb4606c554a9.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230529/a1a644dcf7bb425e9cd4eb4606c554a9.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>pipe backend</h2>">
        
    </a><figcaption class="image-caption">pipe backend</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230529/761e93174f9d4763be59cef6711c3fe0.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230529/761e93174f9d4763be59cef6711c3fe0.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230529/761e93174f9d4763be59cef6711c3fe0.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>dig 解析正常</h2>">
        
    </a><figcaption class="image-caption">dig 解析正常</figcaption>
    </figure></p>
<p>现在在 agent 机器也就是<code>192.168.14.100</code>上通过 <a href="https://hub.docker.com/r/xiaobinqt/redis/tags" target="_blank" rel="noopener noreferrer">xiaobinqt/redis:7-ping</a> 镜像启动一个 redis 容器，容器名为 c-redis：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-docker" data-lang="docker"><span class="line"><span class="cl">docker run --name c-redis --dns 172.17.0.1 --dns-search domain.org --dns-opt <span class="s2">&#34;ndots:2&#34;</span> -d  xiaobinqt/redis:7-ping<span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>比如，当在容器中执行 <code>ping abdd</code>时，正常会先走 hosts 但是这里的 hosts 都没有对应的域名，所以 hosts 失效，再去 nameserver 指定的 DNS 服务器解析域名，由于配置了 ndots:2 ，系统会自动追加搜索域名<code>domain.org</code>，所以会去 172.17.0.1 DNS 服务器搜索域名 <code>abdd.domain.org</code>，172.17.0.1 对应的是宿主机的 docker0 虚拟网桥，最后会走到<strong>宿主机的 dns 服务</strong>，也就是<code>192.168.14.100</code> 的 dnsmasq 服务，对应的端口是 53。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230529/ae90a8281d72406ca0bf831fc375f36c.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230529/ae90a8281d72406ca0bf831fc375f36c.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230529/ae90a8281d72406ca0bf831fc375f36c.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>调试结果</h2>">
        
    </a><figcaption class="image-caption">调试结果</figcaption>
    </figure></p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://gist.github.com/sokratisg/10069682" target="_blank" rel="noopener noreferrer">pdns-pipebackend.py</a></li>
<li><a href="https://www.linuxhelp.com/questions/powerdns-libpipebackend-so-no-such-file-or-directory" target="_blank" rel="noopener noreferrer">PowerDNS : libpipebackend.so no such file or directory</a></li>
<li><a href="https://community.zextras.com/dns-server-installation-guide-on-centos-7-rhel-7-and-centos-8-rhel-8-using-dnsmasq/" target="_blank" rel="noopener noreferrer">Installing DNS Server on CentOS/RHEL using dnsmasq | Zimbra</a></li>
</ul>
]]></description>
</item><item>
    <title>SSH error: permissions are too open</title>
    <link>https://www.xiaobinqt.cn/ssh-permissions-are-too-open/</link>
    <pubDate>Sat, 25 Mar 2023 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/ssh-permissions-are-too-open/</guid>
    <description><![CDATA[<h2 id="问题描述" class="headerLink">
    <a href="#%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0" class="header-mark"></a>问题描述</h2><p>我的 git 版本在 1.8.3.1 的时候提交 push 代码时一直报错</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230324/66823aa8269d4341837ac1a2ecd69735.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230324/66823aa8269d4341837ac1a2ecd69735.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230324/66823aa8269d4341837ac1a2ecd69735.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>git 版本</h2>">
        
    </a><figcaption class="image-caption">git 版本</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230324/934bd49f1f9449ed9a22606e0c19f64d.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230324/934bd49f1f9449ed9a22606e0c19f64d.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230324/934bd49f1f9449ed9a22606e0c19f64d.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>Permission denied (publickey)</h2>">
        
    </a><figcaption class="image-caption">Permission denied (publickey)</figcaption>
    </figure></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Permission denied <span class="o">(</span>publickey<span class="o">)</span>.
</span></span><span class="line"><span class="cl">fatal: Could not <span class="nb">read</span> from remote repository.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Please make sure you have the correct access rights
</span></span><span class="line"><span class="cl">and the repository exists.
</span></span></code></pre></td></tr></table>
</div>
</div><p>排查了几个小时，一直没解决，之前也一直是这么用的，也没出现过问题。后来没办法，我尝试更新了下 git 版本到 2.39.2，发现错误提示不一样了😢</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230324/f4a5ce70fd7146d982ff72b70ec5098a.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230324/f4a5ce70fd7146d982ff72b70ec5098a.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230324/f4a5ce70fd7146d982ff72b70ec5098a.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>Permissions are too open</h2>">
        
    </a><figcaption class="image-caption">Permissions are too open</figcaption>
    </figure></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Warning: Permanently added <span class="s1">&#39;192.168.40.233&#39;</span> <span class="o">(</span>ECDSA<span class="o">)</span> to the list of known hosts.
</span></span><span class="line"><span class="cl">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
</span></span><span class="line"><span class="cl">@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @
</span></span><span class="line"><span class="cl">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
</span></span><span class="line"><span class="cl">Permissions <span class="m">0755</span> <span class="k">for</span> <span class="s1">&#39;/tmp/tmp.LGAlGyMvNs/id_rsa&#39;</span> are too open.
</span></span><span class="line"><span class="cl">It is required that your private key files are NOT accessible by others.
</span></span><span class="line"><span class="cl">This private key will be ignored.
</span></span><span class="line"><span class="cl">Load key <span class="s2">&#34;/tmp/tmp.LGAlGyMvNs/id_rsa&#34;</span>: bad permissions
</span></span><span class="line"><span class="cl">Permission denied <span class="o">(</span>publickey<span class="o">)</span>.
</span></span><span class="line"><span class="cl">致命错误：无法读取远程仓库。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">请确认您有正确的访问权限并且仓库存在。
</span></span></code></pre></td></tr></table>
</div>
</div><p>我根据<code>Permissions 0755 for '/tmp/tmp.LGAlGyMvNs/id_rsa' are too open.</code> google 了下，原来是 isa 文件权限给的太高了，改成 400 或是 600 就可以了。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230324/283ea804c9de4b1dbe456b4e8915182f.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230324/283ea804c9de4b1dbe456b4e8915182f.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230324/283ea804c9de4b1dbe456b4e8915182f.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>问题解决</h2>">
        
    </a><figcaption class="image-caption">问题解决</figcaption>
    </figure></p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://www.educative.io/answers/ssh-error-permissions-are-too-open" target="_blank" rel="noopener noreferrer">SSH error: permissions are too open</a></li>
<li><a href="https://juejin.cn/post/7071910670056292389" target="_blank" rel="noopener noreferrer">CentOS 7 升级 git 版本到 2.x</a></li>
</ul>
]]></description>
</item><item>
    <title>Windows 10 专业版使用 WSL</title>
    <link>https://www.xiaobinqt.cn/windows-wsl/</link>
    <pubDate>Wed, 22 Feb 2023 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/windows-wsl/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="什么是-wsl" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-wsl" class="header-mark"></a>什么是 wsl</h2><p>Windows Subsystem for Linux（WSL）是一个在 Windows 10+ 上能够运行原生 Linux 二进制可执行文件的兼容层。</p>
<p>与 WSL1 相比，WSL 2 使用更新、更强大的虚拟化技术在轻量级实用工具虚拟机 (VM) 中运行 Linux 内核。</p>
<h2 id="安装" class="headerLink">
    <a href="#%e5%ae%89%e8%a3%85" class="header-mark"></a>安装</h2><p>我是 win10 专业版，其他版本的 win10 也类似，不过<strong>推荐使用专业版</strong>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230320/a15dfa3e82854382859261a104cd8f3c.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230320/a15dfa3e82854382859261a104cd8f3c.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230320/a15dfa3e82854382859261a104cd8f3c.png" data-sub-html="<h2>电脑版本</h2>">
        
    </a><figcaption class="image-caption">电脑版本</figcaption>
    </figure></p>
<ol>
<li>进入 windows 终端</li>
<li><code>wsl -l -o</code>查看可安装的发行版</li>
<li>执行<code>wsl --set-default-version 2</code>将 WSL 默认版本调整为 WSL2</li>
<li><code>wsl --install --d NAME</code>即可安装。如： <code>wsl --install --d ubuntu-20.04</code>可安装 ubuntu20.04</li>
<li><code>wsl -l -v</code>可查看安装的发行版的 WSL 版本</li>
</ol>
<p>注销（卸载）当前安装的 Linux 的 Windows 子系统可以使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">wsl --unregister 名称
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230320/0808f63a623d4c44aa9971e854b7f2e5.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230320/0808f63a623d4c44aa9971e854b7f2e5.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230320/0808f63a623d4c44aa9971e854b7f2e5.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>卸载 wsl</h2>">
        
    </a><figcaption class="image-caption">卸载 wsl</figcaption>
    </figure></p>
<p>对于已安装的 wsl 版本，从 wsl1 切换到 wsl2 可以使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">wsl --set-version 名称 <span class="m">2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230222/38eff9e474cc40b0a43068cec25fe08a.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230222/38eff9e474cc40b0a43068cec25fe08a.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230222/38eff9e474cc40b0a43068cec25fe08a.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>切换 wsl2</h2>">
        
    </a><figcaption class="image-caption">切换 wsl2</figcaption>
    </figure></p>
<h2 id="no_proxy-设置" class="headerLink">
    <a href="#no_proxy-%e8%ae%be%e7%bd%ae" class="header-mark"></a>no_proxy 设置</h2><p>win10 的 no_proxy 可以直接添加系统环境变量：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230705/64a916b5dc924109aef92251094661d3.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230705/64a916b5dc924109aef92251094661d3.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230705/64a916b5dc924109aef92251094661d3.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>win10 no_proxy</h2>">
        
    </a><figcaption class="image-caption">win10 no_proxy</figcaption>
    </figure></p>
<p>WSL no_proxy 也可以通过添加环境变量方式：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230705/f562263377664765a1d56204777d5168.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230705/f562263377664765a1d56204777d5168.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230705/f562263377664765a1d56204777d5168.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>wsl no_proxy</h2>">
        
    </a><figcaption class="image-caption">wsl no_proxy</figcaption>
    </figure></p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands" target="_blank" rel="noopener noreferrer">WSL 的基本命令</a></li>
<li><a href="https://www.sysgeek.cn/windows-11-install-windows-subsystem-for-linux/" target="_blank" rel="noopener noreferrer">如何在 Windows 11 中安装 Windows Subsystem for Linux（WSL）</a></li>
<li><a href="https://gist.github.com/libChan/3a804a46b532cc326a2ee55b27e8ac19" target="_blank" rel="noopener noreferrer">windows clash 设置代理</a></li>
<li><a href="https://blog.csdn.net/SHERLOCKSALVATORE/article/details/123599042" target="_blank" rel="noopener noreferrer">windows 的cmd设置代理方法</a></li>
<li><a href="https://www.jianshu.com/p/6e7488440db2" target="_blank" rel="noopener noreferrer">Windows 10/11 安装 WSL2 的简单方法</a></li>
<li><a href="https://blog.csdn.net/admans/article/details/125071913" target="_blank" rel="noopener noreferrer">Win11卸载WSL，卸载Windows子系统</a></li>
</ul>
]]></description>
</item><item>
    <title>Go 编译标签 build tag</title>
    <link>https://www.xiaobinqt.cn/go-build-tag/</link>
    <pubDate>Sat, 28 Jan 2023 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/go-build-tag/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="简介" class="headerLink">
    <a href="#%e7%ae%80%e4%bb%8b" class="header-mark"></a>简介</h2><p>在 Go 中，build tag 是添加到代码中第一行，来标识编译相关信息的，build tag 决定了当前文件是否会被当前 package 所包含，用于限制一整个文件是否应该被编译入最终的二进制文件，而不是一个文件中的部分代码片段。</p>
<p>Go <strong><ruby>编译标签<rt>build tag</rt></ruby></strong>语法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// +build [tag]
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>build tags 文件顶部附近，前面只能有空行和其他行注释。</li>
<li>编译标记必须出现在 package 子句之前，并且为了与包文档区分开来，它<strong>必须</strong>后跟一个空行。</li>
</ul>
<h2 id="编译标签的逻辑" class="headerLink">
    <a href="#%e7%bc%96%e8%af%91%e6%a0%87%e7%ad%be%e7%9a%84%e9%80%bb%e8%be%91" class="header-mark"></a>编译标签的逻辑</h2><p>当在一个包中使用多个标签时会使用 bool 逻辑进行交互，具体取决于我们如何进行声明的。</p>
<p>Build tags 遵循以下三个规则：</p>
<ul>
<li>以空格分隔的标签将在<code>OR</code>逻辑下进行解释。</li>
<li>逗号分隔的标签将在<code>AND</code>逻辑下进行解释。</li>
<li>每个术语都是一个字母数字单词，如果前面有<code>!</code>它意味着它被否定。</li>
</ul>
<h3 id="or-标签逻辑" class="headerLink">
    <a href="#or-%e6%a0%87%e7%ad%be%e9%80%bb%e8%be%91" class="header-mark"></a>or 标签逻辑</h3><p>给定标签：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// +build tag1 tag2
</span></span></code></pre></td></tr></table>
</div>
</div><p>OR 解释是，如果在执行 build 构建命令时存在 tag1 或 tag2，则将包含此文件。</p>
<h3 id="and-标签逻辑" class="headerLink">
    <a href="#and-%e6%a0%87%e7%ad%be%e9%80%bb%e8%be%91" class="header-mark"></a>and 标签逻辑</h3><p>如果我们使用标签：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// +build tag1, tag2
</span></span></code></pre></td></tr></table>
</div>
</div><p>解释是 tag1 且（AND） tag2 必须存在于 build 构建命令中，我们的文件才能包含在编译中。</p>
<h3 id="非标签逻辑" class="headerLink">
    <a href="#%e9%9d%9e%e6%a0%87%e7%ad%be%e9%80%bb%e8%be%91" class="header-mark"></a>！非标签逻辑</h3><p>如果我们使用标签</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> // +build !tag1
</span></span></code></pre></td></tr></table>
</div>
</div><p>解释是，非 tag1，我们的文件才会 build 编译</p>
<h2 id="如何使用" class="headerLink">
    <a href="#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8" class="header-mark"></a>如何使用</h2><h3 id="新建-build-tag" class="headerLink">
    <a href="#%e6%96%b0%e5%bb%ba-build-tag" class="header-mark"></a>新建 build tag</h3><p>我们新建一个 buildtag 文件夹，并在文件夹下新建如下4个空文件，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── dev.go
</span></span><span class="line"><span class="cl">├── main.go
</span></span><span class="line"><span class="cl">├── prod.go
</span></span><span class="line"><span class="cl">├── test.go
</span></span><span class="line"><span class="cl">└── without.go
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们打开 main.go 输入代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">configArr</span> <span class="p">[]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">conf</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">configArr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">conf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们打开 dev.go 输入代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// +build dev
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">configArr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">configArr</span><span class="p">,</span> <span class="s">&#34;mysql dev&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们打开 prod.go 输入代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// +build prod
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">configArr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">configArr</span><span class="p">,</span> <span class="s">&#34;mysql prod&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们打开 test.go 输入代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// +build test1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">configArr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">configArr</span><span class="p">,</span> <span class="s">&#34;mysql test&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们打开 without.go 输入代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// +build !without
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">configArr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">configArr</span><span class="p">,</span> <span class="s">&#34;mysql without&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="使用-tags-编译" class="headerLink">
    <a href="#%e4%bd%bf%e7%94%a8-tags-%e7%bc%96%e8%af%91" class="header-mark"></a>使用 tags 编译</h3><h4 id="1-没有tag编译" class="headerLink">
    <a href="#1-%e6%b2%a1%e6%9c%89tag%e7%bc%96%e8%af%91" class="header-mark"></a>1. 没有tag编译</h4><p>我们使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go build
</span></span></code></pre></td></tr></table>
</div>
</div><p>在文件夹里生成了二进制执行文件 buildtag，我们执行一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">➜ ./buildtag 
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mysql without
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="2-单个tag编译" class="headerLink">
    <a href="#2-%e5%8d%95%e4%b8%aatag%e7%bc%96%e8%af%91" class="header-mark"></a>2. 单个tag编译</h4><p>我们使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go build  -tags &#34;dev&#34; 
</span></span></code></pre></td></tr></table>
</div>
</div><p>在文件夹里生成了二进制执行文件 buildtag，我们执行一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">➜ ./buildtag 
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mysql dev
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="3-多个tag编译" class="headerLink">
    <a href="#3-%e5%a4%9a%e4%b8%aatag%e7%bc%96%e8%af%91" class="header-mark"></a>3. 多个tag编译</h4><p>我们使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go build  -tags &#34;dev prod&#34; 
</span></span></code></pre></td></tr></table>
</div>
</div><p>在文件夹里生成了二进制执行文件 buildtag，我们执行一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">➜ ./buildtag 
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mysql dev
</span></span><span class="line"><span class="cl">mysql prod
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="gobuild-与-build-的区别" class="headerLink">
    <a href="#gobuild-%e4%b8%8e-build-%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-mark"></a>go:build 与 +build 的区别</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//go:build
</span></span></code></pre></td></tr></table>
</div>
</div><p>☝️是 Go 1.17 中引入的新条件编译指令格式。它旨在替换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// +build
</span></span></code></pre></td></tr></table>
</div>
</div><p>指令。那么为何要采用新的格式呢？对比一下新旧格式的区别就知道了👇</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// go:build linux &amp;&amp; amd64 || darwin
</span></span><span class="line"><span class="cl">// +build linux,amd64 darwin
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>go:build</code>这种格式，对 coder 来说，更容易理解其逻辑组合，与<code>//go:embed</code>和<code>//go:generate</code>这些命令相比较，格式上进行了统一。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://github.com/xiaobinqt/go.src/tree/master/dev/buildtag" target="_blank" rel="noopener noreferrer">代码地址</a></li>
<li><a href="https://segmentfault.com/a/1190000042007310" target="_blank" rel="noopener noreferrer">go 编译标签( build tag)-注释里的编译语法</a></li>
<li><a href="https://wrfly.kfd.me/posts/golang-netgo-vs-cgo/" target="_blank" rel="noopener noreferrer">golang: netgo vs cgo</a></li>
</ul>
]]></description>
</item><item>
    <title>curl: (60) Peer&#39;s Certificate has expired 问题解决</title>
    <link>https://www.xiaobinqt.cn/curl-ertificate-has-expired/</link>
    <pubDate>Tue, 17 Jan 2023 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/curl-ertificate-has-expired/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<p>刚执行 curl 命令时发现一个问题</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/51b67e1e9f9847d096a86fe7f7ff27e3.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/51b67e1e9f9847d096a86fe7f7ff27e3.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/51b67e1e9f9847d096a86fe7f7ff27e3.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>Certificate has expired</h2>">
        
    </a><figcaption class="image-caption">Certificate has expired</figcaption>
    </figure></p>
<p>可以先更新证书试试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">update-ca-trust
</span></span></code></pre></td></tr></table>
</div>
</div><p>更新证书后如果问题没有解决，继续看是不是由于时间过期引起的问题</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">date
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果发现机器时间不对就需要同步时间</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ntpdate pool.ntp.org
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/b4ce330953b840b4a1d63c1380beb688.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/b4ce330953b840b4a1d63c1380beb688.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/b4ce330953b840b4a1d63c1380beb688.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>问题解决</h2>">
        
    </a><figcaption class="image-caption">问题解决</figcaption>
    </figure></p>
]]></description>
</item><item>
    <title>minikube 安装使用</title>
    <link>https://www.xiaobinqt.cn/minikube-usage/</link>
    <pubDate>Sat, 31 Dec 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/minikube-usage/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230128/3cce82b4c8ec479aa27d81f4d0388055.png" referrerpolicy="no-referrer">
            </div><!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="简介" class="headerLink">
    <a href="#%e7%ae%80%e4%bb%8b" class="header-mark"></a>简介</h2><p>Kubernetes 是一个生产级别的容器编排平台和集群管理系统，不仅能够创建、调度容器，还能够监控、管理服务器，它凝聚了 Google 等大公司和开源社区的集体智慧，从而让中小型公司也可以具备轻松运维海量计算节点，也就是 “云计算” 的能力。</p>
<p>minikube 是一个 “迷你” 版本的 Kubernetes，自从 2016 年发布以来一直在积极地开发维护，紧跟 Kubernetes 的版本更新，同时也兼容较旧的版本（最多可以到之前的 6 个小版本）。</p>
<p>minikube 最大特点就是 “小而美”，可执行文件仅有不到 100MB，运行镜像也不过 1GB。minikube 集成了 Kubernetes 的绝大多数功能特性，不仅有核心的容器编排功能，还有丰富的插件，例如 Dashboard、GPU、Ingress、Istio、Kong、Registry 等。</p>
<h2 id="安装-docker" class="headerLink">
    <a href="#%e5%ae%89%e8%a3%85-docker" class="header-mark"></a>安装 Docker</h2><p>我的系统是 debian 11，<strong>本文所有的操作都是在 debian 11 的环境下进行</strong>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/1ce3091edf2d4b63933d4d5d7938fd5c.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="系统版本" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/1ce3091edf2d4b63933d4d5d7938fd5c.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>系统版本</h2><p>系统版本</p>">
        
    </a><figcaption class="image-caption">系统版本</figcaption>
    </figure></p>
<p>Docker 的安装可以参考官网 <a href="https://docs.docker.com/engine/install/debian/" target="_blank" rel="noopener noreferrer">Install Docker Engine on Debian</a>，其他系统的安装方式都可以在官网找到。debian 11 的安装步骤大致如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">apt-get remove docker docker-engine docker.io containerd runc <span class="c1"># 卸载旧版本</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apt-get update
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apt-get install <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  ca-certificates <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  curl <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  gnupg <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  lsb-release
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">mkdir -p /etc/apt/keyrings
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">curl -fsSL https://download.docker.com/linux/debian/gpg <span class="p">|</span> gpg --dearmor -o /etc/apt/keyrings/docker.gpg
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  <span class="s2">&#34;deb [arch=</span><span class="k">$(</span>dpkg --print-architecture<span class="k">)</span><span class="s2"> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \
</span></span></span><span class="line"><span class="cl"><span class="s2">  </span><span class="k">$(</span>lsb_release -cs<span class="k">)</span><span class="s2"> stable&#34;</span> <span class="p">|</span> tee /etc/apt/sources.list.d/docker.list &gt;/dev/null
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="安装-minikube" class="headerLink">
    <a href="#%e5%ae%89%e8%a3%85-minikube" class="header-mark"></a>安装 minikube</h2><p>可以去官网 <a href="https://minikube.sigs.k8s.io/docs/start/" target="_blank" rel="noopener noreferrer">https://minikube.sigs.k8s.io/docs/start/</a> 下载对应的版本。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/a7572d5e517e45758a4822e28602502b.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="下载" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/a7572d5e517e45758a4822e28602502b.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>下载地址</h2><p>下载</p>">
        
    </a><figcaption class="image-caption">下载地址</figcaption>
    </figure></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">install minikube-linux-amd64 /usr/local/bin/minikube
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/e285a6927b944c0296c175a192f143d7.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="下载并安装" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/e285a6927b944c0296c175a192f143d7.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>下载并安装 minikube</h2><p>下载并安装</p>">
        
    </a><figcaption class="image-caption">下载并安装 minikube</figcaption>
    </figure></p>
<h2 id="安装-kubectl" class="headerLink">
    <a href="#%e5%ae%89%e8%a3%85-kubectl" class="header-mark"></a>安装 kubectl</h2><p>minikube 只能够搭建 Kubernetes 环境，要操作 Kubernetes，还需要另一个专门的客户端工具 kubectl。</p>
<p>kubectl 是一个命令行工具，通过它可以与 Kubernetes 后台服务通信，把我们的命令转发给 Kubernetes，实现容器和集群的管理功能。</p>
<p>kubectl 是一个与 Kubernetes、minikube 彼此独立的项目，不包含在 minikube 里，但 minikube 提供了安装它的简化方式，只需执行下面的这条命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">minikube kubectl
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/ae06b019feba415092522d5887a34c0b.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="下载 kubectl" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/ae06b019feba415092522d5887a34c0b.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>下载 kubectl</h2><p>下载 kubectl</p>">
        
    </a><figcaption class="image-caption">下载 kubectl</figcaption>
    </figure></p>
<p>以上这条命令会把与当前 Kubernetes 版本匹配的 kubectl 下载下来，存放在内部目录（例如<code>.minikube/cache/linux/amd64/v1.23.3</code>），然后就可以使用它来操作 Kubernetes 了。</p>
<p>在 minikube 环境里会用到两个客户端，minikube 管理 Kubernetes 集群环境，kubectl 操作实际的 Kubernetes 功能。</p>
<h2 id="启动环境" class="headerLink">
    <a href="#%e5%90%af%e5%8a%a8%e7%8e%af%e5%a2%83" class="header-mark"></a>启动环境</h2><p>安装了 minikube 和 kubectl 就可以在本机上运行 minikube，创建 Kubernetes 实验环境了。</p>
<p>最好先关闭 swap 分区，不然会 WARNING 提示：</p>
<blockquote>
<p>swap is enabled; production deployments should disable swap unless testing the NodeSwap feature gate of the kubelet</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 关闭 swap分区</span>
</span></span><span class="line"><span class="cl">swapoff -a
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用命令 minikube start 会从 Docker Hub 上拉取镜像，以当前最新版本的 Kubernetes 启动集群，也可以在后面再加上一个参数<code>--kubernetes-version</code> 明确指定要使用 Kubernetes 版本。这里使用 “1.23.3”，启动命令是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">minikube start --kubernetes-version<span class="o">=</span>v1.23.3
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果出现类似以下的问题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">* minikube v1.28.0 on Centos 7.9.2009 <span class="o">(</span>lxc/amd64<span class="o">)</span>
</span></span><span class="line"><span class="cl">* Automatically selected the docker driver. Other choices: none, ssh
</span></span><span class="line"><span class="cl">* The <span class="s2">&#34;docker&#34;</span> driver should not be used with root privileges. If you wish to <span class="k">continue</span> as root, use --force.
</span></span><span class="line"><span class="cl">* If you are running minikube within a VM, consider using --driver<span class="o">=</span>none:
</span></span><span class="line"><span class="cl">*   https://minikube.sigs.k8s.io/docs/reference/drivers/none/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">X Exiting due to DRV_AS_ROOT: The <span class="s2">&#34;docker&#34;</span> driver should not be used with root privileges.
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以使用加上 <code>--force</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">minikube start --kubernetes-version<span class="o">=</span>v1.23.3 --force
</span></span></code></pre></td></tr></table>
</div>
</div><p>国内网络环境复杂，一般访问外网比较慢，也可以使用加上<code>--image-mirror-country='cn'</code>参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">minikube start --image-mirror-country<span class="o">=</span><span class="s1">&#39;cn&#39;</span> --kubernetes-version<span class="o">=</span>v1.23.3 --force
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/756c1c2c48154d44aedd334ad6d5fe41.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="minikube start" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/756c1c2c48154d44aedd334ad6d5fe41.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>minikube start</h2><p>minikube start</p>">
        
    </a><figcaption class="image-caption">minikube start</figcaption>
    </figure></p>
<h2 id="简单使用" class="headerLink">
    <a href="#%e7%ae%80%e5%8d%95%e4%bd%bf%e7%94%a8" class="header-mark"></a>简单使用</h2><p>minikube 自带的 kubectl 有一点限制，必须要在前面加上 minikube 的前缀，后面再加上 <code>--</code> 才能使用，像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">minikube kubectl -- version
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/6d9652c6330c4cd888416362c9087f12.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="kubectl version" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/6d9652c6330c4cd888416362c9087f12.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>kubectl version</h2><p>kubectl version</p>">
        
    </a><figcaption class="image-caption">kubectl version</figcaption>
    </figure></p>
<p>我们在 Kubernetes 里运行一个 Nginx 应用，命令与 Docker 类似，也是 run，但是需要用<code>--image</code>指定镜像，然后 Kubernetes 会自动拉取镜像并运行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">minikube kubectl -- run ngx --image<span class="o">=</span>nginx:alpine
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/caec80f930f94095832101c5bd351122.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="运行应用" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230117/caec80f930f94095832101c5bd351122.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>运行应用</h2><p>运行应用</p>">
        
    </a><figcaption class="image-caption">运行应用</figcaption>
    </figure></p>
<p>命令执行之后可以看到，在 Kubernetes 集群里就有了一个名字叫 ngx 的 Pod 正在运行，表示这个单节点 minikube 环境已经搭建成功。</p>
<h2 id="什么是容器编排" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92" class="header-mark"></a>什么是容器编排</h2><p>容器，是现代程序的运行方式。编排就是部署、管理应用程序的系统，能动态地响应变化，如：回滚、滚动升级、故障自愈、自动扩缩容。自动完成这些所有任务，需要人工最初进行一些配置，就可以一劳永逸。所以，运行容器形式的应用程序，这些应用程序的构建方式，使它们能够实现回滚、滚动升级、故障自愈、自动扩缩容等就是容器编排。</p>
<h2 id="k8s-和-docker-的区别" class="headerLink">
    <a href="#k8s-%e5%92%8c-docker-%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-mark"></a>K8s 和 Docker 的区别</h2><p>Docker 应用打包、测试、交付，Kubernetes 是基于 Docker 的产物，进行编排、运行。例如有 1 个集群，3 个节点。这些节点，都以 Docker 作为容器运行时，Docker 是更偏向底层的技术。Kubernetes 更偏向上层的技术 ，它实现了对容器运行时的抽象，抽象的目的是兼容底层容器运行时（容器进行时技术不仅有 Docker，还有 containerd、kata 等，无论哪种容器运行时，Kubernetes 层面的操作都是一样的）以及解耦，同时还提供了一套容器运行时的标准。抽象的产物是容器运行时接口 CRI（Container Runtime Interface）。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://minikube.sigs.k8s.io/docs/start/" target="_blank" rel="noopener noreferrer">minikube start</a></li>
<li><a href="https://docs.docker.com/engine/install/debian/" target="_blank" rel="noopener noreferrer">docker docs</a></li>
</ul>
]]></description>
</item><item>
    <title>近视手术调研笔记</title>
    <link>https://www.xiaobinqt.cn/surgery-for-myopia/</link>
    <pubDate>Thu, 03 Nov 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/surgery-for-myopia/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221201/81daef1e24f9440e816b87838959e711.png" referrerpolicy="no-referrer">
            </div><!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="英文简称" class="headerLink">
    <a href="#%e8%8b%b1%e6%96%87%e7%ae%80%e7%a7%b0" class="header-mark"></a>英文简称</h2><table>
<thead>
<tr>
<th>英文简称</th>
<th>中文</th>
</tr>
</thead>
<tbody>
<tr>
<td>SMILE</td>
<td>全飞秒激光</td>
</tr>
<tr>
<td>FS-LASIK</td>
<td>半飞秒激光</td>
</tr>
<tr>
<td>ICL</td>
<td>晶体植入</td>
</tr>
</tbody>
</table>
<h2 id="近视度数划分" class="headerLink">
    <a href="#%e8%bf%91%e8%a7%86%e5%ba%a6%e6%95%b0%e5%88%92%e5%88%86" class="header-mark"></a>近视度数划分</h2><ul>
<li>300 度以下属于<strong>低度近视</strong>（25-275度）</li>
<li>300 度以上600度以下属于<strong>中度近视</strong>（300-575度）</li>
<li>600 度以上900以下属于<strong>高度近视</strong>（600-875度）</li>
<li>900 度以上属于<strong>超高度近视</strong>（900-∞度）</li>
</ul>
<h2 id="验光单怎么看" class="headerLink">
    <a href="#%e9%aa%8c%e5%85%89%e5%8d%95%e6%80%8e%e4%b9%88%e7%9c%8b" class="header-mark"></a>验光单怎么看</h2><p>想看明白视力验光单，需要了解验光单上的<code>OD</code>、<code>OS</code>、<code>DS</code>、<code>DC</code>英文缩写以及<code>+</code>、<code>-</code>各代表着什么意义❓</p>
<ul>
<li>
<p>验光单上的<code>OD</code>表示表示<strong>右眼</strong>，<code>OS</code>表示<strong>左眼</strong>。</p>
</li>
<li>
<p><code>+</code>表示凸透镜片（远视眼用），<code>-</code>表示凹透镜片（近视眼用）。</p>
</li>
<li>
<p><code>DS</code>表示球镜（近视和远视用），<code>DC</code>表示柱镜（散光用）。而<code>+</code>或<code>-</code>之后的数值则表示我们镜片的屈光度，这里有一个值得注意的地方，屈光度的数值常常和我们所说的近视或远视度差100倍。例如验光报告上的<code>—2.00</code>就相当于我们常说的近视 200 度。</p>
</li>
<li>
<p>以<code>OD：-3.00DS/-2.00DC×80°</code>的验光报告为例，其表示右眼 300 度的近视镜联合 200 度的散光镜，散光的轴度是 80 度。</p>
</li>
<li>
<p><code>PD</code>一般是指瞳孔距离，就是我们常说的瞳距。</p>
</li>
</ul>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221201/c4f9ebcb4fe74923802fc158d05c826a.png" title="验光单" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221201/c4f9ebcb4fe74923802fc158d05c826a.png" data-sub-html="<h2>验光单</h2><p>验光单</p>">
        
    </a><figcaption class="image-caption">验光单</figcaption>
    </figure></p>
<h2 id="近视原理" class="headerLink">
    <a href="#%e8%bf%91%e8%a7%86%e5%8e%9f%e7%90%86" class="header-mark"></a>近视原理</h2><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221105/0102bebd1eb749c29bef7388c9c497e6.png" title="近视屈光" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221105/0102bebd1eb749c29bef7388c9c497e6.png" data-sub-html="<h2>近视屈光</h2><p>近视屈光</p>">
        
    </a><figcaption class="image-caption">近视屈光</figcaption>
    </figure></p>
<p>当长时间近距离用眼，导致睫状肌经常处于收缩的状态，导致调节紧张或调节痉挛。晶状体失去睫状肌的牵引就会增厚变凸。☝️ 如上图，当光线进入到眼睛以后聚焦在 D 点，距离视网膜 C 点出现了一段距离。所以这个时候我们就看不清楚了。最真实的表现是看远处的物体变大模糊。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221105/666151ee59cb4d50ae860ed1053c2744.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221105/666151ee59cb4d50ae860ed1053c2744.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221105/666151ee59cb4d50ae860ed1053c2744.png" data-sub-html="<h2> </h2>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<p>牵引晶状体的红色部分为睫状肌。正常时候，我们的眼睛看远处的时候，睫状肌放松，晶状体变薄，看近处的时候，睫状肌收缩，晶状体变厚变凸。</p>
<p>近视是因为长时间看较近的物体，导致睫状肌痉挛，不能有效的调节牵引晶状体，所以这个时候就出现了假性近视。假性近视患者的眼轴没有发生根本的改变，适当的休息和锻炼是可以恢复过来。</p>
<div align="center"></div>
<p>当出现假性近视的情况没有采取合适的治疗手段就会发生以上病变的过程。晶状体收缩变厚可以对眼睛产生两种力。一种力是轴向上由于晶状体变厚产生的压力，这个压力可以压到玻璃体，进而把眼轴撑长。另一种力是垂直于轴向的拉力，相当于晶状体这块肌肉收缩时的拉力，这个拉力可以把眼球拉扁，从而间接使眼轴变长。这两种力共同作用把眼睛从圆球形变成橄榄形，这就是晶状体的调节力造成的近视眼变形。</p>
<p>所谓真性近视就是长期的作用力导致眼轴增长，眼睛变形到难以恢复到圆球形的地步了。近视度数越高的人，其晶状体收缩的越厉害，力量也越大，足以改变眼球形状并产生破坏性，这个时候就形成了真性近视。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221105/8d9a0c8d145847d6b8d736dddb2e7307.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221105/8d9a0c8d145847d6b8d736dddb2e7307.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221105/8d9a0c8d145847d6b8d736dddb2e7307.png" data-sub-html="<h2>眼轴</h2>">
        
    </a><figcaption class="image-caption">眼轴</figcaption>
    </figure></p>
<h2 id="什么是暗瞳" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%9a%97%e7%9e%b3" class="header-mark"></a>什么是暗瞳</h2><p>暗瞳就是晚上瞳孔（瞳孔的大小是天生的）放大的大小。因为晚上光线弱，瞳孔会<strong>生理性放大</strong>。</p>
<p>有些人放的大，比如 7.5mm，有些人放的小，比如 6mm，近视手术的光学治疗区一般在 6.5mm 左右，过大的瞳孔会超过光学治疗区，因而会有眩光现象。这个问题在手术前是需要查的。</p>
<p>暗瞳越大切削角膜厚度也就越多，针对角膜大的人最好选择半飞秒、个性化半飞秒，<strong>或者不考虑手术</strong>。</p>
<p>比如暗瞳为 7.5mm，光区切削为 7.0mm，其中的 0.5mm 因为还是近视状态，就会出现眩光。</p>
<p>有些人说近视手术后给自己带来了后遗症，出现了以上情况可能跟自身情况有关系或者跟自己选择的手术方式有关，不是近视手术的问题。</p>
<p>如果瞳孔过大，晶体或是激光切削的光学区不能完全覆盖瞳孔，就可能会”漏光“，这部分漏过去的光线，是无法聚焦到视网膜上的，相当于还是近视的朦胧的成像，清晰的和近视的两种影像混合在一起，就形成了独特的散光效果，也就是重影虚影，这在发光物体上尤其明显。</p>
<p>如果暗瞳大，角膜厚度理想，度数不高的条件下可以相对的扩大一点光区。但是如果角膜偏薄，度数又高的人光区不建议设计太大，因为本身度数高，角膜组织就切削的多，光区再大角膜就会丢失更多，角膜的剩余力学安全性就会差。</p>
<blockquote>
<p>一般大于 7 毫米，基本上就算大，7.5 以上甚至 8 毫米的就是很大的瞳孔了，7 以上其实就要考虑到底要不要做手术了。</p>
</blockquote>
<h2 id="什么是光学区" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%85%89%e5%ad%a6%e5%8c%ba" class="header-mark"></a>什么是光学区</h2><p>光学区或者叫光学治疗区。</p>
<p>近视手术，无论是激光类手术比如半飞秒，还是 ICL 晶体植入类手术，都有一个作用的光学区，当光学区完全覆盖瞳孔最大面积的情况下视力效果才会好。</p>
<h3 id="光学区的定义" class="headerLink">
    <a href="#%e5%85%89%e5%ad%a6%e5%8c%ba%e7%9a%84%e5%ae%9a%e4%b9%89" class="header-mark"></a>光学区的定义</h3><p>角膜激光手术利用波长为 193nm 的激光对角膜进行切削（消融），以改变角膜的折光能力，使得平行光线进入眼屈光系统后能准确的聚集在视网膜上。手术医生可以看到激光消融的范围，这个消融区就是切削区，其大小用直径表示。</p>
<p>为确保激光切削后的角膜有光滑的表面，切削区域分为<strong>光学区</strong>和<strong>过渡区</strong>两部分。其中光学区是用来进行屈光矫正的区域，主要起光学成像作用，过渡区起到光学区与非光学区之间的光滑过度作用，可以降低光学区边缘曲率突然改变的几率，有效降低术后球差（<a href="https://www.haodf.com/neirong/wenzhang/8119359366.html" target="_blank" rel="noopener noreferrer">角膜Q值与球差</a>）的增加，减少术后角膜上皮的增生和暗环境下的眩光问题。</p>
<p>光学区在临床上是可以调整的，是控制术后视觉质量的参数。正常成年人的角膜横径为 11.5-12mm，垂直径为 10.5-11mm。在角膜屈光手术的临床设计中，光学区大小一般设定在 6～7mm 左右，这也是为什么当暗瞳大与 7mm 时，要综合考虑手术或是否进行手术的原因。</p>
<p>光学区的大小是综合近视同学的角膜直径、角膜厚度、瞳孔直径、角膜曲率及近视散光度数等因素综合设计。</p>
<h3 id="主流近视手术的光学区范围" class="headerLink">
    <a href="#%e4%b8%bb%e6%b5%81%e8%bf%91%e8%a7%86%e6%89%8b%e6%9c%af%e7%9a%84%e5%85%89%e5%ad%a6%e5%8c%ba%e8%8c%83%e5%9b%b4" class="header-mark"></a>主流近视手术的光学区范围</h3><table>
<thead>
<tr>
<th>手术类型</th>
<th>最大光区</th>
</tr>
</thead>
<tbody>
<tr>
<td>全飞秒</td>
<td>7.0mm</td>
</tr>
<tr>
<td>半飞秒激</td>
<td>6.5mm</td>
</tr>
<tr>
<td>晶体植入</td>
<td>7.3mm</td>
</tr>
</tbody>
</table>
<p>其实，手术切削区域也受到手术设备的影响而有所差异。</p>
<p>比如，同样是 450 度近视加 100 度散光，鹰视的切削区为 9mm，阿玛仕的切削区为 7.45mm，蔡司的切削区域为 6.50mm，所以，有时手术设备选择也很重要。</p>
<h2 id="光学区与暗瞳的关系" class="headerLink">
    <a href="#%e5%85%89%e5%ad%a6%e5%8c%ba%e4%b8%8e%e6%9a%97%e7%9e%b3%e7%9a%84%e5%85%b3%e7%b3%bb" class="header-mark"></a>光学区与暗瞳的关系</h2><p>正常人白天亮环境瞳孔直径约 3mm，暗环境下，瞳孔会不由自主的放大，也就是生理性放大；对于中低度近视的同学，如果光学区域做的较大，很少会出现眩光的情况；对于高度近视的朋友，因为度数较高，需要切削掉的组织较多，又不可能把光学区域做的那么大，所以到了晚上光线变暗，瞳孔放大的时候就可能会出现眩光的问题。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221103/1e3a14e76a6543f8ad90c97dd6d52c4a.png" title="光学区与暗瞳的关系" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221103/1e3a14e76a6543f8ad90c97dd6d52c4a.png" data-sub-html="<h2>光学区与暗瞳的关系</h2><p>光学区与暗瞳的关系</p>">
        
    </a><figcaption class="image-caption">光学区与暗瞳的关系</figcaption>
    </figure></p>
<p>如上☝️ 暗瞳直径大于近视手术光学区直径，则会发生眩光的症状。</p>
<blockquote>
<p>若暗瞳超过手术光学区的值过大，为避免出现严重眩光的问题，建议进行保守的矫正方法，采取佩戴眼镜或是隐形眼镜来满足日常用眼需求。</p>
</blockquote>
<h2 id="什么是角膜制瓣" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%a7%92%e8%86%9c%e5%88%b6%e7%93%a3" class="header-mark"></a>什么是角膜制瓣</h2><p>近视眼往往伴随着角膜过凸，近视激光手术通过切削角膜组织，将角膜前表面的弧度削平，降低角膜的折光力，从而矫正近视屈光，提高视力。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221105/0bda646992e242038cc6b2899a66ca1f.png" title="眼睛的结构" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221105/0bda646992e242038cc6b2899a66ca1f.png" data-sub-html="<h2>眼睛的结构</h2><p>眼睛的结构</p>">
        
    </a><figcaption class="image-caption">眼睛的结构</figcaption>
    </figure></p>
<p>角膜分为五层，由前向后依次为上皮细胞层、前弹力层、基质层、后弹力层、内皮细胞层。角膜中基质层厚度占到整体厚度的 90%，方便切削，<strong>手术主要在基质层完成</strong>。</p>
<p>角膜瓣是角膜的一部分，是手术过程切开的一层薄薄的角膜组织。</p>
<p>如果要在基质层完成手术，此时必须要掀开上皮细胞层和前弹力层，就需要制作角膜瓣，所以为了达到基质层而进行手术需要掀开的部分就是角膜瓣。</p>
<p>如果将角膜组织比如成一个西瓜，角膜瓣相当于掀起的一块西瓜皮，里面的西瓜瓤就是角膜基质层。手术过程中，先将角膜瓣掀开翻在一边，然后用准分子激光在基质层上进行切削，切削完毕后，再将角膜瓣翻回来盖在原处，手术就完成了。因为角膜厚度和形状发生改变，成像就会准确落到视网膜上，以此达到矫正示例的目的。</p>
<p>如果只拿半飞秒和全飞秒来举例的话，其实可以简单理解为，只有在半飞秒中才会有角膜瓣，全飞秒是不会有角膜瓣的，因为现在激光可以聚焦在角膜的一定深度去处理的，也就是直接在基质层上进行切削，不需要掀开角膜瓣，激光直接对基质层进行切削完成后，在角膜边缘切割一个 2-4mm 的小口，将切割的基质层取出，手术就完成了。</p>
<p>所以，半飞秒需要掀开角膜瓣，全飞秒不需要掀开角膜瓣，在手术都成功的情况下，全飞秒对于角膜的创伤会更小。当然选择那种手术方式，需要更过医生的综合考量，这里只做理论分析。</p>
<h2 id="术后眩光症的可能原因" class="headerLink">
    <a href="#%e6%9c%af%e5%90%8e%e7%9c%a9%e5%85%89%e7%97%87%e7%9a%84%e5%8f%af%e8%83%bd%e5%8e%9f%e5%9b%a0" class="header-mark"></a>术后眩光症的可能原因</h2><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221103/a3ac36956e614b6da595e99aeb4bd1fb.png" title="炫光" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221103/a3ac36956e614b6da595e99aeb4bd1fb.png" data-sub-html="<h2>炫光</h2><p>炫光</p>">
        
    </a><figcaption class="image-caption">炫光</figcaption>
    </figure></p>
<ol>
<li>暗光下瞳孔直径大</li>
</ol>
<p>即使采用大光区矫正近视难以完全覆盖暗光下的瞳孔，形成眩光，此类人群不宜进行近视手术。</p>
<ol start="2">
<li>近视度数过高</li>
</ol>
<p>近视度数过高，若采用激光矫治近视，切削的角膜就越多，激光在角膜表面形成的“凹陷”也就越深，其斜率也越大。</p>
<ol start="3">
<li>手术过程中太过于紧张</li>
</ol>
<p>手术者配合度较差，造成偏中心切削。</p>
<ol start="4">
<li>过度关注引起的心理“假象”</li>
</ol>
<p>有一小部分人群可能术前就有一定的“眩光”，只是没有在意，而术后对视觉质量的关注度明显提高，往往认为是手术导致的眩光。</p>
<h2 id="夜视力下降问题" class="headerLink">
    <a href="#%e5%a4%9c%e8%a7%86%e5%8a%9b%e4%b8%8b%e9%99%8d%e9%97%ae%e9%a2%98" class="header-mark"></a>夜视力下降问题</h2><p>大部分人黑乌珠的角膜直径是在 11~12 毫米大小，做激光手术时是在角膜的中心，大约 6~7 个毫米的中间进行，平均是在大约 6.5 毫米的区域当中做。由于白天的瞳孔只有 2~3 个毫米，都在 6.5 毫米的覆盖范围之内，所以术后白天视力都是好的；到了晚上，人的瞳孔会慢慢放大，有的人可能放大到 6.7、6.5 毫米，这种人白天和晚上的视觉质量跟手术之前差别一般不会很大。但是有的人瞳孔会放大到很大，比如到 7点几、8.0 毫米以上，这时候不难想象，当8.0毫米的瞳孔大小范围之内，中间部分 6.5
毫米的范围是做过激光手术的，而边上的这一圈还是没有做过激光手术之前的近视状态的角膜，晚上看东西的时候就会有两个屈光界面的图像投射到他的视网膜上，这时候他的大脑会感受到两套清晰度不一样的图像，从而对视觉产生干扰，会觉得有点光晕、光圈。</p>
<div align="center"></div>
<p>所以做了激光手术以后，一部分人一开始可能会有夜间视觉质量点下降的感觉。随着时间慢慢的延长，人晚上的瞳孔大小，也就是暗瞳的直径，会逐渐缩小。因为暗瞳直径是受人体的交感神经和副交感神经控制，当交感神经兴奋的时候，瞳孔就会变大；当副交感神经兴奋的时候，瞳孔就会变小。所以激光手术后，当晚上有眩光时，副交感神经就会慢慢兴奋起来，他的瞳孔就会逐渐缩小，缩小到一定程度以后，夜间眩光的现象就会消失。</p>
<h2 id="为什么会出现干眼" class="headerLink">
    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e5%87%ba%e7%8e%b0%e5%b9%b2%e7%9c%bc" class="header-mark"></a>为什么会出现干眼</h2><p>我们的眼睛最表面有一层泪膜，来维持眼表面的湿润。泪膜是由眼睛表面的睑板腺、泪腺、副泪腺分泌出来的，这些腺体分泌的泪液由角膜表面的神经反馈所控制。</p>
<p>当做了激光手术以后，会损伤一部分角膜表面的神经，使得反馈的机制减弱，泪腺分泌的泪液量就会减少。</p>
<p>做了近视激光手术之后，都会或多或少的有一点干眼症。但是随着术后的恢复，大部分人在术后 6 个月的时候，角膜表面神经的功能会逐步恢复起来，干眼症也会逐步减轻。</p>
<p><strong>但是，但是，但是</strong>，我觉得干眼可能跟医生的水平和设备有关，很多都只是理论上没问题，比如我老表很早之前在我们市里做的手术，到现在了还一直干眼👇</p>
<div align="center"></div>
<p>因为全飞秒的对角膜的损伤是非常小的，所以对角膜的神经的损伤也是非常小的，相对而言，全飞秒对干眼的症状理论上会小很多。</p>
<h2 id="飞蚊症" class="headerLink">
    <a href="#%e9%a3%9e%e8%9a%8a%e7%97%87" class="header-mark"></a>飞蚊症</h2><p>在我查近视手术后遗症时，很多人发帖说在术手会出现飞蚊症。</p>
<h3 id="飞蚊表现" class="headerLink">
    <a href="#%e9%a3%9e%e8%9a%8a%e8%a1%a8%e7%8e%b0" class="header-mark"></a>飞蚊表现</h3><ul>
<li>视野中出现一些小图形，可以表现为色暗的斑点或圆球、透明的线状漂浮物</li>
<li>转动眼球时，这些斑点会移动，但是当你想要看清斑点时，它们又迅速从您的视野中消失</li>
<li>在你看着明亮的背景（例如蓝天或白墙）时，这些斑点最明显</li>
<li>小图形或线状物最终会下降并漂出您的视线</li>
</ul>
<h3 id="出现原因" class="headerLink">
    <a href="#%e5%87%ba%e7%8e%b0%e5%8e%9f%e5%9b%a0" class="header-mark"></a>出现原因</h3><ul>
<li><strong>与年龄有关的眼部变化</strong>。 随着年龄的增长，充满眼球并帮助其保持圆形的玻璃体或胶状物质会发生变化。随着时间的推移，玻璃体部分液化，这一过程导致其脱离眼球内表面。当玻璃体收缩和下垂时，它会结块并变得黏稠。这些结块碎片阻挡了一些通过眼睛的光线，在您的视网膜上投射出微小的阴影，被视为漂浮物。</li>
<li><strong>眼睛后部发炎</strong>。后葡萄膜炎是眼睛后部葡萄膜层的炎症。这种病症会导致炎症碎片释放到玻璃体中而被视为漂浮物。后葡萄膜炎可能时由于感染、炎症性疾病或其他原因所致。</li>
<li><strong>眼睛出血</strong>。玻璃体出血有很多原因，包括糖尿病、高血压、血管阻塞和损伤。血细胞被视为漂浮物。</li>
<li><strong>视网膜撕裂</strong>。当下垂的玻璃体产生足够的力拉扯视网膜时，就会发生视网膜撕裂。如果不治疗，视网膜撕裂可能导致视网膜脱离，也就是视网膜后面的液体积聚，导致视网膜从您眼睛后方脱离。视网膜脱离不经治疗可导致永久性视力丧失。</li>
<li><strong>眼科手术和眼科药物</strong>。某些药物注入玻璃体会导致气泡形成。这些气泡会被视为阴影，直至您的眼睛将其吸收。某些玻璃体视网膜手术会在玻璃体中加入硅油，这也可能被看作是漂浮物。</li>
</ul>
<h3 id="近视手术是否会导致飞蚊" class="headerLink">
    <a href="#%e8%bf%91%e8%a7%86%e6%89%8b%e6%9c%af%e6%98%af%e5%90%a6%e4%bc%9a%e5%af%bc%e8%87%b4%e9%a3%9e%e8%9a%8a" class="header-mark"></a>近视手术是否会导致飞蚊</h3><div align="center"></div>
<p>在知乎很多这样的回答中，出现了 2 个比较高赞的观点，一个是手术过程损伤了玻璃体，导致了飞蚊现象，比如这个👇</p>
<div align="center"></div>
<p>近视手术是在角膜上进行的手术，由【玻璃体图】可知，角膜和玻璃体之间还隔了一个水晶体或是叫晶状体，在手术过程中根本不会接触到玻璃体，所以近视手术破坏晶状体的一些回答应该是不可靠的。这个回答还说了会导致夜盲症，这里的夜盲应该是夜视力下降，而夜视力下降是光学区和暗瞳不一定导致的，具体可以看<a href="#%e5%85%89%e5%ad%a6%e5%8c%ba%e4%b8%8e%e6%9a%97%e7%9e%b3%e7%9a%84%e5%85%b3%e7%b3%bb" rel="">光学区和暗瞳的关系</a>。当然这只是我的个人分析。</p>
<p>还有一个导致飞蚊的观点是负压吸引导致的，比如这个回答：</p>
<div align="center"></div>
<p>负压是手术过程中，负压环对眼球产生的压力。负压高，会导致眼压升高，视神经和视网膜受到压迫，术中出现短暂的黑朦情况。我查到的资料是，蔡司的机器，半飞秒负压极低，术中不会出现眼压升高，全程可视，所以我觉得这个可能跟机器有关系，跟手术本身关系不大。</p>
<h2 id="手术失败眼会瞎吗" class="headerLink">
    <a href="#%e6%89%8b%e6%9c%af%e5%a4%b1%e8%b4%a5%e7%9c%bc%e4%bc%9a%e7%9e%8e%e5%90%97" class="header-mark"></a>手术失败眼会瞎吗</h2><p>飞秒和全飞秒近视手术是在眼角膜的基质层上进行的，对眼内组织没有影响，直接上医生的科普：</p>
<div class="bilibili"><iframe src="//player.bilibili.com/player.html?bvid=BV1qJ411i7ZL&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe></div>

<p>但是要注意<strong>术后感染</strong>，比如这个视频：</p>
<div class="bilibili"><iframe src="//player.bilibili.com/player.html?bvid=BV1Nq4y1b79G&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe></div>

<h2 id="是否可以通过训练逆转近视" class="headerLink">
    <a href="#%e6%98%af%e5%90%a6%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87%e8%ae%ad%e7%bb%83%e9%80%86%e8%bd%ac%e8%bf%91%e8%a7%86" class="header-mark"></a>是否可以通过训练逆转近视</h2><p><a href="https://www.youtube.com/watch?v=mYQ_5t8vf14&amp;ab_channel=%E8%B6%A3%E5%91%B3%E7%A7%91%E6%99%AE%E4%BA%BA%E6%96%87" target="_blank" rel="noopener noreferrer">近视，一个可以逆转的现代疾病！</a></p>
<video width="100%" height="100%" controls>
  <source src="https://cdn.xiaobinqt.cn/videoplayback.mp4" type="video/mp4">
</video>
<h2 id="相关视频" class="headerLink">
    <a href="#%e7%9b%b8%e5%85%b3%e8%a7%86%e9%a2%91" class="header-mark"></a>相关视频</h2><ol>
<li><a href="https://www.youtube.com/watch?v=ckLg6R3638I&amp;ab_channel=%E8%92%BC%E8%97%8D%E9%B4%BF%E7%9A%84%E9%86%AB%E5%AD%B8%E5%A4%A9%E5%9C%B0" target="_blank" rel="noopener noreferrer">我不做近視雷射手術的原因? 該擔心後遺症嗎? Smile全飛秒是什麼? | 蒼藍鴿聊醫學EP179</a></li>
</ol>
<video width="100%" height="100%" controls>
  <source src="https://cdn.xiaobinqt.cn/%E6%88%91%E4%B8%8D%E5%81%9A%E8%BF%91%E8%A6%96%E9%9B%B7%E5%B0%84%E6%89%8B%E8%A1%93%E7%9A%84%E5%8E%9F%E5%9B%A0_%20%E8%A9%B2%E6%93%94%E5%BF%83%E5%BE%8C%E9%81%BA%E7%97%87%E5%97%8E_%20Smile%E5%85%A8%E9%A3%9B%E7%A7%92%E6%98%AF%E4%BB%80%E9%BA%BC_%20_%20%E8%92%BC%E8%97%8D%E9%B4%BF%E8%81%8A%E9%86%AB%E5%AD%B8EP179.mp4" type="video/mp4">
</video>
<br/>
<ol start="2">
<li><a href="https://www.youtube.com/watch?v=xLWVj5uOJPM&amp;ab_channel=%E4%BA%AE%E7%94%9F%E6%B4%BB%2FBrightSide" target="_blank" rel="noopener noreferrer">眼睛裡面是什麼樣的呢</a></li>
</ol>
<video width="100%" height="100%" controls>
  <source src="https://cdn.xiaobinqt.cn/%E7%9C%BC%E7%9D%9B%E8%A3%A1%E9%9D%A2%E6%98%AF%E4%BB%80%E9%BA%BC%E6%A8%A3%E7%9A%84%E5%91%A2.mp4" type="video/mp4">
</video>
<ol start="3">
<li><a href="https://www.bilibili.com/video/BV11J411677z/" target="_blank" rel="noopener noreferrer">激光近视术后十年回顾！本人遭遇无法避免的后遗症并发症大盘点！</a></li>
</ol>
<div class="bilibili"><iframe src="//player.bilibili.com/player.html?bvid=BV11J411677z&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe></div>

<h2 id="关于我" class="headerLink">
    <a href="#%e5%85%b3%e4%ba%8e%e6%88%91" class="header-mark"></a>关于我</h2><p>我觉得我可以不用考虑手术了😢，毕竟我暗瞳已经大与 7mm 了。以下是我在同仁医院的挂号医生跟我说的我的暗瞳。</p>
<div align="center"></div>
<p>而且我眼底也有问题，做过次全视网膜凝光术。</p>
<div align="center"></div>
<p>这几天查了一些资料，包括跟朋友的交流，我对做手术的欲望已经不是很大了，但是，个人觉得可以通过一些锻炼来恢复自己的视力😂🙈。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="http://lxjk.people.cn/n1/2018/1129/c404177-30432947.html" target="_blank" rel="noopener noreferrer">人民网-科普中国-近视激光手术安全吗？十个问题了解近视激光手术</a></li>
<li><a href="https://ishare.ifeng.com/c/s/v002Tk2F33yq---_EKzB5lXqC0682NIp09ySVxU9CjnYQQkPE__" target="_blank" rel="noopener noreferrer">想做近视手术，却被各种并发症“劝退”？眼科专家破解五大传言</a></li>
<li><a href="https://www.youtube.com/watch?v=7ewRPWa37YY&amp;ab_channel=%E6%96%87%E5%85%A8%E7%BB%83%E7%9C%BC" target="_blank" rel="noopener noreferrer">近视成因和恢复视力原理及操作方法！</a></li>
<li><a href="https://www.zhihu.com/question/392573805/answer/2392053374" target="_blank" rel="noopener noreferrer">暗瞳大做近视手术会有什么后遗症？ - 眼科医生陈鼎的回答 - 知乎</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/485201330" target="_blank" rel="noopener noreferrer">详解近视手术中手术光学区问题</a></li>
<li><a href="https://tech.sina.com.cn/scientist/2019-07-04/doc-ihytcitk9574179.shtml" target="_blank" rel="noopener noreferrer">近视手术靠谱吗？只是能矫正，但无法根治近视</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/102476044" target="_blank" rel="noopener noreferrer">近视手术中的角膜瓣是什么</a></li>
<li><a href="https://www.mayoclinic.org/zh-hans/diseases-conditions/eye-floaters/symptoms-causes/syc-20372346" target="_blank" rel="noopener noreferrer">飞蚊症</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/441747388" target="_blank" rel="noopener noreferrer">近视真的可以自愈吗？</a></li>
<li><a href="https://www.eachsee.com/article-5054.html" target="_blank" rel="noopener noreferrer">验光单怎么看？史上最全验光单样式及参数详解</a></li>
</ul>
]]></description>
</item><item>
    <title>Go1.18 sync.Map 解读</title>
    <link>https://www.xiaobinqt.cn/go-sync-map/</link>
    <pubDate>Wed, 14 Sep 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/go-sync-map/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="背景" class="headerLink">
    <a href="#%e8%83%8c%e6%99%af" class="header-mark"></a>背景</h2><p>项目中遇到了需要使用高并发的 map 的场景，众所周知 Go 官方的原生 map 是不支持并发读写的，直接并发的读写很容易触发 panic。</p>
<p>解决的办法有两个：</p>
<ul>
<li>自己配一把锁 <code>sync.Mutex</code> 或者更加考究一点配一把读写锁 <code>sync.RWMutex</code>。这种方案简约直接，但是缺点也明显，就是性能不会太高。</li>
<li>使用 Go 语言在 2017 年发布的 Go 1.9 中正式加入了并发安全的字典类型 <code>sync.Map</code>。</li>
</ul>
<p>很显然，方案 2 是优雅且实用的。但是，为什么官方的 <code>sync.Map</code> 能够在 <strong><ruby>lock free<rt>无锁并发</rt></ruby></strong> 的前提下，保证足够高的性能❓本文结合 golang 1.18 源码进行简单的分析。</p>
<h2 id="核心思想" class="headerLink">
    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e6%83%b3" class="header-mark"></a>核心思想</h2><p>如果要保证并发的安全，最朴素的想法就是使用锁，但是这意味着要把一些并发的操作强制串行化，性能自然就会下降。</p>
<p>事实上，除了使用锁，还有一个办法也可以达到类似并发安全的目的，就是 <code>atomic</code> 原子操作。<code>sync.Map</code> 的设计非常巧妙，充分利用了 <code>atmoic</code> 和 <code>mutex</code> 互斥锁的配合。</p>
<ul>
<li>
<p>read map 由于是原子包托管，主要负责高性能，但是无法保证拥有全量的 key，因为对于新增 key，会首先加到 dirty 中，所以 read 某种程度上，类似于一个 key 的快照，这个快照在某些情况下可能是全量快照。</p>
</li>
<li>
<p>dirty map 拥有全量的 key，当 <code>Store</code> 操作要新增一个之前不存在的 key 的时候，会先增加到 dirty 中的。</p>
</li>
<li>
<p>在查找指定的 key 的时候，总会先去 read map 中寻找，并不需要锁定互斥锁。只有当 read 中没有，但 dirty 中可能会有这个 key 的时候，才会在锁的保护下去访问 dirty。</p>
</li>
<li>
<p>在存储键值对的时候，只要 read 中已存有这个 key，并且该键值对<strong>未被</strong>标记为 <code>expunged</code>，就会把新值存到里面并直接返回，这种情况下也不需要用到锁。</p>
</li>
<li>
<p>read 和 dirty 之间是会互相转换的，在 dirty 中查找 key 对次数足够多的时候，<code>sync.Map</code> 会把 dirty 直接作为 read，即触发  <code>dirty-&gt;read</code> 的转变，此时 read 中拥有全量的 key。同时在某些情况，也会出现 <code>read-&gt;dirty</code> 的转变。</p>
</li>
</ul>
<h2 id="数据结构" class="headerLink">
    <a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="header-mark"></a>数据结构</h2><p>尽量使用原子操作，最大程度上减少了锁的使用，从而接近了 lock free 的效果。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221205/3c105d85e5c24fecb51e45bc3a184cfe.png" title="数据结构" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221205/3c105d85e5c24fecb51e45bc3a184cfe.png" data-sub-html="<h2>数据结构</h2><p>数据结构</p>">
        
    </a><figcaption class="image-caption">数据结构</figcaption>
    </figure></p>
<p>sync.Map 类型的底层数据结构如下👇</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type Map struct {
</span></span><span class="line"><span class="cl"> mu Mutex
</span></span><span class="line"><span class="cl"> read atomic.Value // readOnly
</span></span><span class="line"><span class="cl"> dirty map[any]*entry
</span></span><span class="line"><span class="cl"> misses int
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// Map.read 属性实际存储的是 readOnly。
</span></span><span class="line"><span class="cl">type readOnly struct {
</span></span><span class="line"><span class="cl"> m map[any]*entry
</span></span><span class="line"><span class="cl"> amended bool
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>mu：互斥锁，用于保护 read 和 dirty。</p>
</li>
<li>
<p>read：只读数据，支持并发读取（<code>atomic.Value</code>）。如果涉及到更新操作，则只需要加锁来保证数据安全。</p>
</li>
<li>
<p>read 实际存储的是 readOnly 结构体，内部也是一个原生 map，amended 属性用于标记 read 和 dirty 的数据是否一致，当 dirty 中存在 read 中不存在的 key 时，amended 为 <code>true</code>。</p>
</li>
<li>
<p>dirty：读写数据，是一个原生 map，也就是非线程安全。操作 dirty 需要加锁来保证数据安全。</p>
</li>
<li>
<p>misses：统计有多少次读取 read 没有命中。每次 read 中读取失败后，misses 的计数值都会加 1。</p>
</li>
</ul>
<p>在 read 和 dirty 中，都有涉及到的结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type entry struct {
</span></span><span class="line"><span class="cl"> p unsafe.Pointer // *any
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>其包含一个指针 p, 用于指向用户存储的元素（key）所指向的 value 值。</p>
<h2 id="atomicvalue" class="headerLink">
    <a href="#atomicvalue" class="header-mark"></a>atomic.Value</h2><p>当需要在 Go 中进行并发安全的值存储和读取时，可以使用 <code>sync/atomic</code> 包中的 <code>atomic.Value</code> 类型。<code>atomic.Value</code> 提供了一种原子操作的方式来存储和读取值，以确保在并发环境下不会出现数据竞争。</p>
<p>以下是关于 <code>atomic.Value</code> 的详细说明：</p>
<ol>
<li>
<p><strong>创建 <code>atomic.Value</code></strong>：
要创建一个 <code>atomic.Value</code>，可以使用 <code>sync/atomic</code> 包中的 <code>atomic.Value</code> 类型的零值。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">var v atomic.Value
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>存储值</strong>：
使用 <code>Store</code> 方法来存储一个值到 <code>atomic.Value</code> 中。这个操作是原子的，不会出现数据竞争。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">v.Store(&#34;Hello, World!&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>读取值</strong>：
使用 <code>Load</code> 方法来从 <code>atomic.Value</code> 中读取值。这个操作也是原子的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">value := v.Load()
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>并发安全</strong>：
<code>atomic.Value</code> 保证了存储和读取的操作是并发安全的，不需要额外的锁或互斥体。这对于在多个 goroutine 之间共享数据非常有用。</p>
</li>
<li>
<p><strong>值的类型</strong>：
<code>atomic.Value</code> 可以存储任何类型的值。这意味着它可以用于存储字符串、整数、结构体、切片、接口等任何 Go 类型。</p>
</li>
<li>
<p><strong>注意事项</strong>：</p>
<ul>
<li>
<p>虽然 <code>atomic.Value</code> 提供了并发安全的存储和读取，但它并不适用于复杂的数据结构。如果需要对复杂数据结构进行并发访问和修改，可能需要使用其他同步机制，如互斥锁。</p>
</li>
<li>
<p>当从 <code>atomic.Value</code> 中读取值时，需要进行类型断言，以将接口类型转换为实际的值类型。这需要谨慎处理，以确保类型安全。</p>
</li>
</ul>
</li>
</ol>
<p><code>atomic.Value</code> 是 Go 语言中用于并发安全值存储和读取的有用工具。它在简单的值存储和读取场景中非常有用，可以帮助避免数据竞争问题。但在处理复杂数据结构或需要更复杂同步的情况下，可能需要考虑其他并发控制机制。</p>
<h2 id="entry-的-p-可能状态" class="headerLink">
    <a href="#entry-%e7%9a%84-p-%e5%8f%af%e8%83%bd%e7%8a%b6%e6%80%81" class="header-mark"></a>entry 的 p 可能状态</h2><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230714/9ab5f3ce270e4d39ac832e6bea79238b.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230714/9ab5f3ce270e4d39ac832e6bea79238b.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230714/9ab5f3ce270e4d39ac832e6bea79238b.png" data-sub-html="<h2>p 的状态</h2>">
        
    </a><figcaption class="image-caption">p 的状态</figcaption>
    </figure></p>
<h3 id="nil" class="headerLink">
    <a href="#nil" class="header-mark"></a>nil</h3><p>当删除一个 key 时，如果 read 中存在会把这个 key 的 value 也就是 e.p 标记为 nil。这样在下次查找的时候还会在 read 中找个这个 key，这时需要去判断下 e.p 是否是 nil，如果是 nil 就表示这个 key 是已经删除的。</p>
<p>如果 read 中不存在但是 dirty 中存在，会先从 dirty 中把这个 key 删除，然后把这个 key 对应的 value 也就是 e.p 标记为 nil。</p>
<ul>
<li><code>e.p==nil</code>：entry 已经被标记删除，不过此时还未经过 <code>read-&gt;dirty</code> 重塑，此时可能仍然属于 dirty（如果 dirty 非 nil）。</li>
</ul>
<h3 id="expunged" class="headerLink">
    <a href="#expunged" class="header-mark"></a>expunged</h3><p>当 <code>dirty-&gt;read</code> 完成后，又有新 key 写入时，此时 read 中的 amended 为 <code>false</code>，就会调用 <code>dirtyLocked()</code> 方法，此时会发生 <code>read-&gt;dirty</code> 的转变，此时会循环 read 数据，将 p 不为 nil 的值写到 dirty 中，如果 p 为 nil 则将 nil 转为 expunged，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Map) dirtyLocked() {
</span></span><span class="line"><span class="cl">	if m.dirty != nil {
</span></span><span class="line"><span class="cl">		return
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	read, _ := m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl">	m.dirty = make(map[any]*entry, len(read.m))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	println(&#34;read-&gt;dirty 转变&#34;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	for k, e := range read.m {
</span></span><span class="line"><span class="cl">		// 把 read 中 value e.p 不是 expunged 的 key,value 转到 dirty 中
</span></span><span class="line"><span class="cl">		// 这里是循环，如果数据量大可能会非常耗时
</span></span><span class="line"><span class="cl">		if !e.tryExpungeLocked() {
</span></span><span class="line"><span class="cl">			m.dirty[k] = e
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func (e *entry) tryExpungeLocked() (isExpunged bool) {
</span></span><span class="line"><span class="cl">	p := atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">	for p == nil {
</span></span><span class="line"><span class="cl">		// 将 e.p 的 nil 转成 expunged
</span></span><span class="line"><span class="cl">		if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) {
</span></span><span class="line"><span class="cl">			return true
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		p = atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	return p == expunged
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在从 <code>read-&gt;dirty</code> 的转变中，虽然 read 中还会存在 expunged 的内容（expunged 是 read 独有的），但是不影响 sync.map 的高性能。相反，如果在 Delete 时直接去删除元素，那么就会去加锁操作 dirty，只要涉及到锁，就会影响到性能。</p>
<h3 id="正常" class="headerLink">
    <a href="#%e6%ad%a3%e5%b8%b8" class="header-mark"></a>正常</h3><p>此时 entry 是一个普通的存在状态，属于 read，如果 dirty 非 nil，也属于 dirty。</p>
<h2 id="store写入过程" class="headerLink">
    <a href="#store%e5%86%99%e5%85%a5%e8%bf%87%e7%a8%8b" class="header-mark"></a>Store写入过程</h2><p>先来看 expunged</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">var expunged = unsafe.Pointer(new(any))
</span></span></code></pre></td></tr></table>
</div>
</div><p>expunged 是一个指向任意类型的指针，用来标记从 dirty map 中<strong>删除</strong>的 entry。</p>
<p>sync.Map 类型的 Store 方法，该方法的作用是新增或更新一个元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Map) Store(key, value any) {
</span></span><span class="line"><span class="cl"> read, _ := m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl"> if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {
</span></span><span class="line"><span class="cl">  return
</span></span><span class="line"><span class="cl"> }
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// tryStore stores a value if the entry has not been expunged.
</span></span><span class="line"><span class="cl">//
</span></span><span class="line"><span class="cl">// If the entry is expunged, tryStore returns false and leaves the entry
</span></span><span class="line"><span class="cl">// unchanged.
</span></span><span class="line"><span class="cl">func (e *entry) tryStore(i *any) bool {
</span></span><span class="line"><span class="cl">	for {
</span></span><span class="line"><span class="cl">		p := atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">		if p == expunged {
</span></span><span class="line"><span class="cl">			return false
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		if atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) {
</span></span><span class="line"><span class="cl">			return true
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>调用<code>Load</code>方法检查<code>m.read</code>中是否存在这个元素。若存在，且在 tryStore 时，判断没有被标记为 expunged 删除状态，则尝试存储。</p>
<p>若该元素不存在或在 tryStore 时判断时，已经被标记为删除状态，则继续走到下面流程👇</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Map) Store(key, value any) {
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    m.mu.Lock()
</span></span><span class="line"><span class="cl">	read, _ = m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl">	if e, ok := read.m[key]; ok {
</span></span><span class="line"><span class="cl">		if e.unexpungeLocked() {
</span></span><span class="line"><span class="cl">			// 如果 read map 中存在该 key，但 p == expunged，则说明在 read 中已经被删除了:
</span></span><span class="line"><span class="cl">			//    a. 将 p 的状态由中间值 expunged 更改为 nil
</span></span><span class="line"><span class="cl">			//    b. dirty map 插入 key
</span></span><span class="line"><span class="cl">			m.dirty[key] = e
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		// 更新 entry.p = value (read map 和 dirty map 指向同一个 entry)
</span></span><span class="line"><span class="cl">		e.storeLocked(&amp;value)
</span></span><span class="line"><span class="cl">	} else if e, ok := m.dirty[key]; ok {
</span></span><span class="line"><span class="cl">		// 如果 read map 中不存在该 key，但 dirty map 中存在该 key，直接写入更新 entry(read map 中仍然没有这个 key)
</span></span><span class="line"><span class="cl">		e.storeLocked(&amp;value)
</span></span><span class="line"><span class="cl">	} else {
</span></span><span class="line"><span class="cl">		// 如果 read map 和 dirty map 中都不存在该 key，则：
</span></span><span class="line"><span class="cl">		//	  a. 如果 dirty map 为空，则需要创建 dirty map，并从 read map 中拷贝未删除的元素到新创建的 dirty map
</span></span><span class="line"><span class="cl">		//    b. 更新 amended 字段，标识 dirty map 中存在 read map 中没有的 key
</span></span><span class="line"><span class="cl">		//    c. 将 kv 写入 dirty map 中，read 不变
</span></span><span class="line"><span class="cl">		if !read.amended {
</span></span><span class="line"><span class="cl">		    // 到这里就意味着，当前的 key 是第一次被加到 dirty map 中。
</span></span><span class="line"><span class="cl">			// store 之前先判断一下 dirty map 是否为空，如果为空，就把 read map 浅拷贝一次。
</span></span><span class="line"><span class="cl">			m.dirtyLocked()
</span></span><span class="line"><span class="cl">			m.read.Store(readOnly{m: read.m, amended: true})
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		// 写入新 key，在 dirty 中存储 value
</span></span><span class="line"><span class="cl">		m.dirty[key] = newEntry(value)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	m.mu.Unlock()
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func (m *Map) dirtyLocked() {
</span></span><span class="line"><span class="cl">	if m.dirty != nil {
</span></span><span class="line"><span class="cl">		return
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	read, _ := m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl">	m.dirty = make(map[any]*entry, len(read.m))
</span></span><span class="line"><span class="cl">	for k, e := range read.m {
</span></span><span class="line"><span class="cl">		if !e.tryExpungeLocked() {
</span></span><span class="line"><span class="cl">			m.dirty[k] = e
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func (e *entry) tryExpungeLocked() (isExpunged bool) {
</span></span><span class="line"><span class="cl">	p := atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">	for p == nil {
</span></span><span class="line"><span class="cl">		// 将已经删除标记为nil的数据标记为 expunged
</span></span><span class="line"><span class="cl">		if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) {
</span></span><span class="line"><span class="cl">			return true
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		p = atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	return p == expunged
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里使用了<strong>双检查</strong>的处理，因为在下面的两个语句中，这两行语句并不是一个原子操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if !ok &amp;&amp; read.amended {
</span></span><span class="line"><span class="cl">		m.mu.Lock()
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然第一句执行的时候条件满足，但是在加锁之前，<code>m.dirty</code> 可能被提升为 <code>m.read</code>，所以加锁后还得再检查一次 <code>m.read</code>，后续的方法中都使用了这个方法。</p>
<p>由于已经走到了 dirty 的流程，因此开头就直接调用了 <code>Lock</code> 方法上<strong>互斥锁</strong>，保证数据安全，也是凸显<strong>性能变差的第一幕</strong>。</p>
<p>写入过程的整体流程是👇</p>
<ol>
<li>如果在 read 里能够找到待存储的 key，并且对应的 entry 的 p 值不为 expunged，也就是没被删除时，直接更新对应的 entry 即可。</li>
<li>如果第一步没有成功，要么 read 中没有这个 key，要么 key 被标记为删除。则先加锁，再进行后续的操作。</li>
<li>再次在 read 中查找是否存在这个 key，也就是 double check 双检查一下，这是 lock-free 编程的常见套路。如果 read 中存在该 key，但 <code>p == expunged</code>，说明 <code>m.dirty != nil</code>（<code>m.dirty</code> 是被初始化过的）并且 <code>m.dirty</code> 中不存在该 key 值（因为已经被删除了，dirty 中的删除直接就删除了；read 中的删除，会先标记为 nil，<code>read-&gt;dirty</code> 重塑时再标记为 <code>expunged</code>），此时👇
<ol>
<li>将 p 的状态由 <code>expunged</code> 更改为 <code>nil</code></li>
<li>dirty map 插入 key。然后，直接更新对应的 value</li>
</ol>
</li>
<li>如果 read 中没有此 key，那就查看 dirty 中是否有此 key，如果有，则直接更新对应的 value，这时 read 中还是没有此 key。</li>
<li>最后一步，如果 read 和 dirty 中都不存在该 key，则👇
<ol>
<li>如果 <code>dirty</code> 为空，则需要创建 <code>dirty</code>，并从 <code>read</code> 中拷贝未被删除的元素</li>
<li>更新 <code>amended</code> 字段为 true，标识 dirty map 中存在 read map 中没有的 <code>key</code></li>
<li>将 <code>k-v</code> 写入 dirty map 中，<code>read.m</code> 不变。最后，更新此 key 对应的 <code>value</code>。</li>
</ol>
</li>
</ol>
<p><strong>为什么 read 中存在 key，但是 <code>p == expunged</code> 时需要把 p 的状态由 <code>expunged</code> 更改为 <code>nil</code></strong> ❓</p>
<p>expunged 的意义是在删除操作后，键的对应值被标记为 expunged，而不是简单地设置为 nil。这样做的好处是，nil 值可能是键本身的有效值，因此无法区分键已被删除和键对应的值为 nil 两种情况。通过使用 expunged 标记，sync.Map 可以清楚地区分键被删除和键对应的值为 nil。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if e.unexpungeLocked() {
</span></span><span class="line"><span class="cl">      // The entry was previously expunged, which implies that there is a
</span></span><span class="line"><span class="cl">      // non-nil dirty map and this entry is not in it.
</span></span><span class="line"><span class="cl">      m.dirty[key] = e
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  e.storeLocked(&amp;value)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// storeLocked unconditionally stores a value to the entry.
</span></span><span class="line"><span class="cl">//
</span></span><span class="line"><span class="cl">// The entry must be known not to be expunged.
</span></span><span class="line"><span class="cl">func (e *entry) storeLocked(i *any) {
</span></span><span class="line"><span class="cl">	atomic.StorePointer(&amp;e.p, unsafe.Pointer(i))
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Store 可能会在某种情况下（初始化或者 <code>m.dirty</code> 刚被提升后，此时 <code>m.read</code> 中的数据和 <code>m.dirty</code> 中的相等，readOnly 中的 <code>amended</code> 为 <code>false</code>，也就是说可能存在一个 key，read 中找不到 dirty 中也找不到）从 <code>m.read</code> 中复制数据，如果这个时候 <code>m.read</code> 中数据量非常大，可能会影响性能。</p>
<p>综上，sync.Map 类型<strong>不适合写多的场景</strong>，读多写少是比较好的。若有大数据量的场景，则需要考虑 read 复制数据时的偶然性能抖动是否能够接受。</p>
<h2 id="load查找过程" class="headerLink">
    <a href="#load%e6%9f%a5%e6%89%be%e8%bf%87%e7%a8%8b" class="header-mark"></a>Load查找过程</h2><p>sync.Map 类型本质上是有两个 map。一个叫 read、一个叫 dirty，长的也差不多👇</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221204/301dd5df668c43c08845983b106b0fc4.png" title="sync.map" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221204/301dd5df668c43c08845983b106b0fc4.png" data-sub-html="<h2>sync.map</h2><p>sync.map</p>">
        
    </a><figcaption class="image-caption">sync.map</figcaption>
    </figure></p>
<p>当从 sync.Map 类型中读取数据时，其会先查看 read 中是否包含所需的元素：</p>
<ul>
<li>若有，则通过 atomic 原子操作读取数据并返回。</li>
<li>若无，则会判断 read.readOnly 中的 amended 属性，他会告诉程序，dirty 是否包含 <code>read.readOnly.m</code> 中没有的数据；如果存在，也就是 amended 为 true，将会进 一步到 dirty 中查找数据。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Map) Load(key any) (value any, ok bool) {
</span></span><span class="line"><span class="cl">	// 1.首先从 m.read 中得到只读 readOnly,从它的 map 中查找，不需要加锁
</span></span><span class="line"><span class="cl">	read, _ := m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl">	e, ok := read.m[key]
</span></span><span class="line"><span class="cl">	// 2. 如果没找到，并且 m.dirty 中有新数据，需要从 m.dirty 查找，这个时候需要加锁
</span></span><span class="line"><span class="cl">	if !ok &amp;&amp; read.amended {
</span></span><span class="line"><span class="cl">		m.mu.Lock()
</span></span><span class="line"><span class="cl">		// 双检查，避免加锁的时候 m.dirty 提升为 m.read,这个时候 m.read 可能被替换了。
</span></span><span class="line"><span class="cl">		read, _ = m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl">		e, ok = read.m[key]
</span></span><span class="line"><span class="cl">		// 如果m.read中还是不存在，并且m.dirty中有新数据
</span></span><span class="line"><span class="cl">		if !ok &amp;&amp; read.amended {
</span></span><span class="line"><span class="cl">			// 从m.dirty查找
</span></span><span class="line"><span class="cl">			e, ok = m.dirty[key]
</span></span><span class="line"><span class="cl">			// 不管 m.dirty 中存不存在，都将 misses 计数加一
</span></span><span class="line"><span class="cl">			// missLocked()中满足条件后就会提升 m.dirty
</span></span><span class="line"><span class="cl">			m.missLocked()
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		m.mu.Unlock()
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	if !ok {
</span></span><span class="line"><span class="cl">		return nil, false
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	return e.load()
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>处理路径分为 fast path 和 slow path，整体流程如下：</p>
<ol>
<li>首先是 fast path，直接在 read 中找，如果找到了直接调用 entry 的 load 方法，取出其中的值。</li>
<li>如果 read 中没有这个 key，且 amended 为 false，说明 dirty 为空，那直接返回空和 false。</li>
<li>如果 read 中没有这个 key，且 amended 为 true，说明 dirty 中可能存在我们要找的 key。要先上锁，再尝试去 dirty 中查找。在这之前，仍然有一个 double check 的操作。若还是没有在 read 中找到，那么就从 dirty 中找。不管 dirty 中有没有找到，都要 “记一笔”，因为在 dirty 被提升为 read 之前，都会进入这条路径</li>
</ol>
<p>那么 <code>m.dirty</code> 是如何被提升的❓ <code>missLocked</code> 方法中可能会将 <code>m.dirty</code> 提升。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Map) missLocked() {
</span></span><span class="line"><span class="cl">	m.misses++ // 不管在 dirty 中没有读到，miss 都执行 ++ 操作
</span></span><span class="line"><span class="cl">	if m.misses &lt; len(m.dirty) {
</span></span><span class="line"><span class="cl">		return
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// 如果 miss 的值 &gt;= len(dirty)，将 dirty 赋给 read, dirty 和 miss 重新初始化
</span></span><span class="line"><span class="cl">	// 此时 dirty 就为空了，说明从 dirty 全部过渡到了 read, 此时 read 是全量的
</span></span><span class="line"><span class="cl">	m.read.Store(readOnly{m: m.dirty})
</span></span><span class="line"><span class="cl">	m.dirty = nil
</span></span><span class="line"><span class="cl">	m.misses = 0
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>直接将 misses 的值加 1，表示一次未命中，如果 misses 值小于 <code>m.dirty</code> 的长度，就直接返回。否则，将 <code>m.dirty</code> 晋升为 read，并清空 dirty，清空 misses 计数值，并且 <code>m.read.amended</code> 为 <code>false</code>。这样，之前一段时间新加入的 key 都会进入到 read 中，从而能够提升 read 的命中率。</p>
<p>再来看下 entry 的 load 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (e *entry) load() (value any, ok bool) {
</span></span><span class="line"><span class="cl">	p := atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">	if p == nil || p == expunged {
</span></span><span class="line"><span class="cl">		return nil, false
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	return *(*any)(p), true
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于 nil 和 expunged 状态的 entry，直接返回 <code>ok=false</code>；否则，将 p 转成 <code>any</code> 返回。</p>
<p>sync.Map 的读操作性能如此之高的原因，就在于存在 read 这一巧妙的设计，其作为一个缓存层，提供了<strong><ruby>快路径<rt>fast path</rt></ruby></strong>的查找。</p>
<h2 id="delete删除过程" class="headerLink">
    <a href="#delete%e5%88%a0%e9%99%a4%e8%bf%87%e7%a8%8b" class="header-mark"></a>Delete删除过程</h2><p>写入过程，理论上和删除不会差太远。怎么 sync.Map 类型的删除的性能似乎还行，那这里面到底是如何实现的呢❓</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Map) Delete(key any) {
</span></span><span class="line"><span class="cl">	read, _ := m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl">	e, ok := read.m[key]
</span></span><span class="line"><span class="cl">	// 如果 read 中没有这个 key，且 dirty map 不为空
</span></span><span class="line"><span class="cl">	if !ok &amp;&amp; read.amended {
</span></span><span class="line"><span class="cl">		m.mu.Lock()
</span></span><span class="line"><span class="cl">		read, _ = m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl">		e, ok = read.m[key]
</span></span><span class="line"><span class="cl">		if !ok &amp;&amp; read.amended {
</span></span><span class="line"><span class="cl">			delete(m.dirty, key) // 直接从 dirty 中删除这个 key
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		m.mu.Unlock()
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	if ok {
</span></span><span class="line"><span class="cl">		e.delete() // 如果在 read 中找到了这个 key，将 p 置为 nil
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>第一种情况：可以看到，先从 read 里查是否有这个 key，如果有则执行 <code>e.delete</code> 方法，将 p 置为 nil，这样 read 和 dirty 都能看到这个变化，因为它们指向的是同一块内存地址。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221205/3c105d85e5c24fecb51e45bc3a184cfe.png" title="数据结构" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221205/3c105d85e5c24fecb51e45bc3a184cfe.png" data-sub-html="<h2>数据结构</h2><p>数据结构</p>">
        
    </a><figcaption class="image-caption">数据结构</figcaption>
    </figure></p>
<p>以下是<code>entry.delete</code>方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (e *entry) delete() (hadValue bool) {
</span></span><span class="line"><span class="cl">	for {
</span></span><span class="line"><span class="cl">		p := atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">		if p == nil || p == expunged {
</span></span><span class="line"><span class="cl">			return false
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) {
</span></span><span class="line"><span class="cl">			return true
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>它真正做的事情是将正常状态（指向一个 any）的 p 设置成 nil。没有设置成 expunged 的原因是，当 p 为 expunged 时，表示它已经不在 dirty 中了，这是 p 的状态决定的，在 <code>tryExpungeLocked</code> 函数中，会将 nil 原子地设置成 expunged。</p>
<p><code>tryExpungeLocked</code> 是在新创建 dirty 时调用的，会将已被删除的 <code>entry.p</code> 从 nil 改成 expunged，这个 entry 就不会写入 dirty 了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (e *entry) tryExpungeLocked() (isExpunged bool) {
</span></span><span class="line"><span class="cl">	p := atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">	for p == nil {
</span></span><span class="line"><span class="cl">		// 如果原来是 nil，说明原 key 已被删除，则将其转为 expunged。
</span></span><span class="line"><span class="cl">		if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) {
</span></span><span class="line"><span class="cl">			return true
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		p = atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	return p == expunged
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>第二种情况：如果没在 read 中找到这个 key，并且 dirty 不为空，那么就要操作 dirty 了，操作之前，还是要先上锁。然后进行 double check，如果仍然没有在 read 里找到此 key，则从 dirty 中删掉这个 key。</p>
<p>注意到如果 key 同时存在于 read 和 dirty 中时，删除只是做了一个标记，将 p 置为 nil；而如果仅在 dirty 中含有这个 key 时，会直接删除这个 key。原因在于，若两者都存在这个 key，仅做标记删除，可以在下次查找这个 key 时，命中 read，提升效率。若只有在 dirty 中存在时，read 起不到 “缓存” 的作用，直接删除。</p>
<h2 id="dirty和read互转分别在什么样的时机下进行" class="headerLink">
    <a href="#dirty%e5%92%8cread%e4%ba%92%e8%bd%ac%e5%88%86%e5%88%ab%e5%9c%a8%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84%e6%97%b6%e6%9c%ba%e4%b8%8b%e8%bf%9b%e8%a1%8c" class="header-mark"></a>dirty和read互转，分别在什么样的时机下进行</h2><ul>
<li>
<p><code>dirty-&gt;read</code>：随着 load 的 miss 不断自增，达到阈值（<code>m.misses &gt;= len(m.dirty)</code>）后触发升级转储。</p>
</li>
<li>
<p><code>read-&gt;dirty</code>：当有 read 中不存在的新 key 需要增加，且 read 和 dirty 一致的时候，触发重塑，且 <code>read.amended</code> 设置为 true，然后再在 dirty 中新增。重塑的过程，会将 nil 状态的 entry，全部转换为 expunged 状态中，同时将非 expunged 的 entry 浅拷贝到 dirty 中，这样可以避免 read 的 key 无限的膨胀（存在大量逻辑删除的 key）。最终，在 dirty 再次升级为 read 的时候，这些逻辑删除的 key 就可以一次性丢弃释放（因为是直接覆盖上去）。</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if !read.amended {
</span></span><span class="line"><span class="cl">   // We&#39;re adding the first new key to the dirty map.
</span></span><span class="line"><span class="cl">   // Make sure it is allocated and mark the read-only map as incomplete.
</span></span><span class="line"><span class="cl">   m.dirtyLocked()
</span></span><span class="line"><span class="cl">   m.read.Store(readOnly{m: read.m, amended: true})
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221025/e8837d7eda904db586f5e78b23a69ef2.png" title="read-&amp;gt;dirty" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221025/e8837d7eda904db586f5e78b23a69ef2.png" data-sub-html="<h2>read-&gt;dirty</h2><p>read-&amp;gt;dirty</p>">
        
    </a><figcaption class="image-caption">read->dirty</figcaption>
    </figure></p>
<h2 id="read从何而来存在的意义是什么" class="headerLink">
    <a href="#read%e4%bb%8e%e4%bd%95%e8%80%8c%e6%9d%a5%e5%ad%98%e5%9c%a8%e7%9a%84%e6%84%8f%e4%b9%89%e6%98%af%e4%bb%80%e4%b9%88" class="header-mark"></a>read从何而来，存在的意义是什么</h2><ul>
<li>
<p>read 是由 dirty 升级而来，是利用了 <code>atomic.Store</code> 一次性覆盖，而不是一点点的 set 操作出来的。所以，read 更像是一个快照，read 中 key 的集合不能被改变（注意，这里说的 read 的 key 不可改变，不代表指定的 key 的 value 不可改变，value 是可以通过原子 <code>CAS</code> 来进行更改的），所以其中的键的集合有时候可能是不全的。</p>
</li>
<li>
<p>脏字典中的键值对集合总是完全的，但是其中<strong>不会包含</strong> expunged 的键值对。</p>
</li>
<li>
<p>read 的存在价值，在于加速读性能（通过原子操作避免了锁）。</p>
</li>
</ul>
<h2 id="dirty什么时候是nil" class="headerLink">
    <a href="#dirty%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e6%98%afnil" class="header-mark"></a>dirty什么时候是nil</h2><p>dirty 数据提升为 read 时 <code>m.dirty</code> 会置为 nil。此时，<code>m.read</code> 和 <code>m.dirty</code> 相等，<code>m.amended</code> 为 false，也就是说，read 中找不到的数据，dirty 中同样找不到。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">amended bool // true if the dirty map contains some key not in m.
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Map) missLocked() {
</span></span><span class="line"><span class="cl">	m.misses++
</span></span><span class="line"><span class="cl">	if m.misses &lt; len(m.dirty) {
</span></span><span class="line"><span class="cl">		return
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	m.read.Store(readOnly{m: m.dirty})
</span></span><span class="line"><span class="cl">	m.dirty = nil
</span></span><span class="line"><span class="cl">	m.misses = 0
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="删除时-ep-设置成了-nil-还是-expunged" class="headerLink">
    <a href="#%e5%88%a0%e9%99%a4%e6%97%b6-ep-%e8%ae%be%e7%bd%ae%e6%88%90%e4%ba%86-nil-%e8%bf%98%e6%98%af-expunged" class="header-mark"></a>删除时 e.p 设置成了 nil 还是 expunged</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Map) Delete(key any) {
</span></span><span class="line"><span class="cl">	m.LoadAndDelete(key)
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func (m *Map) LoadAndDelete(key any) (value any, loaded bool) {
</span></span><span class="line"><span class="cl">	read, _ := m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl">	e, ok := read.m[key]
</span></span><span class="line"><span class="cl">	// 如果 read 中不存在这个 key 并且 dirty map 中存在这个 key
</span></span><span class="line"><span class="cl">	if !ok &amp;&amp; read.amended {
</span></span><span class="line"><span class="cl">		m.mu.Lock()
</span></span><span class="line"><span class="cl">		read, _ = m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl">		e, ok = read.m[key]
</span></span><span class="line"><span class="cl">		if !ok &amp;&amp; read.amended {
</span></span><span class="line"><span class="cl">			e, ok = m.dirty[key]
</span></span><span class="line"><span class="cl">			delete(m.dirty, key) // 直接删除 dirty 中的 key，不管 dirty 中存不存在
</span></span><span class="line"><span class="cl">			// Regardless of whether the entry was present, record a miss: this key
</span></span><span class="line"><span class="cl">			// will take the slow path until the dirty map is promoted to the read
</span></span><span class="line"><span class="cl">			// map.
</span></span><span class="line"><span class="cl">			m.missLocked()
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		m.mu.Unlock()
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// read 中存在或是 dirty 中存在都会走到这里,执行 e.delete()
</span></span><span class="line"><span class="cl">	if ok {
</span></span><span class="line"><span class="cl">		return e.delete()
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	return nil, false
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func (e *entry) delete() (value any, ok bool) {
</span></span><span class="line"><span class="cl">	for {
</span></span><span class="line"><span class="cl">		p := atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">		if p == nil || p == expunged {
</span></span><span class="line"><span class="cl">			return nil, false
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		// 把 entry 中的 p 转成 nil，表示已经删除
</span></span><span class="line"><span class="cl">		if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) {
</span></span><span class="line"><span class="cl">			// *(*any)(p) 的作用是将指针 p 指向的数据转换为 any 类型，并且解引用该指针，以便访问 any 类型的值。
</span></span><span class="line"><span class="cl">			return *(*any)(p), true
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>由源码可知，不管 key 是在 read 中还是 dirty 中，最后都调用了 <code>e.delete()</code> 方法，将 e.p 设置为 nil。</p>
<h2 id="什么时候-ep-由-nil-变成-expunged" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99-ep-%e7%94%b1-nil-%e5%8f%98%e6%88%90-expunged" class="header-mark"></a>什么时候 e.p 由 nil 变成 expunged</h2><ul>
<li><code>read-&gt;dirty</code> 重塑的时候，此时 read 中仍然是 nil 的会变成 expunged，表示这部分 key 等待被最终丢弃（expunged 是最终态，等待被丢弃，除非又出现了重新 Store 的情况）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 判断 e.p 是不是 expunged, 如果是 e.p 是 nil 则转为 expunged
</span></span><span class="line"><span class="cl">func (e *entry) tryExpungeLocked() (isExpunged bool) {
</span></span><span class="line"><span class="cl">	p := atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">	for p == nil {
</span></span><span class="line"><span class="cl">		// 将 e.p 的 nil 转成 expunged
</span></span><span class="line"><span class="cl">		if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) {
</span></span><span class="line"><span class="cl">			return true
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		p = atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	return p == expunged
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>最终丢弃的时机就是 <code>dirty-&gt;read</code> 升级的时候，dirty 的直接粗暴覆盖，会使得 read 中的所有成员都被丢弃，包括 expunged。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Map) missLocked() {
</span></span><span class="line"><span class="cl">	m.misses++ // 不管在 dirty 中没有读到，miss 都执行 ++ 操作
</span></span><span class="line"><span class="cl">	if m.misses &lt; len(m.dirty) {
</span></span><span class="line"><span class="cl">		return
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// 如果 miss 的值 &gt;= len(dirty)，将 dirty 赋给 read, dirty 和 miss 重新初始化
</span></span><span class="line"><span class="cl">	// 此时 dirty 就为空了，说明从 dirty 全部过渡到了 read, 此时 read 是全量的
</span></span><span class="line"><span class="cl">	m.read.Store(readOnly{m: m.dirty})
</span></span><span class="line"><span class="cl">	m.dirty = nil
</span></span><span class="line"><span class="cl">	m.misses = 0
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="既然-nil-表示标记删除expunged-的意义是什么" class="headerLink">
    <a href="#%e6%97%a2%e7%84%b6-nil-%e8%a1%a8%e7%a4%ba%e6%a0%87%e8%ae%b0%e5%88%a0%e9%99%a4expunged-%e7%9a%84%e6%84%8f%e4%b9%89%e6%98%af%e4%bb%80%e4%b9%88" class="header-mark"></a>既然 nil 表示标记删除，expunged 的意义是什么</h2><p><code>expunged</code> 的意义是在删除操作后，键对应值被标记为 <code>expunged</code>，而不是简单地设置为 <code>nil</code>。这样做的好处是，<code>nil</code> 值可能是键本身的有效值，因此无法区分键已被删除和键对应的值为 <code>nil</code> 两种情况。通过使用 <code>expunged</code> 标记，<code>sync.Map</code> 可以清楚地区分键被删除和键对应的值为 <code>nil</code>。</p>
<p>具体来说，当执行删除操作时，<code>sync.Map</code> 将键对应的值设置为一个特殊的占位符 <code>expunged</code>，表示该键已被删除。在后续的操作中，通过检查值是否等于 <code>expunged</code>，可以判断键是否存在。</p>
<p>这种设计有以下好处：</p>
<ol>
<li>
<p>避免了 <code>nil</code> 值可能带来的歧义：<code>nil</code> 值可能是键的有效值，因此不能简单地依靠 <code>nil</code> 值来判断键是否存在或已被删除。</p>
</li>
<li>
<p>提高了删除操作的效率：直接将值标记为 <code>expunged</code>，而不是删除键值对，可以避免重新分配内存或进行其他复杂的操作，从而提高了删除操作的效率。</p>
</li>
<li>
<p>保持了并发安全性：通过将键的对应值设置为 <code>expunged</code>，<code>sync.Map</code> 在并发环境中仍然能够保持正确的状态和操作一致性。</p>
</li>
</ol>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://cloud.tencent.com/developer/article/2022098" target="_blank" rel="noopener noreferrer">不得不知道的Golang之sync.Map解读！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;mid=2247489164&amp;idx=1&amp;sn=e56e5c9836cda40f3c95a39e2ba57dde" target="_blank" rel="noopener noreferrer">一口气搞懂 Go sync.map 所有知识点</a></li>
<li><a href="https://colobu.com/2017/07/11/dive-into-sync-Map/" target="_blank" rel="noopener noreferrer">Go 1.9 sync.Map揭秘</a></li>
<li><a href="https://qcrao.com/post/dive-into-go-sync-map/" target="_blank" rel="noopener noreferrer">深度解密 Go 语言之 sync.map</a></li>
</ul>
]]></description>
</item><item>
    <title>高并发分布式架构演进</title>
    <link>https://www.xiaobinqt.cn/highly-concurrent-architecture-evolution/</link>
    <pubDate>Mon, 29 Aug 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/highly-concurrent-architecture-evolution/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/89de4f7569e845ad91eab0a8857d5afb.png" referrerpolicy="no-referrer">
            </div><!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<blockquote>
<p>原文链接：<a href="https://segmentfault.com/a/1190000018626163" target="_blank" rel="noopener noreferrer">https://segmentfault.com/a/1190000018626163</a></p>
</blockquote>
<h2 id="0-目录和说明" class="headerLink">
    <a href="#0-%e7%9b%ae%e5%bd%95%e5%92%8c%e8%af%b4%e6%98%8e" class="header-mark"></a>0. 目录和说明</h2><p>文章在介绍一些基本概念后，按照以下过程阐述了整个架构的演进过程：</p>
<ul>
<li>
<p>单机架构</p>
</li>
<li>
<p>第一次演进：Tomcat 与数据库分开部署</p>
</li>
<li>
<p>第二次演进：引入本地缓存和分布式缓存</p>
</li>
<li>
<p>第三次演进：引入反向代理实现负载均衡</p>
</li>
<li>
<p>第四次演进：数据库读写分离</p>
</li>
<li>
<p>第五次演进：数据库按业务分库</p>
</li>
<li>
<p>第六次演进：把大表拆分为小表</p>
</li>
<li>
<p>第七次演进：使用 LVS 或 F5 来使多个 Nginx 负载均衡</p>
</li>
<li>
<p>第八次演进：通过 DNS 轮询实现机房间的负载均衡</p>
</li>
<li>
<p>第九次演进：引入 NoSQL 数据库和搜索引擎等技术</p>
</li>
<li>
<p>第十次演进：大应用拆分为小应用</p>
</li>
<li>
<p>第十一次演进：复用的功能抽离成微服务</p>
</li>
<li>
<p>第十二次演进：引入企业服务总线 ESB 屏蔽服务接口的访问差异</p>
</li>
<li>
<p>第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理</p>
</li>
<li>
<p>第十四次演进：以云平台承载系统</p>
</li>
</ul>
<h2 id="1-概述" class="headerLink">
    <a href="#1-%e6%a6%82%e8%bf%b0" class="header-mark"></a>1. 概述</h2><p>本文以淘宝作为例子，介绍从一百个到千万级并发情况下服务端的架构的演进过程，同时列举出每个演进阶段会遇到的相关技术，让大家对架构的演进有一个整体的认知，文章最后汇总了一些架构设计的原则。</p>
<blockquote>
<p>特别说明：本文以淘宝为例仅仅是为了便于说明演进过程可能遇到的问题，并非是淘宝真正的技术演进路径</p>
</blockquote>
<h2 id="2-基本概念" class="headerLink">
    <a href="#2-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" class="header-mark"></a>2. 基本概念</h2><p>在介绍架构之前，为了避免部分读者对架构设计中的一些概念不了解，下面对几个最基础的概念进行介绍。</p>
<ul>
<li><strong>分布式</strong></li>
</ul>
<p>系统中的多个模块在不同服务器上部署，即可称为分布式系统，如 Tomcat 和数据库分别部署在不同的服务器上，或两个相同功能的 Tomcat 分别部署在不同服务器上</p>
<ul>
<li><strong>高可用</strong></li>
</ul>
<p>系统中部分节点失效时，其他节点能够接替它继续提供服务，则可认为系统具有高可用性</p>
<ul>
<li><strong>集群</strong></li>
</ul>
<p>一个特定领域的软件部署在多台服务器上并<strong>作为一个整体</strong>提供一类服务，这个整体称为集群。如 Zookeeper 中的 Master 和 Slave 分别部署在多台服务器上，共同组成一个整体提供集中配置服务。在常见的集群中，客户端往往能够连接任意一个节点获得服务，并且当集群中一个节点掉线时，其他节点往往能够自动的接替它继续提供服务，这时候说明集群具有高可用性</p>
<ul>
<li><strong>负载均衡</strong></li>
</ul>
<p>请求发送到系统时，通过某些方式把请求均匀分发到多个节点上，使系统中每个节点能够均匀的处理请求负载，则可认为系统是负载均衡的</p>
<ul>
<li><strong>正向代理和反向代理</strong></li>
</ul>
<p>系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去，在外部网络看来就是代理服务器发起的访问，此时代理服务器实现的是正向代理；当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上，对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。简单来说，<strong>正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程</strong>。</p>
<h2 id="3-架构演进" class="headerLink">
    <a href="#3-%e6%9e%b6%e6%9e%84%e6%bc%94%e8%bf%9b" class="header-mark"></a>3. 架构演进</h2><h3 id="31-单机架构" class="headerLink">
    <a href="#31-%e5%8d%95%e6%9c%ba%e6%9e%b6%e6%9e%84" class="header-mark"></a>3.1 单机架构</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/1f117811d1f646bbbb030f52013818ab.png" title="单机架构" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/1f117811d1f646bbbb030f52013818ab.png" data-sub-html="<h2>单机架构</h2><p>单机架构</p>">
        
    </a><figcaption class="image-caption">单机架构</figcaption>
    </figure></p>
<p>以淘宝作为例子。在网站最初时，应用数量与用户数都较少，可以把 Tomcat 和数据库部署在同一台服务器上。浏览器往 <code>www.taobao.com</code> 发起请求时，首先经过 DNS 服务器（域名系统）把域名转换为实际 IP 地址
<code>10.102.4.1</code>，浏览器转而访问该 IP 对应的 Tomcat。</p>
<blockquote>
<p>随着用户数的增长，Tomcat 和数据库之间竞争资源，单机性能不足以支撑业务</p>
</blockquote>
<h3 id="32-第一次演进tomcat-与数据库分开部署" class="headerLink">
    <a href="#32-%e7%ac%ac%e4%b8%80%e6%ac%a1%e6%bc%94%e8%bf%9btomcat-%e4%b8%8e%e6%95%b0%e6%8d%ae%e5%ba%93%e5%88%86%e5%bc%80%e9%83%a8%e7%bd%b2" class="header-mark"></a>3.2 第一次演进：Tomcat 与数据库分开部署</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/51b57795a18a487daae0807e4e005d73.png" title="第一次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/51b57795a18a487daae0807e4e005d73.png" data-sub-html="<h2>第一次演进</h2><p>第一次演进</p>">
        
    </a><figcaption class="image-caption">第一次演进</figcaption>
    </figure></p>
<p>Tomcat 和数据库分别独占服务器资源，显著提高两者各自性能。</p>
<blockquote>
<p>随着用户数的增长，并发读写数据库成为瓶颈</p>
</blockquote>
<h3 id="33-第二次演进引入本地缓存和分布式缓存" class="headerLink">
    <a href="#33-%e7%ac%ac%e4%ba%8c%e6%ac%a1%e6%bc%94%e8%bf%9b%e5%bc%95%e5%85%a5%e6%9c%ac%e5%9c%b0%e7%bc%93%e5%ad%98%e5%92%8c%e5%88%86%e5%b8%83%e5%bc%8f%e7%bc%93%e5%ad%98" class="header-mark"></a>3.3 第二次演进：引入本地缓存和分布式缓存</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/08062e488e3a42c3952d2e083e117f28.png" title="第二次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/08062e488e3a42c3952d2e083e117f28.png" data-sub-html="<h2>第二次演进</h2><p>第二次演进</p>">
        
    </a><figcaption class="image-caption">第二次演进</figcaption>
    </figure></p>
<p>在 Tomcat 同服务器上或同 JVM 中增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的 html 页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力。其中涉及的技术包括：使用 memcached 作为本地缓存，使用 Redis 作为分布式缓存，还会涉及缓存一致性、缓存穿透/击穿、缓存雪崩、热点数据集中失效等问题。</p>
<blockquote>
<p>缓存抗住了大部分的访问请求，随着用户数的增长，并发压力主要落在单机的 Tomcat 上，响应逐渐变慢</p>
</blockquote>
<h3 id="34-第三次演进引入反向代理实现负载均衡" class="headerLink">
    <a href="#34-%e7%ac%ac%e4%b8%89%e6%ac%a1%e6%bc%94%e8%bf%9b%e5%bc%95%e5%85%a5%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86%e5%ae%9e%e7%8e%b0%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" class="header-mark"></a>3.4 第三次演进：引入反向代理实现负载均衡</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/447531a9c371496e9263e32a312b192c.png" title="第三次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/447531a9c371496e9263e32a312b192c.png" data-sub-html="<h2>第三次演进</h2><p>第三次演进</p>">
        
    </a><figcaption class="image-caption">第三次演进</figcaption>
    </figure></p>
<p>在多台服务器上分别部署 Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个 Tomcat 中。此处假设 Tomcat 最多支持 100 个并发，Nginx 最多支持 50000 个并发，那么理论上 Nginx 把请求分发到 500 个 Tomcat 上，就能抗住 50000 个并发。其中涉及的技术包括：Nginx、HAProxy，两者都是工作在网络第七层的反向代理软件，主要支持 http 协议，还会涉及 session 共享、文件上传下载的问题。</p>
<blockquote>
<p>反向代理使应用服务器可支持的并发量大大增加，但并发量的增长也意味着更多请求穿透到数据库，单机的数据库最终成为瓶颈</p>
</blockquote>
<h3 id="35-第四次演进数据库读写分离" class="headerLink">
    <a href="#35-%e7%ac%ac%e5%9b%9b%e6%ac%a1%e6%bc%94%e8%bf%9b%e6%95%b0%e6%8d%ae%e5%ba%93%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb" class="header-mark"></a>3.5 第四次演进：数据库读写分离</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/53d08f904fa54100bb891bacf5d55eec.png" title="第四次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/53d08f904fa54100bb891bacf5d55eec.png" data-sub-html="<h2>第四次演进</h2><p>第四次演进</p>">
        
    </a><figcaption class="image-caption">第四次演进</figcaption>
    </figure></p>
<p>把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据。其中涉及的技术包括：Mycat，它是数据库中间件，可通过它来组织数据库的分离读写和分库分表，客户端通过它来访问下层数据库，还会涉及数据同步，数据一致性的问题。</p>
<blockquote>
<p>业务逐渐变多，不同业务之间的访问量差距较大，不同业务直接竞争数据库，相互影响性能</p>
</blockquote>
<h3 id="36-第五次演进数据库按业务分库" class="headerLink">
    <a href="#36-%e7%ac%ac%e4%ba%94%e6%ac%a1%e6%bc%94%e8%bf%9b%e6%95%b0%e6%8d%ae%e5%ba%93%e6%8c%89%e4%b8%9a%e5%8a%a1%e5%88%86%e5%ba%93" class="header-mark"></a>3.6 第五次演进：数据库按业务分库</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/effe7db154244811af27331d0b1a4d8c.png" title="第五次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/effe7db154244811af27331d0b1a4d8c.png" data-sub-html="<h2>第五次演进</h2><p>第五次演进</p>">
        
    </a><figcaption class="image-caption">第五次演进</figcaption>
    </figure></p>
<p>把不同业务的数据保存到不同的数据库中，使业务之间的资源竞争降低，对于访问量大的业务，可以部署更多的服务器来支撑。这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决，但这不是本文讨论的重点，有兴趣的可以自行搜索解决方案。</p>
<blockquote>
<p>随着用户数的增长，单机的写库会逐渐会达到性能瓶颈</p>
</blockquote>
<h3 id="37-第六次演进把大表拆分为小表" class="headerLink">
    <a href="#37-%e7%ac%ac%e5%85%ad%e6%ac%a1%e6%bc%94%e8%bf%9b%e6%8a%8a%e5%a4%a7%e8%a1%a8%e6%8b%86%e5%88%86%e4%b8%ba%e5%b0%8f%e8%a1%a8" class="header-mark"></a>3.7 第六次演进：把大表拆分为小表</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/2fad6020cd9b4b97baebc993157067dc.png" title="第六次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/2fad6020cd9b4b97baebc993157067dc.png" data-sub-html="<h2>第六次演进</h2><p>第六次演进</p>">
        
    </a><figcaption class="image-caption">第六次演进</figcaption>
    </figure></p>
<p>比如针对评论数据，可按照商品 ID 进行 hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户 ID 或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀的分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能。其中前面提到的 Mycat 也支持在大表拆分为小表情况下的访问控制。</p>
<p>这种做法显著的增加了数据库运维的难度，对 DBA 的要求较高。数据库设计到这种结构时，已经可以称为分布式数据库，但是这只是一个逻辑的数据库整体，数据库里不同的组成部分是由不同的组件单独来实现的，如分库分表的管理和请求分发，由 Mycat 实现，SQL 的解析由单机的数据库实现，读写分离可能由网关和消息队列来实现，查询结果的汇总可能由数据库接口层来实现等等，这种架构其实是 <strong><ruby>MPP<rt>Massively Parallel Processing</rt></ruby></strong>
（大规模并行处理）架构的一类实现。</p>
<p>目前开源和商用都已经有不少 MPP 数据库，开源中比较流行的有 Greenplum、TiDB、Postgresql XC、HAWQ 等，商用的如南大通用的 GBase、睿帆科技的雪球 DB、华为的 LibrA 等等，不同的 MPP 数据库的侧重点也不一样，如 TiDB 更侧重于分布式 OLTP 场景，Greenplum 更侧重于分布式 OLAP 场景，这些 MPP 数据库基本都提供了类似 Postgresql、Oracle、MySQL 那样的 SQL 标准支持能力，能把一个查询解析为分布式的执行计划分发到每台机器上并行执行，最终由数据库本身汇总数据进行返回，也提供了诸如权限管理、分库分表、事务、数据副本等能力，并且大多能够支持 100 个节点以上的集群，大大降低了数据库运维的成本，并且使数据库也能够实现水平扩展。</p>
<blockquote>
<p>数据库和 Tomcat 都能够水平扩展，可支撑的并发大幅提高，随着用户数的增长，最终单机的 Nginx 会成为瓶颈</p>
</blockquote>
<h3 id="38-第七次演进使用-lvs-或-f5-来使多个-nginx-负载均衡" class="headerLink">
    <a href="#38-%e7%ac%ac%e4%b8%83%e6%ac%a1%e6%bc%94%e8%bf%9b%e4%bd%bf%e7%94%a8-lvs-%e6%88%96-f5-%e6%9d%a5%e4%bd%bf%e5%a4%9a%e4%b8%aa-nginx-%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" class="header-mark"></a>3.8 第七次演进：使用 LVS 或 F5 来使多个 Nginx 负载均衡</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/1b37027ad49a4aaeb4485885ad9a696a.png" title="第七次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/1b37027ad49a4aaeb4485885ad9a696a.png" data-sub-html="<h2>第七次演进</h2><p>第七次演进</p>">
        
    </a><figcaption class="image-caption">第七次演进</figcaption>
    </figure></p>
<p>由于瓶颈在 Nginx，因此无法通过两层的 Nginx 来实现多个 Nginx 的负载均衡。图中的 <strong><ruby>LVS<rt>Linux Virtual Server</rt></ruby></strong> 和 F5 是工作在网络第四层的负载均衡解决方案，其中 LVS 是软件，运行在操作系统内核态，可对 TCP 请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于 Nginx，可假设单机的 LVS 可支持几十万个并发的请求转发；F5 是一种负载均衡硬件，与 LVS 提供的能力类似，性能比 LVS 更高，但价格昂贵。</p>
<p>由于 LVS 是单机版的软件，若 LVS 所在服务器宕机则会导致整个后端系统都无法访问，因此需要有备用节点。可使用 keepalived 软件模拟出虚拟 IP，然后把虚拟 IP 绑定到多台 LVS 服务器上，浏览器访问虚拟 IP 时，会被路由器重定向到真实的 LVS 服务器，当主 LVS 服务器宕机时，keepalived 软件会自动更新路由器中的路由表，把虚拟 IP 重定向到另外一台正常的 LVS 服务器，从而达到 LVS 服务器高可用的效果。</p>
<p>此处需要注意的是，上图中从 Nginx 层到 Tomcat 层这样画并不代表全部 Nginx 都转发请求到全部的 Tomcat，在实际使用时，可能会是几个 Nginx 下面接一部分的 Tomcat，这些 Nginx 之间通过 keepalived 实现高可用，其他的 Nginx 接另外的 Tomcat，这样可接入的 Tomcat 数量就能成倍的增加。</p>
<blockquote>
<p>由于 LVS 也是单机的，随着并发数增长到几十万时，LVS 服务器最终会达到瓶颈，此时用户数达到千万甚至上亿级别，用户分布在不同的地区，与服务器机房距离不同，导致了访问的延迟会明显不同</p>
</blockquote>
<h3 id="39-第八次演进通过-dns-轮询实现机房间的负载均衡" class="headerLink">
    <a href="#39-%e7%ac%ac%e5%85%ab%e6%ac%a1%e6%bc%94%e8%bf%9b%e9%80%9a%e8%bf%87-dns-%e8%bd%ae%e8%af%a2%e5%ae%9e%e7%8e%b0%e6%9c%ba%e6%88%bf%e9%97%b4%e7%9a%84%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" class="header-mark"></a>3.9 第八次演进：通过 DNS 轮询实现机房间的负载均衡</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/460349470a99405eb838823aa29cbe27.png" title="第八次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/460349470a99405eb838823aa29cbe27.png" data-sub-html="<h2>第八次演进</h2><p>第八次演进</p>">
        
    </a><figcaption class="image-caption">第八次演进</figcaption>
    </figure></p>
<p>在 DNS 服务器中可配置一个域名对应多个 IP 地址，每个 IP 地址对应到不同的机房里的虚拟 IP。当用户访问 <code>www.taobao.com</code> 时，DNS 服务器会使用轮询策略或其他策略，来选择某个 IP 供用户访问。此方式能实现机房间的负载均衡，至此，系统可做到机房级别的水平扩展，千万级到亿级的并发量都可通过增加机房来解决，系统入口处的请求并发量不再是问题。</p>
<blockquote>
<p>随着数据的丰富程度和业务的发展，检索、分析等需求越来越丰富，单单依靠数据库无法解决如此丰富的需求</p>
</blockquote>
<h3 id="310-第九次演进引入-nosql-数据库和搜索引擎等技术" class="headerLink">
    <a href="#310-%e7%ac%ac%e4%b9%9d%e6%ac%a1%e6%bc%94%e8%bf%9b%e5%bc%95%e5%85%a5-nosql-%e6%95%b0%e6%8d%ae%e5%ba%93%e5%92%8c%e6%90%9c%e7%b4%a2%e5%bc%95%e6%93%8e%e7%ad%89%e6%8a%80%e6%9c%af" class="header-mark"></a>3.10 第九次演进：引入 NoSQL 数据库和搜索引擎等技术</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/4431084b90e14e95bad5a0beb93e9196.png" title="第九次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/4431084b90e14e95bad5a0beb93e9196.png" data-sub-html="<h2>第九次演进</h2><p>第九次演进</p>">
        
    </a><figcaption class="image-caption">第九次演进</figcaption>
    </figure></p>
<p>当数据库中的数据多到一定规模时，数据库就不适用于复杂的查询了，往往只能满足普通查询的场景。对于统计报表场景，在数据量大时不一定能跑出结果，而且在跑复杂查询时会导致其他查询变慢，对于全文检索、可变数据结构等场景，数据库天生不适用。因此需要针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统 HDFS 解决，对于 key value 类型的数据，可通过 HBase 和 Redis 等方案解决，对于全文检索场景，可通过搜索引擎如 ElasticSearch 解决，对于多维分析场景，可通过 Kylin 或 Druid 等方案解决。</p>
<p>当然，引入更多组件同时会提高系统的复杂度，不同的组件保存的数据需要同步，需要考虑一致性的问题，需要有更多的运维手段来管理这些组件等。</p>
<blockquote>
<p>引入更多组件解决了丰富的需求，业务维度能够极大扩充，随之而来的是一个应用中包含了太多的业务代码，业务的升级迭代变得困难</p>
</blockquote>
<h3 id="311-第十次演进大应用拆分为小应用" class="headerLink">
    <a href="#311-%e7%ac%ac%e5%8d%81%e6%ac%a1%e6%bc%94%e8%bf%9b%e5%a4%a7%e5%ba%94%e7%94%a8%e6%8b%86%e5%88%86%e4%b8%ba%e5%b0%8f%e5%ba%94%e7%94%a8" class="header-mark"></a>3.11 第十次演进：大应用拆分为小应用</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/8cb5f4af10c54384bcda7ac1a19bdaba.png" title="第十次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/8cb5f4af10c54384bcda7ac1a19bdaba.png" data-sub-html="<h2>第十次演进</h2><p>第十次演进</p>">
        
    </a><figcaption class="image-caption">第十次演进</figcaption>
    </figure></p>
<p>按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心 Zookeeper 来解决。</p>
<blockquote>
<p>不同应用之间存在共用的模块，由应用单独管理会导致相同代码存在多份，导致公共功能升级时全部应用代码都要跟着升级</p>
</blockquote>
<h3 id="312-第十一次演进复用的功能抽离成微服务" class="headerLink">
    <a href="#312-%e7%ac%ac%e5%8d%81%e4%b8%80%e6%ac%a1%e6%bc%94%e8%bf%9b%e5%a4%8d%e7%94%a8%e7%9a%84%e5%8a%9f%e8%83%bd%e6%8a%bd%e7%a6%bb%e6%88%90%e5%be%ae%e6%9c%8d%e5%8a%a1" class="header-mark"></a>3.12 第十一次演进：复用的功能抽离成微服务</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/542da2f0e6704dd2bc537098708aedcc.png" title="第十一次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/542da2f0e6704dd2bc537098708aedcc.png" data-sub-html="<h2>第十一次演进</h2><p>第十一次演进</p>">
        
    </a><figcaption class="image-caption">第十一次演进</figcaption>
    </figure></p>
<p>如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过 HTTP、TCP 或 RPC 请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理。此外，可以通过 Dubbo、SpringCloud 等框架实现服务治理、限流、熔断、降级等功能，提高服务的稳定性和可用性。</p>
<blockquote>
<p>不同服务的接口访问方式不同，应用代码需要适配多种访问方式才能使用服务，此外，应用访问服务，服务之间也可能相互访问，调用链将会变得非常复杂，逻辑变得混乱</p>
</blockquote>
<h3 id="313-第十二次演进引入企业服务总线-esb-屏蔽服务接口的访问差异" class="headerLink">
    <a href="#313-%e7%ac%ac%e5%8d%81%e4%ba%8c%e6%ac%a1%e6%bc%94%e8%bf%9b%e5%bc%95%e5%85%a5%e4%bc%81%e4%b8%9a%e6%9c%8d%e5%8a%a1%e6%80%bb%e7%ba%bf-esb-%e5%b1%8f%e8%94%bd%e6%9c%8d%e5%8a%a1%e6%8e%a5%e5%8f%a3%e7%9a%84%e8%ae%bf%e9%97%ae%e5%b7%ae%e5%bc%82" class="header-mark"></a>3.13 第十二次演进：引入企业服务总线 ESB 屏蔽服务接口的访问差异</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/a2f54a652b6141f88fc441a97e8dea97.png" title="第十二次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/a2f54a652b6141f88fc441a97e8dea97.png" data-sub-html="<h2>第十二次演进</h2><p>第十二次演进</p>">
        
    </a><figcaption class="image-caption">第十二次演进</figcaption>
    </figure></p>
<p>通过 ESB 统一进行访问协议转换，应用统一通过 ESB 来访问后端服务，服务与服务之间也通过 ESB 来相互调用，以此降低系统的耦合程度。这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的
<strong><ruby>SOA<rt>Service-Oriented Architecture</rt></ruby></strong>（面向服务）架构，这种架构与微服务架构容易混淆，因为表现形式十分相似。</p>
<p>个人理解，微服务架构更多是指把系统里的公共服务抽取出来单独运维管理的思想，而 SOA 架构则是指一种拆分服务并使服务接口访问变得统一的架构思想，SOA 架构中包含了微服务的思想。</p>
<blockquote>
<p>业务不断发展，应用和服务都会不断变多，应用和服务的部署变得复杂，同一台服务器上部署多个服务还要解决运行环境冲突的问题，
此外，对于如大促这类需要动态扩缩容的场景，需要水平扩展服务的性能，就需要在新增的服务上准备运行环境，部署服务等，运维将变得十分困难</p>
</blockquote>
<h3 id="314-第十三次演进引入容器化技术实现运行环境隔离与动态服务管理" class="headerLink">
    <a href="#314-%e7%ac%ac%e5%8d%81%e4%b8%89%e6%ac%a1%e6%bc%94%e8%bf%9b%e5%bc%95%e5%85%a5%e5%ae%b9%e5%99%a8%e5%8c%96%e6%8a%80%e6%9c%af%e5%ae%9e%e7%8e%b0%e8%bf%90%e8%a1%8c%e7%8e%af%e5%a2%83%e9%9a%94%e7%a6%bb%e4%b8%8e%e5%8a%a8%e6%80%81%e6%9c%8d%e5%8a%a1%e7%ae%a1%e7%90%86" class="header-mark"></a>3.14 第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/ebae2b361aaa4d00a266279ffb59f28e.png" title="第十三次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/ebae2b361aaa4d00a266279ffb59f28e.png" data-sub-html="<h2>第十三次演进</h2><p>第十三次演进</p>">
        
    </a><figcaption class="image-caption">第十三次演进</figcaption>
    </figure></p>
<p>目前最流行的容器化技术是 Docker，最流行的容器管理服务是 Kubernetes(K8S)，应用/服务可以打包为 Docker 镜像，通过 K8S 来动态分发和部署镜像。Docker 镜像可理解为一个能运行你的应用/服务的最小的操作系统，里面放着应用/服务的运行代码，运行环境根据实际的需要设置好。把整个“操作系统”打包为一个镜像后，就可以分发到需要部署相关服务的机器上，直接启动 Docker 镜像就可以把服务起起来，使服务的部署和运维变得简单。</p>
<p>在大促的之前，可以在现有的机器集群上划分出服务器来启动 Docker 镜像，增强服务的性能，大促过后就可以关闭镜像，对机器上的其他服务不造成影响（在 3.14 节之前，服务运行在新增机器上需要修改系统配置来适配服务，这会导致机器上其他服务需要的运行环境被破坏）。</p>
<blockquote>
<p>使用容器化技术后服务动态扩缩容问题得以解决，但是机器还是需要公司自身来管理，在非大促的时候，还是需要闲置着大量的机器资源来应对大促，机器自身成本和运维成本都极高，资源利用率低</p>
</blockquote>
<h3 id="315-第十四次演进以云平台承载系统" class="headerLink">
    <a href="#315-%e7%ac%ac%e5%8d%81%e5%9b%9b%e6%ac%a1%e6%bc%94%e8%bf%9b%e4%bb%a5%e4%ba%91%e5%b9%b3%e5%8f%b0%e6%89%bf%e8%bd%bd%e7%b3%bb%e7%bb%9f" class="header-mark"></a>3.15 第十四次演进：以云平台承载系统</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/9c8cba63d6594fa19726b0b0c97fe17d.png" title="第十四次演进" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220830/9c8cba63d6594fa19726b0b0c97fe17d.png" data-sub-html="<h2>第十四次演进</h2><p>第十四次演进</p>">
        
    </a><figcaption class="image-caption">第十四次演进</figcaption>
    </figure></p>
<p>系统可部署到公有云上，利用公有云的海量机器资源，解决动态硬件资源的问题，在大促的时间段里，在云平台中临时申请更多的资源，结合 Docker 和 K8S 来快速部署服务，在大促结束后释放资源，真正做到按需付费，资源利用率大大提高，同时大大降低了运维成本。</p>
<p>所谓的云平台，就是把海量机器资源，通过统一的资源管理，抽象为一个资源整体，在之上可按需动态申请硬件资源（如 CPU、内存、网络等），并且之上提供通用的操作系统，提供常用的技术组件（如 Hadoop 技术栈，MPP 数据库等）供用户使用，甚至提供开发好的应用，用户不需要关系应用内部使用了什么技术，就能够解决需求（如音视频转码服务、邮件服务、个人博客等）。在云平台中会涉及如下几个概念：</p>
<ul>
<li>
<p><strong>IaaS</strong>基础设施即服务。对应于上面所说的机器资源统一为资源整体，可动态申请硬件资源的层面；</p>
</li>
<li>
<p><strong>PaaS</strong>平台即服务。对应于上面所说的提供常用的技术组件方便系统的开发和维护；</p>
</li>
<li>
<p><strong>SaaS</strong>软件即服务。对应于上面所说的提供开发好的应用或服务，按功能或性能要求付费。</p>
</li>
</ul>
<blockquote>
<p>至此，以上所提到的从高并发访问问题，到服务的架构和系统实施的层面都有了各自的解决方案，但同时也应该意识到，在上面的介绍中，其实是有意忽略了诸如跨机房数据同步、分布式事务实现等等的实际问题，这些问题以后有机会再拿出来单独讨论</p>
</blockquote>
<h2 id="4-架构设计总结" class="headerLink">
    <a href="#4-%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1%e6%80%bb%e7%bb%93" class="header-mark"></a>4. 架构设计总结</h2><ul>
<li><strong>架构的调整是否必须按照上述演变路径进行？</strong></li>
</ul>
<p>不是的，以上所说的架构演变顺序只是针对某个侧面进行单独的改进，在实际场景中，可能同一时间会有几个问题需要解决，或者可能先达到瓶颈的是另外的方面，这时候就应该按照实际问题实际解决。如在政府类的并发量可能不大，但业务可能很丰富的场景，高并发就不是重点解决的问题，此时优先需要的可能会是丰富需求的解决方案。</p>
<ul>
<li><strong>对于将要实施的系统，架构应该设计到什么程度？</strong></li>
</ul>
<p>对于单次实施并且性能指标明确的系统，架构设计到能够支持系统的性能指标要求就足够了，但要留有扩展架构的接口以便不备之需。对于不断发展的系统，如电商平台，应设计到能满足下一阶段用户量和性能指标要求的程度，并根据业务的增长不断的迭代升级架构，以支持更高的并发和更丰富的业务。</p>
<ul>
<li><strong>服务端架构和大数据架构有什么区别</strong>?</li>
</ul>
<p>所谓的“大数据”其实是海量数据采集清洗转换、数据存储、数据分析、数据服务等场景解决方案的一个统称，在每一个场景都包含了多种可选的技术，如数据采集有 Flume、Sqoop、Kettle 等，数据存储有分布式文件系统 HDFS、FastDFS，NoSQL 数据库 HBase、MongoDB 等，数据分析有 Spark 技术栈、机器学习算法等。总的来说大数据架构就是根据业务的需求，整合各种大数据组件组合而成的架构，一般会提供分布式存储、分布式计算、多维分析、数据仓库、机器学习算法等能力。而服务端架构更多指的是应用组织层面的架构，底层能力往往是由大数据架构来提供。</p>
<ul>
<li>
<p><strong>有没有一些架构设计的原则？</strong></p>
<ul>
<li>
<p>N+1 设计。系统中的每个组件都应做到没有单点故障；</p>
</li>
<li>
<p>回滚设计。确保系统可以向前兼容，在系统升级时应能有办法回滚版本；</p>
</li>
<li>
<p>禁用设计。应该提供控制具体功能是否可用的配置，在系统出现故障时能够快速下线功能；</p>
</li>
<li>
<p>监控设计。在设计阶段就要考虑监控的手段；</p>
</li>
<li>
<p>多活数据中心设计。若系统需要极高的高可用，应考虑在多地实施数据中心进行多活，至少在一个机房断电的情况下系统依然可用；</p>
</li>
<li>
<p>采用成熟的技术。刚开发的或开源的技术往往存在很多隐藏的 bug，出了问题没有商业支持可能会是一个灾难；</p>
</li>
<li>
<p>资源隔离设计。应避免单一业务占用全部资源；</p>
</li>
<li>
<p>架构应能水平扩展。系统只有做到能水平扩展，才能有效避免瓶颈问题；</p>
</li>
<li>
<p>非核心则购买。非核心功能若需要占用大量的研发资源才能解决，则考虑购买成熟的产品；</p>
</li>
<li>
<p>使用商用硬件。商用硬件能有效降低硬件故障的机率；</p>
</li>
<li>
<p>快速迭代。系统应该快速开发小功能模块，尽快上线进行验证，早日发现问题大大降低系统交付的风险；</p>
</li>
<li>
<p>无状态设计。服务接口应该做成无状态的，当前接口的访问不依赖于接口上次访问的状态。</p>
</li>
</ul>
</li>
</ul>
]]></description>
</item><item>
    <title>MySQL 常见问题（三）</title>
    <link>https://www.xiaobinqt.cn/mysql-faq-3/</link>
    <pubDate>Mon, 11 Jul 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/mysql-faq-3/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="innodbmyisam的区别" class="headerLink">
    <a href="#innodbmyisam%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-mark"></a>InnoDB、MyISAM的区别</h2><ul>
<li>磁盘文件不同：</li>
</ul>
<p>MyISAM 引擎的表会生成三个磁盘文件：</p>
<p><code>table_name.frm</code> 该文件中存储表的结构信息。<code>table_name.MYD</code> 该文件中存储表的行数据。<code>table_name.MYI</code> 该文件中存储表的索引数据。</p>
<p>而 InnoDB 引擎的表只会生成两个磁盘文件：</p>
<p><code>table_name.frm</code> 该文件中存储表的结构信息。<code>table_name.ibd</code> 该文件中存储表的行数据和索引数据。</p>
<ul>
<li>InnoDB 支持聚簇索引，而 MyISAM 只支持非聚簇索引，因为 MyISAM 索引数据和表数据是<strong>分开存储</strong>的。</li>
<li>InnoDB 基于 Undo-log 日志实现了事务机制，但 MyISAM 没有，所以 MyISAM 不支持事务。</li>
<li>InnoDB 基于 Redo-log 日志实现了故障恢复机制，但 MyISAM 则只能依靠 Bin-log，因此会有丢失数据的风险。</li>
<li>InnoDB 可以基于聚簇索引实现行锁，同时还兼容表锁，但 MyISAM 仅支持表锁。</li>
<li>InnoDB 因为支持行锁以及 MVCC 机制，所以并发场景下的性能会远超 MyISAM 引擎。</li>
<li>InnoDB 由于设计了 BufferPool 缓冲池，所以内存利用度会远超 MyISAM 引擎。</li>
</ul>
<h2 id="行锁和表锁的区别" class="headerLink">
    <a href="#%e8%a1%8c%e9%94%81%e5%92%8c%e8%a1%a8%e9%94%81%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-mark"></a>行锁和表锁的区别</h2><p>主要是粒度不同，表锁是指对一整张表加锁，当加锁后，其他来访问该表的事务都会被阻塞，而行锁的粒度则小很多，是指针对于一条/多条数据加锁，并不会阻塞操作同一表的事务，而仅仅<strong>只会阻塞操作相同行数据的事务</strong>。</p>
<h2 id="共享锁和排他锁的区别" class="headerLink">
    <a href="#%e5%85%b1%e4%ba%ab%e9%94%81%e5%92%8c%e6%8e%92%e4%bb%96%e9%94%81%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-mark"></a>共享锁和排他锁的区别</h2><p>共享锁允许多个事务一起持有，而排他锁在同一时间内只能允许一个事务持有，也就是但凡出现排他锁的场景，其他事务都需要阻塞等待。</p>
<h2 id="表锁行锁有哪些" class="headerLink">
    <a href="#%e8%a1%a8%e9%94%81%e8%a1%8c%e9%94%81%e6%9c%89%e5%93%aa%e4%ba%9b" class="header-mark"></a>表锁、行锁有哪些</h2><p>表锁有元数据锁、意向锁、自增锁、全局锁这四种，行锁有记录锁、间隙锁、临键锁、插入意向锁这四类，行锁在 MySQL 中是 InnoDB 引擎独有的，并且 InnoDB 的行锁和表锁之间，是相互兼容的。</p>
<h2 id="记录锁间隙锁临键锁这三种行锁有什么区别" class="headerLink">
    <a href="#%e8%ae%b0%e5%bd%95%e9%94%81%e9%97%b4%e9%9a%99%e9%94%81%e4%b8%b4%e9%94%ae%e9%94%81%e8%bf%99%e4%b8%89%e7%a7%8d%e8%a1%8c%e9%94%81%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" class="header-mark"></a>记录锁、间隙锁、临键锁这三种行锁有什么区别</h2><p>记录锁是指对一条数据上锁、当我们针对主键或者唯一索引加锁的时候， MySQL 默认会对查询的这一行数据加行锁，避免其他事务对这一行数据进行修改。</p>
<p>间隙锁，就是锁定一个索引区间。在普通索引或者唯一索引列上，由于索引是基于 B+ 树的结构存储，所以默认会存在一个索引区间。而间隙锁，就是某个事务对索引列加锁的时候，默认锁定对应索引的<strong>左右开区间</strong>范围。在基于索引列的范围查询，无论是否是唯一索引，都会自动触发间隙锁。比如基于<code>between</code>的范围查询，就会产生一个左右开区间的间隙锁。</p>
<p>临键锁，它相当于「行锁+间隙锁」的组合，也就是它的锁定范围既包含了索引记录，也包含了索引区间，它会锁定一个<strong>左开右闭区间</strong>的数据范围。比如我们使用非唯一索引列进行查询的时候，默认会加一个临键锁，锁定一个左开右闭区间的范围。</p>
<p>总的来说，记录锁、临键锁、间隙锁只是表示锁定数据的范围，最终目的是<strong>为了解决幻读</strong>的问题。而临键锁相当于「行锁+间隙锁」，因此当我们使用非唯一索引进行精准匹配的时候，会默认加临键锁，因为它需要锁定匹配的这一行数据，还需要锁定这一行数据对应的左开右闭区间。因此在实际应用中，尽可能使用唯一索引或者主键索引进行查询，避免大面积的锁定造成性能影响。</p>
<h2 id="隐式锁或手动加锁后什么时候释放锁" class="headerLink">
    <a href="#%e9%9a%90%e5%bc%8f%e9%94%81%e6%88%96%e6%89%8b%e5%8a%a8%e5%8a%a0%e9%94%81%e5%90%8e%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e9%87%8a%e6%94%be%e9%94%81" class="header-mark"></a>隐式锁或手动加锁后，什么时候释放锁</h2><p>几乎所有释放锁的工作都是 MySQL 自动完成的，但不同事务隔离级别中，释放锁的时机也不同，如果目前是读未提交级别，MySQL 执行完一条语句后就会立马释放锁。如果是其他级别中，基本上都需要等待持有锁的事务结束（commit/rollback）后才会释放。</p>
<h2 id="mysql57的共享排他锁是什么" class="headerLink">
    <a href="#mysql57%e7%9a%84%e5%85%b1%e4%ba%ab%e6%8e%92%e4%bb%96%e9%94%81%e6%98%af%e4%bb%80%e4%b9%88" class="header-mark"></a>MySQL5.7的共享排他锁是什么</h2><p>因为索引树的结构会发生变更，比如一个无序数据插入时，就会导致树节点的分裂，这时需要挪动树中的一些节点位置，为了防止其他事务再次破坏树结构，或从索引树中读到不对的数据，所以会对整棵树上锁，这个问题被称为<code>SMO</code>问题，共享排他锁主要就是用来解决<code>SMO</code>问题。</p>
<h2 id="死锁发生的原因该如何避免" class="headerLink">
    <a href="#%e6%ad%bb%e9%94%81%e5%8f%91%e7%94%9f%e7%9a%84%e5%8e%9f%e5%9b%a0%e8%af%a5%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d" class="header-mark"></a>死锁发生的原因，该如何避免</h2><p>死锁，简单来说就是两个或者两个以上的线程在执行的过程中，争夺同一个共享资源造成的相互等待的现象。</p>
<p>如果没有外部干预，线程会一直阻塞无法往下执行，这些一直处于相互等待资源的线程就称为死锁线程。</p>
<p>导致死锁的条件有四个，也就是这四个条件<strong>同时满足</strong>就会产生死锁👇</p>
<ul>
<li>互斥条件，共享资源 X 和 Y 只能被一个线程占用</li>
<li>请求和保持条件，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X</li>
<li>不可抢占条件，其他线程不能强行抢占线程 T1 占有的资源</li>
<li>循环等待条件，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待</li>
</ul>
<p>导致死锁之后，只能通过人工干预来解决，比如重启服务，或者杀掉某个线程。所以，只能在写代码的时候，去规避可能出现的死锁问题。</p>
<p>按照死锁发生的四个条件，<strong>只需要破坏其中的任何一个</strong>，就可以解决，但是，互斥条件是没办法破坏的，因为这是互斥锁的基本约束，其他三方条件都有办法来破坏：</p>
<ul>
<li>对于“请求和保持”这个条件，可以一次性申请所有的资源，这样就不存在等待了。</li>
<li>对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</li>
<li>对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</li>
</ul>
<h2 id="有哪些常见索引" class="headerLink">
    <a href="#%e6%9c%89%e5%93%aa%e4%ba%9b%e5%b8%b8%e8%a7%81%e7%b4%a2%e5%bc%95" class="header-mark"></a>有哪些常见索引</h2><p><strong>聚簇索引</strong>，在聚簇索引中，索引数据和表数据在磁盘中的位置是一起的。聚簇索引存的是主键和当前行的数据，一张表中只能存在一个聚簇索引，一般都会选用主键作为聚簇索引。一般聚簇索引要求索引必须是<strong>非空唯一</strong>索引才行。</p>
<p><strong>唯一索引</strong>，索引中的索引节点值不允许重复，一般配合唯一约束使用。</p>
<p><strong>主键索引</strong>，是一种特殊的唯一索引，和普通唯一索引的区别在于<strong>不允许有空值</strong>。</p>
<p><strong>普通索引</strong>，通过<code>KEY</code>、<code>INDEX</code>关键字创建的索引就是这个类型，没什么限制，就是单纯的可以让查询快一点。</p>
<p><strong>全文索引</strong>在 5.7 版本之前，只有 MyISAM 引擎支持。全文索引只能创建在<code>CHAR</code>、<code>VARCHAR</code>、<code>TEXT</code>等这些文本类型字段上，而且使用全文索引查询时，条件字符数量必须<strong>大于</strong> 3 才生效。如果想要创建出的全文索引支持中文，需要在最后指定解析器<code>with parser ngram</code>。</p>
<h2 id="什么是索引覆盖和索引下推" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%b4%a2%e5%bc%95%e8%a6%86%e7%9b%96%e5%92%8c%e7%b4%a2%e5%bc%95%e4%b8%8b%e6%8e%a8" class="header-mark"></a>什么是索引覆盖和索引下推</h2><p><strong>覆盖索引</strong></p>
<p>比如有个联合索引为<code>user_name、user_sex、password</code>，那么 SQL:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">SELECT</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">user_name</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">user_sex</span><span class="o">`</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">password</span><span class="o">`</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;1234&#34;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="o">`</span><span class="n">user_sex</span><span class="o">`</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;男&#34;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>虽然不符合联合索引的最左前缀匹配原则的，但是也可以用到索引，这就是索引覆盖。也就是：查询的列，在使用的索引中已经包含，被所使用的索引覆盖，这种情况称之为索引覆盖。</p>
<p><strong>索引下推</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    [&#34;熊猫&#34;,&#34;女&#34;,&#34;6666&#34;] : 1,
</span></span><span class="line"><span class="cl">    [&#34;竹子&#34;,&#34;男&#34;,&#34;1234&#34;] : 2,
</span></span><span class="line"><span class="cl">    [&#34;子竹&#34;,&#34;男&#34;,&#34;4321&#34;] : 3,
</span></span><span class="line"><span class="cl">    [&#34;1111&#34;,&#34;男&#34;,&#34;4321&#34;] : 4,
</span></span><span class="line"><span class="cl">    [&#34;竹竹&#34;,&#34;女&#34;,&#34;8888&#34;] : 5
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>比如 zz_users 表中有数据☝️，索引<code>user_name、user_sex、password</code>，查询 SQL：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="o">`</span><span class="n">user_name</span><span class="o">`</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s2">&#34;竹%&#34;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="o">`</span><span class="n">user_sex</span><span class="o">`=</span><span class="s2">&#34;男&#34;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于使用了模糊查询，但<code>%</code>在结尾，因此可以使用<code>竹</code>这个字作为条件在联合索引中查询，整个查询过程如下：</p>
<ul>
<li>① 利用联合索引中的<code>user_name</code>字段找出「竹子、竹竹」两个索引节点。</li>
<li>② 返回索引节点存储的值「2、5」给<code>Server</code>层，然后去逐一做回表扫描。</li>
<li>③ 在<code>Server</code>层中根据<code>user_sex=&quot;男&quot;</code>这个条件逐条判断，最终筛选到「竹子」这条数据。</li>
</ul>
<p>那么为什么<code>user_sex=&quot;男&quot;</code>这个条件不在联合索引中处理呢？因为前面是模糊查询，所以拼接起来是这样的<code>竹X男</code>，由于这个<code>X</code>是未知的，因此无法根据最左前缀原则去匹配数据，最终这里只能使用联合索引中<code>user_name</code>字段的一部分，后续的<code>user_sex=&quot;男&quot;</code>还需要回到<code>Server</code>层处理。</p>
<p>所谓的索引下推，就是将<code>Server</code>层筛选数据的工作，下推到引擎层处理。</p>
<p>MySQL5.6 后加入索引下推机制后，其执行过程就是下面的顺序：</p>
<ul>
<li>① 利用联合索引中的<code>user_name</code>字段找出「竹子、竹竹」两个索引节点。</li>
<li>② 根据<code>user_sex=&quot;男&quot;</code>这个条件在索引节点中逐个判断，从而得到「竹子」这个节点。</li>
<li>③ 最终将「竹子」这个节点对应的「2」返回给<code>Server</code>层，然后聚簇索引中回表拿数据。</li>
</ul>
<p>相较于没有索引下推之前，原本需要做「2、5」两次回表查询，但在拥有索引下推之后，仅需做「2」一次回表查询。</p>
<h2 id="什么是脏读幻读不可重复读" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%84%8f%e8%af%bb%e5%b9%bb%e8%af%bb%e4%b8%8d%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb" class="header-mark"></a>什么是脏读、幻读、不可重复读</h2><p><strong>脏读</strong>：指一个事务读到了其他事务还未提交的数据，也就是当前事务读到的数据，由于还未提交，因此有可能会回滚。</p>
<p><strong>幻读</strong>：另外一个事务在第一个事务要处理的目标数据范围之内<strong>新增</strong>了数据，然后先于第一个事务提交造成的问题。<strong>幻读仅专指 “新插入的行”</strong>。</p>
<p>幻读是对自己来说的，比如，事务 A 在对表中多行数据进行修改，将性别「男、女」改为「0、1」，此时事务 B 又插入了一条性别为男的数据，当事务 A 提交后，再次查询表时，会发现表中依旧存在一条性别为男的数据。</p>
<p><strong>不可重复读</strong>：指在一个事务中，多次读取同一数据，先后读取到的数据不一致。</p>
<p>事务 A 执行下单业务时，因为添加物流信息的时候出错了，导致整个事务回滚，事务回滚完成后，事务 A 就结束了。但事务 B 却并未结束，在事务 B 中，在事务 A 执行时读取了一次剩余库存，然后在事务 A 回滚后又读取了一次剩余库存，仔细想想：B 事务第一次读到的剩余库存是扣减之后的，第二次读到的剩余库存则是扣减之前的（因为 A 事务回滚又加回去了），导致两次读取的数据不一致，这就是不可重复读。</p>
<h2 id="什么是脏写" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%84%8f%e5%86%99" class="header-mark"></a>什么是脏写</h2><p>多个事务一起操作同一条数据，例如两个事务同时向表中添加一条<code>ID=88</code>的数据，此时就会造成数据覆盖，或者主键冲突的问题，这个问题也被称之为更新丢失问题。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://juejin.cn/post/7149074488649318431" target="_blank" rel="noopener noreferrer">建立索引的正确姿势与使用索引的最佳指南！</a></li>
<li><a href="https://juejin.cn/post/7152765784299667487" target="_blank" rel="noopener noreferrer">ACID原则、事务隔离级别及事务机制原理剖析</a></li>
<li><a href="https://juejin.cn/post/7156111610589741063" target="_blank" rel="noopener noreferrer">全解MySQL之死锁问题分析、事务隔离与锁机制的底层原理剖析</a></li>
</ul>
]]></description>
</item><item>
    <title>session cookie token 的区别</title>
    <link>https://www.xiaobinqt.cn/session-cookie-token-difference/</link>
    <pubDate>Sat, 11 Jun 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/session-cookie-token-difference/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220824/ee39a9cb19524d918d984db89b1661a5.png" referrerpolicy="no-referrer">
            </div><!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="cookie-和-session" class="headerLink">
    <a href="#cookie-%e5%92%8c-session" class="header-mark"></a>Cookie 和 Session</h2><p>HTTP 协议是一种<code>无状态协议</code>，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录；Session 和 Cookie 的主要目的就是为了弥补 HTTP 的无状态特性。</p>
<h3 id="session-是什么" class="headerLink">
    <a href="#session-%e6%98%af%e4%bb%80%e4%b9%88" class="header-mark"></a>Session 是什么</h3><p>客户端请求服务端，服务端会为这次请求开辟一块<code>内存空间</code>，这个对象便是 Session 对象，存储结构为 <code>ConcurrentHashMap</code>。Session 弥补了 HTTP 无状态特性，服务器可以利用 Session 存储客户端在同一个会话期间的一些操作记录。</p>
<h3 id="session-如何判断是否是同一会话" class="headerLink">
    <a href="#session-%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e6%98%af%e5%90%a6%e6%98%af%e5%90%8c%e4%b8%80%e4%bc%9a%e8%af%9d" class="header-mark"></a>Session 如何判断是否是同一会话</h3><p>服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 <code>sessionId</code> ，并通过响应头的 <strong>Set-Cookie：JSESSIONID=XXXXXXX</strong> 命令，向客户端发送要求设置 Cookie 的响应；客户端收到响应后，在本机客户端设置了一个 <strong>JSESSIONID=XXXXXXX</strong> 的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220824/50c3ccd67e62465ab1beaa691995ed06.png" title="会话" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220824/50c3ccd67e62465ab1beaa691995ed06.png" data-sub-html="<h2>会话</h2><p>会话</p>">
        
    </a><figcaption class="image-caption">会话</figcaption>
    </figure></p>
<p>接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie 信息（包含 sessionId ），然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。</p>
<h3 id="session-的缺点" class="headerLink">
    <a href="#session-%e7%9a%84%e7%bc%ba%e7%82%b9" class="header-mark"></a>Session 的缺点</h3><p>Session 机制有个缺点，比如 A 服务器存储了 Session，就是做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。</p>
<h3 id="cookies-是什么" class="headerLink">
    <a href="#cookies-%e6%98%af%e4%bb%80%e4%b9%88" class="header-mark"></a>Cookies 是什么</h3><p>HTTP 协议中的 Cookie 包括 <code>Web Cookie</code> 和<code>浏览器 Cookie</code>，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。</p>
<blockquote>
<p>HTTP Cookie 机制是 HTTP 协议无状态的一种补充和改良</p>
</blockquote>
<p>Cookie 主要用于下面三个目的</p>
<ul>
<li><code>会话管理</code></li>
</ul>
<p>登陆、购物车、游戏得分或者服务器应该记住的其他内容</p>
<ul>
<li><code>个性化</code></li>
</ul>
<p>用户偏好、主题或者其他设置</p>
<ul>
<li><code>追踪</code></li>
</ul>
<p>记录和分析用户行为</p>
<p>Cookie 曾经用于一般的客户端存储。虽然这是合法的，因为它们是在客户端上存储数据的唯一方法，但如今建议使用现代存储 API。Cookie 随每个请求一起发送，因此它们<strong>可能会降低性能</strong>（尤其是对于移动数据连接而言）。</p>
<h3 id="创建-cookie" class="headerLink">
    <a href="#%e5%88%9b%e5%bb%ba-cookie" class="header-mark"></a>创建 Cookie</h3><p>当接收到客户端发出的 HTTP 请求时，服务器可以发送带有响应的 <code>Set-Cookie</code> 标头，Cookie 通常由浏览器存储，然后将 Cookie 与 HTTP 标头一同向服务器发出请求。</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Max-Age</code></td>
<td>设置 cookie 的过期时间，单位为秒</td>
</tr>
<tr>
<td><code>Domain</code></td>
<td>指定了 Cookie 所属的域名</td>
</tr>
<tr>
<td><code>Path</code></td>
<td>指定了 Cookie 所属的路径</td>
</tr>
<tr>
<td><code>HttpOnly</code></td>
<td>告诉浏览器此 Cookie 只能靠浏览器 Http 协议传输,禁止其他方式访问</td>
</tr>
<tr>
<td><code>Secure</code></td>
<td>告诉浏览器此 Cookie 只能在 Https 安全协议中传输,如果是 Http 则禁止传输</td>
</tr>
</tbody>
</table>
<h4 id="set-cookie-和-cookie-标头" class="headerLink">
    <a href="#set-cookie-%e5%92%8c-cookie-%e6%a0%87%e5%a4%b4" class="header-mark"></a>Set-Cookie 和 Cookie 标头</h4><p><code>Set-Cookie</code> HTTP 响应标头将 cookie 从服务器发送到用户代理。下面是一个发送 Cookie 的例子</p>
<p><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/68ec0f0d662d4a8ea816a2e4b1f301e3.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/68ec0f0d662d4a8ea816a2e4b1f301e3.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/68ec0f0d662d4a8ea816a2e4b1f301e3.png">
        
    </a></p>
<p>此标头告诉客户端存储 Cookie</p>
<p>现在，随着对服务器的每个新请求，浏览器将使用 Cookie 头将所有以前存储的 Cookie 发送回服务器。</p>
<p><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/88919b06618940d9b5c0bae71d0cfb86.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/88919b06618940d9b5c0bae71d0cfb86.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/88919b06618940d9b5c0bae71d0cfb86.png">
        
    </a></p>
<p>有两种类型的 Cookies，一种是 <strong><ruby>Session Cookies<rt>会话 cookie</rt></ruby></strong>，一种是 <strong><ruby>Persistent Cookies<rt>永久 cookie</rt></ruby></strong>，如果 Cookie 不包含到期日期，则将其视为会话 Cookie。会话 Cookie 存储在内存中，永远不会写入磁盘，当浏览器关闭时，此后 Cookie 将永久丢失。如果 Cookie 包含<code>有效期</code> ，则将其视为持久性 Cookie。在到期指定的日期，Cookie 将从磁盘中删除。</p>
<p>还有一种是 Cookie 的 <code>Secure</code> 和 <code>HttpOnly</code> 标记。</p>
<h4 id="会话-cookies" class="headerLink">
    <a href="#%e4%bc%9a%e8%af%9d-cookies" class="header-mark"></a>会话 Cookies</h4><p>上面的示例创建的是会话 Cookie ，会话 Cookie 有个特征，客户端关闭时 Cookie 会删除，因为它<strong>没有指定</strong><code>Expires</code>或 <code>Max-Age</code> 指令。</p>
<p>但是，Web 浏览器可能会使用会话还原，这会使大多数会话 Cookie 保持永久状态，就像从未关闭过浏览器一样。</p>
<h4 id="永久性-cookies" class="headerLink">
    <a href="#%e6%b0%b8%e4%b9%85%e6%80%a7-cookies" class="header-mark"></a>永久性 Cookies</h4><p>永久性 Cookie 不会在客户端关闭时过期，而是在<code>特定日期（Expires）</code>或<code>特定时间长度（Max-Age）</code>外过期。例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="cookie-的-secure-和-httponly-标记" class="headerLink">
    <a href="#cookie-%e7%9a%84-secure-%e5%92%8c-httponly-%e6%a0%87%e8%ae%b0" class="header-mark"></a>Cookie 的 Secure 和 HttpOnly 标记</h4><p>安全的 Cookie 需要经过 HTTPS 协议通过加密的方式发送到服务器。即使是安全的，也不应该将敏感信息存储在cookie 中，因为它们本质上是不安全的，并且此标志不能提供真正的保护。</p>
<p><strong>HttpOnly 的作用</strong></p>
<ul>
<li>
<p>会话 Cookie 中缺少 HttpOnly 属性会导致攻击者可以通过程序( JS 脚本、Applet 等)获取到用户的 Cookie 信息，造成用户 Cookie 信息泄露，增加攻击者的跨站脚本攻击威胁。</p>
</li>
<li>
<p>HttpOnly 是微软对 Cookie 做的扩展，该值指定 Cookie 是否可通过客户端脚本访问。</p>
</li>
<li>
<p>如果在 Cookie 中<strong>没有设置</strong> <code>HttpOnly</code> 属性为 true，可能导致 Cookie 被窃取。窃取的 Cookie 可以包含标识站点用户的敏感信息，如 ASP.NET 会话 ID 或 Forms 身份验证票证，攻击者可以重播窃取的 Cookie，以便伪装成用户或获取敏感信息，进行跨站脚本攻击等。</p>
</li>
</ul>
<h3 id="cookie-的作用域" class="headerLink">
    <a href="#cookie-%e7%9a%84%e4%bd%9c%e7%94%a8%e5%9f%9f" class="header-mark"></a>Cookie 的作用域</h3><p><code>Domain</code> 和 <code>Path</code> 标识定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。</p>
<p><code>Domain</code> 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前主机(<strong>不包含子域名</strong>）。如果指定了<code>Domain</code>，则一般包含子域名。</p>
<p>例如，如果设置 <code>Domain=mozilla.org</code>，则 Cookie 也包含在子域名中（如<code>developer.mozilla.org</code>）。</p>
<p>例如，设置 <code>Path=/docs</code>，则以下地址都会匹配：</p>
<ul>
<li><code>/docs</code></li>
<li><code>/docs/Web/</code></li>
<li><code>/docs/Web/HTTP</code></li>
</ul>
<h2 id="json-web-token-和-session-cookies-的对比" class="headerLink">
    <a href="#json-web-token-%e5%92%8c-session-cookies-%e7%9a%84%e5%af%b9%e6%af%94" class="header-mark"></a>JSON Web Token 和 Session Cookies 的对比</h2><p><code>JSON Web Token</code>，简称 <code>JWT</code>，它和 <code>Session</code>都可以为网站提供用户的身份认证，但是它们不是一回事。</p>
<h3 id="jwt-和-session-cookies-的相同之处" class="headerLink">
    <a href="#jwt-%e5%92%8c-session-cookies-%e7%9a%84%e7%9b%b8%e5%90%8c%e4%b9%8b%e5%a4%84" class="header-mark"></a>JWT 和 Session Cookies 的相同之处</h3><p>在探讨 JWT 和 Session Cookies 之前，有必要需要先去理解一下它们的相同之处。</p>
<p>它们既可以对用户进行身份验证，也可以用来在用户单击进入不同页面时以及登陆网站或应用程序后进行身份验证。</p>
<p>如果没有这两者，那你可能需要在每个页面切换时都需要进行登录了。因为 HTTP 是一个无状态的协议。这也就意味着当你访问某个网页，然后单击同一站点上的另一个页面时，服务器的<code>内存中</code>将不会记住你之前的操作。</p>
<p><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/dcc63c8881794018b714769f214547c3.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/dcc63c8881794018b714769f214547c3.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/dcc63c8881794018b714769f214547c3.png">
        
    </a></p>
<p>因此，如果你登录并访问了你有权访问的另一个页面，由于 HTTP 不会记录你刚刚登录的信息，因此你将再次登录。</p>
<p><strong>JWT 和 Session Cookies 就是用来处理在不同页面之间切换，保存用户登录信息的机制</strong>。</p>
<p>也就是说，这两种技术都是<strong>用来保存你的登录状态</strong>，能够让你在浏览任意受密码保护的网站。通过在每次产生新的请求时对用户数据进行身份验证来解决此问题。</p>
<p>所以 JWT 和 Session Cookies 的相同之处是什么？那就是它们能够支持你在发送不同请求之间，记录并验证你的登录状态的一种机制。</p>
<h3 id="什么是-session-cookies" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-session-cookies" class="header-mark"></a>什么是 Session Cookies</h3><p>Session Cookies 也称为<code>会话 Cookies</code>，在 Session Cookies 中，用户的登录状态会保存在<code>服务器</code>的<code>内存</code>中。当用户登录时，Session 就被服务端安全的创建。</p>
<p>在每次请求时，服务器都会从会话 Cookie 中读取 SessionId，如果服务端的数据和读取的 SessionId 相同，那么服务器就会发送响应给浏览器，允许用户登录。</p>
<p>⚠️ 下图有点问题，域名应该一致。</p>
<p><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/7de5d6b609354be5b1a8346b66e2643d.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/7de5d6b609354be5b1a8346b66e2643d.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/7de5d6b609354be5b1a8346b66e2643d.png">
        
    </a></p>
<h3 id="什么是-json-web-tokens" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-json-web-tokens" class="header-mark"></a>什么是 Json Web Tokens</h3><p>Json Web Token 的简称就是 JWT，通常可以称为 <code>Json 令牌</code>。它是<code>RFC 7519</code> 中定义的用于<code>安全的</code>将信息作为 <code>Json 对象</code>进行传输的一种形式。JWT 中存储的信息是经过<code>数字签名</code>的，因此可以被信任和理解。可以使用 HMAC 算法或使用 RSA/ECDSA 的公用/专用密钥对 JWT 进行签名。</p>
<p>使用 JWT 主要用来下面两点</p>
<ul>
<li>
<p><code>认证(Authorization)</code>：这是使用 JWT 最常见的一种情况，一旦用户登录，后面每个请求都会包含 JWT，从而允许用户访问该令牌所允许的路由、服务和资源。<code>单点登录</code>是当今广泛使用 JWT 的一项功能，因为它的开销很小。</p>
</li>
<li>
<p><code>信息交换(Information Exchange)</code>：JWT 是能够安全传输信息的一种方式。通过使用公钥/私钥对 JWT 进行签名认证。此外，由于签名是使用 <code>head</code> 和 <code>payload</code>计算的，因此你还可以验证内容是否遭到篡改。</p>
</li>
</ul>
<h4 id="jwt-的格式" class="headerLink">
    <a href="#jwt-%e7%9a%84%e6%a0%bc%e5%bc%8f" class="header-mark"></a>JWT 的格式</h4><p>下面，我们会探讨一下 JWT 的组成和格式是什么</p>
<p>JWT 主要由三部分组成，每个部分用 <code>.</code> 进行分割，各个部分分别是</p>
<ul>
<li><code>Header</code></li>
<li><code>Payload</code></li>
<li><code>Signature</code></li>
</ul>
<p>因此，一个非常简单的 JWT 组成会是下面这样</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/e32110689a834f6b86911766f9080ad3.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/e32110689a834f6b86911766f9080ad3.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/e32110689a834f6b86911766f9080ad3.png" data-sub-html="<h2>JWT 组成</h2>">
        
    </a><figcaption class="image-caption">JWT 组成</figcaption>
    </figure></p>
<p><strong>Header</strong></p>
<p>Header 是 JWT 的标头，它通常由两部分组成：<code>令牌的类型(即 JWT)</code>和使用的 <code>签名算法</code>，例如 <code>HMAC SHA256</code>（写成 HS256） 或 <code>RSA</code>。</p>
<p>例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;alg&#34;: &#34;HS256&#34;,
</span></span><span class="line"><span class="cl">  &#34;typ&#34;: &#34;JWT&#34;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>指定类型和签名算法后，Json 块被 <code>Base64Url</code> 编码形成 JWT 的第一部分。</p>
<p><strong>Payload</strong></p>
<p>Token 的第二部分是 <code>Payload</code>，Payload 中包含一个声明。声明是有关实体（通常是用户）和其他数据的声明。共有三种类型的声明：<strong><code>registered</code>, <code>public</code> 和 <code>private</code></strong> 声明。</p>
<ul>
<li><code>registered 声明</code>： 包含一组建议使用的预定义声明，主要包括</li>
</ul>
<table>
<thead>
<tr>
<th>ISS</th>
<th>签发人</th>
</tr>
</thead>
<tbody>
<tr>
<td>iss (issuer)</td>
<td>签发人</td>
</tr>
<tr>
<td>exp (expiration time)</td>
<td>过期时间</td>
</tr>
<tr>
<td>sub (subject)</td>
<td>主题</td>
</tr>
<tr>
<td>aud (audience)</td>
<td>受众</td>
</tr>
<tr>
<td>nbf (Not Before)</td>
<td>生效时间</td>
</tr>
<tr>
<td>iat (Issued At)</td>
<td>签发时间</td>
</tr>
<tr>
<td>jti (JWT ID)</td>
<td>编号</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>public 声明</code>：公共的声明，可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密。</p>
</li>
<li>
<p><code>private 声明</code>：自定义声明，旨在在同意使用它们的各方之间共享信息，既不是注册声明也不是公共声明。</p>
</li>
</ul>
<p>例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;sub&#34;: &#34;1234567890&#34;,
</span></span><span class="line"><span class="cl">  &#34;name&#34;: &#34;John Doe&#34;,
</span></span><span class="line"><span class="cl">  &#34;admin&#34;: true
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后 payload Json 块会被<code>Base64Url</code> 编码形成 JWT 的第二部分。</p>
<p><strong>signature</strong></p>
<p>JWT 的第三部分是一个签证信息，这个签证信息由三部分组成</p>
<ul>
<li>header (base64后的)</li>
<li>payload (base64后的)</li>
<li>secret</li>
</ul>
<p>比如我们需要 HMAC SHA256 算法进行签名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">HMACSHA256(
</span></span><span class="line"><span class="cl">  base64UrlEncode(header) + &#34;.&#34; +
</span></span><span class="line"><span class="cl">  base64UrlEncode(payload),
</span></span><span class="line"><span class="cl">  secret)
</span></span></code></pre></td></tr></table>
</div>
</div><p>签名用于验证消息在此过程中没有更改，并且对于使用私钥进行签名的令牌，它还可以验证 JWT 的发送者的真实身份</p>
<h4 id="拼凑在一起" class="headerLink">
    <a href="#%e6%8b%bc%e5%87%91%e5%9c%a8%e4%b8%80%e8%b5%b7" class="header-mark"></a>拼凑在一起</h4><p>现在我们把上面的三个由点分隔的 Base64-URL 字符串部分组成在一起，这个字符串可以在 HTML 和 HTTP 环境中轻松传递这些字符串。</p>
<p>下面是一个完整的 JWT 示例，它对 header 和 payload 进行编码，然后使用 signature 进行签名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
</span></span></code></pre></td></tr></table>
</div>
</div><p><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/00f5b92c8950490fa0d836e532dff8d0.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/00f5b92c8950490fa0d836e532dff8d0.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/00f5b92c8950490fa0d836e532dff8d0.png">
        
    </a></p>
<p>如果想自己测试编写的话，可以访问 JWT 官网 <a href="https://jwt.io/#debugger-io" target="_blank" rel="noopener noreferrer">https://jwt.io/#debugger-io</a></p>
<h3 id="jwt-和-session-cookies-的不同" class="headerLink">
    <a href="#jwt-%e5%92%8c-session-cookies-%e7%9a%84%e4%b8%8d%e5%90%8c" class="header-mark"></a>JWT 和 Session Cookies 的不同</h3><p>JWT 和 Session Cookies 都提供安全的用户身份验证，但是它们有以下几点不同</p>
<h4 id="密码签名" class="headerLink">
    <a href="#%e5%af%86%e7%a0%81%e7%ad%be%e5%90%8d" class="header-mark"></a>密码签名</h4><p>JWT 具有加密签名，而 Session Cookies 则没有。</p>
<h4 id="json-是无状态的" class="headerLink">
    <a href="#json-%e6%98%af%e6%97%a0%e7%8a%b6%e6%80%81%e7%9a%84" class="header-mark"></a>JSON 是无状态的</h4><p>JWT 是<code>无状态</code>的，因为声明被存储在<code>客户端</code>，而不是服务端内存中。</p>
<p>身份验证可以在<code>本地</code>进行，而不是在请求必须通过服务器数据库或类似位置中进行。 这意味着可以对用户进行多次身份验证，而无需与站点或应用程序的数据库进行通信，也无需在此过程中消耗大量资源。</p>
<h4 id="可扩展性" class="headerLink">
    <a href="#%e5%8f%af%e6%89%a9%e5%b1%95%e6%80%a7" class="header-mark"></a>可扩展性</h4><p>Session Cookies 是存储在服务器内存中，这就意味着如果网站或者应用很大的情况下会耗费大量的资源。由于 JWT 是无状态的，在许多情况下，它们可以节省服务器资源。因此 JWT 要比 Session Cookies 具有更强的<code>可扩展性</code>。</p>
<h4 id="jwt-支持跨域认证" class="headerLink">
    <a href="#jwt-%e6%94%af%e6%8c%81%e8%b7%a8%e5%9f%9f%e8%ae%a4%e8%af%81" class="header-mark"></a>JWT 支持跨域认证</h4><p>Session Cookies 只能用在<code>单个节点的域</code>或者它的<code>子域</code>中有效。如果它们尝试通过第三个节点访问，就会被禁止。如果你希望自己的网站和其他站点建立安全连接时，这是一个问题。</p>
<p>使用 JWT 可以解决这个问题，使用 JWT 能够通过<code>多个节点</code>进行用户认证，也就是我们常说的<code>跨域认证</code>。</p>
<h3 id="jwt-和-session-cookies-的选型" class="headerLink">
    <a href="#jwt-%e5%92%8c-session-cookies-%e7%9a%84%e9%80%89%e5%9e%8b" class="header-mark"></a>JWT 和 Session Cookies 的选型</h3><p>我们上面探讨了 JWT 和 Cookies 的不同点，相信你也会对选型有了更深的认识，大致来说</p>
<p>对于只需要登录用户并访问存储在站点数据库中的一些信息的中小型网站来说，Session Cookies 通常就能满足。</p>
<p>如果你有企业级站点，应用程序或附近的站点，并且需要处理大量的请求，尤其是第三方或很多第三方（包括位于不同域的API），则 JWT 显然更适合。</p>
<h2 id="jwt-解码" class="headerLink">
    <a href="#jwt-%e8%a7%a3%e7%a0%81" class="header-mark"></a>JWT 解码</h2><p>JWT（JSON Web Token）的解码包括以下步骤：</p>
<ol>
<li>
<p>将 JWT 字符串分为头部、负载和签名三个部分。</p>
</li>
<li>
<p>使用 Base64URL 解码头部和负载，以获取原始的 JSON 数据。</p>
</li>
<li>
<p>使用头部中的算法信息（通常在 <code>alg</code> 字段中）来验证签名。在这种情况下，头部指定了使用 HS256 算法，这意味着需要使用相同的密钥对头部和负载部分进行签名，并验证签名是否匹配。</p>
</li>
</ol>
<p>以下是使用 Golang 进行 JWT 解码的示例代码，不使用第三方包，但假设你已经有了密钥。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;encoding/base64&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;encoding/json&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strings&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义JWT结构体来解析头部和负载
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">JWT</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Header</span>    <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Payload</span>   <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Signature</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 要解码的JWT字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">jwtString</span> <span class="o">:=</span> <span class="s">&#34;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2OTY5MDY5MTcsInVzZXJfaWQiOjF9.-CGzj1oGoQtk3PfY1ppkzGkaArGbvNX5eQIkKNGR4EE&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 使用点号分割JWT字符串，得到头部、负载和签名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">parts</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">jwtString</span><span class="p">,</span> <span class="s">&#34;.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">parts</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Invalid JWT format&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 解码头部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">headerJSON</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">base64</span><span class="p">.</span><span class="nx">RawURLEncoding</span><span class="p">.</span><span class="nf">DecodeString</span><span class="p">(</span><span class="nx">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Error decoding header:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 解码负载
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">payloadJSON</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">base64</span><span class="p">.</span><span class="nx">RawURLEncoding</span><span class="p">.</span><span class="nf">DecodeString</span><span class="p">(</span><span class="nx">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Error decoding payload:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 解码头部和负载中的JSON数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">headerData</span><span class="p">,</span> <span class="nx">payloadData</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">headerJSON</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">headerData</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Error unmarshaling header:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">payloadJSON</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">payloadData</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Error unmarshaling payload:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 解析签名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">signature</span> <span class="o">:=</span> <span class="nx">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建JWT结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">jwt</span> <span class="o">:=</span> <span class="nx">JWT</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Header</span><span class="p">:</span>    <span class="nx">headerData</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Payload</span><span class="p">:</span>   <span class="nx">payloadData</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Signature</span><span class="p">:</span> <span class="nx">signature</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 打印解析结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Header:&#34;</span><span class="p">,</span> <span class="nx">jwt</span><span class="p">.</span><span class="nx">Header</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Payload:&#34;</span><span class="p">,</span> <span class="nx">jwt</span><span class="p">.</span><span class="nx">Payload</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Signature:&#34;</span><span class="p">,</span> <span class="nx">jwt</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此示例假定你已经有用于验证签名的密钥，并且使用的是 HS256 算法。要验证签名是否有效，你需要使用相同的密钥对头部和负载部分进行签名，并比较得到的签名与 JWT 中的签名是否匹配。如果匹配，JWT 就是有效的。如果不匹配，说明 JWT 被篡改或无效。</p>
<h2 id="faq" class="headerLink">
    <a href="#faq" class="header-mark"></a>FAQ</h2><h4 id="如何禁用-cookies-后使用-session" class="headerLink">
    <a href="#%e5%a6%82%e4%bd%95%e7%a6%81%e7%94%a8-cookies-%e5%90%8e%e4%bd%bf%e7%94%a8-session" class="header-mark"></a>如何禁用 Cookies 后，使用 Session</h4><ul>
<li>如果禁用了 Cookies，服务器仍会将 sessionId 以 cookie 的方式发送给浏览器，但是，浏览器不再保存这个 cookie （即 sessionId） 了。</li>
<li>如果想要继续使用 session，需要采用 <code>URL 重写</code>的方式来实现，可以参考 <a href="https://www.cnblogs.com/Renyi-Fan/p/11012086.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/Renyi-Fan/p/11012086.html</a></li>
</ul>
<h3 id="jwt-前端解码" class="headerLink">
    <a href="#jwt-%e5%89%8d%e7%ab%af%e8%a7%a3%e7%a0%81" class="header-mark"></a>JWT 前端解码</h3><p>在线解密工具<a href="https://www.box3.cn/tools/jwt.html" target="_blank" rel="noopener noreferrer">https://www.box3.cn/tools/jwt.html</a></p>
<p>npm 包<a href="https://www.npmjs.com/package/jwt-decode" target="_blank" rel="noopener noreferrer">https://www.npmjs.com/package/jwt-decode</a></p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://juejin.cn/post/6844904115080790023" target="_blank" rel="noopener noreferrer">看完这篇 Session、Cookie、Token，和面试官扯皮就没问题了</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener noreferrer">JSON Web Token 入门教程</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/193090304" target="_blank" rel="noopener noreferrer">认证方式的前世今生，以及 JWT 的使用</a></li>
</ul>
]]></description>
</item></channel>
</rss>
