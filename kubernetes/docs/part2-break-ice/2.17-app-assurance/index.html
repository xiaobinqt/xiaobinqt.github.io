<!DOCTYPE html>
<html lang="zh" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="2.17 应用保障 # 2.17.1 容器资源配额 # 创建容器有三大隔离技术：namespace、cgroup、chroot。其中的 namespace 实现了独立的进程空间，chroot 实现了独立的文件系统，cgroup 的作用是管控 CPU、内存，保证容器不会无节制地占用基础资源，进而影响到系统里的其他应用。
因为 CPU、内存与存储卷有明显的不同，它是直接 “内置” 在系统里的，不像硬盘那样需要 “外挂”，所以申请和管理的过程会简单很多。Kubernetes 在管控容器使用 CPU 和内存的做法是，只要在 Pod 容器的描述部分添加一个新字段 resources 就可以了，它就相当于申请资源的 Claim。
以下是一个 YAML 描述示例：
apiVersion: v1 kind: Pod metadata: name: ngx-pod-resources spec: containers: - image: nginx:alpine name: ngx resources: requests: cpu: 10m memory: 100Mi limits: cpu: 20m memory: 200Mi requests 意思是容器要申请的资源，也就是说要求 Kubernetes 在创建 Pod 的时候必须分配这里列出的资源，否则容器就无法运行。
limits 意思是容器使用资源的上限，不能超过设定值，否则就有可能被强制停止运行。
内存的写法和磁盘容量一样，使用 Ki、Mi、Gi 来表示 KB、MB、GB，比如 512Ki、100Mi、0.5Gi 等。
因为 CPU 因为在计算机中数量有限，非常宝贵，所以 Kubernetes 允许容器精细分割 CPU，既可以 1 个、2 个地完整使用 CPU，也可以用小数 0.">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://example.com/kubernetes/docs/part2-break-ice/2.17-app-assurance/">
  <meta property="og:site_name" content="Kubernetes 学习笔记">
  <meta property="og:title" content="2.17 应用保障">
  <meta property="og:description" content="2.17 应用保障 # 2.17.1 容器资源配额 # 创建容器有三大隔离技术：namespace、cgroup、chroot。其中的 namespace 实现了独立的进程空间，chroot 实现了独立的文件系统，cgroup 的作用是管控 CPU、内存，保证容器不会无节制地占用基础资源，进而影响到系统里的其他应用。
因为 CPU、内存与存储卷有明显的不同，它是直接 “内置” 在系统里的，不像硬盘那样需要 “外挂”，所以申请和管理的过程会简单很多。Kubernetes 在管控容器使用 CPU 和内存的做法是，只要在 Pod 容器的描述部分添加一个新字段 resources 就可以了，它就相当于申请资源的 Claim。
以下是一个 YAML 描述示例：
apiVersion: v1 kind: Pod metadata: name: ngx-pod-resources spec: containers: - image: nginx:alpine name: ngx resources: requests: cpu: 10m memory: 100Mi limits: cpu: 20m memory: 200Mi requests 意思是容器要申请的资源，也就是说要求 Kubernetes 在创建 Pod 的时候必须分配这里列出的资源，否则容器就无法运行。
limits 意思是容器使用资源的上限，不能超过设定值，否则就有可能被强制停止运行。
内存的写法和磁盘容量一样，使用 Ki、Mi、Gi 来表示 KB、MB、GB，比如 512Ki、100Mi、0.5Gi 等。
因为 CPU 因为在计算机中数量有限，非常宝贵，所以 Kubernetes 允许容器精细分割 CPU，既可以 1 个、2 个地完整使用 CPU，也可以用小数 0.">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
    <meta property="article:modified_time" content="2023-06-25T11:50:53+08:00">
<title>2.17 应用保障 | Kubernetes 学习笔记</title>
<link rel="manifest" href="/kubernetes/manifest.json">
<link rel="icon" href="/kubernetes/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/kubernetes/book.min.cad59a3be22b32d901c8b99a5bf0c00f01535383d8d0e86742e5449f598d17af.css" integrity="sha256-ytWaO&#43;IrMtkByLmaW/DADwFTU4PY0OhnQuVEn1mNF68=" crossorigin="anonymous">
  <script defer src="/kubernetes/flexsearch.min.js"></script>
  <script defer src="/kubernetes/zh.search.min.6a49f949d6c64c82c1530df1a06dca2b9fc0405bdaedd9bb43bc1e183bad6c4e.js" integrity="sha256-akn5SdbGTILBUw3xoG3KK5/AQFva7dm7Q7weGDutbE4=" crossorigin="anonymous"></script>

  <script defer src="/kubernetes/sw.min.448c1a1f6d77a9e91ad10af73bc5bccfa94948c630159862e4b698042cdae427.js" integrity="sha256-RIwaH213qeka0Qr3O8W8z6lJSMYwFZhi5LaYBCza5Cc=" crossorigin="anonymous"></script>

  

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/kubernetes/"><span>Kubernetes 学习笔记</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>




<ul>
    <li>
        <a href="javascript:void(0)" onclick="hrefIndex()" rel="noopener">主页</a>
    </li>
    <li>
        <a href="https://github.com/xiaobinqt" target="_blank" rel="noopener">GitHub</a>
    </li>
</ul>

<hr>

<script>
    function hrefIndex() {
        window.location = window.location.origin;
    }
</script>


  
<ul>
  
  <li>
    <a href=""  target="_blank" rel="noopener">
        
      </a>
  </li>
  
</ul>







  



  
  <ul>
    
      
        <li>
          
  
  

  
    <span>第一部分 Docker</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part1-primary/1.1-docker-brief/" class="">1.1 Docker 简介</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part1-primary/1.2-docker-cmd/" class="">1.2 Docker 常用命令</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part1-primary/1.3-container/" class="">1.3 容器</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part1-primary/1.4-image/" class="">1.4 镜像</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part1-primary/1.5-network/" class="">1.5 网络互通</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part1-primary/1.6-docker-compose/" class="">1.6 Docker Compose</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part1-primary/1.7-private-registry/" class="">1.7 私有镜像仓库</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>第二部分 入门</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.1-k8s-overview/" class="">2.1 简介</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.2-minikube/" class="">2.2 minikube</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.3-working-mechanism/" class="">2.3 工作机制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.4-pod/" class="">2.4 Pod</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.5-job/" class="">2.5 Job</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.6-config-manage/" class="">2.6 配置管理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.7-general-cmd/" class="">2.7 常用命令</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.8-kubeadm/" class="">2.8 kubeadm 搭建</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.9-deployment/" class="">2.9 Deployment</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.10-daemonset/" class="">2.10 DaemonSet</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.11-service/" class="">2.11 Service</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.12-ingress/" class="">2.12 Ingress</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.13-persistent-volume/" class="">2.13 PersistentVolume</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.14-persistentvolume-nfs/" class="">2.14 网络共享存储</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.15-statefulset/" class="">2.15 StatefulSet</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.16-rolling-update/" class="">2.16 滚动更新</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.17-app-assurance/" class="active">2.17 应用保障</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.18-cluster-management/" class="">2.18 集群管理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.19-system-monitor/" class="">2.19 系统监控</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/kubernetes/docs/part2-break-ice/2.20-network-communications/" class="">2.20 网络通信</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/kubernetes/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>2.17 应用保障</strong>

  <label for="toc-control">
    
    <img src="/kubernetes/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#217-应用保障">2.17 应用保障</a>
      <ul>
        <li><a href="#2171-容器资源配额">2.17.1 容器资源配额</a></li>
        <li><a href="#1172-容器状态探针">1.17.2 容器状态探针</a></li>
        <li><a href="#2173-使用容器状态探针">2.17.3 使用容器状态探针</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="217-应用保障">
  2.17 应用保障
  <a class="anchor" href="#217-%e5%ba%94%e7%94%a8%e4%bf%9d%e9%9a%9c">#</a>
</h1>
<h2 id="2171-容器资源配额">
  2.17.1 容器资源配额
  <a class="anchor" href="#2171-%e5%ae%b9%e5%99%a8%e8%b5%84%e6%ba%90%e9%85%8d%e9%a2%9d">#</a>
</h2>
<p>创建容器有三大隔离技术：namespace、cgroup、chroot。其中的 namespace 实现了独立的进程空间，chroot 实现了独立的文件系统，cgroup 的作用是管控 CPU、内存，保证容器不会无节制地占用基础资源，进而影响到系统里的其他应用。</p>
<p>因为 CPU、内存与存储卷有明显的不同，它是直接 “内置” 在系统里的，不像硬盘那样需要 “外挂”，所以申请和管理的过程会简单很多。Kubernetes 在管控容器使用 CPU 和内存的做法是，只要在 Pod 容器的描述部分添加一个新字段 resources 就可以了，它就相当于申请资源的 Claim。</p>
<p>以下是一个 YAML 描述示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">ngx-pod-resources</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">image</span>: <span style="color:#ae81ff">nginx:alpine</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">name</span>: <span style="color:#ae81ff">ngx</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">resources</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">requests</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">cpu</span>: <span style="color:#ae81ff">10m</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">memory</span>: <span style="color:#ae81ff">100Mi</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">limits</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">cpu</span>: <span style="color:#ae81ff">20m</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">memory</span>: <span style="color:#ae81ff">200Mi</span>
</span></span></code></pre></div><ul>
<li>
<p>requests 意思是容器要申请的资源，也就是说要求 Kubernetes 在创建 Pod 的时候必须分配这里列出的资源，否则容器就无法运行。</p>
</li>
<li>
<p>limits 意思是容器使用资源的上限，不能超过设定值，否则就有可能被强制停止运行。</p>
</li>
</ul>
<p>内存的写法和磁盘容量一样，使用 Ki、Mi、Gi 来表示 KB、MB、GB，比如 512Ki、100Mi、0.5Gi 等。</p>
<p>因为 CPU 因为在计算机中数量有限，非常宝贵，所以 Kubernetes 允许容器精细分割 CPU，既可以 1 个、2 个地完整使用 CPU，也可以用小数 0.1、0.2 的方式来部分使用 CPU。这其实是效仿了 UNIX “时间片” 的用法，意思是进程最多可以占用多少 CPU 时间。CPU 时间也不能无限分割，Kubernetes 里 CPU 的最小使用单位是 0.001，为了方便表示用了一个特别的单位 m，就是 “milli” “毫” 的意思，比如说 500m 就相当于 0.5。</p>
<p>上面的示例 YAML 描述向系统申请的是 1% 的 CPU 时间和 100MB 的内存，运行时的资源上限是 2%CPU 时间和 200MB 内存。有了这个申请，Kubernetes 就会在集群中查找最符合这个资源要求的节点去运行 Pod。</p>
<p>Kubernetes 会根据每个 Pod 声明的需求，像搭积木或者玩俄罗斯方块一样，把节点尽量 “塞满”，充分利用每个节点的资源，让集群的效益最大化。</p>
<div align="center"><img src="https://cdn.xiaobinqt.cn/397bfabd8234f8d859ca877a58f0d191.gif" width=450  /></div>
<p>如果 Pod 不写 resources 字段，就意味着 Pod 对运行的资源要求 “既没有下限，也没有上限”，Kubernetes 不用管 CPU 和内存是否足够，可以把 Pod 调度到任意的节点上，而且后续 Pod 运行时也可以无限制地使用 CPU 和内存。如果是生产环境就很危险了，Pod 可能会因为资源不足而运行缓慢，或者是占用太多资源而影响其他应用，所以应当合理评估 Pod 的资源使用情况，尽量为 Pod 加上限制。</p>
<p>如果预估错误，Pod 申请的资源太多，系统无法满足，比如申请 10 个 CPU，但是系统里没有节点能满足这个要求，Kubernetes 会<strong>调度失败</strong>，当前集群里的所有节点都无法运行这个 Pod。</p>
<h2 id="1172-容器状态探针">
  1.17.2 容器状态探针
  <a class="anchor" href="#1172-%e5%ae%b9%e5%99%a8%e7%8a%b6%e6%80%81%e6%8e%a2%e9%92%88">#</a>
</h2>
<p>使用 resources 字段加上资源配额之后，Pod 在 Kubernetes 里的运行就有了初步保障，Kubernetes 会监控 Pod 的资源使用情况，让它既不会 “饿死” 也不会 “撑死”。 如果还希望 Kubernetes 能够更细致地监控 Pod 的状态，除了保证崩溃重启，还必须要能够探查到 Pod 的内部运行状态，定时给应用做 “体检”，让应用时刻保持 “健康”，能够满负荷稳定工作，这就需要用到 “探针”（Probe）。</p>
<p>Kubernetes 为检查应用状态定义了三种探针，分别对应容器不同的状态：</p>
<ul>
<li>
<p>Startup 启动探针，用来检查应用是否已经启动成功，适合那些有大量初始化工作要做，启动很慢的应用。</p>
</li>
<li>
<p>Liveness 存活探针，用来检查应用是否正常运行，是否存在死锁、死循环。</p>
</li>
<li>
<p>Readiness 就绪探针，用来检查应用是否可以接收流量，是否能够对外提供服务。</p>
</li>
</ul>
<p>这三种探针是递进的关系：应用程序先启动，加载完配置文件等基本的初始化数据就进入了 Startup 状态，之后如果没有什么异常就是 Liveness 存活状态，但可能有一些准备工作没有完成，还不一定能对外提供服务，只有到最后的 Readiness 状态才是一个容器最健康可用的状态。</p>
<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230625/59b48d50a178444b86cff093322a7ac8.png" width=  /></div>
<p>如果一个 Pod 里的容器配置了探针，Kubernetes 在启动容器后就会不断地调用探针来检查容器的状态：</p>
<ul>
<li>
<p>如果 Startup 探针失败，Kubernetes 会认为容器没有正常启动，就会尝试反复重启，其后面的 Liveness 探针和 Readiness 探针也不会启动。</p>
</li>
<li>
<p>如果 Liveness 探针失败，Kubernetes 就会认为容器发生了异常，也会重启容器。</p>
</li>
<li>
<p>如果 Readiness 探针失败，Kubernetes 会认为容器虽然在运行，但内部有错误，不能正常提供服务，就会把容器从 Service 对象的负载均衡集合中排除，不会给它分配流量。</p>
</li>
</ul>
<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230625/fa0d5bae9b6e448bbf6c6aec0e1fb3a1.png" width=  /></div>
<h2 id="2173-使用容器状态探针">
  2.17.3 使用容器状态探针
  <a class="anchor" href="#2173-%e4%bd%bf%e7%94%a8%e5%ae%b9%e5%99%a8%e7%8a%b6%e6%80%81%e6%8e%a2%e9%92%88">#</a>
</h2>
<p>startupProbe、livenessProbe、readinessProbe 三种探针的配置方式都是一样的，关键字段有：</p>
<ul>
<li>
<p>periodSeconds 执行探测动作的时间间隔，默认是 10 秒探测一次。</p>
</li>
<li>
<p>timeoutSeconds 探测动作的超时时间，如果超时就认为探测失败，默认是 1 秒。</p>
</li>
<li>
<p>successThreshold 连续几次探测成功才认为是正常，对于 startupProbe 和 livenessProbe 来说它只能是 1。</p>
</li>
<li>
<p>failureThreshold 连续探测失败几次才认为是真正发生了异常，默认是 3 次。</p>
</li>
</ul>
<p>Kubernetes 支持 3 种探测方式，分别是：Shell、TCP Socket、HTTP GET，需要在探针里配置：</p>
<ul>
<li>
<p>exec，执行一个 Linux 命令，比如 ps、cat 等等，和 container 的 command 字段很类似。</p>
</li>
<li>
<p>tcpSocket，使用 TCP 协议尝试连接容器的指定端口。</p>
</li>
<li>
<p>httpGet，连接端口并发送 HTTP GET 请求。</p>
</li>
</ul>
<p>要使用这些探针，就必须要在开发应用时预留出 “检查口”，这样 Kubernetes 才能调用探针获取信息。这里以 Nginx 作为示例，用 ConfigMap 编写一个配置文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">ConfigMap</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">ngx-conf</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">data</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">default.conf</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    server {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      listen 80;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      location = /ready {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        return 200 &#39;I am ready&#39;;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }</span>    
</span></span></code></pre></div><p>在这个配置文件里，启用 80 端口，然后用 location 指令定义了 HTTP 路径 /ready，把它作为对外暴露的 “检查口”，用来检测就绪状态，返回简单的 200 状态码和一个字符串表示工作正常。</p>
<p>接下来是 Pod 里三种探针的具体定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">ngx-pod-probe</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">volumes</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">ngx-conf-vol</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">configMap</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">name</span>: <span style="color:#ae81ff">ngx-conf</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">image</span>: <span style="color:#ae81ff">nginx:alpine</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">name</span>: <span style="color:#ae81ff">ngx</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">volumeMounts</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/etc/nginx/conf.d</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">ngx-conf-vol</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">startupProbe</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">periodSeconds</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">exec</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">command</span>: [ <span style="color:#e6db74">&#34;cat&#34;</span>, <span style="color:#e6db74">&#34;/var/run/nginx.pid&#34;</span> ]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">livenessProbe</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">periodSeconds</span>: <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">tcpSocket</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">port</span>: <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">readinessProbe</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">periodSeconds</span>: <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">httpGet</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/ready</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">port</span>: <span style="color:#ae81ff">80</span>
</span></span></code></pre></div><p>StartupProbe 使用了 Shell 方式，使用 cat 命令检查 Nginx 存在磁盘上的进程号文件（/var/run/nginx.pid），如果存在就认为是启动成功，它的执行频率是每秒探测一次。</p>
<p>LivenessProbe 使用了 TCP Socket 方式，尝试连接 Nginx 的 80 端口，每 10 秒探测一次。</p>
<p>ReadinessProbe 使用的是 HTTP GET 方式，访问容器的 /ready 路径，每 5 秒发一次请求。</p>
<p>apply 创建 Pod 后，然后查看它的状态，也可以使用 kubectl logs 来查看 Nginx 的访问日志，里面会记录 HTTP GET 探针的执行情况：</p>
<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230625/c51e49a008a447ffa18b3fffad5a627e.png" width=  /></div>
<p>可以看到 Kubernetes 正是以大约 5 秒一次的频率，向 URI /ready 发送 HTTP 请求，不断地检查容器是否处于就绪状态。</p>
<blockquote>
<p>探针可以配置 “initialDelaySeconds” 字段，表示容器启动后多久才执行探针动作，适用于某些启动比较慢的应用，默认值是 0。</p>
<p>在容器里还可以配置 “lifecycle” 字段，在启动后和终止前安装两个钩子 “postStart” “preStop”，执行 Shell 命令或者发送 HTTP 请求做一些初始化和收尾工作。</p>
</blockquote>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/xiaobinqt/xiaobinqt.github.io/commit/dcfca4e4eb26ac149c752618b3b3f88929a33db5" title='最后修改者 weibin | June 25, 2023' target="_blank" rel="noopener">
      <img src="/kubernetes/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>June 25, 2023</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/xiaobinqt/xiaobinqt.github.io/tree/main/content/docs/part2-break-ice/2.17-app-assurance.md" target="_blank" rel="noopener">
      <img src="/kubernetes/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>编辑本页</span>
    </a>
  </div>


</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#217-应用保障">2.17 应用保障</a>
      <ul>
        <li><a href="#2171-容器资源配额">2.17.1 容器资源配额</a></li>
        <li><a href="#1172-容器状态探针">1.17.2 容器状态探针</a></li>
        <li><a href="#2173-使用容器状态探针">2.17.3 使用容器状态探针</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












