<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Medium on LeetCode</title>
    <link>https://example.com/leetcode/docs/medium/</link>
    <description>Recent content in Medium on LeetCode</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/leetcode/docs/medium/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>24. 两两交换链表中的节点</title>
      <link>https://example.com/leetcode/docs/medium/24/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/24/</guid>
      <description>24. 两两交换链表中的节点 # 题目地址 # 力扣 LeetCode 解题思路 # 参考 https://leetcode.cn/problems/swap-nodes-in-pairs/solutions/444474/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/
递归法 # 可以通过递归的方式实现两两交换链表中的节点。递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。
如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。
用head表示原始链表的头节点，新的链表的第二个节点，用newHead表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是newHead.next。令head.next = swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为head的下一个节点。然后令newHead.next = head，即完成了所有节点的交换。最后返回新的链表的头节点newHead。
⚠️好吧，再理解一下，关于递归，我只关注我这一层要干什么，返回什么，至于我的下一层（规模减 1），我不管，我就是一个甩手掌柜🙈。
我其实只需要关心第一层，也就是节点1和节点2的交换，把节点2的next指向节点1，节点2的next给下一层也就是递归函数。而我最后返回的应该是头结点，其实也就是原始节点的节点2。
迭代法 # TODO
具体实现 # Go迭代 package main import ( &amp;#34;fmt&amp;#34; ) type ListNode struct { Val int Next *ListNode } func swapPairs(head *ListNode) *ListNode { if head == nil { return head } dummy := &amp;amp;ListNode{ Val: 0, Next: head, } curr := dummy // 如果是链表长度是奇数那就没有必要交换，只有偶数才需要交换，所以这里的判断条件是 &amp;amp;&amp;amp; // 这里不能用一个临时参数，因为链表指针后的值会变化 for curr.</description>
    </item>
    
    <item>
      <title>😪59. 螺旋矩阵 II</title>
      <link>https://example.com/leetcode/docs/medium/59/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/59/</guid>
      <description>59. 螺旋矩阵 II # 题目地址： https://leetcode.cn/problems/spiral-matrix-ii/
解题思路 # 可以参考 https://leetcode.cn/problems/spiral-matrix-ii/solutions/12594/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/</description>
    </item>
    
    <item>
      <title>209. 长度最小的子数组</title>
      <link>https://example.com/leetcode/docs/medium/209/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/209/</guid>
      <description>209. 长度最小的子数组 # 题目地址 # 力扣 LeetCode 解题思路 # 暴力法 # 暴力法是最直观的方法，但是在 leetcode 提交暴力法解题会报「超出时间限制」😴。暴力法可以参看 https://leetcode.cn/problems/minimum-size-subarray-sum/solutions/305704/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/。
初始化子数组的最小长度为无穷大，枚举数组nums中的每个下标作为子数组的开始下标，对于每个开始下标i，需要找到大于或等于i的最小下标j，使得从nums[i]到nums[j]的元素和大于或等于s，并更新子数组的最小长度，此时子数组的长度是 j−i+1。需要 注意的是，两个 for 循环都是&amp;lt;len(nums)，不是内层的&amp;lt;len(nums)-1。
滑动窗口法 # 可以参看 B站-长度最小的子数组 和 209.长度最小的子数组
具体实现 # Go暴力法 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math&amp;#34; ) func minSubArrayLen(target int, nums []int) int { n := len(nums) if n == 0 { return 0 } min := func(x, y int) int { if x &amp;gt; y { return y } return x } ans := math.</description>
    </item>
    
    <item>
      <title>😪707. 设计链表</title>
      <link>https://example.com/leetcode/docs/medium/707/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/707/</guid>
      <description> 707. 设计链表 # 题目地址： https://leetcode.cn/problems/design-linked-list/
解题思路 # 具体实现 # Go </description>
    </item>
    
  </channel>
</rss>
