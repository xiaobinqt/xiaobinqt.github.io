<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Medium on LeetCode</title>
    <link>https://example.com/leetcode/docs/medium/</link>
    <description>Recent content in Medium on LeetCode</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/leetcode/docs/medium/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>24. 两两交换链表中的节点</title>
      <link>https://example.com/leetcode/docs/medium/24/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/24/</guid>
      <description>24. 两两交换链表中的节点 # 题目地址： https://leetcode.cn/problems/swap-nodes-in-pairs/
解题思路 # 参考 https://leetcode.cn/problems/swap-nodes-in-pairs/solutions/444474/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/
递归法 # 可以通过递归的方式实现两两交换链表中的节点。递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。
如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。
用head表示原始链表的头节点，新的链表的第二个节点，用newHead表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是newHead.next。令head.next = swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为head的下一个节点。然后令newHead.next = head，即完成了所有节点的交换。最后返回新的链表的头节点newHead。
:warning:好吧，再理解一下，关于递归，我只关注我这一层要干什么，返回什么，至于我的下一层（规模减 1），我不管，我就是一个甩手掌柜:see_no_evil:。
我其实只需要关心第一层，也就是节点1和节点2的交换，把节点2的next指向节点1，节点2的next给下一层也就是递归函数。而我最后返回的应该是头结点，其实也就是原始节点的节点2。
迭代法 # TODO
具体实现 # Go递归 package main import ( &amp;#34;fmt&amp;#34; ) type ListNode struct { Val int Next *ListNode } func swapPairs(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } newHead := head.Next head.Next = swapPairs(head.Next.Next) newHead.Next = head return newHead } func main() { x := swapPairs(&amp;amp;ListNode{ Val: 1, Next: &amp;amp;ListNode{ Val: 2, Next: &amp;amp;ListNode{ Val: 3, Next: &amp;amp;ListNode{ Val: 4, Next: nil, }, }, }, }) fmt.</description>
    </item>
    
    <item>
      <title>😪59. 螺旋矩阵 II</title>
      <link>https://example.com/leetcode/docs/medium/59/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/59/</guid>
      <description>59. 螺旋矩阵 II # 题目地址： https://leetcode.cn/problems/spiral-matrix-ii/
解题思路 # 可以参考 https://leetcode.cn/problems/spiral-matrix-ii/solutions/12594/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/</description>
    </item>
    
    <item>
      <title>209. 长度最小的子数组</title>
      <link>https://example.com/leetcode/docs/medium/209/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/209/</guid>
      <description>209. 长度最小的子数组 # 题目地址： https://leetcode.cn/problems/minimum-size-subarray-sum/description/
解题思路 # 暴力法 # 暴力法是最直观的方法，但是在 leetcode 提交暴力法解题会报「超出时间限制」😴。暴力法可以参看 https://leetcode.cn/problems/minimum-size-subarray-sum/solutions/305704/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/。
初始化子数组的最小长度为无穷大，枚举数组nums中的每个下标作为子数组的开始下标，对于每个开始下标i，需要找到大于或等于i的最小下标j，使得从nums[i]到nums[j]的元素和大于或等于s，并更新子数组的最小长度，此时子数组的长度是 j−i+1。需要 注意的是，两个 for 循环都是&amp;lt;len(nums)，不是内层的&amp;lt;len(nums)-1。
滑动窗口法 # 可以参看 B站-长度最小的子数组 和 209.长度最小的子数组
具体实现 # Go暴力法 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math&amp;#34; ) func minSubArrayLen(target int, nums []int) int { n := len(nums) if n == 0 { return 0 } min := func(x, y int) int { if x &amp;gt; y { return y } return x } ans := math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/leetcode/docs/medium/hidden/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/hidden/</guid>
      <description>This page is hidden in menu # Quondam non pater est dignior ille Eurotas # Latent te facies # Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.
Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona # O fallor in sustinui iussorum equidem.</description>
    </item>
    
  </channel>
</rss>
