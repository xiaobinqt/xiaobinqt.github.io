<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Easy on LeetCode</title>
    <link>https://example.com/leetcode/docs/easy/</link>
    <description>Recent content in Easy on LeetCode</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/leetcode/docs/easy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>21. 合并两个有序链表</title>
      <link>https://example.com/leetcode/docs/easy/21/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/21/</guid>
      <description>21. 合并两个有序链表 # 题目地址： https://leetcode.cn/problems/merge-two-sorted-lists/description/
解题思路 # 递归解法 # 递归的核心在于，我只关注我这一层要干什么，返回什么，至于我的下一层（规模减 1），我不管，我就是甩手掌柜。
那么现在我要 merge L1，L2 我需要怎么做:question:
但一条链表为空时，返回对方，因为如果返回自己，就退出了，返回对方，不管对方是什么，让下级去判断。 如果 L1 第一个元素小于 L2 的？那我得把 L1 的这个元素放到最前面，至于后面的那串长啥样，我不管。我只要接过下级员工干完活后给我的包裹，然后把我干的活附上去（令 L1-&amp;gt;next = 这个包裹）就行。 这个包裹是下级员工干的活，即merge(L1-&amp;gt;next,L2)。 我该返回啥❓
现在不管我的下一层干了什么，又返回了什么给我，我只要知道，假设我的工具人们都完成了任务，那我的任务也就完成了，可以返回最终结果了。 最终结果就是我一开始接手的 L1 头结点+下级员工给我的大包裹，要一并交上去，这样我的 boss 才能根据我给它的 L1 头节点往下找，检查我完成的工作。 具体实现 # Go递归 package main import &amp;#34;fmt&amp;#34; type ListNode struct { Val int Next *ListNode } func mergeTwoLists(list1 *ListNode, list2 *ListNode) (x *ListNode) { if list1 == nil { return list2 } if list2 == nil { return list1 } if list1.</description>
    </item>
    
    <item>
      <title>27. 移除元素</title>
      <link>https://example.com/leetcode/docs/easy/27/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/27/</guid>
      <description> 27. 移除元素 # 题目地址： https://leetcode.cn/problems/remove-element/description/
解题思路 # 可以用双指针/快慢指针法来解决。快指针用来寻找新数组的元素，新数组就是不含有目标元素的数组。慢指针用来指向更新新数组下标的位置。这里需要的注意的是，“新数组”其实旧数组，因为一直都在在同一个数组上的操作。
具体实现 # Go双指针 package main import &amp;#34;fmt&amp;#34; func removeElement(nums []int, val int) int { length := len(nums) low := 0 for i := 0; i &amp;lt; length; i++ { if nums[i] != val { nums[low] = nums[i] low++ } } return low } func main() { x := []int{1, 2, 6, 7, 9, 6, 6, 6} xx := removeElement(x, 6) fmt.Println(x, xx) } </description>
    </item>
    
    <item>
      <title>203. 移除链表元素</title>
      <link>https://example.com/leetcode/docs/easy/203/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/203/</guid>
      <description>203. 移除链表元素 # 题目地址： https://leetcode.cn/problems/remove-linked-list-elements/
解题思路 # 参看 https://leetcode.cn/problems/remove-linked-list-elements/solutions/813358/yi-chu-lian-biao-yuan-su-by-leetcode-sol-654m/
迭代法 # 用curr 表示当前节点。如果curr的下一个节点不为空且下一个节点的节点值等于给定的val，则需要删除下一个节点。删除下一个节点可以通过curr.next=curr.next.next实现。
如果curr的下一个节点的节点值不等于给定的val，则保留下一个节点，将curr移动到下一个节点即可。
当curr的下一个节点为空时，链表遍历结束，此时所有节点值等于val的节点都被删除。
具体实现方面，由于链表的头节点head有可能需要被删除，因此创建哑节点/虚拟节点dummyHead，令dummyHead.next=head，初始化 curr=dummyHead，然后遍历链表进行删除操作。最终返回dummyHead.next即为删除操作后的头节点。
:question:为什么要用curr=dummyHead，那么这样curr指向的地址跟dummyHead指向的地址是一样的，如果不提前赋值，那么迭代到最后dummyHead.Next就是nil，不能正确的返回头结点，所以赋值下dummyHead.Next还是正常的。
递归法 # 链表的定义具有递归的性质，因此链表题目常可以用递归的方法求解。
递归的核心在于，我只关注我这一层要干什么，返回什么，至于我的下一层（规模减 1），我不管，我就是甩手掌柜。
那么现在我要删除特定链表元素，我需要怎么做❓
如果链表是nil我就直接返回，我的 next 让工具人函数去判断，当工具人函数昨晚判断给我之后，我按需 return，也就是如果head.Val == val return head.Next，否则直接 return head。
具体实现 # Go迭代 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;go.src/leetcode/model&amp;#34; ) func removeElements(head *model.ListNode, val int) *model.ListNode { dummyHead := &amp;amp;model.ListNode{ Val: 0, Next: head, } curr := dummyHead fmt.Println(dummyHead, curr) for curr.Next != nil { if curr.</description>
    </item>
    
    <item>
      <title>206. 反转链表</title>
      <link>https://example.com/leetcode/docs/easy/206/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/206/</guid>
      <description>206. 反转链表 # 题目地址： https://leetcode.cn/problems/reverse-linked-list/
类似/相同题目： 剑指 Offer 24. 反转链表
解题思路 # 迭代法 # 递归法 # 具体实现 # Go迭代 package main type ListNode struct { Val int Next *ListNode } func reverseList(head *ListNode) *ListNode { if head == nil { return nil } var ( prev, next *ListNode curr = head ) for curr != nil { next = curr.Next curr.Next = prev // 下一个 prev = curr curr = next } return prev } func main() { reverseList(&amp;amp;ListNode{ Val: 1, Next: &amp;amp;ListNode{Val: 2, Next: &amp;amp;ListNode{Val: 3, Next: &amp;amp;ListNode{Val: 4, Next: &amp;amp;ListNode{Val: 5}}}}}) } Go递归 package main import ( &amp;#34;fmt&amp;#34; ) type ListNode struct { Val int Next *ListNode } func reverseList(head *ListNode) *ListNode { if head == nil || head.</description>
    </item>
    
    <item>
      <title>344. 反转字符串</title>
      <link>https://example.com/leetcode/docs/easy/344/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/344/</guid>
      <description>344. 反转字符串 # 题目地址： https://leetcode.cn/problems/reverse-string/description/
解题思路 # 双指针法 # 对于长度为N的待被反转的字符数组，我们可以观察反转前后下标的变化，假设反转前字符数组为s[0] s[1] s[2] ... s[N - 1]，那么反转后字符数组为s[N - 1] s[N - 2] ... s[0]。比较反转前后下标变化很容易得出s[i]的字符与s[N - 1 - i]的字符发生了交换的规律，因此我们可以得出如下双指针的解法：
将left指向字符数组首元素，right指向字符数组尾元素。 当left &amp;lt; right： 交换s[left]和s[right]； left指针右移一位，即left = left + 1； right指针左移一位，即right = right - 1。 当left &amp;gt;= right，反转结束，返回字符数组即可。 具体实现 # Go package main import ( &amp;#34;fmt&amp;#34; ) func reverseString(s []byte) { for left, right := 0, len(s)-1; left &amp;lt; right; left++ { s[left], s[right] = s[right], s[left] right-- } } func main() { x := []byte{&amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;} reverseString(x) fmt.</description>
    </item>
    
    <item>
      <title>704. 二分查找</title>
      <link>https://example.com/leetcode/docs/easy/704/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/704/</guid>
      <description>704. 二分查找 # 题目地址： https://leetcode.cn/problems/binary-search/
解题思路 # 参考 https://www.bilibili.com/video/BV1fA4y1o715/?spm_id_from=333.788
对于常规实现来说，其实要区分区间，也就是左闭右闭和左闭右开的两种解法，对于左闭右闭来说，包含最右边，那么right其实是数组长度-1，但是对于左闭右开来说，因为不包含最右元素，那个right其实就是数组长度。
具体实现 # Go 区间左闭右闭
package main import ( &amp;#34;fmt&amp;#34; ) func main() { arr := []int{0, 1, 2, 3, 4, 5, 10} fmt.Println(binarySearch(arr, 10)) } func binarySearch(nums []int, target int) int { left := 0 right := len(nums) - 1 for left &amp;lt;= right { middle := (left + right) / 2 if target &amp;gt; nums[middle] { left = middle + 1 } else if target &amp;lt; nums[middle] { right = middle - 1 } else { return middle } } return -1 } 区间左闭右开</description>
    </item>
    
    <item>
      <title>977. 有序数组的平方</title>
      <link>https://example.com/leetcode/docs/easy/977/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/977/</guid>
      <description>977. 有序数组的平方 # 题目地址： https://leetcode.cn/problems/squares-of-a-sorted-array/description/
解题思路 # 暴力法 # 可以直接先计算平方，然后再利用库函数排序。
双指针法 # 可以参考 https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html#%E6%9A%B4%E5%8A%9B%E6%8E%92%E5%BA%8F
数组其实是有序的，只不过负数平方之后可能成为最大数了。那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。此时可以考虑双指针法了，i指向起始位置，j指向终止位置。定义一个新数组 result，和 A 数组一样的大小，让k指向 result 数组终止位置。
如果A[i] * A[i] &amp;lt; A[j] * A[j] 那么result[k--] = A[j] * A[j] 。
如果A[i] * A[i] &amp;gt;= A[j] * A[j]那么result[k--] = A[i] * A[i]。
具体实现 # Go暴力法 package main import &amp;#34;fmt&amp;#34; func removeElement(nums []int, val int) int { length := len(nums) low := 0 for i := 0; i &amp;lt; length; i++ { if nums[i] !</description>
    </item>
    
  </channel>
</rss>
