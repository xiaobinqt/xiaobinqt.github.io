<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Easy on LeetCode</title>
    <link>https://example.com/leetcode/docs/easy/</link>
    <description>Recent content in Easy on LeetCode</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/leetcode/docs/easy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>21. 合并两个有序链表</title>
      <link>https://example.com/leetcode/docs/easy/21/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/21/</guid>
      <description>21. 合并两个有序链表 # 题目地址 # 力扣 LeetCode 解题思路 # 递归解法 # 参考 一看就会，一写就废？详解递归。
递归的核心在于，我只关注我这一层要干什么，返回什么，至于我的下一层（规模减 1），我不管，我就是甩手掌柜。
那么现在我要 merge L1，L2 我需要怎么做❓
当一条链表为空时，返回对方，因为如果返回自己，就退出了，返回对方，不管对方是什么，让下级去判断。 如果 L1 第一个元素小于 L2 的？那我得把 L1 的这个元素放到最前面，至于后面的那串长啥样，我不管。我只要接过下级员工干完活后给我的包裹，然后把我干的活附上去（令 L1-&amp;gt;next = 这个包裹）就行。 这个包裹是下级员工干的活，即merge(L1-&amp;gt;next,L2)。 我该返回啥❓
现在不管我的下一层干了什么，又返回了什么给我，我只要知道，假设我的工具人们都完成了任务，那我的任务也就完成了，可以返回最终结果了。 最终结果就是我一开始接手的 L1 头结点+下级员工给我的大包裹，要一并交上去，这样我的 boss 才能根据我给它的 L1 头节点往下找，检查我完成的工作。 具体实现 # Go递归 package main import &amp;#34;fmt&amp;#34; type ListNode struct { Val int Next *ListNode } func mergeTwoLists(list1 *ListNode, list2 *ListNode) (x *ListNode) { if list1 == nil { return list2 } if list2 == nil { return list1 } if list1.</description>
    </item>
    
    <item>
      <title>27. 移除元素</title>
      <link>https://example.com/leetcode/docs/easy/27/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/27/</guid>
      <description>27. 移除元素 # 题目地址 # 力扣 LeetCode 解题思路 # 暴力法 # TODO
双指针法 # 可以用双指针/快慢指针来解决。快指针用来寻找新数组的元素，新数组就是不含有目标元素的数组，慢指针用来指向更新新数组下标的位置。这里需要的注意的是，“新数组”其实就是旧数组，因为一直都在在同一个数组上的操作，这也是题目的要求👇
不要使用额外的数组空间，你必须仅使用O(1)额外空间并原地修改输入数组。
具体实现 # Go双指针 package main import &amp;#34;fmt&amp;#34; func removeElement(nums []int, val int) int { length := len(nums) low := 0 for i := 0; i &amp;lt; length; i++ { if nums[i] != val { nums[low] = nums[i] low++ } } return low } func main() { x := []int{1, 2, 6, 7, 9, 6, 6, 6} xx := removeElement(x, 6) fmt.</description>
    </item>
    
    <item>
      <title>😪104. 二叉树的最大深度</title>
      <link>https://example.com/leetcode/docs/easy/104/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/104/</guid>
      <description> 104. 二叉树的最大深度 # 题目地址 # 力扣 LeetCode </description>
    </item>
    
    <item>
      <title>203. 移除链表元素</title>
      <link>https://example.com/leetcode/docs/easy/203/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/203/</guid>
      <description>203. 移除链表元素 # 题目地址 # 力扣 LeetCode 解题思路 # 参看 https://leetcode.cn/problems/remove-linked-list-elements/solutions/813358/yi-chu-lian-biao-yuan-su-by-leetcode-sol-654m/
迭代法 # 用curr 表示当前节点。如果curr的下一个节点不为空且下一个节点的节点值等于给定的val，则需要删除下一个节点。删除下一个节点可以通过curr.next=curr.next.next实现。
如果curr的下一个节点的节点值不等于给定的val，则保留下一个节点，将curr移动到下一个节点即可。
当curr的下一个节点为空时，链表遍历结束，此时所有节点值等于val的节点都被删除。
具体实现方面，由于链表的头节点head有可能需要被删除，因此创建哑节点/虚拟节点dummyHead，令dummyHead.next=head，初始化 curr=dummyHead，然后遍历链表进行删除操作。最终返回dummyHead.next即为删除操作后的头节点。
为什么要用curr=dummyHead❓，这样curr指向的地址跟dummyHead指向的地址是一样的，如果不提前赋值，那么迭代到最后dummyHead.Next就是nil，不能正确的返回头结点，所以重新赋值后，用curr去循环dummyHead.Next还是正常的。
递归法 # 链表的定义具有递归的性质，因此链表题目常可以用递归的方法求解。
递归的核心在于，我只关注我这一层要干什么，返回什么，至于我的下一层（规模减 1），我不管，我就是甩手掌柜。
那么现在我要删除特定链表元素，我需要怎么做❓
如果链表是nil我就直接返回，我的 next 让工具人函数去判断，当工具人函数昨晚判断给我之后，我按需 return，也就是如果head.Val == val return head.Next，否则直接 return head。
具体实现 # Go迭代 package main import ( &amp;#34;fmt&amp;#34; ) func removeElements(head *ListNode, val int) *ListNode { dummyHead := &amp;amp;ListNode{ Val: 0, Next: head, } curr := dummyHead fmt.Println(dummyHead, curr) for curr.Next != nil { if curr.</description>
    </item>
    
    <item>
      <title>206. 反转链表</title>
      <link>https://example.com/leetcode/docs/easy/206/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/206/</guid>
      <description>206. 反转链表 # 题目地址 # 力扣 LeetCode 类似/相同题目： 剑指 Offer 24. 反转链表
解题思路 # 迭代法 # TODO
递归法 # TODO
具体实现 # Go迭代 package main type ListNode struct { Val int Next *ListNode } func reverseList(head *ListNode) *ListNode { if head == nil { return nil } var ( prev, next *ListNode curr = head ) for curr != nil { next = curr.Next curr.Next = prev // 下一个 prev = curr curr = next } return prev } func main() { reverseList(&amp;amp;ListNode{ Val: 1, Next: &amp;amp;ListNode{Val: 2, Next: &amp;amp;ListNode{Val: 3, Next: &amp;amp;ListNode{Val: 4, Next: &amp;amp;ListNode{Val: 5}}}}}) } Go递归 package main import ( &amp;#34;fmt&amp;#34; ) type ListNode struct { Val int Next *ListNode } func reverseList(head *ListNode) *ListNode { if head == nil || head.</description>
    </item>
    
    <item>
      <title>344. 反转字符串</title>
      <link>https://example.com/leetcode/docs/easy/344/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/344/</guid>
      <description>344. 反转字符串 # 题目地址 # 力扣 LeetCode 解题思路 # 双指针法 # 对于长度为N的待被反转的字符数组，我们可以观察反转前后下标的变化，假设反转前字符数组为s[0] s[1] s[2] ... s[N - 1]，那么反转后字符数组为s[N - 1] s[N - 2] ... s[0]。比较反转前后下标变化很容易得出s[i]的字符与s[N - 1 - i]的字符发生了交换的规律，因此我们可以得出如下双指针的解法：
将left指向字符数组首元素，right指向字符数组尾元素。 当left &amp;lt; right： 交换s[left]和s[right]； left指针右移一位，即left = left + 1； right指针左移一位，即right = right - 1。 当left &amp;gt;= right，反转结束，返回字符数组即可。 具体实现 # Go package main import ( &amp;#34;fmt&amp;#34; ) func reverseString(s []byte) { length := len(s) if length == 0 { return } left, right := 0, length-1 for left &amp;lt; right { tmp := s[left] s[left] = s[right] s[right] = tmp left++ right-- } return } func main() { x := []byte{&amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;} reverseString(x) fmt.</description>
    </item>
    
    <item>
      <title>704. 二分查找</title>
      <link>https://example.com/leetcode/docs/easy/704/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/704/</guid>
      <description>704. 二分查找 # 题目地址 # 力扣 LeetCode 解题思路 # 可以参考
https://www.bilibili.com/video/BV1fA4y1o715 二分查找 对于常规实现来说，在解题时要区分区间，也就是左闭右闭还是左闭右开区间两种解法，其实就是要区分右闭还是右开，在临界条件判断时包不包含最右边的值。
对于左闭右闭来说，包含最右边，所以在临界条件判断时，左边的值可以等于右边的值，那么right其实是数组长度-1，也就是数组最后一个值。
while (left &amp;lt;= right)，因为left == right是有意义的，所以使用&amp;lt;= if (nums[middle] &amp;gt; target)，right要赋值为middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是middle - 1 但是对于左闭右开来说，因为不包含最右元素，那么right其实就是数组长度，right 取不到数组最后一个值。
while (left &amp;lt; right)，因为left == right在区间[left, right)是没有意义的，所以这里要用&amp;lt; if (nums[middle] &amp;gt; target) right更新为middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，也就是说，下一个查询区间不会去比较nums[middle] 具体实现 # Go 区间左闭右闭
package main import ( &amp;#34;fmt&amp;#34; ) func main() { arr := []int{0, 1, 2, 3, 4, 5, 10} fmt.Println(binarySearch(arr, 10)) } func binarySearch(nums []int, target int) int { left := 0 right := len(nums) - 1 for left &amp;lt;= right { middle := (left + right) / 2 if target &amp;gt; nums[middle] { left = middle + 1 } else if target &amp;lt; nums[middle] { right = middle - 1 } else { return middle } } return -1 } 区间左闭右开</description>
    </item>
    
    <item>
      <title>977. 有序数组的平方</title>
      <link>https://example.com/leetcode/docs/easy/977/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/977/</guid>
      <description>977. 有序数组的平方 # 题目地址 # 力扣 LeetCode 解题思路 # 暴力法 # 可以直接先计算平方，然后再利用库函数排序。
双指针法 # 可以参考
有序数组的平方 B 站-有序数组的平方 数组其实是有序的，只不过负数平方之后可能成为最大数了。那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。此时可以考虑双指针法了，i指向起始位置，j指向终止位置。定义一个新数组 result，和 A 数组一样的大小，让k指向 result 数组终止位置，也就是说让 k 从大（右）到小（左）填充。
如果A[i] * A[i] &amp;lt; A[j] * A[j] 那么result[k--] = A[j] * A[j] 。
如果A[i] * A[i] &amp;gt;= A[j] * A[j]那么result[k--] = A[i] * A[i]。
具体实现 # Go双指针 package main import &amp;#34;fmt&amp;#34; func sortedSquares(nums []int) []int { if len(nums) == 0 { return []int{} } var ( result = make([]int, len(nums)) i, j = 0, len(nums) - 1 k = len(nums) - 1 // 能访问到最后一个值 ) for i &amp;lt;= j { if nums[i]*nums[i] &amp;gt; nums[j]*nums[j] { result[k] = nums[i] * nums[i] k-- i++ } else { result[k] = nums[j] * nums[j] k-- j-- } } return result } func main() { fmt.</description>
    </item>
    
  </channel>
</rss>
