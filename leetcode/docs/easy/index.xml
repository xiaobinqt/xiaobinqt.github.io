<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Easy on LeetCode</title>
    <link>https://example.com/leetcode/docs/easy/</link>
    <description>Recent content in Easy on LeetCode</description>
    <generator>Hugo</generator>
    <language>zh</language>
    <atom:link href="https://example.com/leetcode/docs/easy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1. 两数之和</title>
      <link>https://example.com/leetcode/docs/easy/1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/1/</guid>
      <description>&lt;h1 id=&#34;1-两数之和&#34;&gt;&#xA;  1. 两数之和&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e4%b8%a4%e6%95%b0%e4%b9%8b%e5%92%8c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/two-sum/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/two-sum/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;解题思路&#34;&gt;&#xA;  解题思路&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;暴力法&#34;&gt;&#xA;  暴力法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9a%b4%e5%8a%9b%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;嵌套遍历数组，外层遍历的值和内层遍历的值相加，如果相加等于目标值，则返回结果，否则继续遍历。内层遍历开始的位置是外层遍历的位置加 1，结束的位置是数组长度。&lt;/p&gt;&#xA;&lt;h3 id=&#34;map&#34;&gt;&#xA;  map&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#map&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;TODO&lt;/p&gt;&#xA;&lt;h2 id=&#34;具体实现&#34;&gt;&#xA;  具体实现&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-0&#34; checked=&#34;checked&#34; /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-0&#34;&gt;Go Map&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func twoSum(nums []int, target int) []int {&#xA;&#x9;if len(nums) == 0 {&#xA;&#x9;&#x9;return []int{}&#xA;&#x9;}&#xA;&#xA;&#x9;m := make(map[int]int, 0) // val =&gt; index&#xA;&#xA;&#x9;for index, val := range nums {&#xA;&#x9;&#x9;ass := target - val&#xA;&#x9;&#x9;if idx, ok := m[ass]; ok {&#xA;&#x9;&#x9;&#x9;return []int{idx, index}&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;m[val] = index&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return []int{}&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;fmt.Println(twoSum([]int{3, 2, 4}, 6))&#xA;}&#xA;&#xA;```&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-1&#34;  /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-1&#34;&gt;Go暴力法&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func twoSum(nums []int, target int) []int {&#xA;&#x9;for index, value := range nums {&#xA;&#x9;&#x9;for i := index + 1; i &lt; len(nums); i++ {&#xA;&#x9;&#x9;&#x9;if (value + nums[i]) == target {&#xA;&#x9;&#x9;&#x9;&#x9;return []int{index, i}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return nil&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;fmt.Println(twoSum([]int{3, 2, 4}, 6))&#xA;}&#xA;```&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>20. 有效的括号</title>
      <link>https://example.com/leetcode/docs/easy/20/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/20/</guid>
      <description>&lt;h1 id=&#34;20-有效的括号&#34;&gt;&#xA;  20. 有效的括号&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#20-%e6%9c%89%e6%95%88%e7%9a%84%e6%8b%ac%e5%8f%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/valid-parentheses/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/valid-parentheses/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;解题思路&#34;&gt;&#xA;  解题思路&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;判断括号的有效性可以使用「栈」这一数据结构来解决。&lt;/p&gt;&#xA;&lt;p&gt;我们遍历给定的字符串 s。当我们遇到一个&lt;strong&gt;左括号&lt;/strong&gt;时，我们会期望在后续的遍历中，有一个相同类型的&lt;strong&gt;右括号&lt;/strong&gt;将其闭合。由于&#xA;&lt;strong&gt;后遇到的左括号要先闭合&lt;/strong&gt;，因此我们可以将这个&lt;strong&gt;左括号放入栈顶&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回&#xA;&lt;code&gt;False&lt;/code&gt;。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。&lt;strong&gt;哈希表的键为右括号，值为相同类型的左括号&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 &lt;code&gt;True&lt;/code&gt;，否则返回 &lt;code&gt;False&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 &lt;code&gt;False&lt;/code&gt;，省去后续的遍历判断过程。&lt;/p&gt;&#xA;&lt;h2 id=&#34;具体实现&#34;&gt;&#xA;  具体实现&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-0&#34; checked=&#34;checked&#34; /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-0&#34;&gt;Go&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func isValid(s string) bool {&#xA;&#x9;n := len(s)&#xA;&#xA;&#x9;if n%2 != 0 { // 奇数直接退出&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#xA;&#x9;pairs := map[byte]byte{&#xA;&#x9;&#x9;&#39;)&#39;: &#39;(&#39;,&#xA;&#x9;&#x9;&#39;]&#39;: &#39;[&#39;,&#xA;&#x9;&#x9;&#39;}&#39;: &#39;{&#39;,&#xA;&#x9;}&#xA;&#xA;&#x9;stack := []byte{}&#xA;&#x9;for i := 0; i &lt; n; i++ {&#xA;&#x9;&#x9;if pairs[s[i]] &gt; 0 { // 如果是右括号,判断栈顶是否是对应的左括号,果然有对应的左括号,则弹出栈顶元素,否则直接退出&#xA;&#x9;&#x9;&#x9;if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] {&#xA;&#x9;&#x9;&#x9;&#x9;return false&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;stack = stack[:len(stack)-1]&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;stack = append(stack, s[i])&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return len(stack) == 0&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;fmt.Println(isValid(&#34;()[]{}&#34;))&#xA;}&#xA;&#xA;```&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>21. 合并两个有序链表</title>
      <link>https://example.com/leetcode/docs/easy/21/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/21/</guid>
      <description>&lt;h1 id=&#34;21-合并两个有序链表&#34;&gt;&#xA;  21. 合并两个有序链表&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#21-%e5%90%88%e5%b9%b6%e4%b8%a4%e4%b8%aa%e6%9c%89%e5%ba%8f%e9%93%be%e8%a1%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/merge-two-sorted-lists/description/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/merge-two-sorted-lists/description/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;解题思路&#34;&gt;&#xA;  解题思路&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;递归解法&#34;&gt;&#xA;  递归解法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%92%e5%bd%92%e8%a7%a3%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;参考 &#xA;  &lt;a href=&#34;https://leetcode.cn/problems/merge-two-sorted-lists/solutions/103891/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/&#34;&gt;一看就会，一写就废？详解递归&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;p&gt;递归的核心在于，我只关注我这一层要干什么，返回什么，至于我的下一层（规模减 1），我不管，我就是甩手掌柜。&lt;/p&gt;&#xA;&lt;p&gt;那么现在我要 merge L1，L2 我需要怎么做❓&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当一条链表为空时，&lt;strong&gt;返回对方&lt;/strong&gt;，因为如果返回自己，就退出了，返回对方，不管对方是什么，让下级去判断。&lt;/li&gt;&#xA;&lt;li&gt;如果 L1 第一个元素小于 L2 的？那我得把 L1 的这个元素放到最前面，至于后面的那串长啥样，我不管。我只要接过下级员工干完活后给我的包裹，然后把我干的活附上去（令 L1-&amp;gt;next = 这个包裹）就行。&lt;/li&gt;&#xA;&lt;li&gt;这个包裹是下级员工干的活，即&lt;code&gt;merge(L1-&amp;gt;next,L2)&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;我该返回啥❓&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;现在不管我的下一层干了什么，又返回了什么给我，我只要知道，假设我的工具人们都完成了任务，那我的任务也就完成了，可以返回最终结果了。&lt;/li&gt;&#xA;&lt;li&gt;最终结果就是我一开始接手的 L1 头结点+下级员工给我的大包裹，要一并交上去，这样我的 boss 才能根据我给它的 L1 头节点往下找，检查我完成的工作。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;具体实现&#34;&gt;&#xA;  具体实现&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-0&#34; checked=&#34;checked&#34; /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-0&#34;&gt;Go 递归&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;type ListNode struct {&#xA;&#x9;Val  int&#xA;&#x9;Next *ListNode&#xA;}&#xA;&#xA;func mergeTwoLists(list1 *ListNode, list2 *ListNode) (x *ListNode) {&#xA;&#x9;if list1 == nil {&#xA;&#x9;&#x9;return list2&#xA;&#x9;}&#xA;&#x9;if list2 == nil {&#xA;&#x9;&#x9;return list1&#xA;&#x9;}&#xA;&#xA;&#x9;if list1.Val &lt;= list2.Val {&#xA;&#x9;&#x9;list1.Next = mergeTwoLists(list1.Next, list2)&#xA;&#x9;&#x9;return list1&#xA;&#x9;} else {&#xA;&#x9;&#x9;list2.Next = mergeTwoLists(list2.Next, list1)&#xA;&#x9;&#x9;return list2&#xA;&#x9;}&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;x := mergeTwoLists(&amp;ListNode{Val: 1, Next: &amp;ListNode{&#xA;&#x9;&#x9;Val: 2,&#xA;&#x9;&#x9;Next: &amp;ListNode{&#xA;&#x9;&#x9;&#x9;Val:  4,&#xA;&#x9;&#x9;&#x9;Next: nil,&#xA;&#x9;&#x9;},&#xA;&#x9;}}, &amp;ListNode{Val: 1, Next: &amp;ListNode{&#xA;&#x9;&#x9;Val: 3,&#xA;&#x9;&#x9;Next: &amp;ListNode{&#xA;&#x9;&#x9;&#x9;Val:  4,&#xA;&#x9;&#x9;&#x9;Next: nil,&#xA;&#x9;&#x9;},&#xA;&#x9;}})&#xA;&#x9;fmt.Println(x)&#xA;}&#xA;&#xA;```&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-1&#34;  /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-1&#34;&gt;Go 迭代&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;type ListNode struct {&#xA;&#x9;Val  int&#xA;&#x9;Next *ListNode&#xA;}&#xA;&#xA;func mergeTwoLists(list1 *ListNode, list2 *ListNode) (x *ListNode) {&#xA;&#x9;// 方便遍历完成后快速找到头节点&#xA;&#x9;dummy := &amp;ListNode{}&#xA;&#x9;prev := dummy&#xA;&#xA;&#x9;for list1 != nil &amp;&amp; list2 != nil {&#xA;&#x9;&#x9;if list1.Val &gt;= list2.Val {&#xA;&#x9;&#x9;&#x9;prev.Next = list2&#xA;&#x9;&#x9;&#x9;list2 = list2.Next&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;prev.Next = list1&#xA;&#x9;&#x9;&#x9;list1 = list1.Next&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;prev = prev.Next&#xA;&#x9;}&#xA;&#xA;&#x9;if list1 != nil {&#xA;&#x9;&#x9;prev.Next = list1&#xA;&#x9;}&#xA;&#x9;if list2 != nil {&#xA;&#x9;&#x9;prev.Next = list2&#xA;&#x9;}&#xA;&#xA;&#x9;return dummy.Next&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;x := mergeTwoLists(&amp;ListNode{Val: 1, Next: &amp;ListNode{&#xA;&#x9;&#x9;Val: 2,&#xA;&#x9;&#x9;Next: &amp;ListNode{&#xA;&#x9;&#x9;&#x9;Val:  4,&#xA;&#x9;&#x9;&#x9;Next: nil,&#xA;&#x9;&#x9;},&#xA;&#x9;}}, &amp;ListNode{Val: 1, Next: &amp;ListNode{&#xA;&#x9;&#x9;Val: 3,&#xA;&#x9;&#x9;Next: &amp;ListNode{&#xA;&#x9;&#x9;&#x9;Val:  4,&#xA;&#x9;&#x9;&#x9;Next: nil,&#xA;&#x9;&#x9;},&#xA;&#x9;}})&#xA;&#x9;fmt.Println(x)&#xA;}&#xA;&#xA;```&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  参考&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://www.bilibili.com/video/BV1qL411X7vz&#34;&gt;B 站 - 合并两个有序链表&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/merge-two-sorted-lists/solutions/226408/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/&#34;&gt;LeetCode - 合并两个有序链表&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>27. 移除元素</title>
      <link>https://example.com/leetcode/docs/easy/27/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/27/</guid>
      <description>&lt;h1 id=&#34;27-移除元素&#34;&gt;&#xA;  27. 移除元素&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#27-%e7%a7%bb%e9%99%a4%e5%85%83%e7%b4%a0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/remove-element/description/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/remove-element/description/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;解题思路&#34;&gt;&#xA;  解题思路&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;暴力法&#34;&gt;&#xA;  暴力法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9a%b4%e5%8a%9b%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;TODO&lt;/p&gt;&#xA;&lt;h3 id=&#34;双指针法&#34;&gt;&#xA;  双指针法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%8c%e6%8c%87%e9%92%88%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;可以用双指针/快慢指针来解决。快指针用来寻找新数组的元素，新数组就是不含有目标元素的数组，慢指针用来指向更新新数组下标的位置。这里需要的注意的是，“新数组”其实就是旧数组，因为一直都在在同一个数组上的操作，这也是题目的要求👇&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;不要使用额外的数组空间，你必须仅使用&lt;code&gt;O(1)&lt;/code&gt;额外空间并&lt;strong&gt;原地&lt;/strong&gt;修改输入数组。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;具体实现&#34;&gt;&#xA;  具体实现&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-0&#34; checked=&#34;checked&#34; /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-0&#34;&gt;Go双指针&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func removeElement(nums []int, val int) int {&#xA;&#x9;length := len(nums)&#xA;&#x9;low := 0&#xA;&#x9;for i := 0; i &lt; length; i++ {&#xA;&#x9;&#x9;if nums[i] != val {&#xA;&#x9;&#x9;&#x9;nums[low] = nums[i]&#xA;&#x9;&#x9;&#x9;low++&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return low&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;x := []int{1, 2, 6, 7, 9, 6, 6, 6}&#xA;&#x9;xx := removeElement(x, 6)&#xA;&#x9;fmt.Println(x, xx)&#xA;}&#xA;&#xA;```&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-1&#34;  /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-1&#34;&gt;Go暴力法&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func removeElement(nums []int, val int) int {&#xA;&#x9;if len(nums) == 0 {&#xA;&#x9;&#x9;return 0&#xA;&#x9;}&#xA;&#xA;&#x9;length := len(nums)&#xA;&#x9;for i := 0; i &lt; length; i++ {&#xA;&#x9;&#x9;if nums[i] == val { // 发现需要移除的元素，就将数组集体向前移动一位&#xA;&#x9;&#x9;&#x9;for j := i + 1; j &lt; length; j++ {&#xA;&#x9;&#x9;&#x9;&#x9;nums[j-1] = nums[j]&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;// 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位&#xA;&#x9;&#x9;&#x9;// 因为不知道移动过来的第一位的值是不是 val&#xA;&#x9;&#x9;&#x9;i--&#xA;&#x9;&#x9;&#x9;length-- // 此时数组的大小-1&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;return length&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;x := []int{1, 2, 6, 7, 9, 6, 6, 6}&#xA;&#x9;xx := removeElement(x, 6)&#xA;&#x9;fmt.Println(x, xx)&#xA;}&#xA;&#xA;```&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  参考&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html&#34;&gt;27. 移除元素&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>😪104. 二叉树的最大深度</title>
      <link>https://example.com/leetcode/docs/easy/104/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/104/</guid>
      <description>&lt;h1 id=&#34;104-二叉树的最大深度&#34;&gt;&#xA;  104. 二叉树的最大深度&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#104-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e5%a4%a7%e6%b7%b1%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/maximum-depth-of-binary-tree/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/maximum-depth-of-binary-tree/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>242. 有效的字母异位词</title>
      <link>https://example.com/leetcode/docs/easy/242/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/242/</guid>
      <description>&lt;h1 id=&#34;242-有效的字母异位词&#34;&gt;&#xA;  242. 有效的字母异位词&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#242-%e6%9c%89%e6%95%88%e7%9a%84%e5%ad%97%e6%af%8d%e5%bc%82%e4%bd%8d%e8%af%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/valid-anagram/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/valid-anagram/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;解题思路&#34;&gt;&#xA;  解题思路&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;map&#34;&gt;&#xA;  map&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#map&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;具体实现&#34;&gt;&#xA;  具体实现&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-0&#34; checked=&#34;checked&#34; /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-0&#34;&gt;Go map&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func isAnagram(s string, t string) bool {&#xA;&#x9;if len(s) != len(t) {&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#xA;&#x9;var arr [26]int&#xA;&#xA;&#x9;for i := 0; i &lt; len(s); i++ {&#xA;&#x9;&#x9;arr[s[i]-&#39;a&#39;]++&#xA;&#x9;}&#xA;&#x9;for i := 0; i &lt; len(t); i++ {&#xA;&#x9;&#x9;arr[t[i]-&#39;a&#39;]--&#xA;&#x9;}&#xA;&#xA;&#x9;for _, each := range arr {&#xA;&#x9;&#x9;if each &gt; 0 {&#xA;&#x9;&#x9;&#x9;return false&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return true&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;fmt.Println(isAnagram(&#34;abc&#34;, &#34;bcc&#34;))&#xA;}&#xA;&#xA;&#xA;```&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-1&#34;  /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-1&#34;&gt;方法2&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func isAnagram(s string, t string) bool {&#xA;&#x9;if len(s) != len(t) {&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#xA;&#x9;count := make(map[int32]int)&#xA;&#x9;for _, w := range s {&#xA;&#x9;&#x9;if _, ok := count[w]; ok {&#xA;&#x9;&#x9;&#x9;count[w]++&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;count[w] = 1&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;for _, w := range t {&#xA;&#x9;&#x9;if _, ok := count[w]; ok {&#xA;&#x9;&#x9;&#x9;count[w]--&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;for _, v := range count {&#xA;&#x9;&#x9;if v != 0 {&#xA;&#x9;&#x9;&#x9;return false&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return true&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;fmt.Println(isAnagram(&#34;anagram&#34;, &#34;nagaram&#34;))&#xA;}&#xA;&#xA;```&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>141. 环形链表</title>
      <link>https://example.com/leetcode/docs/easy/141/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/141/</guid>
      <description>&lt;h1 id=&#34;141-环形链表&#34;&gt;&#xA;  141. 环形链表&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#141-%e7%8e%af%e5%bd%a2%e9%93%be%e8%a1%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/linked-list-cycle/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/linked-list-cycle/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;解题思路&#34;&gt;&#xA;  解题思路&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;具体实现&#34;&gt;&#xA;  具体实现&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-0&#34; checked=&#34;checked&#34; /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-0&#34;&gt;Go&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;type ListNode struct {&#xA;&#x9;Val  int&#xA;&#x9;Next *ListNode&#xA;}&#xA;&#xA;func hasCycle(head *ListNode) bool {&#xA;&#x9;slow, fast := head, head&#xA;&#x9;for fast != nil &amp;&amp; fast.Next != nil {&#xA;&#x9;&#x9;slow = slow.Next&#xA;&#x9;&#x9;fast = fast.Next.Next&#xA;&#x9;&#x9;if slow == fast {&#xA;&#x9;&#x9;&#x9;return true&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return false&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;createLinkedList := func(arr []int) *ListNode {&#xA;&#x9;&#x9;if len(arr) == 0 {&#xA;&#x9;&#x9;&#x9;return nil&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;head := &amp;ListNode{Val: arr[0]}&#xA;&#x9;&#x9;current := head&#xA;&#x9;&#x9;for i := 1; i &lt; len(arr); i++ {&#xA;&#x9;&#x9;&#x9;node := &amp;ListNode{Val: arr[i]}&#xA;&#x9;&#x9;&#x9;current.Next = node&#xA;&#x9;&#x9;&#x9;current = node&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Make it a circular linked list (connect the last node to the head)&#xA;&#x9;&#x9;current.Next = head&#xA;&#xA;&#x9;&#x9;return head&#xA;&#x9;}&#xA;&#xA;&#x9;arr := []int{1, 2, 3, 4, 5}&#xA;&#x9;head := createLinkedList(arr)&#xA;&#x9;head.Next.Next.Next.Next.Next = head.Next&#xA;&#xA;&#x9;// Test the hasCycle function&#xA;&#x9;if hasCycle(head) {&#xA;&#x9;&#x9;fmt.Println(&#34;The linked list has a cycle.&#34;)&#xA;&#x9;} else {&#xA;&#x9;&#x9;fmt.Println(&#34;The linked list does not have a cycle.&#34;)&#xA;&#x9;}&#xA;}&#xA;&#xA;```&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>160. 相交链表</title>
      <link>https://example.com/leetcode/docs/easy/160/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/160/</guid>
      <description>&lt;h1 id=&#34;160-相交链表&#34;&gt;&#xA;  160. 相交链表&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#160-%e7%9b%b8%e4%ba%a4%e9%93%be%e8%a1%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/intersection-of-two-linked-lists/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/intersection-of-two-linked-lists/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;解题思路&#34;&gt;&#xA;  解题思路&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;如果两个链表相交，那么相交点之后的长度是相同的。&lt;/p&gt;&#xA;&lt;p&gt;所以，我们需要做的事情是，让两个链表从&lt;strong&gt;距离末尾同等距离的位置&lt;/strong&gt;开始遍历。而这个位置只能是较短链表的头结点位置。为此，需要求出两个链表的长度并消除两个链表的长度差。&lt;/p&gt;&#xA;&lt;h2 id=&#34;具体实现&#34;&gt;&#xA;  具体实现&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-0&#34; checked=&#34;checked&#34; /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-0&#34;&gt;Go&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;type ListNode struct {&#xA;&#x9;Next *ListNode&#xA;&#x9;Val  int&#xA;}&#xA;&#xA;func getIntersectionNode(headA, headB *ListNode) *ListNode {&#xA;&#x9;if headA == nil || headB == nil {&#xA;&#x9;&#x9;return nil&#xA;&#x9;}&#xA;&#xA;&#x9;var (&#xA;&#x9;&#x9;currA, currB = headA, headB&#xA;&#x9;&#x9;lenA, lenB   int&#xA;&#x9;)&#xA;&#x9;// 计算链表的长度&#xA;&#x9;for currA != nil {&#xA;&#x9;&#x9;lenA++&#xA;&#x9;&#x9;currA = currA.Next&#xA;&#x9;}&#xA;&#xA;&#x9;for currB != nil {&#xA;&#x9;&#x9;lenB++&#xA;&#x9;&#x9;currB = currB.Next&#xA;&#x9;}&#xA;&#xA;&#x9;currA, currB = headA, headB&#xA;&#xA;&#x9;// 判断谁是最长的,把最长的赋值给 currA&#xA;&#x9;gap := 0&#xA;&#x9;if lenA &gt;= lenB {&#xA;&#x9;&#x9;gap = lenA - lenB&#xA;&#x9;} else {&#xA;&#x9;&#x9;gap = lenB - lenA&#xA;&#x9;&#x9;currA, currB = currB, currA&#xA;&#x9;}&#xA;&#xA;&#x9;for gap &gt; 0 { // 移动最大的位置&#xA;&#x9;&#x9;currA = currA.Next&#xA;&#x9;&#x9;gap--&#xA;&#x9;}&#xA;&#xA;&#x9;// 同时移动&#xA;&#x9;for currA != nil {&#xA;&#x9;&#x9;if currA == currB {&#xA;&#x9;&#x9;&#x9;return currA // 这里 return currB 也行&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;currA = currA.Next&#xA;&#x9;&#x9;currB = currB.Next&#xA;&#x9;}&#xA;&#xA;&#x9;return nil&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;t := &amp;ListNode{&#xA;&#x9;&#x9;Next: &amp;ListNode{&#xA;&#x9;&#x9;&#x9;Next: nil,&#xA;&#x9;&#x9;&#x9;Val:  9,&#xA;&#x9;&#x9;},&#xA;&#x9;&#x9;Val: 8,&#xA;&#x9;}&#xA;&#xA;&#x9;ca := &amp;ListNode{&#xA;&#x9;&#x9;Next: &amp;ListNode{&#xA;&#x9;&#x9;&#x9;Next: t,&#xA;&#x9;&#x9;&#x9;Val:  2,&#xA;&#x9;&#x9;},&#xA;&#x9;&#x9;Val: 1,&#xA;&#x9;}&#xA;&#xA;&#x9;cb := &amp;ListNode{&#xA;&#x9;&#x9;Next: &amp;ListNode{&#xA;&#x9;&#x9;&#x9;Next: &amp;ListNode{&#xA;&#x9;&#x9;&#x9;&#x9;Next: t,&#xA;&#x9;&#x9;&#x9;&#x9;Val:  5,&#xA;&#x9;&#x9;&#x9;},&#xA;&#x9;&#x9;&#x9;Val: 4,&#xA;&#x9;&#x9;},&#xA;&#x9;&#x9;Val: 3,&#xA;&#x9;}&#xA;&#x9;ret := getIntersectionNode(ca, cb)&#xA;&#x9;fmt.Println(ret)&#xA;}&#xA;&#xA;```&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>203. 移除链表元素</title>
      <link>https://example.com/leetcode/docs/easy/203/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/203/</guid>
      <description>&lt;h1 id=&#34;203-移除链表元素&#34;&gt;&#xA;  203. 移除链表元素&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#203-%e7%a7%bb%e9%99%a4%e9%93%be%e8%a1%a8%e5%85%83%e7%b4%a0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/remove-linked-list-elements/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/remove-linked-list-elements/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;解题思路&#34;&gt;&#xA;  解题思路&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;参看 &#xA;  &lt;a href=&#34;https://leetcode.cn/problems/remove-linked-list-elements/solutions/813358/yi-chu-lian-biao-yuan-su-by-leetcode-sol-654m/&#34;&gt;https://leetcode.cn/problems/remove-linked-list-elements/solutions/813358/yi-chu-lian-biao-yuan-su-by-leetcode-sol-654m/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;迭代法&#34;&gt;&#xA;  迭代法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%ad%e4%bb%a3%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;用 &lt;code&gt;curr&lt;/code&gt; 表示当前节点。如果 &lt;code&gt;curr&lt;/code&gt; 的下一个节点不为空且下一个节点的节点值等于给定的 &lt;code&gt;val&lt;/code&gt;，则需要删除下一个节点。删除下一个节点可以通过 &lt;code&gt;curr.next=curr.next.next&lt;/code&gt; 实现。&lt;/p&gt;&#xA;&lt;p&gt;如果 &lt;code&gt;curr&lt;/code&gt; 的下一个节点的节点值不等于给定的 &lt;code&gt;val&lt;/code&gt;，则保留下一个节点，将 &lt;code&gt;curr&lt;/code&gt; 移动到下一个节点即可。&lt;/p&gt;&#xA;&lt;p&gt;当&lt;code&gt;curr&lt;/code&gt;的下一个节点为空时，链表遍历结束，此时所有节点值等于 &lt;code&gt;val&lt;/code&gt; 的节点都被删除。&lt;/p&gt;&#xA;&lt;p&gt;具体实现方面，由于链表的头节点 &lt;code&gt;head&lt;/code&gt; 有可能需要被删除，因此创建哑节点/虚拟节点 &lt;code&gt;dummyHead&lt;/code&gt;，令 &lt;code&gt;dummyHead.next=head&lt;/code&gt;，初始化 &lt;code&gt;curr=dummyHead&lt;/code&gt;，然后遍历链表进行删除操作。最终返回&lt;code&gt;dummyHead.next&lt;/code&gt;即为删除操作后的头节点。&lt;/p&gt;&#xA;&lt;p&gt;为什么要用 &lt;code&gt;curr=dummyHead&lt;/code&gt;❓，这样 &lt;code&gt;curr&lt;/code&gt; 指向的地址跟 &lt;code&gt;dummyHead&lt;/code&gt; 指向的地址是一样的，如果不提前赋值，那么迭代到最后&lt;code&gt;dummyHead.Next&lt;/code&gt;就是&lt;code&gt;nil&lt;/code&gt;，不能正确的返回头结点，所以重新赋值后，用 &lt;code&gt;curr&lt;/code&gt; 去循环 &lt;code&gt;dummyHead.Next&lt;/code&gt; 还是正常的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;递归法&#34;&gt;&#xA;  递归法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%92%e5%bd%92%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;链表的定义具有递归的性质，因此链表题目常可以用递归的方法求解。&lt;/p&gt;&#xA;&lt;p&gt;递归的核心在于，我只关注我这一层要干什么，返回什么，至于我的下一层（规模减 1），我不管，我就是甩手掌柜。&lt;/p&gt;&#xA;&lt;p&gt;那么现在我要删除特定链表元素，我需要怎么做❓&lt;/p&gt;&#xA;&lt;p&gt;如果链表是&lt;code&gt;nil&lt;/code&gt;我就直接返回，我的 next 让工具人函数去判断，当工具人函数做完判断给我之后，我按需 return，也就是如果 &lt;code&gt;head.Val == val&lt;/code&gt; return &lt;code&gt;head.Next&lt;/code&gt;，否则直接 return head。&lt;/p&gt;&#xA;&lt;h2 id=&#34;具体实现&#34;&gt;&#xA;  具体实现&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-0&#34; checked=&#34;checked&#34; /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-0&#34;&gt;Go迭代&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;func removeElements(head *ListNode, val int) *ListNode {&#xA;&#x9;dummyHead := &amp;ListNode{&#xA;&#x9;&#x9;Val:  0,&#xA;&#x9;&#x9;Next: head,&#xA;&#x9;}&#xA;&#xA;&#x9;curr := dummyHead&#xA;&#x9;fmt.Println(dummyHead, curr)&#xA;&#x9;for curr.Next != nil {&#xA;&#x9;&#x9;if curr.Next.Val == val {&#xA;&#x9;&#x9;&#x9;curr.Next = curr.Next.Next&#xA;&#x9;&#x9;&#x9;// 需要注意：这里不需要再使用 curr = curr.Next，因为指针已经移动了&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;curr = curr.Next&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return dummyHead.Next&#xA;}&#xA;&#xA;type ListNode struct {&#xA;&#x9;Val  int&#xA;&#x9;Next *ListNode&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;x := removeElements(&amp;ListNode{&#xA;&#x9;&#x9;Val: 1,&#xA;&#x9;&#x9;Next: &amp;ListNode{&#xA;&#x9;&#x9;&#x9;Val: 2,&#xA;&#x9;&#x9;&#x9;Next: &amp;ListNode{&#xA;&#x9;&#x9;&#x9;&#x9;Val: 1,&#xA;&#x9;&#x9;&#x9;&#x9;Next: &amp;ListNode{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Val:  3,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Next: nil,&#xA;&#x9;&#x9;&#x9;&#x9;},&#xA;&#x9;&#x9;&#x9;},&#xA;&#x9;&#x9;},&#xA;&#x9;}, 1)&#xA;&#xA;&#x9;fmt.Println(x)&#xA;}&#xA;&#xA;&#xA;```&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-1&#34;  /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-1&#34;&gt;Go递归&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;````go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;type ListNode struct {&#xA;&#x9;Val  int&#xA;&#x9;Next *ListNode&#xA;}&#xA;&#xA;func removeElements(head *ListNode, val int) *ListNode {&#xA;&#x9;if head == nil {&#xA;&#x9;&#x9;return head&#xA;&#x9;}&#xA;&#xA;&#x9;head.Next = removeElements(head.Next, val)&#xA;&#x9;if head.Val == val {&#xA;&#x9;&#x9;return head.Next&#xA;&#x9;}&#xA;&#xA;&#x9;return head&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;x := removeElements(&amp;ListNode{&#xA;&#x9;&#x9;Val: 1,&#xA;&#x9;&#x9;Next: &amp;ListNode{&#xA;&#x9;&#x9;&#x9;Val: 2,&#xA;&#x9;&#x9;&#x9;Next: &amp;ListNode{&#xA;&#x9;&#x9;&#x9;&#x9;Val: 1,&#xA;&#x9;&#x9;&#x9;&#x9;Next: &amp;ListNode{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Val:  3,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Next: nil,&#xA;&#x9;&#x9;&#x9;&#x9;},&#xA;&#x9;&#x9;&#x9;},&#xA;&#x9;&#x9;},&#xA;&#x9;}, 1)&#xA;&#xA;&#x9;fmt.Println(x)&#xA;}&#xA;&#xA;````&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>206. 反转链表</title>
      <link>https://example.com/leetcode/docs/easy/206/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/206/</guid>
      <description>&lt;h1 id=&#34;206-反转链表&#34;&gt;&#xA;  206. 反转链表&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#206-%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/reverse-linked-list/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/reverse-linked-list/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;类似/相同题目：&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/&#34;&gt;剑指 Offer 24. 反转链表&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;解题思路&#34;&gt;&#xA;  解题思路&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;迭代法&#34;&gt;&#xA;  迭代法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%ad%e4%bb%a3%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;TODO&lt;/p&gt;&#xA;&lt;h3 id=&#34;递归法&#34;&gt;&#xA;  递归法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%92%e5%bd%92%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;TODO&lt;/p&gt;&#xA;&lt;h2 id=&#34;具体实现&#34;&gt;&#xA;  具体实现&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-0&#34; checked=&#34;checked&#34; /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-0&#34;&gt;Go迭代&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;type ListNode struct {&#xA;&#x9;Val  int&#xA;&#x9;Next *ListNode&#xA;}&#xA;&#xA;func reverseList(head *ListNode) *ListNode {&#xA;&#x9;if head == nil {&#xA;&#x9;&#x9;return nil&#xA;&#x9;}&#xA;&#xA;&#x9;var (&#xA;&#x9;&#x9;prev, next *ListNode&#xA;&#x9;&#x9;curr       = head&#xA;&#x9;)&#xA;&#xA;&#x9;for curr != nil {&#xA;&#x9;&#x9;next = curr.Next&#xA;&#x9;&#x9;curr.Next = prev&#xA;&#x9;&#x9;// 下一个&#xA;&#x9;&#x9;prev = curr&#xA;&#x9;&#x9;curr = next&#xA;&#x9;}&#xA;&#xA;&#x9;return prev&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;reverseList(&amp;ListNode{&#xA;&#x9;&#x9;Val: 1, Next: &amp;ListNode{Val: 2, Next: &amp;ListNode{Val: 3, Next: &amp;ListNode{Val: 4, Next: &amp;ListNode{Val: 5}}}}})&#xA;}&#xA;&#xA;```&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-1&#34;  /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-1&#34;&gt;Go递归&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;type ListNode struct {&#xA;&#x9;Val  int&#xA;&#x9;Next *ListNode&#xA;}&#xA;&#xA;func reverseList(head *ListNode) *ListNode {&#xA;&#x9;// head == null：当第一次输入为 nil 的时候直接返回 nil，不进行递归操作。&#xA;&#x9;// head.next == null：返回链表的最后一个节点&#xA;&#x9;if head == nil || head.Next == nil {&#xA;&#x9;&#x9;return head&#xA;&#x9;}&#xA;&#xA;&#x9;newHead := reverseList(head.Next)&#xA;&#x9;head.Next.Next = head&#xA;&#x9;head.Next = nil&#xA;&#xA;&#x9;return newHead&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;x := reverseList(&amp;ListNode{&#xA;&#x9;&#x9;Val: 1,&#xA;&#x9;&#x9;Next: &amp;ListNode{&#xA;&#x9;&#x9;&#x9;Val: 2,&#xA;&#x9;&#x9;&#x9;Next: &amp;ListNode{&#xA;&#x9;&#x9;&#x9;&#x9;Val: 3,&#xA;&#x9;&#x9;&#x9;&#x9;Next: &amp;ListNode{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Val:  4,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Next: nil,&#xA;&#x9;&#x9;&#x9;&#x9;},&#xA;&#x9;&#x9;&#x9;},&#xA;&#x9;&#x9;},&#xA;&#x9;})&#xA;&#x9;fmt.Println(x)&#xA;}&#xA;&#xA;```&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  参考&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://www.bilibili.com/video/BV1bg4y1s7vS/&#34;&gt;反转链表递归（动画演示、手写 Java 代码、详细注释、LeetCode 高频算法题）&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>232. 用栈实现队列</title>
      <link>https://example.com/leetcode/docs/easy/232/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/232/</guid>
      <description>&lt;h1 id=&#34;232-用栈实现队列&#34;&gt;&#xA;  232. 用栈实现队列&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#232-%e7%94%a8%e6%a0%88%e5%ae%9e%e7%8e%b0%e9%98%9f%e5%88%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/implement-queue-using-stacks/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/implement-queue-using-stacks/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>344. 反转字符串</title>
      <link>https://example.com/leetcode/docs/easy/344/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/344/</guid>
      <description>&lt;h1 id=&#34;344-反转字符串&#34;&gt;&#xA;  344. 反转字符串&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#344-%e5%8f%8d%e8%bd%ac%e5%ad%97%e7%ac%a6%e4%b8%b2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/reverse-string/description/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/reverse-string/description/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;解题思路&#34;&gt;&#xA;  解题思路&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;双指针法&#34;&gt;&#xA;  双指针法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%8c%e6%8c%87%e9%92%88%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;对于长度为&lt;code&gt;N&lt;/code&gt;的待被反转的字符数组，我们可以观察反转前后下标的变化，假设反转前字符数组为&lt;code&gt;s[0] s[1] s[2] ... s[N - 1]&lt;/code&gt;，那么反转后字符数组为&lt;code&gt;s[N - 1] s[N - 2] ... s[0]&lt;/code&gt;。比较反转前后下标变化很容易得出&lt;code&gt;s[i]&lt;/code&gt;的字符与&lt;code&gt;s[N - 1 - i]&lt;/code&gt;的字符发生了交换的规律，因此我们可以得出如下双指针的解法：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将&lt;code&gt;left&lt;/code&gt;指向字符数组首元素，&lt;code&gt;right&lt;/code&gt;指向字符数组尾元素。&lt;/li&gt;&#xA;&lt;li&gt;当&lt;code&gt;left &amp;lt; right&lt;/code&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;交换&lt;code&gt;s[left]&lt;/code&gt;和&lt;code&gt;s[right]&lt;/code&gt;；&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;left&lt;/code&gt;指针右移一位，即&lt;code&gt;left = left + 1&lt;/code&gt;；&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;right&lt;/code&gt;指针左移一位，即&lt;code&gt;right = right - 1&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;当&lt;code&gt;left &amp;gt;= right&lt;/code&gt;，反转结束，返回字符数组即可。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;具体实现&#34;&gt;&#xA;  具体实现&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-0&#34; checked=&#34;checked&#34; /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-0&#34;&gt;Go&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;func reverseString(s []byte) {&#xA;&#x9;length := len(s)&#xA;&#x9;if length == 0 {&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;left, right := 0, length-1&#xA;&#xA;&#x9;for left &lt; right {&#xA;&#x9;&#x9;tmp := s[left]&#xA;&#x9;&#x9;s[left] = s[right]&#xA;&#x9;&#x9;s[right] = tmp&#xA;&#x9;&#x9;left++&#xA;&#x9;&#x9;right--&#xA;&#x9;}&#xA;&#xA;&#x9;return&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;x := []byte{&#39;1&#39;, &#39;2&#39;, &#39;3&#39;}&#xA;&#x9;reverseString(x)&#xA;&#x9;fmt.Println(string(x))&#xA;}&#xA;&#xA;```&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>349. 两个数组的交集</title>
      <link>https://example.com/leetcode/docs/easy/349/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/349/</guid>
      <description>&lt;h1 id=&#34;349-两个数组的交集&#34;&gt;&#xA;  349. 两个数组的交集&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#349-%e4%b8%a4%e4%b8%aa%e6%95%b0%e7%bb%84%e7%9a%84%e4%ba%a4%e9%9b%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/intersection-of-two-arrays/description/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/intersection-of-two-arrays/description/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;解题思路&#34;&gt;&#xA;  解题思路&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;TODO&lt;/p&gt;&#xA;&lt;h2 id=&#34;具体实现&#34;&gt;&#xA;  具体实现&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-0&#34; checked=&#34;checked&#34; /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-0&#34;&gt;Go&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func intersection(nums1 []int, nums2 []int) []int {&#xA;&#x9;if len(nums1) == 0 || len(nums2) == 0 {&#xA;&#x9;&#x9;return []int{}&#xA;&#x9;}&#xA;&#xA;&#x9;var (&#xA;&#x9;&#x9;set = make(map[int]struct{}, 0)&#xA;&#x9;&#x9;ret = make([]int, 0)&#xA;&#x9;)&#xA;&#xA;&#x9;// 重复的会直接覆盖&#xA;&#x9;for _, each := range nums1 {&#xA;&#x9;&#x9;set[each] = struct{}{}&#xA;&#x9;}&#xA;&#xA;&#x9;for _, each := range nums2 {&#xA;&#x9;&#x9;if _, ok := set[each]; ok {&#xA;&#x9;&#x9;&#x9;ret = append(ret, each)&#xA;&#x9;&#x9;&#x9;delete(set, each)&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return ret&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;fmt.Println(intersection([]int{1, 2, 2, 1}, []int{2, 2}))&#xA;}&#xA;&#xA;```&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>451. 根据字符出现频率排序</title>
      <link>https://example.com/leetcode/docs/easy/541/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/541/</guid>
      <description>&lt;h1 id=&#34;451-根据字符出现频率排序&#34;&gt;&#xA;  451. 根据字符出现频率排序&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#451-%e6%a0%b9%e6%8d%ae%e5%ad%97%e7%ac%a6%e5%87%ba%e7%8e%b0%e9%a2%91%e7%8e%87%e6%8e%92%e5%ba%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/sort-characters-by-frequency/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/sort-characters-by-frequency/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>459. 重复的子字符串</title>
      <link>https://example.com/leetcode/docs/easy/459/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/459/</guid>
      <description>&lt;h1 id=&#34;459-重复的子字符串&#34;&gt;&#xA;  459. 重复的子字符串&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#459-%e9%87%8d%e5%a4%8d%e7%9a%84%e5%ad%90%e5%ad%97%e7%ac%a6%e4%b8%b2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/repeated-substring-pattern/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/repeated-substring-pattern/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>496. 下一个更大元素 I</title>
      <link>https://example.com/leetcode/docs/easy/496/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/496/</guid>
      <description>&lt;h1 id=&#34;496-下一个更大元素-i&#34;&gt;&#xA;  496. 下一个更大元素 I&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#496-%e4%b8%8b%e4%b8%80%e4%b8%aa%e6%9b%b4%e5%a4%a7%e5%85%83%e7%b4%a0-i&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/next-greater-element-i/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/next-greater-element-i/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>682. 棒球比赛</title>
      <link>https://example.com/leetcode/docs/easy/682/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/682/</guid>
      <description>&lt;h1 id=&#34;682-棒球比赛&#34;&gt;&#xA;  682. 棒球比赛&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#682-%e6%a3%92%e7%90%83%e6%af%94%e8%b5%9b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/baseball-game/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/baseball-game/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>704. 二分查找</title>
      <link>https://example.com/leetcode/docs/easy/704/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/704/</guid>
      <description>&lt;h1 id=&#34;704-二分查找&#34;&gt;&#xA;  704. 二分查找&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#704-%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/binary-search/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/binary-search/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;解题思路&#34;&gt;&#xA;  解题思路&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;可以参考&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://www.bilibili.com/video/BV1fA4y1o715&#34;&gt;https://www.bilibili.com/video/BV1fA4y1o715&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#_704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE&#34;&gt;二分查找&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;对于常规实现来说，在解题时要区分区间，也就是&lt;code&gt;左闭右闭&lt;/code&gt;还是&lt;code&gt;左闭右开&lt;/code&gt;区间两种解法，其实就是要区分&lt;code&gt;右闭&lt;/code&gt;还是&lt;code&gt;右开&lt;/code&gt;，在临界条件判断时包不包含最右边的值。&lt;/p&gt;&#xA;&lt;p&gt;对于&lt;code&gt;左闭右闭&lt;/code&gt;来说，包含最右边，所以在临界条件判断时，左边的值可以等于右边的值，那么&lt;code&gt;right&lt;/code&gt;其实是&lt;code&gt;数组长度-1&lt;/code&gt;，也就是数组最后一个值。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;while (left &amp;lt;= right)&lt;/code&gt;，因为&lt;code&gt;left == right&lt;/code&gt;是有意义的，所以使用&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;if (nums[middle] &amp;gt; target)&lt;/code&gt;，&lt;code&gt;right&lt;/code&gt;要赋值为&lt;code&gt;middle - 1&lt;/code&gt;，因为当前这个&lt;code&gt;nums[middle]&lt;/code&gt;一定不是&lt;code&gt;target&lt;/code&gt;，那么接下来要查找的左区间结束下标位置就是&lt;code&gt;middle - 1&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;但是对于&lt;code&gt;左闭右开&lt;/code&gt;来说，因为不包含最右元素，那么&lt;code&gt;right&lt;/code&gt;其实就是数组长度，&lt;code&gt;right&lt;/code&gt; 取不到数组最后一个值。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;while (left &amp;lt; right)&lt;/code&gt;，因为&lt;code&gt;left == right&lt;/code&gt;在区间&lt;code&gt;[left, right)&lt;/code&gt;是没有意义的，所以这里要用&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;if (nums[middle] &amp;gt; target)&lt;/code&gt; &lt;code&gt;right&lt;/code&gt;更新为&lt;code&gt;middle&lt;/code&gt;，因为当前&lt;code&gt;nums[middle]&lt;/code&gt;不等于&lt;code&gt;target&lt;/code&gt;，去左区间继续寻找，而寻找区间是左闭右开区间，所以&lt;code&gt;right&lt;/code&gt;更新为&lt;code&gt;middle&lt;/code&gt;，也就是说，下一个查询区间不会去比较&lt;code&gt;nums[middle]&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;具体实现&#34;&gt;&#xA;  具体实现&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-0&#34; checked=&#34;checked&#34; /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-0&#34;&gt;Go&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;**区间左闭右闭**&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;arr := []int{0, 1, 2, 3, 4, 5, 10}&#xA;&#x9;fmt.Println(binarySearch(arr, 10))&#xA;}&#xA;&#xA;func binarySearch(nums []int, target int) int {&#xA;&#x9;left := 0&#xA;&#x9;right := len(nums) - 1&#xA;&#xA;&#x9;for left &lt;= right {&#xA;&#x9;&#x9;middle := (left + right) / 2&#xA;&#x9;&#x9;if target &gt; nums[middle] {&#xA;&#x9;&#x9;&#x9;left = middle + 1&#xA;&#x9;&#x9;} else if target &lt; nums[middle] {&#xA;&#x9;&#x9;&#x9;right = middle - 1&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;return middle&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return -1&#xA;}&#xA;&#xA;```&#xA;&#xA;**区间左闭右开**&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;arr := []int{0, 1, 2, 3, 4, 5, 10}&#xA;&#x9;fmt.Println(binarySearch(arr, 10))&#xA;}&#xA;&#xA;func binarySearch(nums []int, target int) int {&#xA;&#x9;left := 0&#xA;&#x9;right := len(nums)&#xA;&#xA;&#x9;for left &lt; right {&#xA;&#x9;&#x9;middle := (left + right) / 2&#xA;&#x9;&#x9;if target &gt; nums[middle] {&#xA;&#x9;&#x9;&#x9;left = middle + 1&#xA;&#x9;&#x9;} else if target &lt; nums[middle] {&#xA;&#x9;&#x9;&#x9;right = middle&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;return middle&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return -1&#xA;}&#xA;&#xA;```&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-1&#34;  /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-1&#34;&gt;Python&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;TODO&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>844. 比较含退格的字符串</title>
      <link>https://example.com/leetcode/docs/easy/844/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/844/</guid>
      <description>&lt;h1 id=&#34;844-比较含退格的字符串&#34;&gt;&#xA;  844. 比较含退格的字符串&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#844-%e6%af%94%e8%be%83%e5%90%ab%e9%80%80%e6%a0%bc%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/backspace-string-compare/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/backspace-string-compare/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>876. 链表的中间结点</title>
      <link>https://example.com/leetcode/docs/easy/876/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/876/</guid>
      <description>&lt;h1 id=&#34;876-链表的中间结点&#34;&gt;&#xA;  876. 链表的中间结点&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#876-%e9%93%be%e8%a1%a8%e7%9a%84%e4%b8%ad%e9%97%b4%e7%bb%93%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/middle-of-the-linked-list/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/middle-of-the-linked-list/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>977. 有序数组的平方</title>
      <link>https://example.com/leetcode/docs/easy/977/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/leetcode/docs/easy/977/</guid>
      <description>&lt;h1 id=&#34;977-有序数组的平方&#34;&gt;&#xA;  977. 有序数组的平方&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#977-%e6%9c%89%e5%ba%8f%e6%95%b0%e7%bb%84%e7%9a%84%e5%b9%b3%e6%96%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目地址&#34;&gt;&#xA;  题目地址&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%ae%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/squares-of-a-sorted-array/description/&#34;&gt;力扣&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://leetcode.com/problems/squares-of-a-sorted-array/description/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;解题思路&#34;&gt;&#xA;  解题思路&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;暴力法&#34;&gt;&#xA;  暴力法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9a%b4%e5%8a%9b%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;可以直接先计算平方，然后再利用库函数排序。&lt;/p&gt;&#xA;&lt;h3 id=&#34;双指针法&#34;&gt;&#xA;  双指针法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%8c%e6%8c%87%e9%92%88%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;可以参考&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html#%E6%9A%B4%E5%8A%9B%E6%8E%92%E5%BA%8F&#34;&gt;有序数组的平方&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;  &lt;a href=&#34;https://www.bilibili.com/video/BV1QB4y1D7ep&#34;&gt;B 站-有序数组的平方&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;数组其实是有序的，只不过负数平方之后可能成为最大数了。那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。此时可以考虑双指针法了，&lt;code&gt;i&lt;/code&gt;指向起始位置，&lt;code&gt;j&lt;/code&gt;指向终止位置。定义一个新数组 result，和 A 数组一样的大小，让&lt;code&gt;k&lt;/code&gt;指向 result 数组终止位置，也就是说让 k 从大（右）到小（左）填充。&lt;/p&gt;&#xA;&lt;p&gt;如果&lt;code&gt;A[i] * A[i] &amp;lt; A[j] * A[j]&lt;/code&gt; 那么&lt;code&gt;result[k--] = A[j] * A[j]&lt;/code&gt; 。&lt;/p&gt;&#xA;&lt;p&gt;如果&lt;code&gt;A[i] * A[i] &amp;gt;= A[j] * A[j]&lt;/code&gt;那么&lt;code&gt;result[k--] = A[i] * A[i]&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;具体实现&#34;&gt;&#xA;  具体实现&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-0&#34; checked=&#34;checked&#34; /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-0&#34;&gt;Go双指针&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func sortedSquares(nums []int) []int {&#xA;&#x9;if len(nums) == 0 {&#xA;&#x9;&#x9;return []int{}&#xA;&#x9;}&#xA;&#xA;&#x9;var (&#xA;&#x9;&#x9;result = make([]int, len(nums))&#xA;&#x9;&#x9;i, j   = 0, len(nums) - 1&#xA;&#x9;&#x9;k      = len(nums) - 1 // 能访问到最后一个值&#xA;&#x9;)&#xA;&#xA;&#x9;// 这里之所以要 &lt;= 是因为，如果仅仅是 &lt; 那么当 = 时会退出，&#xA;&#x9;// 这样就会漏掉了一个元素&#xA;&#x9;for i &lt;= j {&#xA;&#x9;&#x9;if nums[i]*nums[i] &gt; nums[j]*nums[j] {&#xA;&#x9;&#x9;&#x9;result[k] = nums[i] * nums[i]&#xA;&#x9;&#x9;&#x9;k--&#xA;&#x9;&#x9;&#x9;i++&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;result[k] = nums[j] * nums[j]&#xA;&#x9;&#x9;&#x9;k--&#xA;&#x9;&#x9;&#x9;j--&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return result&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;fmt.Println(sortedSquares([]int{-4, -1, 0, 3, 10}))&#xA;}&#xA;&#xA;```&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-uniqueid&#34; id=&#34;tabs-uniqueid-1&#34;  /&gt;&#xA;&lt;label for=&#34;tabs-uniqueid-1&#34;&gt;Go暴力法&lt;/label&gt;&#xA;&lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;sort&#34;&#xA;)&#xA;&#xA;func sortedSquares(nums []int) []int {&#xA;&#x9;if len(nums) == 0 {&#xA;&#x9;&#x9;return []int{}&#xA;&#x9;}&#xA;&#xA;&#x9;for index, item := range nums {&#xA;&#x9;&#x9;nums[index] = item * item&#xA;&#x9;}&#xA;&#xA;&#x9;sort.Ints(nums)&#xA;&#x9;return nums&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;fmt.Println(sortedSquares([]int{-4, -1, 0, 3, 10}))&#xA;}&#xA;&#xA;```&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
