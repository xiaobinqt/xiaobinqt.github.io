<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hard on LeetCode</title>
    <link>https://example.com/leetcode/docs/hard/</link>
    <description>Recent content in Hard on LeetCode</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language><atom:link href="https://example.com/leetcode/docs/hard/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>23. åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨</title>
      <link>https://example.com/leetcode/docs/hard/23/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/hard/23/</guid>
      <description>23. åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # å…·ä½“å®ç° # Go package main import ( &amp;#34;fmt&amp;#34; ) type ListNode struct { Val int Next *ListNode } func mergeKLists(lists []*ListNode) *ListNode { if len(lists) == 0 { return nil } n := len(lists) return merge(lists, 0, n-1) } func merge(lists []*ListNode, left, right int) *ListNode { if left == right { return lists[left] } mid := left + (right-left)/2 l1 := merge(lists, left, mid) l2 := merge(lists, mid+1, right) return mergeTwoLists(l1, l2) } func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1.</description>
    </item>
    
    <item>
      <title>25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨</title>
      <link>https://example.com/leetcode/docs/hard/25/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/hard/25/</guid>
      <description>25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # å…·ä½“å®ç° # Go package main import &amp;#34;fmt&amp;#34; type ListNode struct { Val int Next *ListNode } func reverseKGroup(head *ListNode, k int) *ListNode { // åè½¬é“¾è¡¨ reverse := func(head *ListNode) *ListNode { if head == nil { return nil } var ( prev, curr, next *ListNode ) curr = head for curr != nil { next = curr.Next curr.Next = prev prev = curr curr = next } return prev } dummy := &amp;amp;ListNode{} var ( prev, end *ListNode ) dummy.</description>
    </item>
    
    <item>
      <title>ğŸ˜ª76. æœ€å°è¦†ç›–å­ä¸²</title>
      <link>https://example.com/leetcode/docs/hard/76/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/hard/76/</guid>
      <description> 76. æœ€å°è¦†ç›–å­ä¸² # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # TODO
å…·ä½“æ€è·¯ # </description>
    </item>
    
    <item>
      <title>224. åŸºæœ¬è®¡ç®—å™¨</title>
      <link>https://example.com/leetcode/docs/hard/224/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/hard/224/</guid>
      <description> 224. åŸºæœ¬è®¡ç®—å™¨ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode </description>
    </item>
    
  </channel>
</rss>
