<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>简介 on LeetCode</title>
    <link>https://example.com/leetcode/</link>
    <description>Recent content in 简介 on LeetCode</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language><atom:link href="https://example.com/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>😪面试题 08.06. 汉诺塔问题</title>
      <link>https://example.com/leetcode/docs/other/interview-08.06/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/other/interview-08.06/</guid>
      <description>面试题 08.06. 汉诺塔问题 # 题目地址： 面试题 08.06. 汉诺塔问题 / 图解汉诺塔的故事：据说，当64个盘子全部移完的那天，世界就毁灭了</description>
    </item>
    
    <item>
      <title>1. 两数之和</title>
      <link>https://example.com/leetcode/docs/easy/1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/1/</guid>
      <description>1. 两数之和 # 题目地址 # 力扣 LeetCode 解题思路 # 暴力法 # 嵌套遍历数组，外层遍历的值和内层遍历的值相加，如果相加等于目标值，则返回结果，否则继续遍历。内层遍历开始的位置是外层遍历的位置加 1，结束的位置是数组长度。
map # TODO
具体实现 # Go Map package main import &amp;#34;fmt&amp;#34; func twoSum(nums []int, target int) []int { if len(nums) == 0 { return []int{} } m := make(map[int]int, 0) // val =&amp;gt; index for index, val := range nums { ass := target - val if idx, ok := m[ass]; ok { return []int{idx, index} } else { m[val] = index } } return []int{} } func main() { fmt.</description>
    </item>
    
    <item>
      <title>冒泡排序</title>
      <link>https://example.com/leetcode/docs/other/bubble/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/other/bubble/</guid>
      <description> 冒泡排序 # 题目描述 # 输入一个整数数组，按从小到大的顺序排序。
具体实现 # package main import &amp;#34;fmt&amp;#34; func Bubble(arr []int) []int { length := len(arr) for i := 0; i &amp;lt; length-1; i++ { // 注意这里 j 是从 0 开始而不是从 i 开始 for j := 0; j &amp;lt; length-i-1; j++ { if arr[j] &amp;gt; arr[j+1] { tmp := arr[j] arr[j] = arr[j+1] arr[j+1] = tmp } } } return arr } func main() { fmt.Println(Bubble([]int{1, 10, 25, 30})) } </description>
    </item>
    
    <item>
      <title>15. 三数之和</title>
      <link>https://example.com/leetcode/docs/medium/15/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/15/</guid>
      <description>15. 三数之和 # 题目地址 # 力扣 LeetCode 解题思路 # 具体实现 # Go package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sort&amp;#34; ) func threeSum(nums []int) [][]int { sort.Ints(nums) res := [][]int{} // 找出 a + b + c = 0 // a = nums[i], b = nums[left], c = nums[right] for i := 0; i &amp;lt; len(nums)-2; i++ { // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了 n1 := nums[i] if n1 &amp;gt; 0 { return res } // 去重 a if i &amp;gt; 0 &amp;amp;&amp;amp; n1 == nums[i-1] { continue } left, right := i+1, len(nums)-1 for left &amp;lt; right { n2, n3 := nums[left], nums[right] if n1+n2+n3 == 0 { res = append(res, []int{n1, n2, n3}) // 去重逻辑应该放在找到一个三元组之后，对 b 和 c 去重 for left &amp;lt; right &amp;amp;&amp;amp; nums[left] == n2 { left++ } for left &amp;lt; right &amp;amp;&amp;amp; nums[right] == n3 { right-- } } else if n1+n2+n3 &amp;lt; 0 { left++ } else { right-- } } } return res } func main() { ret := threeSum([]int{-1, 0, 1, 2, -1, -4}) fmt.</description>
    </item>
    
    <item>
      <title>018. 有效的回文</title>
      <link>https://example.com/leetcode/docs/finger-offer2/018/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/finger-offer2/018/</guid>
      <description> 018. 有效的回文 # 题目地址 # 力扣 </description>
    </item>
    
    <item>
      <title>18. 四数之和</title>
      <link>https://example.com/leetcode/docs/medium/18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/18/</guid>
      <description> 18. 四数之和 # 题目地址 # 力扣 LeetCode </description>
    </item>
    
    <item>
      <title>19. 删除链表的倒数第 N 个结点</title>
      <link>https://example.com/leetcode/docs/medium/19/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/19/</guid>
      <description>19. 删除链表的倒数第 N 个结点 # 题目地址 # 力扣 LeetCode 解题思路 # 常规法 # 先计算链表长度，比如是 length。那么删除倒数第 n 个节点，也就是删除顺数第 length-n+1 个节点，设为 s，直接从 1 找到第 s-1 个也就是 s 的上一个节点（其实也就是 length-n），直接把 s-1 删除即可。
双指针法 # TODO
具体实现 # Go常规法 package main import &amp;#34;fmt&amp;#34; type ListNode struct { Val int Next *ListNode } func removeNthFromEnd(head *ListNode, n int) *ListNode { if head == nil { return head } length := 0 tmpc := head for tmpc !</description>
    </item>
    
    <item>
      <title>20. 有效的括号</title>
      <link>https://example.com/leetcode/docs/easy/20/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/20/</guid>
      <description>20. 有效的括号 # 题目地址 # 力扣 LeetCode 解题思路 # 判断括号的有效性可以使用「栈」这一数据结构来解决。
我们遍历给定的字符串 s。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于 后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。
当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。
在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，否则返回 False。
注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。
具体实现 # Go package main import &amp;#34;fmt&amp;#34; func isValid(s string) bool { n := len(s) if n%2 != 0 { // 奇数直接退出 return false } pairs := map[byte]byte{ &amp;#39;)&amp;#39;: &amp;#39;(&amp;#39;, &amp;#39;]&amp;#39;: &amp;#39;[&amp;#39;, &amp;#39;}&amp;#39;: &amp;#39;{&amp;#39;, } stack := []byte{} for i := 0; i &amp;lt; n; i++ { if pairs[s[i]] &amp;gt; 0 { // 如果是右括号,判断栈顶是否是对应的左括号,果然有对应的左括号,则弹出栈顶元素,否则直接退出 if len(stack) == 0 || stack[len(stack)-1] !</description>
    </item>
    
    <item>
      <title>21. 合并两个有序链表</title>
      <link>https://example.com/leetcode/docs/easy/21/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/21/</guid>
      <description>21. 合并两个有序链表 # 题目地址 # 力扣 LeetCode 解题思路 # 递归解法 # 参考 一看就会，一写就废？详解递归。
递归的核心在于，我只关注我这一层要干什么，返回什么，至于我的下一层（规模减 1），我不管，我就是甩手掌柜。
那么现在我要 merge L1，L2 我需要怎么做❓
当一条链表为空时，返回对方，因为如果返回自己，就退出了，返回对方，不管对方是什么，让下级去判断。 如果 L1 第一个元素小于 L2 的？那我得把 L1 的这个元素放到最前面，至于后面的那串长啥样，我不管。我只要接过下级员工干完活后给我的包裹，然后把我干的活附上去（令 L1-&amp;gt;next = 这个包裹）就行。 这个包裹是下级员工干的活，即merge(L1-&amp;gt;next,L2)。 我该返回啥❓
现在不管我的下一层干了什么，又返回了什么给我，我只要知道，假设我的工具人们都完成了任务，那我的任务也就完成了，可以返回最终结果了。 最终结果就是我一开始接手的 L1 头结点+下级员工给我的大包裹，要一并交上去，这样我的 boss 才能根据我给它的 L1 头节点往下找，检查我完成的工作。 具体实现 # Go 递归 package main import &amp;#34;fmt&amp;#34; type ListNode struct { Val int Next *ListNode } func mergeTwoLists(list1 *ListNode, list2 *ListNode) (x *ListNode) { if list1 == nil { return list2 } if list2 == nil { return list1 } if list1.</description>
    </item>
    
    <item>
      <title>23. 合并 K 个升序链表</title>
      <link>https://example.com/leetcode/docs/hard/23/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/hard/23/</guid>
      <description>23. 合并 K 个升序链表 # 题目地址 # 力扣 LeetCode 解题思路 # 具体实现 # Go package main import ( &amp;#34;fmt&amp;#34; ) type ListNode struct { Val int Next *ListNode } func mergeKLists(lists []*ListNode) *ListNode { if len(lists) == 0 { return nil } n := len(lists) return merge(lists, 0, n-1) } func merge(lists []*ListNode, left, right int) *ListNode { if left == right { return lists[left] } mid := left + (right-left)/2 l1 := merge(lists, left, mid) l2 := merge(lists, mid+1, right) return mergeTwoLists(l1, l2) } func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1.</description>
    </item>
    
    <item>
      <title>24. 两两交换链表中的节点</title>
      <link>https://example.com/leetcode/docs/medium/24/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/24/</guid>
      <description>24. 两两交换链表中的节点 # 题目地址 # 力扣 LeetCode 解题思路 # 参考 https://leetcode.cn/problems/swap-nodes-in-pairs/solutions/444474/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/
递归法 # 可以通过递归的方式实现两两交换链表中的节点。递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。
如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。
用head表示原始链表的头节点，新的链表的第二个节点，用newHead表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是newHead.next。令head.next = swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为head的下一个节点。然后令newHead.next = head，即完成了所有节点的交换。最后返回新的链表的头节点newHead。
⚠️好吧，再理解一下，关于递归，我只关注我这一层要干什么，返回什么，至于我的下一层（规模减 1），我不管，我就是一个甩手掌柜🙈。
我其实只需要关心第一层，也就是节点1和节点2的交换，把节点2的next指向节点1，节点2的next给下一层也就是递归函数。而我最后返回的应该是头结点，其实也就是原始节点的节点2。
迭代法 # TODO
具体实现 # Go迭代 package main import ( &amp;#34;fmt&amp;#34; ) type ListNode struct { Val int Next *ListNode } func swapPairs(head *ListNode) *ListNode { if head == nil { return head } dummy := &amp;amp;ListNode{ Val: 0, Next: head, } curr := dummy // 如果是链表长度是奇数那就没有必要交换，只有偶数才需要交换，所以这里的判断条件是 &amp;amp;&amp;amp; // 这里不能用一个临时参数，因为链表指针后的值会变化 for curr.</description>
    </item>
    
    <item>
      <title>25. K 个一组翻转链表</title>
      <link>https://example.com/leetcode/docs/hard/25/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/hard/25/</guid>
      <description>25. K 个一组翻转链表 # 题目地址 # 力扣 LeetCode 解题思路 # 具体实现 # Go package main import &amp;#34;fmt&amp;#34; type ListNode struct { Val int Next *ListNode } func reverseKGroup(head *ListNode, k int) *ListNode { // 反转链表 reverse := func(head *ListNode) *ListNode { if head == nil { return nil } var ( prev, curr, next *ListNode ) curr = head for curr != nil { next = curr.Next curr.Next = prev prev = curr curr = next } return prev } dummy := &amp;amp;ListNode{} var ( prev, end *ListNode ) dummy.</description>
    </item>
    
    <item>
      <title>27. 移除元素</title>
      <link>https://example.com/leetcode/docs/easy/27/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/27/</guid>
      <description>27. 移除元素 # 题目地址 # 力扣 LeetCode 解题思路 # 暴力法 # TODO
双指针法 # 可以用双指针/快慢指针来解决。快指针用来寻找新数组的元素，新数组就是不含有目标元素的数组，慢指针用来指向更新新数组下标的位置。这里需要的注意的是，“新数组”其实就是旧数组，因为一直都在在同一个数组上的操作，这也是题目的要求👇
不要使用额外的数组空间，你必须仅使用O(1)额外空间并原地修改输入数组。
具体实现 # Go双指针 package main import &amp;#34;fmt&amp;#34; func removeElement(nums []int, val int) int { length := len(nums) low := 0 for i := 0; i &amp;lt; length; i++ { if nums[i] != val { nums[low] = nums[i] low++ } } return low } func main() { x := []int{1, 2, 6, 7, 9, 6, 6, 6} xx := removeElement(x, 6) fmt.</description>
    </item>
    
    <item>
      <title>53. 最大子数组和</title>
      <link>https://example.com/leetcode/docs/medium/53/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/53/</guid>
      <description>53. 最大子数组和 # 题目地址 # 力扣 LeetCode 解题思路 # 具体实现 # Go贪心算法 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math&amp;#34; ) func maxSubArray(nums []int) int { if len(nums) == 0 { return 0 } count := 0 result := math.MinInt64 length := len(nums) for i := 0; i &amp;lt; length; i++ { count += nums[i] if count &amp;gt; result { result = count } if count &amp;lt;= 0 { count = 0 } } return result } func main() { fmt.</description>
    </item>
    
    <item>
      <title>59. 螺旋矩阵 II</title>
      <link>https://example.com/leetcode/docs/medium/59/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/59/</guid>
      <description>59. 螺旋矩阵 II # 题目地址 # 力扣 LeetCode 解题思路 # 可以参考 https://leetcode.cn/problems/spiral-matrix-ii/solutions/12594/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/
具体实现 # Go package main import &amp;#34;fmt&amp;#34; func main() { n := 3 fmt.Println(generateMatrix(n)) } func generateMatrix(n int) [][]int { ret := make([][]int, n) startX, startY := 0, 0 count := 1 offset := 1 loop := n / 2 for i := 0; i &amp;lt; n; i++ { ret[i] = make([]int, n) } for loop &amp;gt; 0 { i, j := startX, startY for j = startY; j &amp;lt; n-offset; j++ { ret[startX][j] = count count++ } for i = startX; i &amp;lt; n-offset; i++ { ret[i][j] = count count++ } for ; j &amp;gt; startY; j-- { ret[i][j] = count count++ } for ; i &amp;gt; startX; i-- { ret[i][j] = count count++ } startX++ startY++ offset++ loop-- } if n%2 == 1 { ret[n/2][n/2] = n * n } return ret } 参考 # 一入循环深似海 | LeetCode：59.</description>
    </item>
    
    <item>
      <title>😪76. 最小覆盖子串</title>
      <link>https://example.com/leetcode/docs/hard/76/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/hard/76/</guid>
      <description> 76. 最小覆盖子串 # 题目地址 # 力扣 LeetCode 解题思路 # TODO
具体思路 # </description>
    </item>
    
    <item>
      <title>92. 反转链表 II</title>
      <link>https://example.com/leetcode/docs/medium/92/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/92/</guid>
      <description>92. 反转链表 II # 题目地址 # 力扣 LeetCode 解题思路 # 具体实现 # Go package main import &amp;#34;fmt&amp;#34; type ListNode struct { Val int Next *ListNode } func reverseBetween(head *ListNode, left int, right int) *ListNode { if head == nil { return head } var ( dummy = &amp;amp;ListNode{} prev, curr *ListNode ) dummy.Next = head prev = dummy for i := 0; i &amp;lt; left-1; i++ { prev = prev.</description>
    </item>
    
    <item>
      <title>😪104. 二叉树的最大深度</title>
      <link>https://example.com/leetcode/docs/easy/104/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/104/</guid>
      <description> 104. 二叉树的最大深度 # 题目地址 # 力扣 LeetCode </description>
    </item>
    
    <item>
      <title>242. 有效的字母异位词</title>
      <link>https://example.com/leetcode/docs/easy/242/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/242/</guid>
      <description>242. 有效的字母异位词 # 题目地址 # 力扣 LeetCode 解题思路 # map # 具体实现 # Go map package main import &amp;#34;fmt&amp;#34; func isAnagram(s string, t string) bool { if len(s) != len(t) { return false } var arr [26]int for i := 0; i &amp;lt; len(s); i++ { arr[s[i]-&amp;#39;a&amp;#39;]++ } for i := 0; i &amp;lt; len(t); i++ { arr[t[i]-&amp;#39;a&amp;#39;]-- } for _, each := range arr { if each &amp;gt; 0 { return false } } return true } func main() { fmt.</description>
    </item>
    
    <item>
      <title>141. 环形链表</title>
      <link>https://example.com/leetcode/docs/easy/141/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/141/</guid>
      <description>141. 环形链表 # 题目地址 # 力扣 LeetCode 解题思路 # 具体实现 # Go package main import &amp;#34;fmt&amp;#34; type ListNode struct { Val int Next *ListNode } func hasCycle(head *ListNode) bool { slow, fast := head, head for fast != nil &amp;amp;&amp;amp; fast.Next != nil { slow = slow.Next fast = fast.Next.Next if slow == fast { return true } } return false } func main() { createLinkedList := func(arr []int) *ListNode { if len(arr) == 0 { return nil } head := &amp;amp;ListNode{Val: arr[0]} current := head for i := 1; i &amp;lt; len(arr); i++ { node := &amp;amp;ListNode{Val: arr[i]} current.</description>
    </item>
    
    <item>
      <title>142. 环形链表 II</title>
      <link>https://example.com/leetcode/docs/medium/142/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/142/</guid>
      <description>142. 环形链表 II # 题目地址 # 力扣 LeetCode 解题思路 # 具体实现 # Go package main import &amp;#34;fmt&amp;#34; type ListNode struct { Val int Next *ListNode } func detectCycle(head *ListNode) *ListNode { if head == nil { return head } low, fast := head, head // 因为快指针走 2 步，不要判断 next 是否为 nil for fast != nil &amp;amp;&amp;amp; fast.Next != nil { low = low.Next fast = fast.Next.Next // 注意这里 fast 是走 2 步 if fast == low { for low !</description>
    </item>
    
    <item>
      <title>151. 反转字符串中的单词</title>
      <link>https://example.com/leetcode/docs/medium/151/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/151/</guid>
      <description> 151. 反转字符串中的单词 # 题目地址 # 力扣 LeetCode </description>
    </item>
    
    <item>
      <title>155. 最小栈</title>
      <link>https://example.com/leetcode/docs/medium/155/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/155/</guid>
      <description> 155. 最小栈 # 题目地址 # 力扣 LeetCode </description>
    </item>
    
    <item>
      <title>160. 相交链表</title>
      <link>https://example.com/leetcode/docs/easy/160/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/160/</guid>
      <description>160. 相交链表 # 题目地址 # 力扣 LeetCode 解题思路 # 如果两个链表相交，那么相交点之后的长度是相同的。
所以，我们需要做的事情是，让两个链表从距离末尾同等距离的位置开始遍历。而这个位置只能是较短链表的头结点位置。为此，需要求出两个链表的长度并消除两个链表的长度差。
具体实现 # Go package main import &amp;#34;fmt&amp;#34; type ListNode struct { Next *ListNode Val int } func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } var ( currA, currB = headA, headB lenA, lenB int ) // 计算链表的长度 for currA != nil { lenA++ currA = currA.Next } for currB !</description>
    </item>
    
    <item>
      <title>203. 移除链表元素</title>
      <link>https://example.com/leetcode/docs/easy/203/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/203/</guid>
      <description>203. 移除链表元素 # 题目地址 # 力扣 LeetCode 解题思路 # 参看 https://leetcode.cn/problems/remove-linked-list-elements/solutions/813358/yi-chu-lian-biao-yuan-su-by-leetcode-sol-654m/
迭代法 # 用 curr 表示当前节点。如果 curr 的下一个节点不为空且下一个节点的节点值等于给定的 val，则需要删除下一个节点。删除下一个节点可以通过 curr.next=curr.next.next 实现。
如果 curr 的下一个节点的节点值不等于给定的 val，则保留下一个节点，将 curr 移动到下一个节点即可。
当curr的下一个节点为空时，链表遍历结束，此时所有节点值等于 val 的节点都被删除。
具体实现方面，由于链表的头节点 head 有可能需要被删除，因此创建哑节点/虚拟节点 dummyHead，令 dummyHead.next=head，初始化 curr=dummyHead，然后遍历链表进行删除操作。最终返回dummyHead.next即为删除操作后的头节点。
为什么要用 curr=dummyHead❓，这样 curr 指向的地址跟 dummyHead 指向的地址是一样的，如果不提前赋值，那么迭代到最后dummyHead.Next就是nil，不能正确的返回头结点，所以重新赋值后，用 curr 去循环 dummyHead.Next 还是正常的。
递归法 # 链表的定义具有递归的性质，因此链表题目常可以用递归的方法求解。
递归的核心在于，我只关注我这一层要干什么，返回什么，至于我的下一层（规模减 1），我不管，我就是甩手掌柜。
那么现在我要删除特定链表元素，我需要怎么做❓
如果链表是nil我就直接返回，我的 next 让工具人函数去判断，当工具人函数做完判断给我之后，我按需 return，也就是如果 head.Val == val return head.Next，否则直接 return head。
具体实现 # Go迭代 package main import ( &amp;#34;fmt&amp;#34; ) func removeElements(head *ListNode, val int) *ListNode { dummyHead := &amp;amp;ListNode{ Val: 0, Next: head, } curr := dummyHead fmt.</description>
    </item>
    
    <item>
      <title>206. 反转链表</title>
      <link>https://example.com/leetcode/docs/easy/206/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/206/</guid>
      <description>206. 反转链表 # 题目地址 # 力扣 LeetCode 类似/相同题目： 剑指 Offer 24. 反转链表
解题思路 # 迭代法 # TODO
递归法 # TODO
具体实现 # Go迭代 package main type ListNode struct { Val int Next *ListNode } func reverseList(head *ListNode) *ListNode { if head == nil { return nil } var ( prev, next *ListNode curr = head ) for curr != nil { next = curr.Next curr.Next = prev // 下一个 prev = curr curr = next } return prev } func main() { reverseList(&amp;amp;ListNode{ Val: 1, Next: &amp;amp;ListNode{Val: 2, Next: &amp;amp;ListNode{Val: 3, Next: &amp;amp;ListNode{Val: 4, Next: &amp;amp;ListNode{Val: 5}}}}}) } Go递归 package main import ( &amp;#34;fmt&amp;#34; ) type ListNode struct { Val int Next *ListNode } func reverseList(head *ListNode) *ListNode { // head == null：当第一次输入为 nil 的时候直接返回 nil，不进行递归操作。 // head.</description>
    </item>
    
    <item>
      <title>209. 长度最小的子数组</title>
      <link>https://example.com/leetcode/docs/medium/209/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/209/</guid>
      <description>209. 长度最小的子数组 # 题目地址 # 力扣 LeetCode 解题思路 # 暴力法 # 暴力法是最直观的方法，但是在 leetcode 提交暴力法解题会报「超出时间限制」😴。暴力法可以参看 https://leetcode.cn/problems/minimum-size-subarray-sum/solutions/305704/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/。
初始化子数组的最小长度为无穷大，枚举数组nums中的每个下标作为子数组的开始下标，对于每个开始下标i，需要找到大于或等于i的最小下标j，使得从nums[i]到nums[j]的元素和大于或等于s，并更新子数组的最小长度，此时子数组的长度是 j−i+1。需要 注意的是，两个 for 循环都是&amp;lt;len(nums)，不是内层的&amp;lt;len(nums)-1。
滑动窗口法 # 可以参看 B站-长度最小的子数组 和 209.长度最小的子数组
具体实现 # Go滑动窗口 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math&amp;#34; ) func minSubArrayLen02(target int, nums []int) int { n := len(nums) if n == 0 { return 0 } min := func(x, y int) int { if x &amp;lt; y { return x } return y } ans := math.</description>
    </item>
    
    <item>
      <title>224. 基本计算器</title>
      <link>https://example.com/leetcode/docs/hard/224/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/hard/224/</guid>
      <description> 224. 基本计算器 # 题目地址 # 力扣 LeetCode </description>
    </item>
    
    <item>
      <title>232. 用栈实现队列</title>
      <link>https://example.com/leetcode/docs/easy/232/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/232/</guid>
      <description> 232. 用栈实现队列 # 题目地址 # 力扣 LeetCode </description>
    </item>
    
    <item>
      <title>344. 反转字符串</title>
      <link>https://example.com/leetcode/docs/easy/344/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/344/</guid>
      <description>344. 反转字符串 # 题目地址 # 力扣 LeetCode 解题思路 # 双指针法 # 对于长度为N的待被反转的字符数组，我们可以观察反转前后下标的变化，假设反转前字符数组为s[0] s[1] s[2] ... s[N - 1]，那么反转后字符数组为s[N - 1] s[N - 2] ... s[0]。比较反转前后下标变化很容易得出s[i]的字符与s[N - 1 - i]的字符发生了交换的规律，因此我们可以得出如下双指针的解法：
将left指向字符数组首元素，right指向字符数组尾元素。 当left &amp;lt; right： 交换s[left]和s[right]； left指针右移一位，即left = left + 1； right指针左移一位，即right = right - 1。 当left &amp;gt;= right，反转结束，返回字符数组即可。 具体实现 # Go package main import ( &amp;#34;fmt&amp;#34; ) func reverseString(s []byte) { length := len(s) if length == 0 { return } left, right := 0, length-1 for left &amp;lt; right { tmp := s[left] s[left] = s[right] s[right] = tmp left++ right-- } return } func main() { x := []byte{&amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;} reverseString(x) fmt.</description>
    </item>
    
    <item>
      <title>349. 两个数组的交集</title>
      <link>https://example.com/leetcode/docs/easy/349/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/349/</guid>
      <description>349. 两个数组的交集 # 题目地址 # 力扣 LeetCode 解题思路 # TODO
具体实现 # Go package main import &amp;#34;fmt&amp;#34; func intersection(nums1 []int, nums2 []int) []int { if len(nums1) == 0 || len(nums2) == 0 { return []int{} } var ( set = make(map[int]struct{}, 0) ret = make([]int, 0) ) // 重复的会直接覆盖 for _, each := range nums1 { set[each] = struct{}{} } for _, each := range nums2 { if _, ok := set[each]; ok { ret = append(ret, each) delete(set, each) } } return ret } func main() { fmt.</description>
    </item>
    
    <item>
      <title>451. 根据字符出现频率排序</title>
      <link>https://example.com/leetcode/docs/easy/541/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/541/</guid>
      <description> 451. 根据字符出现频率排序 # 题目地址 # 力扣 LeetCode </description>
    </item>
    
    <item>
      <title>454. 四数相加 II</title>
      <link>https://example.com/leetcode/docs/medium/454/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/454/</guid>
      <description>454. 四数相加 II # 题目地址 # 力扣 LeetCode 解题思路 # 具体实现 # Go package main import &amp;#34;fmt&amp;#34; func fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { count := 0 m := make(map[int]int) for _, a := range nums1 { for _, b := range nums2 { m[a+b]++ } } for _, c := range nums3 { for _, d := range nums4 { target := 0 - (c + d) if v, ok := m[target]; ok { count += v } } } return count } func main() { nums1 := []int{1, 2} nums2 := []int{-2, -1} nums3 := []int{-1, 2} nums4 := []int{0, 2} ret := fourSumCount(nums1, nums2, nums3, nums4) fmt.</description>
    </item>
    
    <item>
      <title>459. 重复的子字符串</title>
      <link>https://example.com/leetcode/docs/easy/459/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/459/</guid>
      <description> 459. 重复的子字符串 # 题目地址 # 力扣 LeetCode </description>
    </item>
    
    <item>
      <title>496. 下一个更大元素 I</title>
      <link>https://example.com/leetcode/docs/easy/496/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/496/</guid>
      <description> 496. 下一个更大元素 I # 题目地址 # 力扣 LeetCode </description>
    </item>
    
    <item>
      <title>682. 棒球比赛</title>
      <link>https://example.com/leetcode/docs/easy/682/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/682/</guid>
      <description> 682. 棒球比赛 # 题目地址 # 力扣 LeetCode </description>
    </item>
    
    <item>
      <title>704. 二分查找</title>
      <link>https://example.com/leetcode/docs/easy/704/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/704/</guid>
      <description>704. 二分查找 # 题目地址 # 力扣 LeetCode 解题思路 # 可以参考
https://www.bilibili.com/video/BV1fA4y1o715 二分查找 对于常规实现来说，在解题时要区分区间，也就是左闭右闭还是左闭右开区间两种解法，其实就是要区分右闭还是右开，在临界条件判断时包不包含最右边的值。
对于左闭右闭来说，包含最右边，所以在临界条件判断时，左边的值可以等于右边的值，那么right其实是数组长度-1，也就是数组最后一个值。
while (left &amp;lt;= right)，因为left == right是有意义的，所以使用&amp;lt;= if (nums[middle] &amp;gt; target)，right要赋值为middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是middle - 1 但是对于左闭右开来说，因为不包含最右元素，那么right其实就是数组长度，right 取不到数组最后一个值。
while (left &amp;lt; right)，因为left == right在区间[left, right)是没有意义的，所以这里要用&amp;lt; if (nums[middle] &amp;gt; target) right更新为middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，也就是说，下一个查询区间不会去比较nums[middle] 具体实现 # Go 区间左闭右闭
package main import ( &amp;#34;fmt&amp;#34; ) func main() { arr := []int{0, 1, 2, 3, 4, 5, 10} fmt.Println(binarySearch(arr, 10)) } func binarySearch(nums []int, target int) int { left := 0 right := len(nums) - 1 for left &amp;lt;= right { middle := (left + right) / 2 if target &amp;gt; nums[middle] { left = middle + 1 } else if target &amp;lt; nums[middle] { right = middle - 1 } else { return middle } } return -1 } 区间左闭右开</description>
    </item>
    
    <item>
      <title>😪707. 设计链表</title>
      <link>https://example.com/leetcode/docs/medium/707/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/medium/707/</guid>
      <description> 707. 设计链表 # 题目地址： https://leetcode.cn/problems/design-linked-list/
解题思路 # 具体实现 # Go </description>
    </item>
    
    <item>
      <title>😪xxxxxx</title>
      <link>https://example.com/leetcode/docs/hidden/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/hidden/</guid>
      <description> xx # 题目地址 # 解题思路 # 具体实现 # Go </description>
    </item>
    
    <item>
      <title>844. 比较含退格的字符串</title>
      <link>https://example.com/leetcode/docs/easy/844/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/844/</guid>
      <description> 844. 比较含退格的字符串 # 题目地址 # 力扣 LeetCode </description>
    </item>
    
    <item>
      <title>876. 链表的中间结点</title>
      <link>https://example.com/leetcode/docs/easy/876/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/876/</guid>
      <description> 876. 链表的中间结点 # 题目地址 # 力扣 LeetCode </description>
    </item>
    
    <item>
      <title>977. 有序数组的平方</title>
      <link>https://example.com/leetcode/docs/easy/977/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/leetcode/docs/easy/977/</guid>
      <description>977. 有序数组的平方 # 题目地址 # 力扣 LeetCode 解题思路 # 暴力法 # 可以直接先计算平方，然后再利用库函数排序。
双指针法 # 可以参考
有序数组的平方 B 站-有序数组的平方 数组其实是有序的，只不过负数平方之后可能成为最大数了。那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。此时可以考虑双指针法了，i指向起始位置，j指向终止位置。定义一个新数组 result，和 A 数组一样的大小，让k指向 result 数组终止位置，也就是说让 k 从大（右）到小（左）填充。
如果A[i] * A[i] &amp;lt; A[j] * A[j] 那么result[k--] = A[j] * A[j] 。
如果A[i] * A[i] &amp;gt;= A[j] * A[j]那么result[k--] = A[i] * A[i]。
具体实现 # Go双指针 package main import &amp;#34;fmt&amp;#34; func sortedSquares(nums []int) []int { if len(nums) == 0 { return []int{} } var ( result = make([]int, len(nums)) i, j = 0, len(nums) - 1 k = len(nums) - 1 // 能访问到最后一个值 ) // 这里之所以要 &amp;lt;= 是因为，如果仅仅是 &amp;lt; 那么当 = 时会退出， // 这样就会漏掉了一个元素 for i &amp;lt;= j { if nums[i]*nums[i] &amp;gt; nums[j]*nums[j] { result[k] = nums[i] * nums[i] k-- i++ } else { result[k] = nums[j] * nums[j] k-- j-- } } return result } func main() { fmt.</description>
    </item>
    
  </channel>
</rss>
