[{"id":0,"href":"/leetcode/docs/hot100/1/","title":"1. 两数之和","section":"热题 HOT 100","content":" 1. 两数之和 # 题目地址： https://leetcode-cn.com/problems/two-sum/\n解题思路 # 嵌套遍历数组，外层遍历的值和内层遍历的值相加，如果相加等于目标值，则返回结果，否则继续遍历。内层遍历开始的位置是外层遍历的位置加 1，结束的位置是数组长度。\n具体实现 # Go package main import \u0026#34;fmt\u0026#34; func twoSum(nums []int, target int) []int { for index, value := range nums { for i := index + 1; i \u0026lt; len(nums); i++ { if (value + nums[i]) == target { return []int{index, i} } } } return nil } func main() { fmt.Println(twoSum([]int{3, 2, 4}, 6)) } "},{"id":1,"href":"/leetcode/docs/easy/","title":"Easy","section":"Docs","content":" Easy # 明日复明日，明日何其多，我生待明日，万事成蹉跎。世人若被明日累，春去秋来老将至。朝看水东流，暮看日西坠。百年明日能几何，请君听我明日歌。 "},{"id":2,"href":"/leetcode/docs/medium/","title":"Medium","section":"Docs","content":" Medium # 劝君莫惜金缕衣，劝君须惜少年时。花开堪折直须折，莫待无花空折枝。 "},{"id":3,"href":"/leetcode/docs/hot100/","title":"热题 HOT 100","section":"Docs","content":" 热题 HOT 100 # 老当益壮，宁移白首之心；穷且益坚，不坠青云之志。 "},{"id":4,"href":"/leetcode/docs/hot100/20/","title":"20. 有效的括号","section":"热题 HOT 100","content":" 20. 有效的括号 # 题目地址： https://leetcode-cn.com/problems/valid-parentheses/\n解题思路 # 判断括号的有效性可以使用「栈」这一数据结构来解决。\n我们遍历给定的字符串 s。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于 后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。\n当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。\n在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，否则返回 False。\n注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。\n具体实现 # Go package main import \u0026#34;fmt\u0026#34; func isValid(s string) bool { n := len(s) if n%2 != 0 { // 奇数直接退出 return false } pairs := map[byte]byte{ \u0026#39;)\u0026#39;: \u0026#39;(\u0026#39;, \u0026#39;]\u0026#39;: \u0026#39;[\u0026#39;, \u0026#39;}\u0026#39;: \u0026#39;{\u0026#39;, } stack := []byte{} for i := 0; i \u0026lt; n; i++ { if pairs[s[i]] \u0026gt; 0 { // 如果是右括号,判断栈顶是否是对应的左括号,果然有对应的左括号,则弹出栈顶元素,否则直接退出 if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] { return false } stack = stack[:len(stack)-1] } else { stack = append(stack, s[i]) } } return len(stack) == 0 } func main() { fmt.Println(isValid(\u0026#34;()[]{}\u0026#34;)) } "},{"id":5,"href":"/leetcode/docs/easy/21/","title":"21. 合并两个有序链表","section":"Easy","content":" 21. 合并两个有序链表 # 题目地址： https://leetcode.cn/problems/merge-two-sorted-lists/description/\n解题思路 # 递归解法 # 递归的核心在于，我只关注我这一层要干什么，返回什么，至于我的下一层（规模减 1），我不管，我就是甩手掌柜。\n那么现在我要 merge L1，L2 我需要怎么做:question:\n但一条链表为空时，返回对方，因为如果返回自己，就退出了，返回对方，不管对方是什么，让下级去判断。 如果 L1 第一个元素小于 L2 的？那我得把 L1 的这个元素放到最前面，至于后面的那串长啥样，我不管。我只要接过下级员工干完活后给我的包裹，然后把我干的活附上去（令 L1-\u0026gt;next = 这个包裹）就行。 这个包裹是下级员工干的活，即merge(L1-\u0026gt;next,L2)。 我该返回啥❓\n现在不管我的下一层干了什么，又返回了什么给我，我只要知道，假设我的工具人们都完成了任务，那我的任务也就完成了，可以返回最终结果了。 最终结果就是我一开始接手的 L1 头结点+下级员工给我的大包裹，要一并交上去，这样我的 boss 才能根据我给它的 L1 头节点往下找，检查我完成的工作。 具体实现 # Go递归 package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func mergeTwoLists(list1 *ListNode, list2 *ListNode) (x *ListNode) { if list1 == nil { return list2 } if list2 == nil { return list1 } if list1.Val \u0026lt;= list2.Val { list1.Next = mergeTwoLists(list1.Next, list2) return list1 } else { list2.Next = mergeTwoLists(list2.Next, list1) return list2 } } func main() { x := mergeTwoLists(\u0026amp;ListNode{Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 4, Next: nil, }, }}, \u0026amp;ListNode{Val: 1, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: nil, }, }}) fmt.Println(x) } "},{"id":6,"href":"/leetcode/docs/medium/24/","title":"24. 两两交换链表中的节点","section":"Medium","content":" 24. 两两交换链表中的节点 # 题目地址： https://leetcode.cn/problems/swap-nodes-in-pairs/\n解题思路 # 参考 https://leetcode.cn/problems/swap-nodes-in-pairs/solutions/444474/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/\n递归法 # 可以通过递归的方式实现两两交换链表中的节点。递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。\n如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。\n用head表示原始链表的头节点，新的链表的第二个节点，用newHead表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是newHead.next。令head.next = swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为head的下一个节点。然后令newHead.next = head，即完成了所有节点的交换。最后返回新的链表的头节点newHead。\n:warning:好吧，再理解一下，关于递归，我只关注我这一层要干什么，返回什么，至于我的下一层（规模减 1），我不管，我就是一个甩手掌柜:see_no_evil:。\n我其实只需要关心第一层，也就是节点1和节点2的交换，把节点2的next指向节点1，节点2的next给下一层也就是递归函数。而我最后返回的应该是头结点，其实也就是原始节点的节点2。\n迭代法 # TODO\n具体实现 # Go递归 package main import ( \u0026#34;fmt\u0026#34; ) type ListNode struct { Val int Next *ListNode } func swapPairs(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } newHead := head.Next head.Next = swapPairs(head.Next.Next) newHead.Next = head return newHead } func main() { x := swapPairs(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: nil, }, }, }, }) fmt.Println(x) } "},{"id":7,"href":"/leetcode/docs/easy/27/","title":"27. 移除元素","section":"Easy","content":" 27. 移除元素 # 题目地址： https://leetcode.cn/problems/remove-element/description/\n解题思路 # 可以用双指针/快慢指针法来解决。快指针用来寻找新数组的元素，新数组就是不含有目标元素的数组。慢指针用来指向更新新数组下标的位置。这里需要的注意的是，“新数组”其实旧数组，因为一直都在在同一个数组上的操作。\n具体实现 # Go双指针 package main import \u0026#34;fmt\u0026#34; func removeElement(nums []int, val int) int { length := len(nums) low := 0 for i := 0; i \u0026lt; length; i++ { if nums[i] != val { nums[low] = nums[i] low++ } } return low } func main() { x := []int{1, 2, 6, 7, 9, 6, 6, 6} xx := removeElement(x, 6) fmt.Println(x, xx) } "},{"id":8,"href":"/leetcode/docs/medium/59/","title":"59. 螺旋矩阵 II","section":"Medium","content":" 59. 螺旋矩阵 II # 题目地址： https://leetcode.cn/problems/spiral-matrix-ii/\n解题思路 # 可以参考 https://leetcode.cn/problems/spiral-matrix-ii/solutions/12594/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/\n"},{"id":9,"href":"/leetcode/docs/easy/203/","title":"203. 移除链表元素","section":"Easy","content":" 203. 移除链表元素 # 题目地址： https://leetcode.cn/problems/remove-linked-list-elements/\n解题思路 # 参看 https://leetcode.cn/problems/remove-linked-list-elements/solutions/813358/yi-chu-lian-biao-yuan-su-by-leetcode-sol-654m/\n迭代法 # 用curr 表示当前节点。如果curr的下一个节点不为空且下一个节点的节点值等于给定的val，则需要删除下一个节点。删除下一个节点可以通过curr.next=curr.next.next实现。\n如果curr的下一个节点的节点值不等于给定的val，则保留下一个节点，将curr移动到下一个节点即可。\n当curr的下一个节点为空时，链表遍历结束，此时所有节点值等于val的节点都被删除。\n具体实现方面，由于链表的头节点head有可能需要被删除，因此创建哑节点/虚拟节点dummyHead，令dummyHead.next=head，初始化 curr=dummyHead，然后遍历链表进行删除操作。最终返回dummyHead.next即为删除操作后的头节点。\n:question:为什么要用curr=dummyHead，那么这样curr指向的地址跟dummyHead指向的地址是一样的，如果不提前赋值，那么迭代到最后dummyHead.Next就是nil，不能正确的返回头结点，所以赋值下dummyHead.Next还是正常的。\n递归法 # 链表的定义具有递归的性质，因此链表题目常可以用递归的方法求解。\n递归的核心在于，我只关注我这一层要干什么，返回什么，至于我的下一层（规模减 1），我不管，我就是甩手掌柜。\n那么现在我要删除特定链表元素，我需要怎么做❓\n如果链表是nil我就直接返回，我的 next 让工具人函数去判断，当工具人函数昨晚判断给我之后，我按需 return，也就是如果head.Val == val return head.Next，否则直接 return head。\n具体实现 # Go迭代 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;go.src/leetcode/model\u0026#34; ) func removeElements(head *model.ListNode, val int) *model.ListNode { dummyHead := \u0026amp;model.ListNode{ Val: 0, Next: head, } curr := dummyHead fmt.Println(dummyHead, curr) for curr.Next != nil { if curr.Next.Val == val { curr.Next = curr.Next.Next } else { curr = curr.Next } } return dummyHead.Next } func main() { x := removeElements(\u0026amp;model.ListNode{ Val: 1, Next: \u0026amp;model.ListNode{ Val: 2, Next: \u0026amp;model.ListNode{ Val: 1, Next: \u0026amp;model.ListNode{ Val: 3, Next: nil, }, }, }, }, 1) fmt.Println(x) } Go递归 package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func removeElements(head *ListNode, val int) *ListNode { if head == nil { return head } head.Next = removeElements(head.Next, val) if head.Val == val { return head.Next } return head } func main() { x := removeElements(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 3, Next: nil, }, }, }, }, 1) fmt.Println(x) } "},{"id":10,"href":"/leetcode/docs/easy/206/","title":"206. 反转链表","section":"Easy","content":" 206. 反转链表 # 题目地址： https://leetcode.cn/problems/reverse-linked-list/\n类似/相同题目： 剑指 Offer 24. 反转链表\n解题思路 # 迭代法 # 递归法 # 具体实现 # Go迭代 package main type ListNode struct { Val int Next *ListNode } func reverseList(head *ListNode) *ListNode { if head == nil { return nil } var ( prev, next *ListNode curr = head ) for curr != nil { next = curr.Next curr.Next = prev // 下一个 prev = curr curr = next } return prev } func main() { reverseList(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{Val: 2, Next: \u0026amp;ListNode{Val: 3, Next: \u0026amp;ListNode{Val: 4, Next: \u0026amp;ListNode{Val: 5}}}}}) } Go递归 package main import ( \u0026#34;fmt\u0026#34; ) type ListNode struct { Val int Next *ListNode } func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } newHead := reverseList(head.Next) head.Next.Next = head head.Next = nil return newHead } func main() { x := reverseList(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: nil, }, }, }, }) fmt.Println(x) } "},{"id":11,"href":"/leetcode/docs/medium/209/","title":"209. 长度最小的子数组","section":"Medium","content":" 209. 长度最小的子数组 # 题目地址： https://leetcode.cn/problems/minimum-size-subarray-sum/description/\n解题思路 # 暴力法 # 暴力法是最直观的方法，但是在 leetcode 提交暴力法解题会报「超出时间限制」错误:sleeping:。暴力法可以参看 https://leetcode.cn/problems/minimum-size-subarray-sum/solutions/305704/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/。\n初始化子数组的最小长度为无穷大，枚举数组nums中的每个下标作为子数组的开始下标，对于每个开始下标i，需要找到大于或等于i的最小下标j，使得从nums[i]到nums[j]的元素和大于或等于s，并更新子数组的最小长度，此时子数组的长度是 j−i+1。需要 注意的是，两个 for 循环都是\u0026lt;len(nums)，不是内层的\u0026lt;len(nums)-1。\n滑动窗口法 # 可以参看 LeetCode 209 长度最小的子数组 和 209.长度最小的子数组\n具体实现 # Go暴力法 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func minSubArrayLen(target int, nums []int) int { n := len(nums) if n == 0 { return 0 } min := func(x, y int) int { if x \u0026gt; y { return y } return x } ans := math.MaxInt32 for i := 0; i \u0026lt; n; i++ { sum := 0 for j := i; j \u0026lt; n; j++ { sum += nums[j] if sum \u0026gt;= target { ans = min(ans, j-i+1) break } } } if ans == math.MaxInt32 { return 0 } return ans } func main() { fmt.Println(minSubArrayLen(7, []int{2, 3, 1, 2, 4, 3})) } Go滑动窗口 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func minSubArrayLen02(target int, nums []int) int { n := len(nums) if n == 0 { return 0 } min := func(x, y int) int { if x \u0026lt; y { return x } return y } ans := math.MaxInt32 i := 0 sum := 0 // 子数组的和 for j := 0; j \u0026lt; n; j++ { sum += nums[j] for sum \u0026gt;= target { ans = min(ans, j-i+1) sum -= nums[i] i++ } } if ans == math.MaxInt32 { return 0 } return ans } func main() { fmt.Println(minSubArrayLen02(7, []int{2, 3, 1, 2, 4, 3})) } "},{"id":12,"href":"/leetcode/docs/easy/344/","title":"344. 反转字符串","section":"Easy","content":" 344. 反转字符串 # 题目地址： https://leetcode.cn/problems/reverse-string/description/\n解题思路 # 双指针法 # 对于长度为N的待被反转的字符数组，我们可以观察反转前后下标的变化，假设反转前字符数组为s[0] s[1] s[2] ... s[N - 1]，那么反转后字符数组为s[N - 1] s[N - 2] ... s[0]。比较反转前后下标变化很容易得出s[i]的字符与s[N - 1 - i]的字符发生了交换的规律，因此我们可以得出如下双指针的解法：\n将left指向字符数组首元素，right指向字符数组尾元素。 当left \u0026lt; right： 交换s[left]和s[right]； left指针右移一位，即left = left + 1； right指针左移一位，即right = right - 1。 当left \u0026gt;= right，反转结束，返回字符数组即可。 具体实现 # Go package main import ( \u0026#34;fmt\u0026#34; ) func reverseString(s []byte) { for left, right := 0, len(s)-1; left \u0026lt; right; left++ { s[left], s[right] = s[right], s[left] right-- } } func main() { x := []byte{\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;} reverseString(x) fmt.Println(string(x)) } "},{"id":13,"href":"/leetcode/docs/easy/704/","title":"704. 二分查找","section":"Easy","content":" 704. 二分查找 # 题目地址： https://leetcode.cn/problems/binary-search/\n解题思路 # 参考 https://www.bilibili.com/video/BV1fA4y1o715/?spm_id_from=333.788\n对于常规实现来说，其实要区分区间，也就是左闭右闭和左闭右开的两种解法，对于左闭右闭来说，包含最右边，那么right其实是数组长度-1，但是对于左闭右开来说，因为不包含最右元素，那个right其实就是数组长度。\n具体实现 # Go 区间左闭右闭\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { arr := []int{0, 1, 2, 3, 4, 5, 10} fmt.Println(binarySearch(arr, 10)) } func binarySearch(nums []int, target int) int { left := 0 right := len(nums) - 1 for left \u0026lt;= right { middle := (left + right) / 2 if target \u0026gt; nums[middle] { left = middle + 1 } else if target \u0026lt; nums[middle] { right = middle - 1 } else { return middle } } return -1 } 区间左闭右开\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { arr := []int{0, 1, 2, 3, 4, 5, 10} fmt.Println(binarySearch(arr, 10)) } func binarySearch(nums []int, target int) int { left := 0 right := len(nums) for left \u0026lt; right { middle := (left + right) / 2 if target \u0026gt; nums[middle] { left = middle + 1 } else if target \u0026lt; nums[middle] { right = middle } else { return middle } } return -1 } Python TODO "},{"id":14,"href":"/leetcode/docs/easy/977/","title":"977. 有序数组的平方","section":"Easy","content":" 977. 有序数组的平方 # 题目地址： https://leetcode.cn/problems/squares-of-a-sorted-array/description/\n解题思路 # 暴力法 # 可以直接先计算平方，然后再利用库函数排序。\n双指针法 # 可以参考 https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html#%E6%9A%B4%E5%8A%9B%E6%8E%92%E5%BA%8F\n数组其实是有序的，只不过负数平方之后可能成为最大数了。那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。此时可以考虑双指针法了，i指向起始位置，j指向终止位置。定义一个新数组 result，和 A 数组一样的大小，让k指向 result 数组终止位置。\n如果A[i] * A[i] \u0026lt; A[j] * A[j] 那么result[k--] = A[j] * A[j] 。\n如果A[i] * A[i] \u0026gt;= A[j] * A[j]那么result[k--] = A[i] * A[i]。\n具体实现 # Go暴力法 package main import \u0026#34;fmt\u0026#34; func removeElement(nums []int, val int) int { length := len(nums) low := 0 for i := 0; i \u0026lt; length; i++ { if nums[i] != val { nums[low] = nums[i] low++ } } return low } func main() { x := []int{1, 2, 6, 7, 9, 6, 6, 6} xx := removeElement(x, 6) fmt.Println(x, xx) } Go双指针 package main import \u0026#34;fmt\u0026#34; func sortedSquares02(nums []int) []int { if len(nums) == 0 { return []int{} } var ( result = make([]int, len(nums)) i, j = 0, len(nums) - 1 k = len(nums) - 1 ) for i \u0026lt;= j { if nums[i]*nums[i] \u0026gt; nums[j]*nums[j] { result[k] = nums[i] * nums[i] k-- i++ } else { result[k] = nums[j] * nums[j] k-- j-- } } return result } func main() { fmt.Println(sortedSquares02([]int{-4, -1, 0, 3, 10})) } "},{"id":15,"href":"/leetcode/docs/medium/hidden/","title":"Hidden","section":"Medium","content":" This page is hidden in menu # Quondam non pater est dignior ille Eurotas # Latent te facies # Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\nPater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona # O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); } Fronde cetera dextrae sequens pennis voce muneris # Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "}]