[{"id":0,"href":"/leetcode/docs/other/interview-08.06/","title":"ğŸ˜ªé¢è¯•é¢˜ 08.06. æ±‰è¯ºå¡”é—®é¢˜","section":"å…¶ä»–","content":" é¢è¯•é¢˜ 08.06. æ±‰è¯ºå¡”é—®é¢˜ # é¢˜ç›®åœ°å€ï¼š é¢è¯•é¢˜ 08.06. æ±‰è¯ºå¡”é—®é¢˜ / å›¾è§£æ±‰è¯ºå¡”çš„æ•…äº‹ï¼šæ®è¯´ï¼Œå½“64ä¸ªç›˜å­å…¨éƒ¨ç§»å®Œçš„é‚£å¤©ï¼Œä¸–ç•Œå°±æ¯ç­äº†\n"},{"id":1,"href":"/leetcode/docs/easy/1/","title":"1. ä¸¤æ•°ä¹‹å’Œ","section":"Easy","content":" 1. ä¸¤æ•°ä¹‹å’Œ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # æš´åŠ›æ³• # åµŒå¥—éå†æ•°ç»„ï¼Œå¤–å±‚éå†çš„å€¼å’Œå†…å±‚éå†çš„å€¼ç›¸åŠ ï¼Œå¦‚æœç›¸åŠ ç­‰äºç›®æ ‡å€¼ï¼Œåˆ™è¿”å›ç»“æœï¼Œå¦åˆ™ç»§ç»­éå†ã€‚å†…å±‚éå†å¼€å§‹çš„ä½ç½®æ˜¯å¤–å±‚éå†çš„ä½ç½®åŠ  1ï¼Œç»“æŸçš„ä½ç½®æ˜¯æ•°ç»„é•¿åº¦ã€‚\nmap # TODO\nå…·ä½“å®ç° # Go Map package main import \u0026#34;fmt\u0026#34; func twoSum(nums []int, target int) []int { if len(nums) == 0 { return []int{} } m := make(map[int]int, 0) // val =\u0026gt; index for index, val := range nums { ass := target - val if idx, ok := m[ass]; ok { return []int{idx, index} } else { m[val] = index } } return []int{} } func main() { fmt.Println(twoSum([]int{3, 2, 4}, 6)) } Goæš´åŠ›æ³• package main import \u0026#34;fmt\u0026#34; func twoSum(nums []int, target int) []int { for index, value := range nums { for i := index + 1; i \u0026lt; len(nums); i++ { if (value + nums[i]) == target { return []int{index, i} } } } return nil } func main() { fmt.Println(twoSum([]int{3, 2, 4}, 6)) } "},{"id":2,"href":"/leetcode/docs/easy/","title":"Easy","section":"Docs","content":" Easy # æ˜æ—¥å¤æ˜æ—¥ï¼Œæ˜æ—¥ä½•å…¶å¤šï¼Œæˆ‘ç”Ÿå¾…æ˜æ—¥ï¼Œä¸‡äº‹æˆè¹‰è·ã€‚ä¸–äººè‹¥è¢«æ˜æ—¥ç´¯ï¼Œæ˜¥å»ç§‹æ¥è€å°†è‡³ã€‚æœçœ‹æ°´ä¸œæµï¼Œæš®çœ‹æ—¥è¥¿å ã€‚ç™¾å¹´æ˜æ—¥èƒ½å‡ ä½•ï¼Œè¯·å›å¬æˆ‘æ˜æ—¥æ­Œã€‚ "},{"id":3,"href":"/leetcode/docs/medium/","title":"Medium","section":"Docs","content":" Medium # åŠå›è«æƒœé‡‘ç¼•è¡£ï¼ŒåŠå›é¡»æƒœå°‘å¹´æ—¶ã€‚èŠ±å¼€å ªæŠ˜ç›´é¡»æŠ˜ï¼Œè«å¾…æ— èŠ±ç©ºæŠ˜æã€‚ "},{"id":4,"href":"/leetcode/docs/other/bubble/","title":"å†’æ³¡æ’åº","section":"å…¶ä»–","content":" å†’æ³¡æ’åº # é¢˜ç›®æè¿° # è¾“å…¥ä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼ŒæŒ‰ä»å°åˆ°å¤§çš„é¡ºåºæ’åºã€‚\nå…·ä½“å®ç° # package main import \u0026#34;fmt\u0026#34; func Bubble(arr []int) []int { length := len(arr) for i := 0; i \u0026lt; length-1; i++ { // æ³¨æ„è¿™é‡Œ j æ˜¯ä» 0 å¼€å§‹è€Œä¸æ˜¯ä» i å¼€å§‹ for j := 0; j \u0026lt; length-i-1; j++ { if arr[j] \u0026gt; arr[j+1] { tmp := arr[j] arr[j] = arr[j+1] arr[j+1] = tmp } } } return arr } func main() { fmt.Println(Bubble([]int{1, 10, 25, 30})) } "},{"id":5,"href":"/leetcode/docs/hard/","title":"Hard","section":"Docs","content":" Hard # å¥½å­¦è¿‘ä¹çŸ¥ï¼ŒåŠ›è¡Œè¿‘ä¹ä»ï¼ŒçŸ¥è€»è¿‘ä¹å‹‡ã€‚ "},{"id":6,"href":"/leetcode/docs/other/","title":"å…¶ä»–","section":"Docs","content":" å…¶ä»– # ä¸€å¯¸å…‰é˜´ä¸€å¯¸é‡‘ï¼Œå¯¸é‡‘éš¾ä¹°å¯¸å…‰é˜´ã€‚é»‘å‘ä¸çŸ¥å‹¤å­¦æ—©ï¼Œè½¬çœ¼ä¾¿æ˜¯ç™½å¤´ç¿ã€‚ "},{"id":7,"href":"/leetcode/docs/medium/15/","title":"15. ä¸‰æ•°ä¹‹å’Œ","section":"Medium","content":" 15. ä¸‰æ•°ä¹‹å’Œ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode "},{"id":8,"href":"/leetcode/docs/finger-offer2/018/","title":"018. æœ‰æ•ˆçš„å›æ–‡","section":"å‰‘æŒ‡ Offerï¼ˆäºŒï¼‰","content":" 018. æœ‰æ•ˆçš„å›æ–‡ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ "},{"id":9,"href":"/leetcode/docs/medium/18/","title":"18. å››æ•°ä¹‹å’Œ","section":"Medium","content":" 18. å››æ•°ä¹‹å’Œ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode "},{"id":10,"href":"/leetcode/docs/medium/19/","title":"19. åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹","section":"Medium","content":" 19. åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # å¸¸è§„æ³• # å…ˆè®¡ç®—é“¾è¡¨é•¿åº¦ï¼Œæ¯”å¦‚æ˜¯ lengthã€‚é‚£ä¹ˆåˆ é™¤å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯åˆ é™¤é¡ºæ•°ç¬¬ length-n+1 ä¸ªèŠ‚ç‚¹ï¼Œè®¾ä¸º sï¼Œç›´æ¥ä» 1 æ‰¾åˆ°ç¬¬ s-1 ä¸ªä¹Ÿå°±æ˜¯ s çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹ï¼ˆå…¶å®ä¹Ÿå°±æ˜¯ length-nï¼‰ï¼Œç›´æ¥æŠŠ s-1 åˆ é™¤å³å¯ã€‚\nåŒæŒ‡é’ˆæ³• # TODO\nå…·ä½“å®ç° # Goå¸¸è§„æ³• package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func removeNthFromEnd(head *ListNode, n int) *ListNode { if head == nil { return head } length := 0 tmpc := head for tmpc != nil { //fmt.Println(tmpc.Val) length++ tmpc = tmpc.Next } // éœ€è¦æœ‰è™šæ‹Ÿå¤´ç»“ç‚¹æ˜¯å› ä¸ºï¼Œå¯èƒ½åˆ é™¤çš„æ˜¯æœ€åçš„èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯å¤´ç»“ç‚¹ï¼Œç”¨è™šæ‹Ÿå¤´ç»“ç‚¹å¯ä»¥ç»Ÿä¸€å¤„ç† dummy := \u0026amp;ListNode{ Val: 0, Next: head, } cur := dummy // æ³¨æ„è¿™é‡Œ i æ˜¯ä» 1 å¼€å§‹ for i := 1; i \u0026lt; length-n+1; i++ { cur = cur.Next } cur.Next = cur.Next.Next return dummy.Next } func main() { ret := removeNthFromEnd(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: \u0026amp;ListNode{ Val: 5, Next: nil, }, }, }, }, }, 2) fmt.Println(ret) } GoåŒæŒ‡é’ˆ package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func removeNthFromEnd(head *ListNode, n int) *ListNode { if head == nil { return head } dummy := \u0026amp;ListNode{ Next: head, } fast, low := dummy, dummy // fast å…ˆç§»åŠ¨ n æ­¥ for n != 0 \u0026amp;\u0026amp; fast != nil { fast = fast.Next n-- } // fast å†ç§»åŠ¨ä¸€æ­¥ï¼Œè¿™æ ·å½“ fast ä¸º nil æ—¶ï¼Œlow åœ¨ n çš„ä¸Šä¸€ä½ fast = fast.Next for fast != nil { fast = fast.Next low = low.Next } low.Next = low.Next.Next return dummy.Next } func main() { ret := removeNthFromEnd(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: \u0026amp;ListNode{ Val: 5, Next: nil, }, }, }, }, }, 2) fmt.Println(ret) } å‚è€ƒ # 19.åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹ "},{"id":11,"href":"/leetcode/docs/easy/20/","title":"20. æœ‰æ•ˆçš„æ‹¬å·","section":"Easy","content":" 20. æœ‰æ•ˆçš„æ‹¬å· # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # åˆ¤æ–­æ‹¬å·çš„æœ‰æ•ˆæ€§å¯ä»¥ä½¿ç”¨ã€Œæ ˆã€è¿™ä¸€æ•°æ®ç»“æ„æ¥è§£å†³ã€‚\næˆ‘ä»¬éå†ç»™å®šçš„å­—ç¬¦ä¸² sã€‚å½“æˆ‘ä»¬é‡åˆ°ä¸€ä¸ªå·¦æ‹¬å·æ—¶ï¼Œæˆ‘ä»¬ä¼šæœŸæœ›åœ¨åç»­çš„éå†ä¸­ï¼Œæœ‰ä¸€ä¸ªç›¸åŒç±»å‹çš„å³æ‹¬å·å°†å…¶é—­åˆã€‚ç”±äº åé‡åˆ°çš„å·¦æ‹¬å·è¦å…ˆé—­åˆï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°†è¿™ä¸ªå·¦æ‹¬å·æ”¾å…¥æ ˆé¡¶ã€‚\nå½“æˆ‘ä»¬é‡åˆ°ä¸€ä¸ªå³æ‹¬å·æ—¶ï¼Œæˆ‘ä»¬éœ€è¦å°†ä¸€ä¸ªç›¸åŒç±»å‹çš„å·¦æ‹¬å·é—­åˆã€‚æ­¤æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å–å‡ºæ ˆé¡¶çš„å·¦æ‹¬å·å¹¶åˆ¤æ–­å®ƒä»¬æ˜¯å¦æ˜¯ç›¸åŒç±»å‹çš„æ‹¬å·ã€‚å¦‚æœä¸æ˜¯ç›¸åŒçš„ç±»å‹ï¼Œæˆ–è€…æ ˆä¸­å¹¶æ²¡æœ‰å·¦æ‹¬å·ï¼Œé‚£ä¹ˆå­—ç¬¦ä¸² s æ— æ•ˆï¼Œè¿”å› Falseã€‚ä¸ºäº†å¿«é€Ÿåˆ¤æ–­æ‹¬å·çš„ç±»å‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨å­˜å‚¨æ¯ä¸€ç§æ‹¬å·ã€‚å“ˆå¸Œè¡¨çš„é”®ä¸ºå³æ‹¬å·ï¼Œå€¼ä¸ºç›¸åŒç±»å‹çš„å·¦æ‹¬å·ã€‚\nåœ¨éå†ç»“æŸåï¼Œå¦‚æœæ ˆä¸­æ²¡æœ‰å·¦æ‹¬å·ï¼Œè¯´æ˜æˆ‘ä»¬å°†å­—ç¬¦ä¸² s ä¸­çš„æ‰€æœ‰å·¦æ‹¬å·é—­åˆï¼Œè¿”å› Trueï¼Œå¦åˆ™è¿”å› Falseã€‚\næ³¨æ„åˆ°æœ‰æ•ˆå­—ç¬¦ä¸²çš„é•¿åº¦ä¸€å®šä¸ºå¶æ•°ï¼Œå› æ­¤å¦‚æœå­—ç¬¦ä¸²çš„é•¿åº¦ä¸ºå¥‡æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è¿”å› Falseï¼Œçœå»åç»­çš„éå†åˆ¤æ–­è¿‡ç¨‹ã€‚\nå…·ä½“å®ç° # Go package main import \u0026#34;fmt\u0026#34; func isValid(s string) bool { n := len(s) if n%2 != 0 { // å¥‡æ•°ç›´æ¥é€€å‡º return false } pairs := map[byte]byte{ \u0026#39;)\u0026#39;: \u0026#39;(\u0026#39;, \u0026#39;]\u0026#39;: \u0026#39;[\u0026#39;, \u0026#39;}\u0026#39;: \u0026#39;{\u0026#39;, } stack := []byte{} for i := 0; i \u0026lt; n; i++ { if pairs[s[i]] \u0026gt; 0 { // å¦‚æœæ˜¯å³æ‹¬å·,åˆ¤æ–­æ ˆé¡¶æ˜¯å¦æ˜¯å¯¹åº”çš„å·¦æ‹¬å·,æœç„¶æœ‰å¯¹åº”çš„å·¦æ‹¬å·,åˆ™å¼¹å‡ºæ ˆé¡¶å…ƒç´ ,å¦åˆ™ç›´æ¥é€€å‡º if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] { return false } stack = stack[:len(stack)-1] } else { stack = append(stack, s[i]) } } return len(stack) == 0 } func main() { fmt.Println(isValid(\u0026#34;()[]{}\u0026#34;)) } "},{"id":12,"href":"/leetcode/docs/easy/21/","title":"21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨","section":"Easy","content":" 21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # é€’å½’è§£æ³• # å‚è€ƒ ä¸€çœ‹å°±ä¼šï¼Œä¸€å†™å°±åºŸï¼Ÿè¯¦è§£é€’å½’ã€‚\né€’å½’çš„æ ¸å¿ƒåœ¨äºï¼Œæˆ‘åªå…³æ³¨æˆ‘è¿™ä¸€å±‚è¦å¹²ä»€ä¹ˆï¼Œè¿”å›ä»€ä¹ˆï¼Œè‡³äºæˆ‘çš„ä¸‹ä¸€å±‚ï¼ˆè§„æ¨¡å‡ 1ï¼‰ï¼Œæˆ‘ä¸ç®¡ï¼Œæˆ‘å°±æ˜¯ç”©æ‰‹æŒæŸœã€‚\né‚£ä¹ˆç°åœ¨æˆ‘è¦ merge L1ï¼ŒL2 æˆ‘éœ€è¦æ€ä¹ˆåšâ“\nå½“ä¸€æ¡é“¾è¡¨ä¸ºç©ºæ—¶ï¼Œè¿”å›å¯¹æ–¹ï¼Œå› ä¸ºå¦‚æœè¿”å›è‡ªå·±ï¼Œå°±é€€å‡ºäº†ï¼Œè¿”å›å¯¹æ–¹ï¼Œä¸ç®¡å¯¹æ–¹æ˜¯ä»€ä¹ˆï¼Œè®©ä¸‹çº§å»åˆ¤æ–­ã€‚ å¦‚æœ L1 ç¬¬ä¸€ä¸ªå…ƒç´ å°äº L2 çš„ï¼Ÿé‚£æˆ‘å¾—æŠŠ L1 çš„è¿™ä¸ªå…ƒç´ æ”¾åˆ°æœ€å‰é¢ï¼Œè‡³äºåé¢çš„é‚£ä¸²é•¿å•¥æ ·ï¼Œæˆ‘ä¸ç®¡ã€‚æˆ‘åªè¦æ¥è¿‡ä¸‹çº§å‘˜å·¥å¹²å®Œæ´»åç»™æˆ‘çš„åŒ…è£¹ï¼Œç„¶åæŠŠæˆ‘å¹²çš„æ´»é™„ä¸Šå»ï¼ˆä»¤ L1-\u0026gt;next = è¿™ä¸ªåŒ…è£¹ï¼‰å°±è¡Œã€‚ è¿™ä¸ªåŒ…è£¹æ˜¯ä¸‹çº§å‘˜å·¥å¹²çš„æ´»ï¼Œå³merge(L1-\u0026gt;next,L2)ã€‚ æˆ‘è¯¥è¿”å›å•¥â“\nç°åœ¨ä¸ç®¡æˆ‘çš„ä¸‹ä¸€å±‚å¹²äº†ä»€ä¹ˆï¼Œåˆè¿”å›äº†ä»€ä¹ˆç»™æˆ‘ï¼Œæˆ‘åªè¦çŸ¥é“ï¼Œå‡è®¾æˆ‘çš„å·¥å…·äººä»¬éƒ½å®Œæˆäº†ä»»åŠ¡ï¼Œé‚£æˆ‘çš„ä»»åŠ¡ä¹Ÿå°±å®Œæˆäº†ï¼Œå¯ä»¥è¿”å›æœ€ç»ˆç»“æœäº†ã€‚ æœ€ç»ˆç»“æœå°±æ˜¯æˆ‘ä¸€å¼€å§‹æ¥æ‰‹çš„ L1 å¤´ç»“ç‚¹+ä¸‹çº§å‘˜å·¥ç»™æˆ‘çš„å¤§åŒ…è£¹ï¼Œè¦ä¸€å¹¶äº¤ä¸Šå»ï¼Œè¿™æ ·æˆ‘çš„ boss æ‰èƒ½æ ¹æ®æˆ‘ç»™å®ƒçš„ L1 å¤´èŠ‚ç‚¹å¾€ä¸‹æ‰¾ï¼Œæ£€æŸ¥æˆ‘å®Œæˆçš„å·¥ä½œã€‚ å…·ä½“å®ç° # Go é€’å½’ package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func mergeTwoLists(list1 *ListNode, list2 *ListNode) (x *ListNode) { if list1 == nil { return list2 } if list2 == nil { return list1 } if list1.Val \u0026lt;= list2.Val { list1.Next = mergeTwoLists(list1.Next, list2) return list1 } else { list2.Next = mergeTwoLists(list2.Next, list1) return list2 } } func main() { x := mergeTwoLists(\u0026amp;ListNode{Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 4, Next: nil, }, }}, \u0026amp;ListNode{Val: 1, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: nil, }, }}) fmt.Println(x) } Go è¿­ä»£ package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func mergeTwoLists(list1 *ListNode, list2 *ListNode) (x *ListNode) { // æ–¹ä¾¿éå†å®Œæˆåå¿«é€Ÿæ‰¾åˆ°å¤´èŠ‚ç‚¹ dummy := \u0026amp;ListNode{} prev := dummy for list1 != nil \u0026amp;\u0026amp; list2 != nil { if list1.Val \u0026gt;= list2.Val { prev.Next = list2 list2 = list2.Next } else { prev.Next = list1 list1 = list1.Next } prev = prev.Next } if list1 != nil { prev.Next = list1 } if list2 != nil { prev.Next = list2 } return dummy.Next } func main() { x := mergeTwoLists(\u0026amp;ListNode{Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 4, Next: nil, }, }}, \u0026amp;ListNode{Val: 1, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: nil, }, }}) fmt.Println(x) } å‚è€ƒ # B ç«™ - åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ LeetCode - åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ "},{"id":13,"href":"/leetcode/docs/hard/23/","title":"23. åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨","section":"Hard","content":" 23. åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # å…·ä½“å®ç° # Go package main import ( \u0026#34;fmt\u0026#34; ) type ListNode struct { Val int Next *ListNode } func mergeKLists(lists []*ListNode) *ListNode { if len(lists) == 0 { return nil } n := len(lists) return merge(lists, 0, n-1) } func merge(lists []*ListNode, left, right int) *ListNode { if left == right { return lists[left] } mid := left + (right-left)/2 l1 := merge(lists, left, mid) l2 := merge(lists, mid+1, right) return mergeTwoLists(l1, l2) } func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1.Val \u0026lt; l2.Val { l1.Next = mergeTwoLists(l1.Next, l2) return l1 } else { l2.Next = mergeTwoLists(l1, l2.Next) return l2 } } func main() { list1 := \u0026amp;ListNode{Val: 1, Next: \u0026amp;ListNode{Val: 4, Next: \u0026amp;ListNode{Val: 5}}} list2 := \u0026amp;ListNode{Val: 1, Next: \u0026amp;ListNode{Val: 3, Next: \u0026amp;ListNode{Val: 4}}} list3 := \u0026amp;ListNode{Val: 2, Next: \u0026amp;ListNode{Val: 6}} lists := []*ListNode{list1, list2, list3} result := mergeKLists(lists) for result != nil { fmt.Printf(\u0026#34;%d \u0026#34;, result.Val) result = result.Next } } å‚è€ƒ # åˆå¹¶Kä¸ªå‡åºé“¾è¡¨-è§£é¢˜æ€è·¯ "},{"id":14,"href":"/leetcode/docs/medium/24/","title":"24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹","section":"Medium","content":" 24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # å‚è€ƒ https://leetcode.cn/problems/swap-nodes-in-pairs/solutions/444474/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/\né€’å½’æ³• # å¯ä»¥é€šè¿‡é€’å½’çš„æ–¹å¼å®ç°ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ã€‚é€’å½’çš„ç»ˆæ­¢æ¡ä»¶æ˜¯é“¾è¡¨ä¸­æ²¡æœ‰èŠ‚ç‚¹ï¼Œæˆ–è€…é“¾è¡¨ä¸­åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ­¤æ—¶æ— æ³•è¿›è¡Œäº¤æ¢ã€‚\nå¦‚æœé“¾è¡¨ä¸­è‡³å°‘æœ‰ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œåˆ™åœ¨ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ä¹‹åï¼ŒåŸå§‹é“¾è¡¨çš„å¤´èŠ‚ç‚¹å˜æˆæ–°çš„é“¾è¡¨çš„ç¬¬äºŒä¸ªèŠ‚ç‚¹ï¼ŒåŸå§‹é“¾è¡¨çš„ç¬¬äºŒä¸ªèŠ‚ç‚¹å˜æˆæ–°çš„é“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚é“¾è¡¨ä¸­çš„å…¶ä½™èŠ‚ç‚¹çš„ä¸¤ä¸¤äº¤æ¢å¯ä»¥é€’å½’åœ°å®ç°ã€‚åœ¨å¯¹é“¾è¡¨ä¸­çš„å…¶ä½™èŠ‚ç‚¹é€’å½’åœ°ä¸¤ä¸¤äº¤æ¢ä¹‹åï¼Œæ›´æ–°èŠ‚ç‚¹ä¹‹é—´çš„æŒ‡é’ˆå…³ç³»ï¼Œå³å¯å®Œæˆæ•´ä¸ªé“¾è¡¨çš„ä¸¤ä¸¤äº¤æ¢ã€‚\nç”¨headè¡¨ç¤ºåŸå§‹é“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œæ–°çš„é“¾è¡¨çš„ç¬¬äºŒä¸ªèŠ‚ç‚¹ï¼Œç”¨newHeadè¡¨ç¤ºæ–°çš„é“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼ŒåŸå§‹é“¾è¡¨çš„ç¬¬äºŒä¸ªèŠ‚ç‚¹ï¼Œåˆ™åŸå§‹é“¾è¡¨ä¸­çš„å…¶ä½™èŠ‚ç‚¹çš„å¤´èŠ‚ç‚¹æ˜¯newHead.nextã€‚ä»¤head.next = swapPairs(newHead.next)ï¼Œè¡¨ç¤ºå°†å…¶ä½™èŠ‚ç‚¹è¿›è¡Œä¸¤ä¸¤äº¤æ¢ï¼Œäº¤æ¢åçš„æ–°çš„å¤´èŠ‚ç‚¹ä¸ºheadçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚ç„¶åä»¤newHead.next = headï¼Œå³å®Œæˆäº†æ‰€æœ‰èŠ‚ç‚¹çš„äº¤æ¢ã€‚æœ€åè¿”å›æ–°çš„é“¾è¡¨çš„å¤´èŠ‚ç‚¹newHeadã€‚\nâš ï¸å¥½å§ï¼Œå†ç†è§£ä¸€ä¸‹ï¼Œå…³äºé€’å½’ï¼Œæˆ‘åªå…³æ³¨æˆ‘è¿™ä¸€å±‚è¦å¹²ä»€ä¹ˆï¼Œè¿”å›ä»€ä¹ˆï¼Œè‡³äºæˆ‘çš„ä¸‹ä¸€å±‚ï¼ˆè§„æ¨¡å‡ 1ï¼‰ï¼Œæˆ‘ä¸ç®¡ï¼Œæˆ‘å°±æ˜¯ä¸€ä¸ªç”©æ‰‹æŒæŸœğŸ™ˆã€‚\næˆ‘å…¶å®åªéœ€è¦å…³å¿ƒç¬¬ä¸€å±‚ï¼Œä¹Ÿå°±æ˜¯èŠ‚ç‚¹1å’ŒèŠ‚ç‚¹2çš„äº¤æ¢ï¼ŒæŠŠèŠ‚ç‚¹2çš„nextæŒ‡å‘èŠ‚ç‚¹1ï¼ŒèŠ‚ç‚¹2çš„nextç»™ä¸‹ä¸€å±‚ä¹Ÿå°±æ˜¯é€’å½’å‡½æ•°ã€‚è€Œæˆ‘æœ€åè¿”å›çš„åº”è¯¥æ˜¯å¤´ç»“ç‚¹ï¼Œå…¶å®ä¹Ÿå°±æ˜¯åŸå§‹èŠ‚ç‚¹çš„èŠ‚ç‚¹2ã€‚\nè¿­ä»£æ³• # TODO\nå…·ä½“å®ç° # Goè¿­ä»£ package main import ( \u0026#34;fmt\u0026#34; ) type ListNode struct { Val int Next *ListNode } func swapPairs(head *ListNode) *ListNode { if head == nil { return head } dummy := \u0026amp;ListNode{ Val: 0, Next: head, } curr := dummy // å¦‚æœæ˜¯é“¾è¡¨é•¿åº¦æ˜¯å¥‡æ•°é‚£å°±æ²¡æœ‰å¿…è¦äº¤æ¢ï¼Œåªæœ‰å¶æ•°æ‰éœ€è¦äº¤æ¢ï¼Œæ‰€ä»¥è¿™é‡Œçš„åˆ¤æ–­æ¡ä»¶æ˜¯ \u0026amp;\u0026amp; // è¿™é‡Œä¸èƒ½ç”¨ä¸€ä¸ªä¸´æ—¶å‚æ•°ï¼Œå› ä¸ºé“¾è¡¨æŒ‡é’ˆåçš„å€¼ä¼šå˜åŒ– for curr.Next != nil \u0026amp;\u0026amp; curr.Next.Next != nil { tmp := curr.Next tmp1 := curr.Next.Next.Next curr.Next = curr.Next.Next curr.Next.Next = tmp curr.Next.Next.Next = tmp1 // è¿™é‡Œä¹Ÿå¯ä»¥ç›´æ¥å†™æˆ curr = tmp curr = curr.Next.Next } return dummy.Next } func main() { x := swapPairs(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: nil, }, }, }, }) fmt.Println(x) } Goé€’å½’ package main import ( \u0026#34;fmt\u0026#34; ) type ListNode struct { Val int Next *ListNode } func swapPairs(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } newHead := head.Next head.Next = swapPairs(head.Next.Next) newHead.Next = head return newHead } func main() { x := swapPairs(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: nil, }, }, }, }) fmt.Println(x) } "},{"id":15,"href":"/leetcode/docs/hard/25/","title":"25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨","section":"Hard","content":" 25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # å…·ä½“å®ç° # Go package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func reverseKGroup(head *ListNode, k int) *ListNode { // åè½¬é“¾è¡¨ reverse := func(head *ListNode) *ListNode { if head == nil { return nil } var ( prev, curr, next *ListNode ) curr = head for curr != nil { next = curr.Next curr.Next = prev prev = curr curr = next } return prev } dummy := \u0026amp;ListNode{} var ( prev, end *ListNode ) dummy.Next = head prev = dummy end = dummy for end.Next != nil { // æŠŠ end å¾€åç§»åŠ¨ k ä¸ªä½ç½® for i := 0; i \u0026lt; k \u0026amp;\u0026amp; end != nil; i++ { end = end.Next } if end == nil { break } start := prev.Next next := end.Next end.Next = nil prev.Next = reverse(start) start.Next = next prev = start end = start } return dummy.Next } func main() { ret := reverseKGroup(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: \u0026amp;ListNode{ Val: 5, Next: nil, }, }, }, }, }, 2) fmt.Println(ret) } å‚è€ƒ # é“¾è¡¨ä¸­çš„èŠ‚ç‚¹æ¯kä¸ªä¸€ç»„ç¿»è½¬ å›¾è§£ K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨ "},{"id":16,"href":"/leetcode/docs/easy/27/","title":"27. ç§»é™¤å…ƒç´ ","section":"Easy","content":" 27. ç§»é™¤å…ƒç´  # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # æš´åŠ›æ³• # TODO\nåŒæŒ‡é’ˆæ³• # å¯ä»¥ç”¨åŒæŒ‡é’ˆ/å¿«æ…¢æŒ‡é’ˆæ¥è§£å†³ã€‚å¿«æŒ‡é’ˆç”¨æ¥å¯»æ‰¾æ–°æ•°ç»„çš„å…ƒç´ ï¼Œæ–°æ•°ç»„å°±æ˜¯ä¸å«æœ‰ç›®æ ‡å…ƒç´ çš„æ•°ç»„ï¼Œæ…¢æŒ‡é’ˆç”¨æ¥æŒ‡å‘æ›´æ–°æ–°æ•°ç»„ä¸‹æ ‡çš„ä½ç½®ã€‚è¿™é‡Œéœ€è¦çš„æ³¨æ„çš„æ˜¯ï¼Œâ€œæ–°æ•°ç»„â€å…¶å®å°±æ˜¯æ—§æ•°ç»„ï¼Œå› ä¸ºä¸€ç›´éƒ½åœ¨åœ¨åŒä¸€ä¸ªæ•°ç»„ä¸Šçš„æ“ä½œï¼Œè¿™ä¹Ÿæ˜¯é¢˜ç›®çš„è¦æ±‚ğŸ‘‡\nä¸è¦ä½¿ç”¨é¢å¤–çš„æ•°ç»„ç©ºé—´ï¼Œä½ å¿…é¡»ä»…ä½¿ç”¨O(1)é¢å¤–ç©ºé—´å¹¶åŸåœ°ä¿®æ”¹è¾“å…¥æ•°ç»„ã€‚\nå…·ä½“å®ç° # GoåŒæŒ‡é’ˆ package main import \u0026#34;fmt\u0026#34; func removeElement(nums []int, val int) int { length := len(nums) low := 0 for i := 0; i \u0026lt; length; i++ { if nums[i] != val { nums[low] = nums[i] low++ } } return low } func main() { x := []int{1, 2, 6, 7, 9, 6, 6, 6} xx := removeElement(x, 6) fmt.Println(x, xx) } Goæš´åŠ›æ³• package main import \u0026#34;fmt\u0026#34; func removeElement(nums []int, val int) int { if len(nums) == 0 { return 0 } length := len(nums) for i := 0; i \u0026lt; length; i++ { if nums[i] == val { // å‘ç°éœ€è¦ç§»é™¤çš„å…ƒç´ ï¼Œå°±å°†æ•°ç»„é›†ä½“å‘å‰ç§»åŠ¨ä¸€ä½ for j := i + 1; j \u0026lt; length; j++ { nums[j-1] = nums[j] } // å› ä¸ºä¸‹æ ‡iä»¥åçš„æ•°å€¼éƒ½å‘å‰ç§»åŠ¨äº†ä¸€ä½ï¼Œæ‰€ä»¥iä¹Ÿå‘å‰ç§»åŠ¨ä¸€ä½ // å› ä¸ºä¸çŸ¥é“ç§»åŠ¨è¿‡æ¥çš„ç¬¬ä¸€ä½çš„å€¼æ˜¯ä¸æ˜¯ val i-- length-- // æ­¤æ—¶æ•°ç»„çš„å¤§å°-1 } } return length } func main() { x := []int{1, 2, 6, 7, 9, 6, 6, 6} xx := removeElement(x, 6) fmt.Println(x, xx) } å‚è€ƒ # 27. ç§»é™¤å…ƒç´  "},{"id":17,"href":"/leetcode/docs/medium/53/","title":"53. æœ€å¤§å­æ•°ç»„å’Œ","section":"Medium","content":" 53. æœ€å¤§å­æ•°ç»„å’Œ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # å…·ä½“å®ç° # Goè´ªå¿ƒç®—æ³• package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func maxSubArray(nums []int) int { if len(nums) == 0 { return 0 } count := 0 result := math.MinInt64 length := len(nums) for i := 0; i \u0026lt; length; i++ { count += nums[i] if count \u0026gt; result { result = count } if count \u0026lt;= 0 { count = 0 } } return result } func main() { fmt.Println(maxSubArray([]int{-2, 1, -3, 4, -1, 2, 1, -5, 4})) } Goæš´åŠ›æ³• package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func maxSubArray(nums []int) int { if len(nums) == 0 { return 0 } count := 0 result := math.MinInt64 length := len(nums) for i := 0; i \u0026lt; length; i++ { count = 0 for j := i; j \u0026lt; length; j++ { count += nums[j] if count \u0026gt; result { result = count } } } return result } func main() { fmt.Println(maxSubArray([]int{-2, 1, -3, 4, -1, 2, 1, -5, 4})) } "},{"id":18,"href":"/leetcode/docs/medium/59/","title":"59. èºæ—‹çŸ©é˜µ II","section":"Medium","content":" 59. èºæ—‹çŸ©é˜µ II # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # å¯ä»¥å‚è€ƒ https://leetcode.cn/problems/spiral-matrix-ii/solutions/12594/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/\nå…·ä½“å®ç° # Go package main import \u0026#34;fmt\u0026#34; func main() { n := 3 fmt.Println(generateMatrix(n)) } func generateMatrix(n int) [][]int { ret := make([][]int, n) startX, startY := 0, 0 count := 1 offset := 1 loop := n / 2 for i := 0; i \u0026lt; n; i++ { ret[i] = make([]int, n) } for loop \u0026gt; 0 { i, j := startX, startY for j = startY; j \u0026lt; n-offset; j++ { ret[startX][j] = count count++ } for i = startX; i \u0026lt; n-offset; i++ { ret[i][j] = count count++ } for ; j \u0026gt; startY; j-- { ret[i][j] = count count++ } for ; i \u0026gt; startX; i-- { ret[i][j] = count count++ } startX++ startY++ offset++ loop-- } if n%2 == 1 { ret[n/2][n/2] = n * n } return ret } å‚è€ƒ # ä¸€å…¥å¾ªç¯æ·±ä¼¼æµ· | LeetCodeï¼š59.èºæ—‹çŸ©é˜µII "},{"id":19,"href":"/leetcode/docs/hard/76/","title":"ğŸ˜ª76. æœ€å°è¦†ç›–å­ä¸²","section":"Hard","content":" 76. æœ€å°è¦†ç›–å­ä¸² # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # TODO\nå…·ä½“æ€è·¯ # "},{"id":20,"href":"/leetcode/docs/medium/92/","title":"92. åè½¬é“¾è¡¨ II","section":"Medium","content":" 92. åè½¬é“¾è¡¨ II # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # å…·ä½“å®ç° # Go package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func reverseBetween(head *ListNode, left int, right int) *ListNode { if head == nil { return head } var ( dummy = \u0026amp;ListNode{} prev, curr *ListNode ) dummy.Next = head prev = dummy for i := 0; i \u0026lt; left-1; i++ { prev = prev.Next } curr = prev.Next for i := 0; i \u0026lt; right-left; i++ { next := curr.Next curr.Next = curr.Next.Next next.Next = prev.Next prev.Next = next } return dummy.Next } func main() { ret := reverseBetween(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: \u0026amp;ListNode{ Val: 5, Next: nil, }, }, }, }, }, 2, 4) fmt.Println(ret) } å‚è€ƒ # é“¾è¡¨å†…æŒ‡å®šåŒºé—´åè½¬ "},{"id":21,"href":"/leetcode/docs/easy/104/","title":"ğŸ˜ª104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦","section":"Easy","content":" 104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode "},{"id":22,"href":"/leetcode/docs/easy/242/","title":"242. æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯","section":"Easy","content":" 242. æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # map # å…·ä½“å®ç° # Go map package main import \u0026#34;fmt\u0026#34; func isAnagram(s string, t string) bool { if len(s) != len(t) { return false } var arr [26]int for i := 0; i \u0026lt; len(s); i++ { arr[s[i]-\u0026#39;a\u0026#39;]++ } for i := 0; i \u0026lt; len(t); i++ { arr[t[i]-\u0026#39;a\u0026#39;]-- } for _, each := range arr { if each \u0026gt; 0 { return false } } return true } func main() { fmt.Println(isAnagram(\u0026#34;abc\u0026#34;, \u0026#34;bcc\u0026#34;)) } "},{"id":23,"href":"/leetcode/docs/easy/141/","title":"141. ç¯å½¢é“¾è¡¨","section":"Easy","content":" 141. ç¯å½¢é“¾è¡¨ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # å…·ä½“å®ç° # Go package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func hasCycle(head *ListNode) bool { slow, fast := head, head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { slow = slow.Next fast = fast.Next.Next if slow == fast { return true } } return false } func main() { createLinkedList := func(arr []int) *ListNode { if len(arr) == 0 { return nil } head := \u0026amp;ListNode{Val: arr[0]} current := head for i := 1; i \u0026lt; len(arr); i++ { node := \u0026amp;ListNode{Val: arr[i]} current.Next = node current = node } // Make it a circular linked list (connect the last node to the head) current.Next = head return head } arr := []int{1, 2, 3, 4, 5} head := createLinkedList(arr) head.Next.Next.Next.Next.Next = head.Next // Test the hasCycle function if hasCycle(head) { fmt.Println(\u0026#34;The linked list has a cycle.\u0026#34;) } else { fmt.Println(\u0026#34;The linked list does not have a cycle.\u0026#34;) } } "},{"id":24,"href":"/leetcode/docs/medium/142/","title":"142. ç¯å½¢é“¾è¡¨ II","section":"Medium","content":" 142. ç¯å½¢é“¾è¡¨ II # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # å…·ä½“å®ç° # Go package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func detectCycle(head *ListNode) *ListNode { if head == nil { return head } low, fast := head, head // å› ä¸ºå¿«æŒ‡é’ˆèµ° 2 æ­¥ï¼Œä¸è¦åˆ¤æ–­ next æ˜¯å¦ä¸º nil for fast != nil \u0026amp;\u0026amp; fast.Next != nil { low = low.Next fast = fast.Next.Next // æ³¨æ„è¿™é‡Œ fast æ˜¯èµ° 2 æ­¥ if fast == low { for low != head { low = low.Next head = head.Next } return head } } return nil } func main() { index2 := \u0026amp;ListNode{ Val: 101, Next: nil, } index := \u0026amp;ListNode{ Val: 100, Next: index2, } index.Next.Next = \u0026amp;ListNode{ Val: 4, Next: index, } fmt.Println(detectCycle(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 3, Next: index, }, }, })) } å‚è€ƒ # æŠŠç¯å½¢é“¾è¡¨è®²æ¸…æ¥šï¼ å¦‚ä½•åˆ¤æ–­ç¯å½¢é“¾è¡¨ï¼Ÿå¦‚ä½•æ‰¾åˆ°ç¯å½¢é“¾è¡¨çš„å…¥å£ï¼Ÿ "},{"id":25,"href":"/leetcode/docs/medium/151/","title":"151. åè½¬å­—ç¬¦ä¸²ä¸­çš„å•è¯","section":"Medium","content":" 151. åè½¬å­—ç¬¦ä¸²ä¸­çš„å•è¯ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode "},{"id":26,"href":"/leetcode/docs/medium/155/","title":"155. æœ€å°æ ˆ","section":"Medium","content":" 155. æœ€å°æ ˆ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode "},{"id":27,"href":"/leetcode/docs/easy/160/","title":"160. ç›¸äº¤é“¾è¡¨","section":"Easy","content":" 160. ç›¸äº¤é“¾è¡¨ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # å¦‚æœä¸¤ä¸ªé“¾è¡¨ç›¸äº¤ï¼Œé‚£ä¹ˆç›¸äº¤ç‚¹ä¹‹åçš„é•¿åº¦æ˜¯ç›¸åŒçš„ã€‚\næ‰€ä»¥ï¼Œæˆ‘ä»¬éœ€è¦åšçš„äº‹æƒ…æ˜¯ï¼Œè®©ä¸¤ä¸ªé“¾è¡¨ä»è·ç¦»æœ«å°¾åŒç­‰è·ç¦»çš„ä½ç½®å¼€å§‹éå†ã€‚è€Œè¿™ä¸ªä½ç½®åªèƒ½æ˜¯è¾ƒçŸ­é“¾è¡¨çš„å¤´ç»“ç‚¹ä½ç½®ã€‚ä¸ºæ­¤ï¼Œéœ€è¦æ±‚å‡ºä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦å¹¶æ¶ˆé™¤ä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦å·®ã€‚\nå…·ä½“å®ç° # Go package main import \u0026#34;fmt\u0026#34; type ListNode struct { Next *ListNode Val int } func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } var ( currA, currB = headA, headB lenA, lenB int ) // è®¡ç®—é“¾è¡¨çš„é•¿åº¦ for currA != nil { lenA++ currA = currA.Next } for currB != nil { lenB++ currB = currB.Next } currA, currB = headA, headB // åˆ¤æ–­è°æ˜¯æœ€é•¿çš„,æŠŠæœ€é•¿çš„èµ‹å€¼ç»™ currA gap := 0 if lenA \u0026gt;= lenB { gap = lenA - lenB } else { gap = lenB - lenA currA, currB = currB, currA } for gap \u0026gt; 0 { // ç§»åŠ¨æœ€å¤§çš„ä½ç½® currA = currA.Next gap-- } // åŒæ—¶ç§»åŠ¨ for currA != nil { if currA == currB { return currA // è¿™é‡Œ return currB ä¹Ÿè¡Œ } currA = currA.Next currB = currB.Next } return nil } func main() { t := \u0026amp;ListNode{ Next: \u0026amp;ListNode{ Next: nil, Val: 9, }, Val: 8, } ca := \u0026amp;ListNode{ Next: \u0026amp;ListNode{ Next: t, Val: 2, }, Val: 1, } cb := \u0026amp;ListNode{ Next: \u0026amp;ListNode{ Next: \u0026amp;ListNode{ Next: t, Val: 5, }, Val: 4, }, Val: 3, } ret := getIntersectionNode(ca, cb) fmt.Println(ret) } "},{"id":28,"href":"/leetcode/docs/easy/203/","title":"203. ç§»é™¤é“¾è¡¨å…ƒç´ ","section":"Easy","content":" 203. ç§»é™¤é“¾è¡¨å…ƒç´  # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # å‚çœ‹ https://leetcode.cn/problems/remove-linked-list-elements/solutions/813358/yi-chu-lian-biao-yuan-su-by-leetcode-sol-654m/\nè¿­ä»£æ³• # ç”¨ curr è¡¨ç¤ºå½“å‰èŠ‚ç‚¹ã€‚å¦‚æœ curr çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ä¸ºç©ºä¸”ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„èŠ‚ç‚¹å€¼ç­‰äºç»™å®šçš„ valï¼Œåˆ™éœ€è¦åˆ é™¤ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚åˆ é™¤ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å¯ä»¥é€šè¿‡ curr.next=curr.next.next å®ç°ã€‚\nå¦‚æœ curr çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„èŠ‚ç‚¹å€¼ä¸ç­‰äºç»™å®šçš„ valï¼Œåˆ™ä¿ç•™ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå°† curr ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å³å¯ã€‚\nå½“currçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ºç©ºæ—¶ï¼Œé“¾è¡¨éå†ç»“æŸï¼Œæ­¤æ—¶æ‰€æœ‰èŠ‚ç‚¹å€¼ç­‰äº val çš„èŠ‚ç‚¹éƒ½è¢«åˆ é™¤ã€‚\nå…·ä½“å®ç°æ–¹é¢ï¼Œç”±äºé“¾è¡¨çš„å¤´èŠ‚ç‚¹ head æœ‰å¯èƒ½éœ€è¦è¢«åˆ é™¤ï¼Œå› æ­¤åˆ›å»ºå“‘èŠ‚ç‚¹/è™šæ‹ŸèŠ‚ç‚¹ dummyHeadï¼Œä»¤ dummyHead.next=headï¼Œåˆå§‹åŒ– curr=dummyHeadï¼Œç„¶åéå†é“¾è¡¨è¿›è¡Œåˆ é™¤æ“ä½œã€‚æœ€ç»ˆè¿”å›dummyHead.nextå³ä¸ºåˆ é™¤æ“ä½œåçš„å¤´èŠ‚ç‚¹ã€‚\nä¸ºä»€ä¹ˆè¦ç”¨ curr=dummyHeadâ“ï¼Œè¿™æ · curr æŒ‡å‘çš„åœ°å€è·Ÿ dummyHead æŒ‡å‘çš„åœ°å€æ˜¯ä¸€æ ·çš„ï¼Œå¦‚æœä¸æå‰èµ‹å€¼ï¼Œé‚£ä¹ˆè¿­ä»£åˆ°æœ€ådummyHead.Nextå°±æ˜¯nilï¼Œä¸èƒ½æ­£ç¡®çš„è¿”å›å¤´ç»“ç‚¹ï¼Œæ‰€ä»¥é‡æ–°èµ‹å€¼åï¼Œç”¨ curr å»å¾ªç¯ dummyHead.Next è¿˜æ˜¯æ­£å¸¸çš„ã€‚\né€’å½’æ³• # é“¾è¡¨çš„å®šä¹‰å…·æœ‰é€’å½’çš„æ€§è´¨ï¼Œå› æ­¤é“¾è¡¨é¢˜ç›®å¸¸å¯ä»¥ç”¨é€’å½’çš„æ–¹æ³•æ±‚è§£ã€‚\né€’å½’çš„æ ¸å¿ƒåœ¨äºï¼Œæˆ‘åªå…³æ³¨æˆ‘è¿™ä¸€å±‚è¦å¹²ä»€ä¹ˆï¼Œè¿”å›ä»€ä¹ˆï¼Œè‡³äºæˆ‘çš„ä¸‹ä¸€å±‚ï¼ˆè§„æ¨¡å‡ 1ï¼‰ï¼Œæˆ‘ä¸ç®¡ï¼Œæˆ‘å°±æ˜¯ç”©æ‰‹æŒæŸœã€‚\né‚£ä¹ˆç°åœ¨æˆ‘è¦åˆ é™¤ç‰¹å®šé“¾è¡¨å…ƒç´ ï¼Œæˆ‘éœ€è¦æ€ä¹ˆåšâ“\nå¦‚æœé“¾è¡¨æ˜¯nilæˆ‘å°±ç›´æ¥è¿”å›ï¼Œæˆ‘çš„ next è®©å·¥å…·äººå‡½æ•°å»åˆ¤æ–­ï¼Œå½“å·¥å…·äººå‡½æ•°åšå®Œåˆ¤æ–­ç»™æˆ‘ä¹‹åï¼Œæˆ‘æŒ‰éœ€ returnï¼Œä¹Ÿå°±æ˜¯å¦‚æœ head.Val == val return head.Nextï¼Œå¦åˆ™ç›´æ¥ return headã€‚\nå…·ä½“å®ç° # Goè¿­ä»£ package main import ( \u0026#34;fmt\u0026#34; ) func removeElements(head *ListNode, val int) *ListNode { dummyHead := \u0026amp;ListNode{ Val: 0, Next: head, } curr := dummyHead fmt.Println(dummyHead, curr) for curr.Next != nil { if curr.Next.Val == val { curr.Next = curr.Next.Next // éœ€è¦æ³¨æ„ï¼šè¿™é‡Œä¸éœ€è¦å†ä½¿ç”¨ curr = curr.Nextï¼Œå› ä¸ºæŒ‡é’ˆå·²ç»ç§»åŠ¨äº† } else { curr = curr.Next } } return dummyHead.Next } type ListNode struct { Val int Next *ListNode } func main() { x := removeElements(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 3, Next: nil, }, }, }, }, 1) fmt.Println(x) } Goé€’å½’ package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func removeElements(head *ListNode, val int) *ListNode { if head == nil { return head } head.Next = removeElements(head.Next, val) if head.Val == val { return head.Next } return head } func main() { x := removeElements(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 3, Next: nil, }, }, }, }, 1) fmt.Println(x) } "},{"id":29,"href":"/leetcode/docs/easy/206/","title":"206. åè½¬é“¾è¡¨","section":"Easy","content":" 206. åè½¬é“¾è¡¨ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode ç±»ä¼¼/ç›¸åŒé¢˜ç›®ï¼š å‰‘æŒ‡ Offer 24. åè½¬é“¾è¡¨\nè§£é¢˜æ€è·¯ # è¿­ä»£æ³• # TODO\né€’å½’æ³• # TODO\nå…·ä½“å®ç° # Goè¿­ä»£ package main type ListNode struct { Val int Next *ListNode } func reverseList(head *ListNode) *ListNode { if head == nil { return nil } var ( prev, next *ListNode curr = head ) for curr != nil { next = curr.Next curr.Next = prev // ä¸‹ä¸€ä¸ª prev = curr curr = next } return prev } func main() { reverseList(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{Val: 2, Next: \u0026amp;ListNode{Val: 3, Next: \u0026amp;ListNode{Val: 4, Next: \u0026amp;ListNode{Val: 5}}}}}) } Goé€’å½’ package main import ( \u0026#34;fmt\u0026#34; ) type ListNode struct { Val int Next *ListNode } func reverseList(head *ListNode) *ListNode { // head == nullï¼šå½“ç¬¬ä¸€æ¬¡è¾“å…¥ä¸º nil çš„æ—¶å€™ç›´æ¥è¿”å› nilï¼Œä¸è¿›è¡Œé€’å½’æ“ä½œã€‚ // head.next == nullï¼šè¿”å›é“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ if head == nil || head.Next == nil { return head } newHead := reverseList(head.Next) head.Next.Next = head head.Next = nil return newHead } func main() { x := reverseList(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: nil, }, }, }, }) fmt.Println(x) } å‚è€ƒ # åè½¬é“¾è¡¨é€’å½’ï¼ˆåŠ¨ç”»æ¼”ç¤ºã€æ‰‹å†™ Java ä»£ç ã€è¯¦ç»†æ³¨é‡Šã€LeetCode é«˜é¢‘ç®—æ³•é¢˜ï¼‰ "},{"id":30,"href":"/leetcode/docs/medium/209/","title":"209. é•¿åº¦æœ€å°çš„å­æ•°ç»„","section":"Medium","content":" 209. é•¿åº¦æœ€å°çš„å­æ•°ç»„ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # æš´åŠ›æ³• # æš´åŠ›æ³•æ˜¯æœ€ç›´è§‚çš„æ–¹æ³•ï¼Œä½†æ˜¯åœ¨ leetcode æäº¤æš´åŠ›æ³•è§£é¢˜ä¼šæŠ¥ã€Œè¶…å‡ºæ—¶é—´é™åˆ¶ã€ğŸ˜´ã€‚æš´åŠ›æ³•å¯ä»¥å‚çœ‹ https://leetcode.cn/problems/minimum-size-subarray-sum/solutions/305704/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/ã€‚\nåˆå§‹åŒ–å­æ•°ç»„çš„æœ€å°é•¿åº¦ä¸ºæ— ç©·å¤§ï¼Œæšä¸¾æ•°ç»„numsä¸­çš„æ¯ä¸ªä¸‹æ ‡ä½œä¸ºå­æ•°ç»„çš„å¼€å§‹ä¸‹æ ‡ï¼Œå¯¹äºæ¯ä¸ªå¼€å§‹ä¸‹æ ‡iï¼Œéœ€è¦æ‰¾åˆ°å¤§äºæˆ–ç­‰äºiçš„æœ€å°ä¸‹æ ‡jï¼Œä½¿å¾—ä»nums[i]åˆ°nums[j]çš„å…ƒç´ å’Œå¤§äºæˆ–ç­‰äºsï¼Œå¹¶æ›´æ–°å­æ•°ç»„çš„æœ€å°é•¿åº¦ï¼Œæ­¤æ—¶å­æ•°ç»„çš„é•¿åº¦æ˜¯ jâˆ’i+1ã€‚éœ€è¦ æ³¨æ„çš„æ˜¯ï¼Œä¸¤ä¸ª for å¾ªç¯éƒ½æ˜¯\u0026lt;len(nums)ï¼Œä¸æ˜¯å†…å±‚çš„\u0026lt;len(nums)-1ã€‚\næ»‘åŠ¨çª—å£æ³• # å¯ä»¥å‚çœ‹ Bç«™-é•¿åº¦æœ€å°çš„å­æ•°ç»„ å’Œ 209.é•¿åº¦æœ€å°çš„å­æ•°ç»„\nå…·ä½“å®ç° # Goæ»‘åŠ¨çª—å£ package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func minSubArrayLen02(target int, nums []int) int { n := len(nums) if n == 0 { return 0 } min := func(x, y int) int { if x \u0026lt; y { return x } return y } ans := math.MaxInt32 i := 0 sum := 0 // å­æ•°ç»„çš„å’Œ for j := 0; j \u0026lt; n; j++ { sum += nums[j] for sum \u0026gt;= target { ans = min(ans, j-i+1) sum -= nums[i] i++ } } if ans == math.MaxInt32 { return 0 } return ans } func main() { fmt.Println(minSubArrayLen02(7, []int{2, 3, 1, 2, 4, 3})) } Goæš´åŠ›æ³• package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func minSubArrayLen(target int, nums []int) int { n := len(nums) if n == 0 { return 0 } min := func(x, y int) int { if x \u0026gt; y { return y } return x } ans := math.MaxInt32 for i := 0; i \u0026lt; n; i++ { sum := 0 for j := i; j \u0026lt; n; j++ { sum += nums[j] if sum \u0026gt;= target { ans = min(ans, j-i+1) break } } } if ans == math.MaxInt32 { return 0 } return ans } func main() { fmt.Println(minSubArrayLen(7, []int{2, 3, 1, 2, 4, 3})) } "},{"id":31,"href":"/leetcode/docs/hard/224/","title":"224. åŸºæœ¬è®¡ç®—å™¨","section":"Hard","content":" 224. åŸºæœ¬è®¡ç®—å™¨ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode "},{"id":32,"href":"/leetcode/docs/easy/232/","title":"232. ç”¨æ ˆå®ç°é˜Ÿåˆ—","section":"Easy","content":" 232. ç”¨æ ˆå®ç°é˜Ÿåˆ— # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode "},{"id":33,"href":"/leetcode/docs/easy/344/","title":"344. åè½¬å­—ç¬¦ä¸²","section":"Easy","content":" 344. åè½¬å­—ç¬¦ä¸² # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # åŒæŒ‡é’ˆæ³• # å¯¹äºé•¿åº¦ä¸ºNçš„å¾…è¢«åè½¬çš„å­—ç¬¦æ•°ç»„ï¼Œæˆ‘ä»¬å¯ä»¥è§‚å¯Ÿåè½¬å‰åä¸‹æ ‡çš„å˜åŒ–ï¼Œå‡è®¾åè½¬å‰å­—ç¬¦æ•°ç»„ä¸ºs[0] s[1] s[2] ... s[N - 1]ï¼Œé‚£ä¹ˆåè½¬åå­—ç¬¦æ•°ç»„ä¸ºs[N - 1] s[N - 2] ... s[0]ã€‚æ¯”è¾ƒåè½¬å‰åä¸‹æ ‡å˜åŒ–å¾ˆå®¹æ˜“å¾—å‡ºs[i]çš„å­—ç¬¦ä¸s[N - 1 - i]çš„å­—ç¬¦å‘ç”Ÿäº†äº¤æ¢çš„è§„å¾‹ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å¾—å‡ºå¦‚ä¸‹åŒæŒ‡é’ˆçš„è§£æ³•ï¼š\nå°†leftæŒ‡å‘å­—ç¬¦æ•°ç»„é¦–å…ƒç´ ï¼ŒrightæŒ‡å‘å­—ç¬¦æ•°ç»„å°¾å…ƒç´ ã€‚ å½“left \u0026lt; rightï¼š äº¤æ¢s[left]å’Œs[right]ï¼› leftæŒ‡é’ˆå³ç§»ä¸€ä½ï¼Œå³left = left + 1ï¼› rightæŒ‡é’ˆå·¦ç§»ä¸€ä½ï¼Œå³right = right - 1ã€‚ å½“left \u0026gt;= rightï¼Œåè½¬ç»“æŸï¼Œè¿”å›å­—ç¬¦æ•°ç»„å³å¯ã€‚ å…·ä½“å®ç° # Go package main import ( \u0026#34;fmt\u0026#34; ) func reverseString(s []byte) { length := len(s) if length == 0 { return } left, right := 0, length-1 for left \u0026lt; right { tmp := s[left] s[left] = s[right] s[right] = tmp left++ right-- } return } func main() { x := []byte{\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;} reverseString(x) fmt.Println(string(x)) } "},{"id":34,"href":"/leetcode/docs/easy/349/","title":"349. ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†","section":"Easy","content":" 349. ä¸¤ä¸ªæ•°ç»„çš„äº¤é›† # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # TODO\nå…·ä½“å®ç° # Go package main import \u0026#34;fmt\u0026#34; func intersection(nums1 []int, nums2 []int) []int { if len(nums1) == 0 || len(nums2) == 0 { return []int{} } var ( m1, m2 = make(map[int]interface{}), make(map[int]interface{}) ) for _, each := range nums1 { m1[each] = nil } for _, each := range nums2 { m2[each] = nil } ret := make([]int, 0) for key, _ := range m1 { if _, ok := m2[key]; ok { ret = append(ret, key) } } return ret } func main() { fmt.Println(intersection([]int{1, 2, 2, 1}, []int{2, 2})) } "},{"id":35,"href":"/leetcode/docs/easy/541/","title":"451. æ ¹æ®å­—ç¬¦å‡ºç°é¢‘ç‡æ’åº","section":"Easy","content":" 451. æ ¹æ®å­—ç¬¦å‡ºç°é¢‘ç‡æ’åº # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode "},{"id":36,"href":"/leetcode/docs/medium/454/","title":"454. å››æ•°ç›¸åŠ  II","section":"Medium","content":" 454. å››æ•°ç›¸åŠ  II # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode "},{"id":37,"href":"/leetcode/docs/easy/459/","title":"459. é‡å¤çš„å­å­—ç¬¦ä¸²","section":"Easy","content":" 459. é‡å¤çš„å­å­—ç¬¦ä¸² # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode "},{"id":38,"href":"/leetcode/docs/easy/496/","title":"496. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  I","section":"Easy","content":" 496. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  I # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode "},{"id":39,"href":"/leetcode/docs/easy/682/","title":"682. æ£’çƒæ¯”èµ›","section":"Easy","content":" 682. æ£’çƒæ¯”èµ› # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode "},{"id":40,"href":"/leetcode/docs/easy/704/","title":"704. äºŒåˆ†æŸ¥æ‰¾","section":"Easy","content":" 704. äºŒåˆ†æŸ¥æ‰¾ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # å¯ä»¥å‚è€ƒ\nhttps://www.bilibili.com/video/BV1fA4y1o715 äºŒåˆ†æŸ¥æ‰¾ å¯¹äºå¸¸è§„å®ç°æ¥è¯´ï¼Œåœ¨è§£é¢˜æ—¶è¦åŒºåˆ†åŒºé—´ï¼Œä¹Ÿå°±æ˜¯å·¦é—­å³é—­è¿˜æ˜¯å·¦é—­å³å¼€åŒºé—´ä¸¤ç§è§£æ³•ï¼Œå…¶å®å°±æ˜¯è¦åŒºåˆ†å³é—­è¿˜æ˜¯å³å¼€ï¼Œåœ¨ä¸´ç•Œæ¡ä»¶åˆ¤æ–­æ—¶åŒ…ä¸åŒ…å«æœ€å³è¾¹çš„å€¼ã€‚\nå¯¹äºå·¦é—­å³é—­æ¥è¯´ï¼ŒåŒ…å«æœ€å³è¾¹ï¼Œæ‰€ä»¥åœ¨ä¸´ç•Œæ¡ä»¶åˆ¤æ–­æ—¶ï¼Œå·¦è¾¹çš„å€¼å¯ä»¥ç­‰äºå³è¾¹çš„å€¼ï¼Œé‚£ä¹ˆrightå…¶å®æ˜¯æ•°ç»„é•¿åº¦-1ï¼Œä¹Ÿå°±æ˜¯æ•°ç»„æœ€åä¸€ä¸ªå€¼ã€‚\nwhile (left \u0026lt;= right)ï¼Œå› ä¸ºleft == rightæ˜¯æœ‰æ„ä¹‰çš„ï¼Œæ‰€ä»¥ä½¿ç”¨\u0026lt;= if (nums[middle] \u0026gt; target)ï¼Œrightè¦èµ‹å€¼ä¸ºmiddle - 1ï¼Œå› ä¸ºå½“å‰è¿™ä¸ªnums[middle]ä¸€å®šä¸æ˜¯targetï¼Œé‚£ä¹ˆæ¥ä¸‹æ¥è¦æŸ¥æ‰¾çš„å·¦åŒºé—´ç»“æŸä¸‹æ ‡ä½ç½®å°±æ˜¯middle - 1 ä½†æ˜¯å¯¹äºå·¦é—­å³å¼€æ¥è¯´ï¼Œå› ä¸ºä¸åŒ…å«æœ€å³å…ƒç´ ï¼Œé‚£ä¹ˆrightå…¶å®å°±æ˜¯æ•°ç»„é•¿åº¦ï¼Œright å–ä¸åˆ°æ•°ç»„æœ€åä¸€ä¸ªå€¼ã€‚\nwhile (left \u0026lt; right)ï¼Œå› ä¸ºleft == rightåœ¨åŒºé—´[left, right)æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼Œæ‰€ä»¥è¿™é‡Œè¦ç”¨\u0026lt; if (nums[middle] \u0026gt; target) rightæ›´æ–°ä¸ºmiddleï¼Œå› ä¸ºå½“å‰nums[middle]ä¸ç­‰äºtargetï¼Œå»å·¦åŒºé—´ç»§ç»­å¯»æ‰¾ï¼Œè€Œå¯»æ‰¾åŒºé—´æ˜¯å·¦é—­å³å¼€åŒºé—´ï¼Œæ‰€ä»¥rightæ›´æ–°ä¸ºmiddleï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä¸‹ä¸€ä¸ªæŸ¥è¯¢åŒºé—´ä¸ä¼šå»æ¯”è¾ƒnums[middle] å…·ä½“å®ç° # Go åŒºé—´å·¦é—­å³é—­\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { arr := []int{0, 1, 2, 3, 4, 5, 10} fmt.Println(binarySearch(arr, 10)) } func binarySearch(nums []int, target int) int { left := 0 right := len(nums) - 1 for left \u0026lt;= right { middle := (left + right) / 2 if target \u0026gt; nums[middle] { left = middle + 1 } else if target \u0026lt; nums[middle] { right = middle - 1 } else { return middle } } return -1 } åŒºé—´å·¦é—­å³å¼€\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { arr := []int{0, 1, 2, 3, 4, 5, 10} fmt.Println(binarySearch(arr, 10)) } func binarySearch(nums []int, target int) int { left := 0 right := len(nums) for left \u0026lt; right { middle := (left + right) / 2 if target \u0026gt; nums[middle] { left = middle + 1 } else if target \u0026lt; nums[middle] { right = middle } else { return middle } } return -1 } Python TODO "},{"id":41,"href":"/leetcode/docs/medium/707/","title":"ğŸ˜ª707. è®¾è®¡é“¾è¡¨","section":"Medium","content":" 707. è®¾è®¡é“¾è¡¨ # é¢˜ç›®åœ°å€ï¼š https://leetcode.cn/problems/design-linked-list/\nè§£é¢˜æ€è·¯ # å…·ä½“å®ç° # Go "},{"id":42,"href":"/leetcode/docs/hidden/","title":"ğŸ˜ªxxxxxx","section":"Docs","content":" xx # é¢˜ç›®åœ°å€ # è§£é¢˜æ€è·¯ # å…·ä½“å®ç° # Go "},{"id":43,"href":"/leetcode/docs/easy/844/","title":"844. æ¯”è¾ƒå«é€€æ ¼çš„å­—ç¬¦ä¸²","section":"Easy","content":" 844. æ¯”è¾ƒå«é€€æ ¼çš„å­—ç¬¦ä¸² # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode "},{"id":44,"href":"/leetcode/docs/easy/876/","title":"876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹","section":"Easy","content":" 876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode "},{"id":45,"href":"/leetcode/docs/easy/977/","title":"977. æœ‰åºæ•°ç»„çš„å¹³æ–¹","section":"Easy","content":" 977. æœ‰åºæ•°ç»„çš„å¹³æ–¹ # é¢˜ç›®åœ°å€ # åŠ›æ‰£ LeetCode è§£é¢˜æ€è·¯ # æš´åŠ›æ³• # å¯ä»¥ç›´æ¥å…ˆè®¡ç®—å¹³æ–¹ï¼Œç„¶åå†åˆ©ç”¨åº“å‡½æ•°æ’åºã€‚\nåŒæŒ‡é’ˆæ³• # å¯ä»¥å‚è€ƒ\næœ‰åºæ•°ç»„çš„å¹³æ–¹ B ç«™-æœ‰åºæ•°ç»„çš„å¹³æ–¹ æ•°ç»„å…¶å®æ˜¯æœ‰åºçš„ï¼Œåªä¸è¿‡è´Ÿæ•°å¹³æ–¹ä¹‹åå¯èƒ½æˆä¸ºæœ€å¤§æ•°äº†ã€‚é‚£ä¹ˆæ•°ç»„å¹³æ–¹çš„æœ€å¤§å€¼å°±åœ¨æ•°ç»„çš„ä¸¤ç«¯ï¼Œä¸æ˜¯æœ€å·¦è¾¹å°±æ˜¯æœ€å³è¾¹ï¼Œä¸å¯èƒ½æ˜¯ä¸­é—´ã€‚æ­¤æ—¶å¯ä»¥è€ƒè™‘åŒæŒ‡é’ˆæ³•äº†ï¼ŒiæŒ‡å‘èµ·å§‹ä½ç½®ï¼ŒjæŒ‡å‘ç»ˆæ­¢ä½ç½®ã€‚å®šä¹‰ä¸€ä¸ªæ–°æ•°ç»„ resultï¼Œå’Œ A æ•°ç»„ä¸€æ ·çš„å¤§å°ï¼Œè®©kæŒ‡å‘ result æ•°ç»„ç»ˆæ­¢ä½ç½®ï¼Œä¹Ÿå°±æ˜¯è¯´è®© k ä»å¤§ï¼ˆå³ï¼‰åˆ°å°ï¼ˆå·¦ï¼‰å¡«å……ã€‚\nå¦‚æœA[i] * A[i] \u0026lt; A[j] * A[j] é‚£ä¹ˆresult[k--] = A[j] * A[j] ã€‚\nå¦‚æœA[i] * A[i] \u0026gt;= A[j] * A[j]é‚£ä¹ˆresult[k--] = A[i] * A[i]ã€‚\nå…·ä½“å®ç° # GoåŒæŒ‡é’ˆ package main import \u0026#34;fmt\u0026#34; func sortedSquares(nums []int) []int { if len(nums) == 0 { return []int{} } var ( result = make([]int, len(nums)) i, j = 0, len(nums) - 1 k = len(nums) - 1 // èƒ½è®¿é—®åˆ°æœ€åä¸€ä¸ªå€¼ ) // è¿™é‡Œä¹‹æ‰€ä»¥è¦ \u0026lt;= æ˜¯å› ä¸ºï¼Œå¦‚æœä»…ä»…æ˜¯ \u0026lt; é‚£ä¹ˆå½“ = æ—¶ä¼šé€€å‡ºï¼Œ // è¿™æ ·å°±ä¼šæ¼æ‰äº†ä¸€ä¸ªå…ƒç´  for i \u0026lt;= j { if nums[i]*nums[i] \u0026gt; nums[j]*nums[j] { result[k] = nums[i] * nums[i] k-- i++ } else { result[k] = nums[j] * nums[j] k-- j-- } } return result } func main() { fmt.Println(sortedSquares([]int{-4, -1, 0, 3, 10})) } Goæš´åŠ›æ³• package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sort\u0026#34; ) func sortedSquares(nums []int) []int { if len(nums) == 0 { return []int{} } for index, item := range nums { nums[index] = item * item } sort.Ints(nums) return nums } func main() { fmt.Println(sortedSquares([]int{-4, -1, 0, 3, 10})) } "}]