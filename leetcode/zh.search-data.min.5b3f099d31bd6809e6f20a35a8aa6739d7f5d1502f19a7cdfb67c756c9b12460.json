[{"id":0,"href":"/leetcode/docs/other/interview-08.06/","title":"😪面试题 08.06. 汉诺塔问题","section":"其他","content":" 面试题 08.06. 汉诺塔问题 # 题目地址： 面试题 08.06. 汉诺塔问题 / 图解汉诺塔的故事：据说，当64个盘子全部移完的那天，世界就毁灭了\n"},{"id":1,"href":"/leetcode/docs/easy/1/","title":"1. 两数之和","section":"Easy","content":" 1. 两数之和 # 题目地址 # 力扣 LeetCode 解题思路 # 暴力法 # 嵌套遍历数组，外层遍历的值和内层遍历的值相加，如果相加等于目标值，则返回结果，否则继续遍历。内层遍历开始的位置是外层遍历的位置加 1，结束的位置是数组长度。\nmap # TODO\n具体实现 # Go Map package main import \u0026#34;fmt\u0026#34; func twoSum(nums []int, target int) []int { if len(nums) == 0 { return []int{} } m := make(map[int]int, 0) // val =\u0026gt; index for index, val := range nums { ass := target - val if idx, ok := m[ass]; ok { return []int{idx, index} } else { m[val] = index } } return []int{} } func main() { fmt.Println(twoSum([]int{3, 2, 4}, 6)) } Go暴力法 package main import \u0026#34;fmt\u0026#34; func twoSum(nums []int, target int) []int { for index, value := range nums { for i := index + 1; i \u0026lt; len(nums); i++ { if (value + nums[i]) == target { return []int{index, i} } } } return nil } func main() { fmt.Println(twoSum([]int{3, 2, 4}, 6)) } "},{"id":2,"href":"/leetcode/docs/easy/","title":"Easy","section":"Docs","content":" Easy # 明日复明日，明日何其多，我生待明日，万事成蹉跎。世人若被明日累，春去秋来老将至。朝看水东流，暮看日西坠。百年明日能几何，请君听我明日歌。 "},{"id":3,"href":"/leetcode/docs/medium/","title":"Medium","section":"Docs","content":" Medium # 劝君莫惜金缕衣，劝君须惜少年时。花开堪折直须折，莫待无花空折枝。 "},{"id":4,"href":"/leetcode/docs/other/bubble/","title":"冒泡排序","section":"其他","content":" 冒泡排序 # 题目描述 # 输入一个整数数组，按从小到大的顺序排序。\n具体实现 # package main import \u0026#34;fmt\u0026#34; func Bubble(arr []int) []int { length := len(arr) for i := 0; i \u0026lt; length-1; i++ { // 注意这里 j 是从 0 开始而不是从 i 开始 for j := 0; j \u0026lt; length-i-1; j++ { if arr[j] \u0026gt; arr[j+1] { tmp := arr[j] arr[j] = arr[j+1] arr[j+1] = tmp } } } return arr } func main() { fmt.Println(Bubble([]int{1, 10, 25, 30})) } "},{"id":5,"href":"/leetcode/docs/hard/","title":"Hard","section":"Docs","content":" Hard # 好学近乎知，力行近乎仁，知耻近乎勇。 "},{"id":6,"href":"/leetcode/docs/other/","title":"其他","section":"Docs","content":" 其他 # 一寸光阴一寸金，寸金难买寸光阴。黑发不知勤学早，转眼便是白头翁。 "},{"id":7,"href":"/leetcode/docs/medium/15/","title":"15. 三数之和","section":"Medium","content":" 15. 三数之和 # 题目地址 # 力扣 LeetCode "},{"id":8,"href":"/leetcode/docs/finger-offer2/018/","title":"018. 有效的回文","section":"剑指 Offer（二）","content":" 018. 有效的回文 # 题目地址 # 力扣 "},{"id":9,"href":"/leetcode/docs/medium/18/","title":"18. 四数之和","section":"Medium","content":" 18. 四数之和 # 题目地址 # 力扣 LeetCode "},{"id":10,"href":"/leetcode/docs/medium/19/","title":"19. 删除链表的倒数第 N 个结点","section":"Medium","content":" 19. 删除链表的倒数第 N 个结点 # 题目地址 # 力扣 LeetCode 解题思路 # 常规法 # 先计算链表长度，比如是 length。那么删除倒数第 n 个节点，也就是删除顺数第 length-n+1 个节点，设为 s，直接从 1 找到第 s-1 个也就是 s 的上一个节点（其实也就是 length-n），直接把 s-1 删除即可。\n双指针法 # TODO\n具体实现 # Go常规法 package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func removeNthFromEnd(head *ListNode, n int) *ListNode { if head == nil { return head } length := 0 tmpc := head for tmpc != nil { //fmt.Println(tmpc.Val) length++ tmpc = tmpc.Next } // 需要有虚拟头结点是因为，可能删除的是最后的节点，也就是头结点，用虚拟头结点可以统一处理 dummy := \u0026amp;ListNode{ Val: 0, Next: head, } cur := dummy // 注意这里 i 是从 1 开始 for i := 1; i \u0026lt; length-n+1; i++ { cur = cur.Next } cur.Next = cur.Next.Next return dummy.Next } func main() { ret := removeNthFromEnd(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: \u0026amp;ListNode{ Val: 5, Next: nil, }, }, }, }, }, 2) fmt.Println(ret) } Go双指针 package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func removeNthFromEnd(head *ListNode, n int) *ListNode { if head == nil { return head } dummy := \u0026amp;ListNode{ Next: head, } fast, low := dummy, dummy // fast 先移动 n 步 for n != 0 \u0026amp;\u0026amp; fast != nil { fast = fast.Next n-- } // fast 再移动一步，这样当 fast 为 nil 时，low 在 n 的上一位 fast = fast.Next for fast != nil { fast = fast.Next low = low.Next } low.Next = low.Next.Next return dummy.Next } func main() { ret := removeNthFromEnd(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: \u0026amp;ListNode{ Val: 5, Next: nil, }, }, }, }, }, 2) fmt.Println(ret) } 参考 # 19.删除链表的倒数第N个节点 "},{"id":11,"href":"/leetcode/docs/easy/20/","title":"20. 有效的括号","section":"Easy","content":" 20. 有效的括号 # 题目地址 # 力扣 LeetCode 解题思路 # 判断括号的有效性可以使用「栈」这一数据结构来解决。\n我们遍历给定的字符串 s。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于 后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。\n当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。\n在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，否则返回 False。\n注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。\n具体实现 # Go package main import \u0026#34;fmt\u0026#34; func isValid(s string) bool { n := len(s) if n%2 != 0 { // 奇数直接退出 return false } pairs := map[byte]byte{ \u0026#39;)\u0026#39;: \u0026#39;(\u0026#39;, \u0026#39;]\u0026#39;: \u0026#39;[\u0026#39;, \u0026#39;}\u0026#39;: \u0026#39;{\u0026#39;, } stack := []byte{} for i := 0; i \u0026lt; n; i++ { if pairs[s[i]] \u0026gt; 0 { // 如果是右括号,判断栈顶是否是对应的左括号,果然有对应的左括号,则弹出栈顶元素,否则直接退出 if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] { return false } stack = stack[:len(stack)-1] } else { stack = append(stack, s[i]) } } return len(stack) == 0 } func main() { fmt.Println(isValid(\u0026#34;()[]{}\u0026#34;)) } "},{"id":12,"href":"/leetcode/docs/easy/21/","title":"21. 合并两个有序链表","section":"Easy","content":" 21. 合并两个有序链表 # 题目地址 # 力扣 LeetCode 解题思路 # 递归解法 # 参考 一看就会，一写就废？详解递归。\n递归的核心在于，我只关注我这一层要干什么，返回什么，至于我的下一层（规模减 1），我不管，我就是甩手掌柜。\n那么现在我要 merge L1，L2 我需要怎么做❓\n当一条链表为空时，返回对方，因为如果返回自己，就退出了，返回对方，不管对方是什么，让下级去判断。 如果 L1 第一个元素小于 L2 的？那我得把 L1 的这个元素放到最前面，至于后面的那串长啥样，我不管。我只要接过下级员工干完活后给我的包裹，然后把我干的活附上去（令 L1-\u0026gt;next = 这个包裹）就行。 这个包裹是下级员工干的活，即merge(L1-\u0026gt;next,L2)。 我该返回啥❓\n现在不管我的下一层干了什么，又返回了什么给我，我只要知道，假设我的工具人们都完成了任务，那我的任务也就完成了，可以返回最终结果了。 最终结果就是我一开始接手的 L1 头结点+下级员工给我的大包裹，要一并交上去，这样我的 boss 才能根据我给它的 L1 头节点往下找，检查我完成的工作。 具体实现 # Go 递归 package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func mergeTwoLists(list1 *ListNode, list2 *ListNode) (x *ListNode) { if list1 == nil { return list2 } if list2 == nil { return list1 } if list1.Val \u0026lt;= list2.Val { list1.Next = mergeTwoLists(list1.Next, list2) return list1 } else { list2.Next = mergeTwoLists(list2.Next, list1) return list2 } } func main() { x := mergeTwoLists(\u0026amp;ListNode{Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 4, Next: nil, }, }}, \u0026amp;ListNode{Val: 1, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: nil, }, }}) fmt.Println(x) } Go 迭代 package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func mergeTwoLists(list1 *ListNode, list2 *ListNode) (x *ListNode) { // 方便遍历完成后快速找到头节点 dummy := \u0026amp;ListNode{} prev := dummy for list1 != nil \u0026amp;\u0026amp; list2 != nil { if list1.Val \u0026gt;= list2.Val { prev.Next = list2 list2 = list2.Next } else { prev.Next = list1 list1 = list1.Next } prev = prev.Next } if list1 != nil { prev.Next = list1 } if list2 != nil { prev.Next = list2 } return dummy.Next } func main() { x := mergeTwoLists(\u0026amp;ListNode{Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 4, Next: nil, }, }}, \u0026amp;ListNode{Val: 1, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: nil, }, }}) fmt.Println(x) } 参考 # B 站 - 合并两个有序链表 LeetCode - 合并两个有序链表 "},{"id":13,"href":"/leetcode/docs/hard/23/","title":"23. 合并 K 个升序链表","section":"Hard","content":" 23. 合并 K 个升序链表 # 题目地址 # 力扣 LeetCode 解题思路 # 具体实现 # Go package main import ( \u0026#34;fmt\u0026#34; ) type ListNode struct { Val int Next *ListNode } func mergeKLists(lists []*ListNode) *ListNode { if len(lists) == 0 { return nil } n := len(lists) return merge(lists, 0, n-1) } func merge(lists []*ListNode, left, right int) *ListNode { if left == right { return lists[left] } mid := left + (right-left)/2 l1 := merge(lists, left, mid) l2 := merge(lists, mid+1, right) return mergeTwoLists(l1, l2) } func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1.Val \u0026lt; l2.Val { l1.Next = mergeTwoLists(l1.Next, l2) return l1 } else { l2.Next = mergeTwoLists(l1, l2.Next) return l2 } } func main() { list1 := \u0026amp;ListNode{Val: 1, Next: \u0026amp;ListNode{Val: 4, Next: \u0026amp;ListNode{Val: 5}}} list2 := \u0026amp;ListNode{Val: 1, Next: \u0026amp;ListNode{Val: 3, Next: \u0026amp;ListNode{Val: 4}}} list3 := \u0026amp;ListNode{Val: 2, Next: \u0026amp;ListNode{Val: 6}} lists := []*ListNode{list1, list2, list3} result := mergeKLists(lists) for result != nil { fmt.Printf(\u0026#34;%d \u0026#34;, result.Val) result = result.Next } } 参考 # 合并K个升序链表-解题思路 "},{"id":14,"href":"/leetcode/docs/medium/24/","title":"24. 两两交换链表中的节点","section":"Medium","content":" 24. 两两交换链表中的节点 # 题目地址 # 力扣 LeetCode 解题思路 # 参考 https://leetcode.cn/problems/swap-nodes-in-pairs/solutions/444474/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/\n递归法 # 可以通过递归的方式实现两两交换链表中的节点。递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。\n如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。\n用head表示原始链表的头节点，新的链表的第二个节点，用newHead表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是newHead.next。令head.next = swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为head的下一个节点。然后令newHead.next = head，即完成了所有节点的交换。最后返回新的链表的头节点newHead。\n⚠️好吧，再理解一下，关于递归，我只关注我这一层要干什么，返回什么，至于我的下一层（规模减 1），我不管，我就是一个甩手掌柜🙈。\n我其实只需要关心第一层，也就是节点1和节点2的交换，把节点2的next指向节点1，节点2的next给下一层也就是递归函数。而我最后返回的应该是头结点，其实也就是原始节点的节点2。\n迭代法 # TODO\n具体实现 # Go迭代 package main import ( \u0026#34;fmt\u0026#34; ) type ListNode struct { Val int Next *ListNode } func swapPairs(head *ListNode) *ListNode { if head == nil { return head } dummy := \u0026amp;ListNode{ Val: 0, Next: head, } curr := dummy // 如果是链表长度是奇数那就没有必要交换，只有偶数才需要交换，所以这里的判断条件是 \u0026amp;\u0026amp; // 这里不能用一个临时参数，因为链表指针后的值会变化 for curr.Next != nil \u0026amp;\u0026amp; curr.Next.Next != nil { tmp := curr.Next tmp1 := curr.Next.Next.Next curr.Next = curr.Next.Next curr.Next.Next = tmp curr.Next.Next.Next = tmp1 // 这里也可以直接写成 curr = tmp curr = curr.Next.Next } return dummy.Next } func main() { x := swapPairs(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: nil, }, }, }, }) fmt.Println(x) } Go递归 package main import ( \u0026#34;fmt\u0026#34; ) type ListNode struct { Val int Next *ListNode } func swapPairs(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } newHead := head.Next head.Next = swapPairs(head.Next.Next) newHead.Next = head return newHead } func main() { x := swapPairs(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: nil, }, }, }, }) fmt.Println(x) } "},{"id":15,"href":"/leetcode/docs/hard/25/","title":"25. K 个一组翻转链表","section":"Hard","content":" 25. K 个一组翻转链表 # 题目地址 # 力扣 LeetCode 解题思路 # 具体实现 # Go package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func reverseKGroup(head *ListNode, k int) *ListNode { // 反转链表 reverse := func(head *ListNode) *ListNode { if head == nil { return nil } var ( prev, curr, next *ListNode ) curr = head for curr != nil { next = curr.Next curr.Next = prev prev = curr curr = next } return prev } dummy := \u0026amp;ListNode{} var ( prev, end *ListNode ) dummy.Next = head prev = dummy end = dummy for end.Next != nil { // 把 end 往后移动 k 个位置 for i := 0; i \u0026lt; k \u0026amp;\u0026amp; end != nil; i++ { end = end.Next } if end == nil { break } start := prev.Next next := end.Next end.Next = nil prev.Next = reverse(start) start.Next = next prev = start end = start } return dummy.Next } func main() { ret := reverseKGroup(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: \u0026amp;ListNode{ Val: 5, Next: nil, }, }, }, }, }, 2) fmt.Println(ret) } 参考 # 链表中的节点每k个一组翻转 图解 K 个一组翻转链表 "},{"id":16,"href":"/leetcode/docs/easy/27/","title":"27. 移除元素","section":"Easy","content":" 27. 移除元素 # 题目地址 # 力扣 LeetCode 解题思路 # 暴力法 # TODO\n双指针法 # 可以用双指针/快慢指针来解决。快指针用来寻找新数组的元素，新数组就是不含有目标元素的数组，慢指针用来指向更新新数组下标的位置。这里需要的注意的是，“新数组”其实就是旧数组，因为一直都在在同一个数组上的操作，这也是题目的要求👇\n不要使用额外的数组空间，你必须仅使用O(1)额外空间并原地修改输入数组。\n具体实现 # Go双指针 package main import \u0026#34;fmt\u0026#34; func removeElement(nums []int, val int) int { length := len(nums) low := 0 for i := 0; i \u0026lt; length; i++ { if nums[i] != val { nums[low] = nums[i] low++ } } return low } func main() { x := []int{1, 2, 6, 7, 9, 6, 6, 6} xx := removeElement(x, 6) fmt.Println(x, xx) } Go暴力法 package main import \u0026#34;fmt\u0026#34; func removeElement(nums []int, val int) int { if len(nums) == 0 { return 0 } length := len(nums) for i := 0; i \u0026lt; length; i++ { if nums[i] == val { // 发现需要移除的元素，就将数组集体向前移动一位 for j := i + 1; j \u0026lt; length; j++ { nums[j-1] = nums[j] } // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位 // 因为不知道移动过来的第一位的值是不是 val i-- length-- // 此时数组的大小-1 } } return length } func main() { x := []int{1, 2, 6, 7, 9, 6, 6, 6} xx := removeElement(x, 6) fmt.Println(x, xx) } 参考 # 27. 移除元素 "},{"id":17,"href":"/leetcode/docs/medium/53/","title":"53. 最大子数组和","section":"Medium","content":" 53. 最大子数组和 # 题目地址 # 力扣 LeetCode 解题思路 # 具体实现 # Go贪心算法 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func maxSubArray(nums []int) int { if len(nums) == 0 { return 0 } count := 0 result := math.MinInt64 length := len(nums) for i := 0; i \u0026lt; length; i++ { count += nums[i] if count \u0026gt; result { result = count } if count \u0026lt;= 0 { count = 0 } } return result } func main() { fmt.Println(maxSubArray([]int{-2, 1, -3, 4, -1, 2, 1, -5, 4})) } Go暴力法 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func maxSubArray(nums []int) int { if len(nums) == 0 { return 0 } count := 0 result := math.MinInt64 length := len(nums) for i := 0; i \u0026lt; length; i++ { count = 0 for j := i; j \u0026lt; length; j++ { count += nums[j] if count \u0026gt; result { result = count } } } return result } func main() { fmt.Println(maxSubArray([]int{-2, 1, -3, 4, -1, 2, 1, -5, 4})) } "},{"id":18,"href":"/leetcode/docs/medium/59/","title":"59. 螺旋矩阵 II","section":"Medium","content":" 59. 螺旋矩阵 II # 题目地址 # 力扣 LeetCode 解题思路 # 可以参考 https://leetcode.cn/problems/spiral-matrix-ii/solutions/12594/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/\n具体实现 # Go package main import \u0026#34;fmt\u0026#34; func main() { n := 3 fmt.Println(generateMatrix(n)) } func generateMatrix(n int) [][]int { ret := make([][]int, n) startX, startY := 0, 0 count := 1 offset := 1 loop := n / 2 for i := 0; i \u0026lt; n; i++ { ret[i] = make([]int, n) } for loop \u0026gt; 0 { i, j := startX, startY for j = startY; j \u0026lt; n-offset; j++ { ret[startX][j] = count count++ } for i = startX; i \u0026lt; n-offset; i++ { ret[i][j] = count count++ } for ; j \u0026gt; startY; j-- { ret[i][j] = count count++ } for ; i \u0026gt; startX; i-- { ret[i][j] = count count++ } startX++ startY++ offset++ loop-- } if n%2 == 1 { ret[n/2][n/2] = n * n } return ret } 参考 # 一入循环深似海 | LeetCode：59.螺旋矩阵II "},{"id":19,"href":"/leetcode/docs/hard/76/","title":"😪76. 最小覆盖子串","section":"Hard","content":" 76. 最小覆盖子串 # 题目地址 # 力扣 LeetCode 解题思路 # TODO\n具体思路 # "},{"id":20,"href":"/leetcode/docs/medium/92/","title":"92. 反转链表 II","section":"Medium","content":" 92. 反转链表 II # 题目地址 # 力扣 LeetCode 解题思路 # 具体实现 # Go package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func reverseBetween(head *ListNode, left int, right int) *ListNode { if head == nil { return head } var ( dummy = \u0026amp;ListNode{} prev, curr *ListNode ) dummy.Next = head prev = dummy for i := 0; i \u0026lt; left-1; i++ { prev = prev.Next } curr = prev.Next for i := 0; i \u0026lt; right-left; i++ { next := curr.Next curr.Next = curr.Next.Next next.Next = prev.Next prev.Next = next } return dummy.Next } func main() { ret := reverseBetween(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: \u0026amp;ListNode{ Val: 5, Next: nil, }, }, }, }, }, 2, 4) fmt.Println(ret) } 参考 # 链表内指定区间反转 "},{"id":21,"href":"/leetcode/docs/easy/104/","title":"😪104. 二叉树的最大深度","section":"Easy","content":" 104. 二叉树的最大深度 # 题目地址 # 力扣 LeetCode "},{"id":22,"href":"/leetcode/docs/easy/242/","title":"242. 有效的字母异位词","section":"Easy","content":" 242. 有效的字母异位词 # 题目地址 # 力扣 LeetCode 解题思路 # map # 具体实现 # Go map package main import \u0026#34;fmt\u0026#34; func isAnagram(s string, t string) bool { if len(s) != len(t) { return false } var arr [26]int for i := 0; i \u0026lt; len(s); i++ { arr[s[i]-\u0026#39;a\u0026#39;]++ } for i := 0; i \u0026lt; len(t); i++ { arr[t[i]-\u0026#39;a\u0026#39;]-- } for _, each := range arr { if each \u0026gt; 0 { return false } } return true } func main() { fmt.Println(isAnagram(\u0026#34;abc\u0026#34;, \u0026#34;bcc\u0026#34;)) } "},{"id":23,"href":"/leetcode/docs/easy/141/","title":"141. 环形链表","section":"Easy","content":" 141. 环形链表 # 题目地址 # 力扣 LeetCode 解题思路 # 具体实现 # Go package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func hasCycle(head *ListNode) bool { slow, fast := head, head for fast != nil \u0026amp;\u0026amp; fast.Next != nil { slow = slow.Next fast = fast.Next.Next if slow == fast { return true } } return false } func main() { createLinkedList := func(arr []int) *ListNode { if len(arr) == 0 { return nil } head := \u0026amp;ListNode{Val: arr[0]} current := head for i := 1; i \u0026lt; len(arr); i++ { node := \u0026amp;ListNode{Val: arr[i]} current.Next = node current = node } // Make it a circular linked list (connect the last node to the head) current.Next = head return head } arr := []int{1, 2, 3, 4, 5} head := createLinkedList(arr) head.Next.Next.Next.Next.Next = head.Next // Test the hasCycle function if hasCycle(head) { fmt.Println(\u0026#34;The linked list has a cycle.\u0026#34;) } else { fmt.Println(\u0026#34;The linked list does not have a cycle.\u0026#34;) } } "},{"id":24,"href":"/leetcode/docs/medium/142/","title":"142. 环形链表 II","section":"Medium","content":" 142. 环形链表 II # 题目地址 # 力扣 LeetCode 解题思路 # 具体实现 # Go package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func detectCycle(head *ListNode) *ListNode { if head == nil { return head } low, fast := head, head // 因为快指针走 2 步，不要判断 next 是否为 nil for fast != nil \u0026amp;\u0026amp; fast.Next != nil { low = low.Next fast = fast.Next.Next // 注意这里 fast 是走 2 步 if fast == low { for low != head { low = low.Next head = head.Next } return head } } return nil } func main() { index2 := \u0026amp;ListNode{ Val: 101, Next: nil, } index := \u0026amp;ListNode{ Val: 100, Next: index2, } index.Next.Next = \u0026amp;ListNode{ Val: 4, Next: index, } fmt.Println(detectCycle(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 3, Next: index, }, }, })) } 参考 # 把环形链表讲清楚！ 如何判断环形链表？如何找到环形链表的入口？ "},{"id":25,"href":"/leetcode/docs/medium/151/","title":"151. 反转字符串中的单词","section":"Medium","content":" 151. 反转字符串中的单词 # 题目地址 # 力扣 LeetCode "},{"id":26,"href":"/leetcode/docs/medium/155/","title":"155. 最小栈","section":"Medium","content":" 155. 最小栈 # 题目地址 # 力扣 LeetCode "},{"id":27,"href":"/leetcode/docs/easy/160/","title":"160. 相交链表","section":"Easy","content":" 160. 相交链表 # 题目地址 # 力扣 LeetCode 解题思路 # 如果两个链表相交，那么相交点之后的长度是相同的。\n所以，我们需要做的事情是，让两个链表从距离末尾同等距离的位置开始遍历。而这个位置只能是较短链表的头结点位置。为此，需要求出两个链表的长度并消除两个链表的长度差。\n具体实现 # Go package main import \u0026#34;fmt\u0026#34; type ListNode struct { Next *ListNode Val int } func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } var ( currA, currB = headA, headB lenA, lenB int ) // 计算链表的长度 for currA != nil { lenA++ currA = currA.Next } for currB != nil { lenB++ currB = currB.Next } currA, currB = headA, headB // 判断谁是最长的,把最长的赋值给 currA gap := 0 if lenA \u0026gt;= lenB { gap = lenA - lenB } else { gap = lenB - lenA currA, currB = currB, currA } for gap \u0026gt; 0 { // 移动最大的位置 currA = currA.Next gap-- } // 同时移动 for currA != nil { if currA == currB { return currA // 这里 return currB 也行 } currA = currA.Next currB = currB.Next } return nil } func main() { t := \u0026amp;ListNode{ Next: \u0026amp;ListNode{ Next: nil, Val: 9, }, Val: 8, } ca := \u0026amp;ListNode{ Next: \u0026amp;ListNode{ Next: t, Val: 2, }, Val: 1, } cb := \u0026amp;ListNode{ Next: \u0026amp;ListNode{ Next: \u0026amp;ListNode{ Next: t, Val: 5, }, Val: 4, }, Val: 3, } ret := getIntersectionNode(ca, cb) fmt.Println(ret) } "},{"id":28,"href":"/leetcode/docs/easy/203/","title":"203. 移除链表元素","section":"Easy","content":" 203. 移除链表元素 # 题目地址 # 力扣 LeetCode 解题思路 # 参看 https://leetcode.cn/problems/remove-linked-list-elements/solutions/813358/yi-chu-lian-biao-yuan-su-by-leetcode-sol-654m/\n迭代法 # 用 curr 表示当前节点。如果 curr 的下一个节点不为空且下一个节点的节点值等于给定的 val，则需要删除下一个节点。删除下一个节点可以通过 curr.next=curr.next.next 实现。\n如果 curr 的下一个节点的节点值不等于给定的 val，则保留下一个节点，将 curr 移动到下一个节点即可。\n当curr的下一个节点为空时，链表遍历结束，此时所有节点值等于 val 的节点都被删除。\n具体实现方面，由于链表的头节点 head 有可能需要被删除，因此创建哑节点/虚拟节点 dummyHead，令 dummyHead.next=head，初始化 curr=dummyHead，然后遍历链表进行删除操作。最终返回dummyHead.next即为删除操作后的头节点。\n为什么要用 curr=dummyHead❓，这样 curr 指向的地址跟 dummyHead 指向的地址是一样的，如果不提前赋值，那么迭代到最后dummyHead.Next就是nil，不能正确的返回头结点，所以重新赋值后，用 curr 去循环 dummyHead.Next 还是正常的。\n递归法 # 链表的定义具有递归的性质，因此链表题目常可以用递归的方法求解。\n递归的核心在于，我只关注我这一层要干什么，返回什么，至于我的下一层（规模减 1），我不管，我就是甩手掌柜。\n那么现在我要删除特定链表元素，我需要怎么做❓\n如果链表是nil我就直接返回，我的 next 让工具人函数去判断，当工具人函数做完判断给我之后，我按需 return，也就是如果 head.Val == val return head.Next，否则直接 return head。\n具体实现 # Go迭代 package main import ( \u0026#34;fmt\u0026#34; ) func removeElements(head *ListNode, val int) *ListNode { dummyHead := \u0026amp;ListNode{ Val: 0, Next: head, } curr := dummyHead fmt.Println(dummyHead, curr) for curr.Next != nil { if curr.Next.Val == val { curr.Next = curr.Next.Next // 需要注意：这里不需要再使用 curr = curr.Next，因为指针已经移动了 } else { curr = curr.Next } } return dummyHead.Next } type ListNode struct { Val int Next *ListNode } func main() { x := removeElements(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 3, Next: nil, }, }, }, }, 1) fmt.Println(x) } Go递归 package main import \u0026#34;fmt\u0026#34; type ListNode struct { Val int Next *ListNode } func removeElements(head *ListNode, val int) *ListNode { if head == nil { return head } head.Next = removeElements(head.Next, val) if head.Val == val { return head.Next } return head } func main() { x := removeElements(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 3, Next: nil, }, }, }, }, 1) fmt.Println(x) } "},{"id":29,"href":"/leetcode/docs/easy/206/","title":"206. 反转链表","section":"Easy","content":" 206. 反转链表 # 题目地址 # 力扣 LeetCode 类似/相同题目： 剑指 Offer 24. 反转链表\n解题思路 # 迭代法 # TODO\n递归法 # TODO\n具体实现 # Go迭代 package main type ListNode struct { Val int Next *ListNode } func reverseList(head *ListNode) *ListNode { if head == nil { return nil } var ( prev, next *ListNode curr = head ) for curr != nil { next = curr.Next curr.Next = prev // 下一个 prev = curr curr = next } return prev } func main() { reverseList(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{Val: 2, Next: \u0026amp;ListNode{Val: 3, Next: \u0026amp;ListNode{Val: 4, Next: \u0026amp;ListNode{Val: 5}}}}}) } Go递归 package main import ( \u0026#34;fmt\u0026#34; ) type ListNode struct { Val int Next *ListNode } func reverseList(head *ListNode) *ListNode { // head == null：当第一次输入为 nil 的时候直接返回 nil，不进行递归操作。 // head.next == null：返回链表的最后一个节点 if head == nil || head.Next == nil { return head } newHead := reverseList(head.Next) head.Next.Next = head head.Next = nil return newHead } func main() { x := reverseList(\u0026amp;ListNode{ Val: 1, Next: \u0026amp;ListNode{ Val: 2, Next: \u0026amp;ListNode{ Val: 3, Next: \u0026amp;ListNode{ Val: 4, Next: nil, }, }, }, }) fmt.Println(x) } 参考 # 反转链表递归（动画演示、手写 Java 代码、详细注释、LeetCode 高频算法题） "},{"id":30,"href":"/leetcode/docs/medium/209/","title":"209. 长度最小的子数组","section":"Medium","content":" 209. 长度最小的子数组 # 题目地址 # 力扣 LeetCode 解题思路 # 暴力法 # 暴力法是最直观的方法，但是在 leetcode 提交暴力法解题会报「超出时间限制」😴。暴力法可以参看 https://leetcode.cn/problems/minimum-size-subarray-sum/solutions/305704/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/。\n初始化子数组的最小长度为无穷大，枚举数组nums中的每个下标作为子数组的开始下标，对于每个开始下标i，需要找到大于或等于i的最小下标j，使得从nums[i]到nums[j]的元素和大于或等于s，并更新子数组的最小长度，此时子数组的长度是 j−i+1。需要 注意的是，两个 for 循环都是\u0026lt;len(nums)，不是内层的\u0026lt;len(nums)-1。\n滑动窗口法 # 可以参看 B站-长度最小的子数组 和 209.长度最小的子数组\n具体实现 # Go滑动窗口 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func minSubArrayLen02(target int, nums []int) int { n := len(nums) if n == 0 { return 0 } min := func(x, y int) int { if x \u0026lt; y { return x } return y } ans := math.MaxInt32 i := 0 sum := 0 // 子数组的和 for j := 0; j \u0026lt; n; j++ { sum += nums[j] for sum \u0026gt;= target { ans = min(ans, j-i+1) sum -= nums[i] i++ } } if ans == math.MaxInt32 { return 0 } return ans } func main() { fmt.Println(minSubArrayLen02(7, []int{2, 3, 1, 2, 4, 3})) } Go暴力法 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func minSubArrayLen(target int, nums []int) int { n := len(nums) if n == 0 { return 0 } min := func(x, y int) int { if x \u0026gt; y { return y } return x } ans := math.MaxInt32 for i := 0; i \u0026lt; n; i++ { sum := 0 for j := i; j \u0026lt; n; j++ { sum += nums[j] if sum \u0026gt;= target { ans = min(ans, j-i+1) break } } } if ans == math.MaxInt32 { return 0 } return ans } func main() { fmt.Println(minSubArrayLen(7, []int{2, 3, 1, 2, 4, 3})) } "},{"id":31,"href":"/leetcode/docs/hard/224/","title":"224. 基本计算器","section":"Hard","content":" 224. 基本计算器 # 题目地址 # 力扣 LeetCode "},{"id":32,"href":"/leetcode/docs/easy/232/","title":"232. 用栈实现队列","section":"Easy","content":" 232. 用栈实现队列 # 题目地址 # 力扣 LeetCode "},{"id":33,"href":"/leetcode/docs/easy/344/","title":"344. 反转字符串","section":"Easy","content":" 344. 反转字符串 # 题目地址 # 力扣 LeetCode 解题思路 # 双指针法 # 对于长度为N的待被反转的字符数组，我们可以观察反转前后下标的变化，假设反转前字符数组为s[0] s[1] s[2] ... s[N - 1]，那么反转后字符数组为s[N - 1] s[N - 2] ... s[0]。比较反转前后下标变化很容易得出s[i]的字符与s[N - 1 - i]的字符发生了交换的规律，因此我们可以得出如下双指针的解法：\n将left指向字符数组首元素，right指向字符数组尾元素。 当left \u0026lt; right： 交换s[left]和s[right]； left指针右移一位，即left = left + 1； right指针左移一位，即right = right - 1。 当left \u0026gt;= right，反转结束，返回字符数组即可。 具体实现 # Go package main import ( \u0026#34;fmt\u0026#34; ) func reverseString(s []byte) { length := len(s) if length == 0 { return } left, right := 0, length-1 for left \u0026lt; right { tmp := s[left] s[left] = s[right] s[right] = tmp left++ right-- } return } func main() { x := []byte{\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;} reverseString(x) fmt.Println(string(x)) } "},{"id":34,"href":"/leetcode/docs/easy/349/","title":"349. 两个数组的交集","section":"Easy","content":" 349. 两个数组的交集 # 题目地址 # 力扣 LeetCode 解题思路 # TODO\n具体实现 # Go package main import \u0026#34;fmt\u0026#34; func intersection(nums1 []int, nums2 []int) []int { if len(nums1) == 0 || len(nums2) == 0 { return []int{} } var ( m1, m2 = make(map[int]interface{}), make(map[int]interface{}) ) for _, each := range nums1 { m1[each] = nil } for _, each := range nums2 { m2[each] = nil } ret := make([]int, 0) for key, _ := range m1 { if _, ok := m2[key]; ok { ret = append(ret, key) } } return ret } func main() { fmt.Println(intersection([]int{1, 2, 2, 1}, []int{2, 2})) } "},{"id":35,"href":"/leetcode/docs/easy/541/","title":"451. 根据字符出现频率排序","section":"Easy","content":" 451. 根据字符出现频率排序 # 题目地址 # 力扣 LeetCode "},{"id":36,"href":"/leetcode/docs/medium/454/","title":"454. 四数相加 II","section":"Medium","content":" 454. 四数相加 II # 题目地址 # 力扣 LeetCode "},{"id":37,"href":"/leetcode/docs/easy/459/","title":"459. 重复的子字符串","section":"Easy","content":" 459. 重复的子字符串 # 题目地址 # 力扣 LeetCode "},{"id":38,"href":"/leetcode/docs/easy/496/","title":"496. 下一个更大元素 I","section":"Easy","content":" 496. 下一个更大元素 I # 题目地址 # 力扣 LeetCode "},{"id":39,"href":"/leetcode/docs/easy/682/","title":"682. 棒球比赛","section":"Easy","content":" 682. 棒球比赛 # 题目地址 # 力扣 LeetCode "},{"id":40,"href":"/leetcode/docs/easy/704/","title":"704. 二分查找","section":"Easy","content":" 704. 二分查找 # 题目地址 # 力扣 LeetCode 解题思路 # 可以参考\nhttps://www.bilibili.com/video/BV1fA4y1o715 二分查找 对于常规实现来说，在解题时要区分区间，也就是左闭右闭还是左闭右开区间两种解法，其实就是要区分右闭还是右开，在临界条件判断时包不包含最右边的值。\n对于左闭右闭来说，包含最右边，所以在临界条件判断时，左边的值可以等于右边的值，那么right其实是数组长度-1，也就是数组最后一个值。\nwhile (left \u0026lt;= right)，因为left == right是有意义的，所以使用\u0026lt;= if (nums[middle] \u0026gt; target)，right要赋值为middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是middle - 1 但是对于左闭右开来说，因为不包含最右元素，那么right其实就是数组长度，right 取不到数组最后一个值。\nwhile (left \u0026lt; right)，因为left == right在区间[left, right)是没有意义的，所以这里要用\u0026lt; if (nums[middle] \u0026gt; target) right更新为middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，也就是说，下一个查询区间不会去比较nums[middle] 具体实现 # Go 区间左闭右闭\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { arr := []int{0, 1, 2, 3, 4, 5, 10} fmt.Println(binarySearch(arr, 10)) } func binarySearch(nums []int, target int) int { left := 0 right := len(nums) - 1 for left \u0026lt;= right { middle := (left + right) / 2 if target \u0026gt; nums[middle] { left = middle + 1 } else if target \u0026lt; nums[middle] { right = middle - 1 } else { return middle } } return -1 } 区间左闭右开\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { arr := []int{0, 1, 2, 3, 4, 5, 10} fmt.Println(binarySearch(arr, 10)) } func binarySearch(nums []int, target int) int { left := 0 right := len(nums) for left \u0026lt; right { middle := (left + right) / 2 if target \u0026gt; nums[middle] { left = middle + 1 } else if target \u0026lt; nums[middle] { right = middle } else { return middle } } return -1 } Python TODO "},{"id":41,"href":"/leetcode/docs/medium/707/","title":"😪707. 设计链表","section":"Medium","content":" 707. 设计链表 # 题目地址： https://leetcode.cn/problems/design-linked-list/\n解题思路 # 具体实现 # Go "},{"id":42,"href":"/leetcode/docs/hidden/","title":"😪xxxxxx","section":"Docs","content":" xx # 题目地址 # 解题思路 # 具体实现 # Go "},{"id":43,"href":"/leetcode/docs/easy/844/","title":"844. 比较含退格的字符串","section":"Easy","content":" 844. 比较含退格的字符串 # 题目地址 # 力扣 LeetCode "},{"id":44,"href":"/leetcode/docs/easy/876/","title":"876. 链表的中间结点","section":"Easy","content":" 876. 链表的中间结点 # 题目地址 # 力扣 LeetCode "},{"id":45,"href":"/leetcode/docs/easy/977/","title":"977. 有序数组的平方","section":"Easy","content":" 977. 有序数组的平方 # 题目地址 # 力扣 LeetCode 解题思路 # 暴力法 # 可以直接先计算平方，然后再利用库函数排序。\n双指针法 # 可以参考\n有序数组的平方 B 站-有序数组的平方 数组其实是有序的，只不过负数平方之后可能成为最大数了。那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。此时可以考虑双指针法了，i指向起始位置，j指向终止位置。定义一个新数组 result，和 A 数组一样的大小，让k指向 result 数组终止位置，也就是说让 k 从大（右）到小（左）填充。\n如果A[i] * A[i] \u0026lt; A[j] * A[j] 那么result[k--] = A[j] * A[j] 。\n如果A[i] * A[i] \u0026gt;= A[j] * A[j]那么result[k--] = A[i] * A[i]。\n具体实现 # Go双指针 package main import \u0026#34;fmt\u0026#34; func sortedSquares(nums []int) []int { if len(nums) == 0 { return []int{} } var ( result = make([]int, len(nums)) i, j = 0, len(nums) - 1 k = len(nums) - 1 // 能访问到最后一个值 ) // 这里之所以要 \u0026lt;= 是因为，如果仅仅是 \u0026lt; 那么当 = 时会退出， // 这样就会漏掉了一个元素 for i \u0026lt;= j { if nums[i]*nums[i] \u0026gt; nums[j]*nums[j] { result[k] = nums[i] * nums[i] k-- i++ } else { result[k] = nums[j] * nums[j] k-- j-- } } return result } func main() { fmt.Println(sortedSquares([]int{-4, -1, 0, 3, 10})) } Go暴力法 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sort\u0026#34; ) func sortedSquares(nums []int) []int { if len(nums) == 0 { return []int{} } for index, item := range nums { nums[index] = item * item } sort.Ints(nums) return nums } func main() { fmt.Println(sortedSquares([]int{-4, -1, 0, 3, 10})) } "}]