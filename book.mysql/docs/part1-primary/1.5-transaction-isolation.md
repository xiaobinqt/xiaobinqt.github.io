---
weight: 5

bookFlatSection: true

bookCollapseSection: false

bookToc: true

title: "1.3 事务隔离"
---

# 1.3 事务隔离

事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。

## 1.5.1 隔离性和隔离级别

当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了 “隔离级别” 的概念。但是，隔离得越严实，效率就会越低。因此需要在二者之间寻找一个平衡点。

> 脏读：读到其他事务未提交的数据；不可重复读：前后读取的记录内容不一致；幻读：前后读取的记录数量不一致。

SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。

+ 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。

+ 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。

+ 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。

+ 串行化，对于同一行记录，“写” 会加 “写锁”，“读” 会加 “读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行 “读提交” 和 “可重复读” 这 2 个事务的行为：

```shell
create table T(c int) engine=InnoDB;

insert into T(c) values(1);
```

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230719/84d82cfaf9f84f1480d8b6afcb389c8e.png" width=400  /></div>

可以看看在不同的隔离级别下，事务 A 会有哪些不同的返回结果，也就是图中 V1、V2、V3 的返回值分别是什么。

+ 若隔离级别是 “读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。

+ 若隔离级别是 “读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。

+ 若隔离级别是 “可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。

+ 若隔离级别是 “串行化”，则在事务 B 执行 “将 1 改成 2” 的时候，会被**锁住**。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。

在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在 “可重复读” 隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在 “读提交” 隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的，在每一次查询之前都会重新给予最新的数据创建一个新的视图，所以可以看到另外一个事务已经提交的内容。这里需要注意的是，“读未提交” 隔离级别下直接返回记录上的最新值，**没有**视图概念；而 “串行化” 隔离级别下直接用加锁的方式来避免并行访问。

### 配置方式

我用的 mysql5.7.42 版本，docker 起的服务：

```shell
docker run --name mysql-5.7.42-debian \
-e MYSQL_ROOT_PASSWORD=123456 \
-e TZ=Asia/Shanghai \
-p 3306:3306 -d mysql:5.7.42-debian
```

进入容器修改 /etc/mysql/mysql.conf.d/mysqld.cnf 文件，在 \[mysqld\] 分组下加一行 transaction-isolation 配置，将隔离级别改为 SERIALIZABLE：

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230720/31125b1d91dd4954b1381302dd1406eb.png" width=  /></div>

> ```shell
> [mysqld]
> ...
> # transaction-isolation=READ-UNCOMMITTED
> # transaction-isolation=READ-COMMITTED
> # transaction-isolation=REPEATABLE-READ
> # transaction-isolation=SERIALIZABLE
> ```

修改完成后重启容器，然后通过 mysql 客户端查看隔离级别是否生效：

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230720/cee8923af3724eacb4a938db7bd3fbe4.png" width=  /></div>

## 1.5.2 事务隔离的实现

在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录：

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230719/f88c1c2ac0c146ca92d273e3770c0816.png" width=  /></div>


当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。

即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。

> A 开启事务，创建视图 A； B 开启事务，创建视图 B，将 c 从 1 改为 2，同时向视图 A、B 中记录一条回滚记录（将 c 从 2 改回 1）； C 开启事务，创建视图 C，此时 c 的值为 2，将 c 从 2 改为 3，同时向视图 A、B、C 中记录一条回滚日志（将 c 从 3 改回 2）； 此时视图 A 中有两条回滚记录，事务 A 再次获取 c 时依次执行这两条回滚记录，即可得到 c 最开始的值 1。

关于回滚日志，系统会判断，当没有事务再需要用到这些回滚日志时，也就是当系统里没有比这个回滚日志更早的 read-view 的时候，回滚日志会被删除。

所以在实际应用中，应尽量不要使用长事务。长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。长事务还占用锁资源，也可能拖垮整个库 <font color="sky blue">TODO</font>。

## 1.5.3 事务启动方式

MySQL 的事务启动方式有以下几种：

1. 显式启动事务语句，begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。

2. set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果只执行一个 select 语句，这个事务就启动了，而且并**不会自动提交**。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。

有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。

建议总是使用 set autocommit=1, 通过显式语句的方式来启动事务。autocommit=1 表示 MySQL 自动开启和提交事务。比如执行一个 update 语句，语句只完成后就自动提交了。不需要显示的使用 begin、commit 来开启和提交事务。当需要对某些操作使用事务的时候，手动用 begin、commit 来开启和提交事务。

在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。

可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务：

```shell
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started)) > 60;
```

## 1.5.4 RR 事务隔离

在可重复读隔离级别，事务 T 启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数据，事务 T 看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，不受外界影响。

但是在 MySQL 行锁中，一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它会被锁住，进入等待状态。这里有个问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？

举个例子，下面是一个只有两行的表的初始化语句：

```shell
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

insert into t(id, k) values(1,1),(2,2);
```

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230728/e044c14b3a7041cc9e0695ce016e395d.png" width=700  /></div>

begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。

{{< hint info >}}

第一种启动方式，一致性视图是在执行第一个快照读语句时创建的；

第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的。

{{< /hint >}}

在这个例子中，事务 C 没有显式地使用 begin/commit，表示这个 update 语句本身就是一个事务（默认 autocommit=1），语句完成的时候会自动提交。事务 B 在更新了行之后查询 ; 事务 A 在一个只读事务中查询，并且时间顺序上是在事务 B 的查询之后。最后的执行结果是，事务 B 查到的 k 的值是 3，而事务 A 查到的 k 的值是 1。

事务 B 之所以查到的是 3，是因为事务 B 的更新是在事务 C 更新的基础之上修改的。在修改的时候，需要先读然后再修改，事务 B 读取的时候，确实不会读取到事务 C 的更新后的内容。但是事务 B **进行更新**的时候，会执行当前读，所谓当前读就是读取当前数据库中最新的数据内容，如果不执行当前读，而直接基于一致性读的前提下，直接执行更新操作，将会把事务 C 的更新给丢失掉。所以事务 B 更新的时候，是在已经提交的事务 C 的基础上更新数据。所以事务 B 就出现一个现象：执行更新前查询的值为 (1,1)，执行完更新之后，会变成 (1,3)，而不是 (1,2)。

MySQL 中读取数据的时候总是一致性读：事务开始前会创建一个一致性视图，在事务执行过程中，所有其他未提交或者已经提交的事务，对当前已经开启的事务不可见。 但是在更新数据的时候，会执行当前读：意思是在更新之前会去数据库中获取最新的已经提交的事务数据内容，然后基于已经提交的事务的基础上更新自己的内容。

{{< hint info >}}

在 MySQL 里，有两个 “视图 ”的概念：

+ 一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。

+ 另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。它没有物理结构，作用是事务执行期间用来定义 “我能看到什么数据”。

{{< /hint >}}

## 1.5.5 MVCC 快照实现

在可重复读隔离级别下，事务在启动的时候就**基于整库**拍了快照。

如果一个库有 100G，其实并不需要拷贝出这 100G 的数据。InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。

而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。

也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。

{{< hint info >}}

为什么表结构不支持 “可重复读”？这是因为表结构没有对应的行数据，也没有 row trx_id，因此只能遵循当前读的逻辑。

MySQL 8.0 已经可以把表结构放在 InnoDB 字典里了，也许以后会支持表结构的可重复读（online DDL）。

{{< /hint >}}

如下图，就是一个记录被多个事务连续更新后的状态：

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230728/d2cb44e5817944d285c0d6f41b93c785.png" width=  /></div>

图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25。

上图中的三个虚线箭头，其实就是 undo log；V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。

按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。

因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。当然，如果 “上一个版本” 也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。

在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在 “活跃” 的所有事务 ID。**“活跃” 指的是，启动了但还没提交**。

**数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位**。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。

这个视图数组把所有的 row trx_id 分成了几种不同的情况。

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230728/75206996d6f3423bb6488d9323917835.png" width=  /></div>

1. 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
3. 如果落在黄色部分，那就包括两种情况

    + a. 若 row trx_id
      在数组中，表示这个版本是由还没提交的事务生成的，不可见（因为数组里存的是，启动了但还没提交的[事务 ID](#155-mvcc-%E5%BF%AB%E7%85%A7%E5%AE%9E%E7%8E%B0:~:text=%E5%9C%A8%E5%AE%9E%E7%8E%B0%E4%B8%8A%EF%BC%8C%20InnoDB%20%E4%B8%BA%E6%AF%8F%E4%B8%AA%E4%BA%8B%E5%8A%A1%E6%9E%84%E9%80%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%8C%E7%94%A8%E6%9D%A5%E4%BF%9D%E5%AD%98%E8%BF%99%E4%B8%AA%E4%BA%8B%E5%8A%A1%E5%90%AF%E5%8A%A8%E7%9E%AC%E9%97%B4%EF%BC%8C%E5%BD%93%E5%89%8D%E6%AD%A3%E5%9C%A8%20%E2%80%9C%E6%B4%BB%E8%B7%83%E2%80%9D%20%E7%9A%84%E6%89%80%E6%9C%89%E4%BA%8B%E5%8A%A1%20ID%E3%80%82%E2%80%9C%E6%B4%BB%E8%B7%83%E2%80%9D%20%E6%8C%87%E7%9A%84%E6%98%AF%EF%BC%8C%E5%90%AF%E5%8A%A8%E4%BA%86%E4%BD%86%E8%BF%98%E6%B2%A1%E6%8F%90%E4%BA%A4%E3%80%82)）；
    + b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。

以下图示例：

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230728/d2cb44e5817944d285c0d6f41b93c785.png" width=  /></div>

如果有一个事务，它的低水位是 18，那么当它访问这一行数据时，就会从 V4 通过 U3 计算出 V3，所以在它看来，这一行的值是 11。

InnoDB 利用了 “所有数据都有多个版本” 的这个特性，实现了 “秒级创建快照” 的能力。

基于以上的分析就可以知道下图中的三个事务，为什么事务 A 的语句返回的结果是 k=1：

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230728/e044c14b3a7041cc9e0695ce016e395d.png" width=700  /></div>

假设：

1. 事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；
2. 事务 A、B、C 的事务 ID 分别是 100、101、102，且当前系统里只有这四个事务；
3. 三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。

这样，事务 A 的视图数组就是 \[99,100\]，事务 B 的视图数组是 \[99,100,101\]，事务 C 的视图数组是 \[99,100,101,102\]。

为了简化分析，我先把其他干扰语句去掉，只画出跟事务 A 查询逻辑有关的操作：

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230728/b3e3728d38f0447f97def9b48486dd3f.png" width=  /></div>

从图中可以看到，第一个有效更新是事务 C，把数据从 (1,1) 改成了 (1,2)。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本。

第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候，这个数据的最新版本（即 row trx_id）是 101，而 102 又成为了历史版本。

在事务 A 查询的时候，其实事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。但这个版本对事务 A 必须是不可见的，否则就变成脏读（读到了尚未提交的事务所改的数据）了。

当事务 A 读数据时，它的视图数组是 \[99,100\]。读数据都是从当前版本读起的。所以，事务 A 查询语句的读数据流程是这样的：

1. 找到 (1,3) 的时候，判断出 row trx_id=101，比高水位大，处于红色区域，不可见；
2. 接着，找到上一个历史版本，一看 row trx_id=102，比高水位大，处于红色区域，不可见；
3. 再往前找，终于找到了（1,1)，它的 row trx_id=90，比低水位小，处于绿色区域，可见。

虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以称之为一致性读。

一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：

1. 版本未提交，不可见；
2. 版本已提交，但是是在视图创建后提交的，不可见；
3. 版本已提交，而且是在视图创建前提交的，可见。

可以用时间先后顺序来判断，是否可见：

事务 A 的查询语句的视图数组是在事务 A 启动的时候生成的，这时候：

+ (1,3) 还没提交，属于情况 1，不可见；
+ (1,2) 虽然提交了，但是是在视图数组创建之后提交的，属于情况 2，不可见；
+ (1,1) 是在视图数组创建之前提交的，可见。

## 1.5.6 更新逻辑

如果按照一致性读，对于事务 B 的 update 操作其实是有问题的。如下图，事务 B 的视图数组是先生成的，之后事务 C 才提交，如果按照一致性读，应该看不见 (1,2)，但是却能算出 (1,3) 来？

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230728/abc5511c0699419eb06b5f117f097e17.png" width=700  /></div>

如果事务 B 在更新之前查询一次数据，这个查询返回的 k 的值确实是 1。但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务 C 的更新就丢失了。因此，事务 B 此时的 set k=k+1 是在（1,2）的基础上进行的操作。

事务与事务之间的隔离不应该影响最终数据的落地。如果事务 C 先更新了数据，而后事务 B 也更新了同一份数据，以数据库的眼光来看这份数据的变动就是事务 C 的更新跟着事务 B 的更新，必须延续在一块而**不能分开**。事务的更新必须是基于当前最新值来执行的，而读则是基于其视图，即可重复读的隔离，真的只是读层面的隔离。

**更新数据都是先读后写的，而这个读，只能读当前的值，称为 “当前读”（current read）**。

因此，在更新的时候，当前读拿到的数据是 (1,2)，更新后生成了新版本的数据 (1,3)，这个新版本的 row trx_id 是 101。在执行事务 B 查询语句的时候，一看自己的版本号是 101，最新数据的版本号也是 101，是自己的更新，可以直接使用，所以查询得到的 k 的值是 3。

对于当前读，除了 update 语句外，select 语句如果加锁，也是当前读。

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230728/e044c14b3a7041cc9e0695ce016e395d.png" width=700  /></div>

如上图，如果把事务 A 的查询语句 select * from t where id=1 修改一下，加上 lock in share mode 或 for update，也都可以读到事务 ID 是 101 ，也就是事务 B 未提交的数据，返回的 k 的值是 3。

下面这两个 select 语句，就是分别加了读锁（S 锁，共享锁）和写锁（X 锁，排他锁）：

```shell
select k from t where id=1 lock in share mode;
select k from t where id=1 for update;
```

假设事务 C 不是马上提交的，而是变成了事务 C’，如下图：

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230728/313764cfb64a4b53a12591ba5b1dd489.png" width=700  /></div>

事务 C’ 的不同是，更新后并没有马上提交，在它提交前，事务 B 的更新语句先发起了。虽然事务 C’ 还没提交，但是 (1,2) 这个版本也已经生成了，并且是当前的最新版本。

这是就要用到 “两阶段锁协议” 。事务 C’ 没提交，也就是说 (1,2) 这个版本上的写锁还没释放。而事务 B 因为是 update 操作，所以是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务 C’ 释放这个锁，才能继续它的当前读。

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230728/931ff5e153cd4f92a5942f28fb230edf.png" width=700  /></div>

可重复读的核心就是一致性读（consistent read）；而**事务更新数据的时候，只能用当前读**。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。

读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：

+ 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；
+ 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。

在读提交隔离级别下，如下图所示，可以分析下事务 A 和事务 B 的查询语句查到的 k，分别应该是多少。

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230728/e044c14b3a7041cc9e0695ce016e395d.png" width=700  /></div>

{{< hint info >}}

“start transaction with consistent snapshot; ” 的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的 start transaction。

{{< /hint >}}

下图是读提交时的状态图，可以看到这两个查询语句的创建视图的时机发生了变化，就是图中的 read view 框。

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230728/22d977a38791454db57df5bf1cc86b9c.png" width=700  /></div>

这时，事务 A 的查询语句的视图数组是在执行这个语句的时候创建的，时序上 (1,2)、(1,3) 的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻：

+ (1,3) 还没提交，属于情况 1，不可见；
+ (1,2) 提交了，属于情况 3，可见。

所以，这时候事务 A 查询语句返回的是 k=2。事务 B 查询结果 k=3。





















