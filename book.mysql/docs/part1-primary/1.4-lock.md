---
weight: 4

bookFlatSection: true

bookCollapseSection: false

bookToc: true

title: "1.4 锁"
---

# 1.4 锁

[//]: # (<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230726/8a04bf76bb63427c95cbe52e271eb143.png" width=  /></div>)

数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。

根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。

## 1.4.1 全局锁

全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。

当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文本。

之前有一种做法，是通过 FTWRL 确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。但是让整库都只读，听上去就很危险：

+ 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；

+ 如果在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。

如果在备份时不加锁会有什么问题呢？

假设现在要维护一个购买系统，关注的是用户账户余额表和用户课程表。现在发起一个逻辑备份。假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉他的余额，然后往已购课程里面加上一门课。如果时间顺序上是先备份账户余额表 (u_account)，然后用户购买，然后备份用户课程表 (u_course)，会怎么样呢？可以看一下下图：

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230726/d0714cdb3fd14c2aa1cc2c63cd3d41ab.png" width=  /></div>

可以看到，这个备份结果里，用户 A 的数据状态是 “账户余额没扣，但是用户课程表里面已经多了一门课”。

官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数 –single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图（可重复读）。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。

但是，对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，就破坏了备份的一致性。这时，就需要使用 FTWRL 命令了。

single-transaction 方法只适用于所有的表使用事务引擎的库。如果有的表使用了不支持事务的引擎，那么备份就只能通过 FTWRL 方法。这其实也是 InnoDB 引擎替代 MyISAM 的原因之一。

既然要全库只读，为什么不使用 set global readonly=true 的方式呢？

readonly 方式确实可以让全库进入只读状态，但实际应用中还是建议使用 FTWRL 方式，主要有两个原因：

1. 在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大。

2. 在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。

业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，再要对里面任何一个表做加字段操作，都是会被锁住的。

## 1.4.2 表级锁

MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

表锁的语法是 lock tables … read/write，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。

需要注意的是，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。也就是说，对表加读锁后，自己也不能对其进行修改；自己和其他线程只能读取该表。当对某个表执加上写锁后（lock table t2 write），该线程可以对这个表进行读写，其他线程对该表的读和写都受到阻塞。

如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。

在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。

另一类表级的锁是 MDL（metadata lock)。MDL 不需要显式使用，在访问一个表的时候会被**自动加上**。MDL 的作用是，保证读写的正确性。可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。

因此，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。

+ 读锁之间不互斥，因此可以有多个线程同时对一张表增删改查。

+ 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

{{< hint info >}}

这里的「增删改查」是针对元数据（表结构）说的, 而不是数据表里面的数据。MDL 作用是防止 DDL 和 DML 并发的冲突。

在 MySQL（和其他数据库系统）中，DDL 和 DML 是数据库操作的两个主要类别：

1. DDL (Data Definition Language)：数据定义语言

   DDL 用于定义和管理数据库结构，包括表、列、索引等。它允许你创建、修改和删除数据库对象。常见的 DDL 命令包括：

- CREATE：用于创建新的数据库对象，如创建表、索引等。
- ALTER：用于修改已存在的数据库对象的结构，如添加、修改或删除列。
- DROP：用于删除数据库对象，如删除表、索引等。
- TRUNCATE：用于删除表中的所有数据，但保留表结构。
- RENAME：用于重命名数据库对象，如重命名表。

2. DML (Data Manipulation Language)：数据操纵语言

   DML 用于对数据库中的数据进行操作，例如插入、更新、删除数据等。它允许你对数据库表中的数据进行查询和修改。常见的 DML 命令包括：

- SELECT：用于从数据库中检索数据。
- INSERT：用于向数据库表中插入新数据。
- UPDATE：用于更新数据库表中现有的数据。
- DELETE：用于从数据库表中删除数据。

总结：

- DDL 是用于定义数据库结构的语言，涉及创建、修改和删除数据库对象。
- DML 是用于操作数据库中的数据的语言，涉及查询、插入、更新和删除数据。

---

MySQL 在线 DDL（加字段、加索引等修改表结构之类的操作）过程如下：

1. 对表加锁（表此时只读）
2. 复制原表物理结构，创建新中间表
3. 修改中间表的物理结构
4. 把原表数据导入中间表中，数据同步完后，锁定中间表，并删除原表
5. rename 中间表为原表
6. 刷新数据字典，并释放锁

{{< /hint >}}

再给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。一般在对大表操作的时候，会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。可以看一下下面的操作序列，假设表 t 是一个小表（实验环境是 MySQL 5.6）：

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230726/c3f4fe58de3b4132830c5c99a5e46c84.png" width=700  /></div>

可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于 session B 需要的也是 MDL 读锁，因此可以正常执行。

之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞。也就是说，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。

申请 MDL 锁的操作会形成一个**队列**，队列中写锁获取优先级高于读锁。一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。

所以，如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。表不可用的原因是因为 session C 申请写锁，并且在队列处于优先，导致 session C 后面的所有读锁请求申请都被 block 了。这个时候客户端如果有频繁重试的逻辑就会导致不停的和数据库建立连接，把连接池打满导致库不可用。

事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。有未提交的事务时无法修改表字段，而且在存在长事务时执行修改表字段命令是一个危险的操作，可能阻塞其它增删改查请求，或导致线程爆满。

其实，在实际开发中，如何安全地给小表加字段也是一个棘手的问题。

首先要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。

但需要考虑一下这个场景。如果要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而又不得不加个字段，这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后再通过重试命令重复这个过程。

## 1.4.3 行锁

MySQL 的行锁是在引擎层由各个引擎自己实现的。并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。

行锁就是针对数据表中行记录的锁比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。

### 两阶段锁

下面的操作序列中，假设字段 id 是表 t 的主键，事务 B 的 update 语句执行时会是什么现象？

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230727/bcdde19ea267405a825ffe0bcf329bdb.png" width=700  /></div>

这个问题的结论取决于事务 A 在执行完两条 update 语句后，持有哪些锁，以及在什么时候释放。实际上事务 B 的 update 语句会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能继续执行。

也就是说，在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。

所以，**如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放**。

比如有个电影票在线交易业务，顾客 A 要在影院 B 购买电影票。需要涉及到以下操作：

1. 从顾客 A 账户余额中扣除电影票价；
2. 给影院 B 的账户余额增加这张电影票价；
3. 记录一条交易日志。

也就是说，要完成这个交易，需要 update 两条记录，并 insert 一条记录。当然，为了保证交易的原子性，要把这三个操作放在一个事务中。那么，需要怎样安排这三个语句在事务中的顺序呢？

试想如果同时有另外一个顾客 C 要在影院 B 买票，那么这两个事务冲突的部分就是语句 2 了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。事务在执行的时候，并不是一次性把所有行锁都持有，而是执行到哪一行就拿哪一行的锁。等到最后 commit 的时候，一起释放。

根据两阶段锁协议，不论怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果把语句 2 安排在最后，比如按照 3、1、2 这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。

### 死锁和死锁检测

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230727/ce591f890d934ac69b30f5d22da56258.png" width=700  /></div>

上面的例子中，事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放 id=1 的行锁。 事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：

1. 直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。

2. 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230727/4fc297aa302b4acbb41da7a59e86d77d.png" width=  /></div>

在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。

但是，又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230727/7c73f0eacd4246368fa93d53551386a0.png" width=  /></div>

其实，正常情况下会采用第二种策略，即：主动死锁检测，而且 innodb_deadlock_detect 的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。

可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。

如果是所有事务都要更新同一行的场景，那么每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁（要加锁访问的行上有锁，他才要检测），这是一个时间复杂度是 **O(n)** 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，就会看到 CPU 利用率很高，但是每秒却执行不了几个事务的情况发生。

解决这种由于热点行更新导致的性能问题，问题的症结其实在于，死锁检测要耗费大量的 CPU 资源。

一种头痛医头的方法是，如果能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。

另一个思路是控制并发度。**减少死锁的主要方向，就是控制访问相同资源的并发事务量**。如果并发能够控制住，比如同一行同时最多只有 10 个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。其实这个方法不太可行，因为如果一旦客户端很多，这样即使每个客户端控制到只有 5 个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到一定的数量级。

因此，这个并发控制要做在数据库服务端。如果有中间件，可以考虑在中间件实现；如果团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。

其实还有一种解决方式，可以考虑通过将一行改成逻辑上的多行来减少锁冲突。

还是以电影票在线交易业务账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1/10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。

## 参考

+ [mysql MDL读写锁阻塞，以及online ddl造成的“插队”现象](https://blog.csdn.net/q2878948/article/details/96430129)













