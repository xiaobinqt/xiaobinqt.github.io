---
weight: 5

bookFlatSection: true

bookCollapseSection: false

bookToc: true

title: "1.5 锁"
---

# 1.5 锁

[//]: # (<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230726/8a04bf76bb63427c95cbe52e271eb143.png" width=  /></div>)

数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。

根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。

## 1.5.1 全局锁

全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。

当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文本。

之前有一种做法，是通过 FTWRL 确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。但是让整库都只读，听上去就很危险：

+ 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；

+ 如果在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。

如果在备份时不加锁会有什么问题呢？

假设现在要维护一个购买系统，关注的是用户账户余额表和用户课程表。现在发起一个逻辑备份。假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉他的余额，然后往已购课程里面加上一门课。如果时间顺序上是先备份账户余额表 (u_account)，然后用户购买，然后备份用户课程表 (u_course)，会怎么样呢？可以看一下下图：

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230726/d0714cdb3fd14c2aa1cc2c63cd3d41ab.png" width=  /></div>

可以看到，这个备份结果里，用户 A 的数据状态是 “账户余额没扣，但是用户课程表里面已经多了一门课”。

官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数 –single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图（可重复读）。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。

但是，对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，就破坏了备份的一致性。这时，就需要使用 FTWRL 命令了。

single-transaction 方法只适用于所有的表使用事务引擎的库。如果有的表使用了不支持事务的引擎，那么备份就只能通过 FTWRL 方法。这其实也是 InnoDB 引擎替代 MyISAM 的原因之一。

既然要全库只读，为什么不使用 set global readonly=true 的方式呢？

readonly 方式确实可以让全库进入只读状态，但实际应用中还是建议使用 FTWRL 方式，主要有两个原因：

1. 在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大。

2. 在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。

业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，再要对里面任何一个表做加字段操作，都是会被锁住的。

## 1.5.2 表级锁

MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

表锁的语法是 lock tables … read/write，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。

需要注意的是，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。也就是说，对表加读锁后，自己也不能对其进行修改；自己和其他线程只能读取该表。当对某个表执加上写锁后（lock table t2 write），该线程可以对这个表进行读写，其他线程对该表的读和写都受到阻塞。

如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。

在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。

另一类表级的锁是 MDL（metadata lock)。MDL 不需要显式使用，在访问一个表的时候会被**自动加上**。MDL 的作用是，保证读写的正确性。可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。

因此，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。

+ 读锁之间不互斥，因此可以有多个线程同时对一张表增删改查。

+ 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

{{< hint info >}}

这里的「增删改查」是针对元数据（表结构）说的, 而不是数据表里面的数据。MDL 作用是防止 DDL 和 DML 并发的冲突。

在 MySQL（和其他数据库系统）中，DDL 和 DML 是数据库操作的两个主要类别：

1. DDL (Data Definition Language)：数据定义语言

   DDL 用于定义和管理数据库结构，包括表、列、索引等。它允许你创建、修改和删除数据库对象。常见的 DDL 命令包括：

- CREATE：用于创建新的数据库对象，如创建表、索引等。
- ALTER：用于修改已存在的数据库对象的结构，如添加、修改或删除列。
- DROP：用于删除数据库对象，如删除表、索引等。
- TRUNCATE：用于删除表中的所有数据，但保留表结构。
- RENAME：用于重命名数据库对象，如重命名表。

2. DML (Data Manipulation Language)：数据操纵语言

   DML 用于对数据库中的数据进行操作，例如插入、更新、删除数据等。它允许你对数据库表中的数据进行查询和修改。常见的 DML 命令包括：

- SELECT：用于从数据库中检索数据。
- INSERT：用于向数据库表中插入新数据。
- UPDATE：用于更新数据库表中现有的数据。
- DELETE：用于从数据库表中删除数据。

总结：

- DDL 是用于定义数据库结构的语言，涉及创建、修改和删除数据库对象。
- DML 是用于操作数据库中的数据的语言，涉及查询、插入、更新和删除数据。

---

MySQL 在线 DDL（加字段、加索引等修改表结构之类的操作）过程如下：

1. 对表加锁（表此时只读）
2. 复制原表物理结构，创建新中间表
3. 修改中间表的物理结构
4. 把原表数据导入中间表中，数据同步完后，锁定中间表，并删除原表
5. rename 中间表为原表
6. 刷新数据字典，并释放锁

{{< /hint >}}

再给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。一般在对大表操作的时候，会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。可以看一下下面的操作序列，假设表 t 是一个小表（实验环境是 MySQL 5.6）：

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230726/c3f4fe58de3b4132830c5c99a5e46c84.png" width=700  /></div>

可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于 session B 需要的也是 MDL 读锁，因此可以正常执行。

之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞。也就是说，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。

申请 MDL 锁的操作会形成一个**队列**，队列中写锁获取优先级高于读锁。一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。

所以，如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。表不可用的原因是因为 session C 申请写锁，并且在队列处于优先，导致 session C 后面的所有读锁请求申请都被 block 了。这个时候客户端如果有频繁重试的逻辑就会导致不停的和数据库建立连接，把连接池打满导致库不可用。

事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。有未提交的事务时无法修改表字段，而且在存在长事务时执行修改表字段命令是一个危险的操作，可能阻塞其它增删改查请求，或导致线程爆满。

其实，在实际开发中，如何安全地给小表加字段也是一个棘手的问题。

首先要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。

但需要考虑一下这个场景。如果要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而又不得不加个字段，这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后再通过重试命令重复这个过程。

## 1.5.3 行锁

## 参考

+ [mysql MDL读写锁阻塞，以及online ddl造成的“插队”现象](https://blog.csdn.net/q2878948/article/details/96430129)













