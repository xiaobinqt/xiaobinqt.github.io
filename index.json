[{"categories":["essays"],"content":"有些人朋友是会一辈子在心里的，哪怕几年也不会见一面，吃一顿饭。 ","date":"2022-03-16","objectID":"/old_pal/:0:0","tags":["随笔","旧人"],"title":"纪念一位老友","uri":"/old_pal/"},{"categories":["c语言"],"content":" #include \u003cstdio.h\u003e int main(void) { char a[6] = {'F', 'i', 's', 'h', 'C', '\\0'}; // 需要主动加上 \\0 char a1[] = {'F', 'i', 's', 'h', 'C', '\\0'}; // 需要主动加上 \\0 char a2[] = {\"FishC\"}; char a3[] = \"FishC\"; printf(\"a: %s \\n\", a); printf(\"a1: %s \\n\", a1); printf(\"a2: %s \\n\", a2); printf(\"a3: %s \\n\", a3); return 0; } 运行结果： c语言定义字符串 \" ","date":"2022-03-17","objectID":"/c_define_string/:0:0","tags":["c语言"],"title":"C语言定义字符串的方法","uri":"/c_define_string/"},{"categories":["web"],"content":"刚在打包项目时执行 yarn run build 时出现了 oom 的情况，具体报错信息如下： JavaScript heap out of memory \" 我的环境是 win10 专业版 WSL。 解决办法，设置 export NODE_OPTIONS=--max_old_space_size=4096，设置完之后重新执行 yarn run build 即可。 ","date":"2022-03-16","objectID":"/node_oom/:0:0","tags":["javascript","node"],"title":"JavaScript heap out of memory","uri":"/node_oom/"},{"categories":["web"],"content":"参考 Node.js heap out of memory ","date":"2022-03-16","objectID":"/node_oom/:1:0","tags":["javascript","node"],"title":"JavaScript heap out of memory","uri":"/node_oom/"},{"categories":["golang"],"content":"进程、线程、协程的区别 ","date":"2022-03-16","objectID":"/gmp_model/:1:0","tags":["golang"],"title":"go GMP 模型","uri":"/gmp_model/"},{"categories":["golang"],"content":"协程的上下文切换比线程的上下文切换代价小 ","date":"2022-03-16","objectID":"/gmp_model/:2:0","tags":["golang"],"title":"go GMP 模型","uri":"/gmp_model/"},{"categories":["golang"],"content":"go 调度器机制 ","date":"2022-03-16","objectID":"/gmp_model/:3:0","tags":["golang"],"title":"go GMP 模型","uri":"/gmp_model/"},{"categories":["golang"],"content":"知识点 Go程序中没有语言级的关键字让你去创建一个内核线程，你只能创建 goroutine，内核线程只能由 runtime 根据实际情况去创建。 Go运行时系统并没有内核调度器的中断能力，内核调度器会发起抢占式调度将长期运行的线程中断并让出CPU资源，让其他线程获得执行机会。 ","date":"2022-03-16","objectID":"/gmp_model/:3:1","tags":["golang"],"title":"go GMP 模型","uri":"/gmp_model/"},{"categories":["golang"],"content":"参考 Go 为什么这么“快” 让你很快就能理解-go的协程调度原理 Golang goroutine与调度器 Go语言的并发模型 ","date":"2022-03-16","objectID":"/gmp_model/:4:0","tags":["golang"],"title":"go GMP 模型","uri":"/gmp_model/"},{"categories":["golang"],"content":"go build 常用命令","date":"2022-03-16","objectID":"/go_build_args/","tags":["golang"],"title":"go build 常用命令","uri":"/go_build_args/"},{"categories":["golang"],"content":"常用编译参数 参数 说明 -o 指定输出可执行文件名 -v 编译时显示包名，可以理解成输出详细编译信息 -race 开启竞态检测 *.go 编译当前目录下的所有go文件，也可以写成 f2.go f2.go … -a 强制重新构建 -w 去掉DWARF调试信息，得到的程序就不能用gdb调试了 -s 去掉符号表,panic时候的stack trace就没有任何文件名/行号信息了，这个等价于普通C/C++程序被strip的效果 -X 设置包中的变量值 -gcflags “-N -l” 编译目标程序的时候会嵌入运行时(runtime)的二进制，禁止优化和内联可以让运行时(runtime)中的函数变得更容易调试。gcflags 其实是给go编译器传入参数，也就是传给go tool compile的参数，因此可以用go tool compile --help查看所有可用的参数 -ldflags 给go链接器传入参数，实际是给go tool link的参数，可以用go tool link --help查看可用的参数。 -ldflags ‘-extldflags “-static”’ 静态编译 ","date":"2022-03-16","objectID":"/go_build_args/:1:0","tags":["golang"],"title":"go build 常用命令","uri":"/go_build_args/"},{"categories":["golang"],"content":"交叉编译 参数 说明 GOOS GOARCH linux 386 / amd64 / arm darwin 386 / amd64 feedbsd 386 / amd64 windows 386 / amd64 对于编译给ARM使用的Go程序，需要根据实际情况配置$GOARM，这是用来控制CPU的浮点协处理器的参数。 $GOARM默认是6，对于不支持VFP使用软件运算的老版本ARM平台要设置成5，支持VFPv1的设置成6，支持VFPv3的设置成7。 示例 GOARM= 7 GOARCH = arm GOOS = linux go build -v -o fca ","date":"2022-03-16","objectID":"/go_build_args/:2:0","tags":["golang"],"title":"go build 常用命令","uri":"/go_build_args/"},{"categories":["golang"],"content":"参考 golang编译时的参数传递（gcflags, ldflags） Golang交叉编译（跨平台编译）简述 交叉编译Go程序 ","date":"2022-03-16","objectID":"/go_build_args/:3:0","tags":["golang"],"title":"go build 常用命令","uri":"/go_build_args/"},{"categories":["developer"],"content":"将google浏览器插件下载到本地","date":"2022-03-16","objectID":"/googe-plugin-download/","tags":["google","开发者工具"],"title":"将google浏览器插件下载到本地","uri":"/googe-plugin-download/"},{"categories":["developer"],"content":"国内的网络太复杂了，在不能访问 google 的情况下，甚至都不能打开网上应用商店，所以我们需要一个方便的方式来下载google浏览器插件并分享 给需要的小伙伴。 我们打开任意一个浏览器插件，如： 浏览器插件 \" URL 地址栏中有一串字符串，这是唯一的，通过这个字符串可以获取到插件的下载地址，如： 插件UUID \" 下载地址为： https://clients2.google.com/service/update2/crx?response=redirect\u0026os=win\u0026arch=x64\u0026os_arch=x86_64\u0026nacl_arch=x86-64\u0026prod=chromecrx\u0026prodchannel=\u0026prodversion=77.0.3865.90\u0026lang=zh-CN\u0026acceptformat=crx2,crx3\u0026x=id%3D{XXXX}%26installsource%3Dondemand%26uc 将以上的 {XXXX} 替换为插件的 ID，就可以下载到本地了。 以下这个地址是Mote：语音笔记和反馈插件的下载地址，成功下载的插件是 .crx 结尾的文件。直接拖到浏览器中就会自动安装。 https://clients2.google.com/service/update2/crx?response=redirect\u0026os=win\u0026arch=x64\u0026os_arch=x86_64\u0026nacl_arch=x86-64\u0026prod=chromecrx\u0026prodchannel=\u0026prodversion=77.0.3865.90\u0026lang=zh-CN\u0026acceptformat=crx2,crx3\u0026x=id%3Dajphlblkfpppdpkgokiejbjfohfohhmk%26installsource%3Dondemand%26uc ","date":"2022-03-16","objectID":"/googe-plugin-download/:0:0","tags":["google","开发者工具"],"title":"将google浏览器插件下载到本地","uri":"/googe-plugin-download/"},{"categories":null,"content":"缘起 11111111111111111111 ","date":"2022-03-06","objectID":"/about/:1:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"职业生涯 222222 33333 ","date":"2022-03-06","objectID":"/about/:2:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":["golang"],"content":"RPC 是一种跨语言的协议，它可以让我们在不同的语言之间进行通信。 远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个 地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。 RPC是一种服务器-客户端（Client/Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。 ","date":"2022-03-05","objectID":"/grpc_demo/:0:0","tags":["golang"],"title":"grpc 入门应用","uri":"/grpc_demo/"},{"categories":["golang"],"content":"安装 go install github.com/golang/protobuf/protoc-gen-go@v1.4.0 go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1 不推荐使用 google.golang.org/protobuf/cmd/protoc-gen-go@v1.26 这个版本太高了，可能会遇到以下这个问题， --go_out: protoc-gen-go: plugins are not supported; use 'protoc --go-grpc_out=...' to generate gRPC See https://grpc.io/docs/languages/go/quickstart/#regenerate-grpc-code for more information. 生成代码遇到的问题 \" 参考解决方案记一次奇妙的go-protobuf包升级之旅 protoc 工具安装 下载地址，下载解压将 bin 目录添加到环境变量中。 protoc \" ","date":"2022-03-05","objectID":"/grpc_demo/:1:0","tags":["golang"],"title":"grpc 入门应用","uri":"/grpc_demo/"},{"categories":["golang"],"content":"定义 proto 文件 syntax = \"proto3\"; // 使用protobuf版本3 option go_package = \"./protobuf\"; // 这个影响生成的目录及go的package命名 // 定义一个计算服务, 输入为CalcRequest, 输出为CalcResponse service CalculatorService { rpc calc(CalcRequest) returns (CalcResponse) {};}// 计算两个数某种运算(如加法)的参数 message CalcRequest { double a = 1; double b = 2; string op = 3;}// 计算结果 message CalcResponse { double r = 1;} ","date":"2022-03-05","objectID":"/grpc_demo/:2:0","tags":["golang"],"title":"grpc 入门应用","uri":"/grpc_demo/"},{"categories":["golang"],"content":"生成 .pb.go 文件 protoc --go_out=plugins=grpc:. calculator.proto 整体目录结构 \" ","date":"2022-03-05","objectID":"/grpc_demo/:3:0","tags":["golang"],"title":"grpc 入门应用","uri":"/grpc_demo/"},{"categories":["golang"],"content":"rpc server package main import ( \"context\" \"fmt\" \"net\" \"go.src/grpc/calculator/protobuf\" \"google.golang.org/grpc\" ) // 实现: CalculatorServiceServer接口, 在calculator.pb.go中定义 type server struct{} func (s server) Calc(ctx context.Context, req *protobuf.CalcRequest) (resp *protobuf.CalcResponse, err error) { a := req.GetA() b := req.GetB() op := req.GetOp() resp = \u0026protobuf.CalcResponse{} switch op { case \"+\": resp.R = a + b case \"-\": resp.R = a - b case \"*\": resp.R = a * b case \"/\": if b == 0 { err = fmt.Errorf(\"divided by zero\") return } resp.R = a / b } return } // 启动rpc server func main() { listener, err := net.Listen(\"tcp\", \"localhost:3233\") if err != nil { panic(err) } s := grpc.NewServer() protobuf.RegisterCalculatorServiceServer(s, \u0026server{}) fmt.Println(\"server start\") err = s.Serve(listener) if err != nil { panic(err) } } ","date":"2022-03-05","objectID":"/grpc_demo/:4:0","tags":["golang"],"title":"grpc 入门应用","uri":"/grpc_demo/"},{"categories":["golang"],"content":"rpc client package main import ( \"context\" \"fmt\" \"log\" \"go.src/grpc/calculator/protobuf\" \"google.golang.org/grpc\" \"google.golang.org/grpc/credentials/insecure\" ) func main() { // 连上grpc server //conn, err := grpc.Dial(\"localhost:3233\", grpc.WithInsecure()) conn, err := grpc.Dial(\"localhost:3233\", grpc.WithTransportCredentials(insecure.NewCredentials())) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() c := protobuf.NewCalculatorServiceClient(conn) // 调用远程方法 resp, err := c.Calc(context.Background(), \u0026protobuf.CalcRequest{ A: 1, B: 2, Op: \"+\", }) if err != nil { fmt.Println(\"calc err: \", err.Error()) return } fmt.Println(\"calc success,respR: \", resp.GetR()) // 3 } ","date":"2022-03-05","objectID":"/grpc_demo/:5:0","tags":["golang"],"title":"grpc 入门应用","uri":"/grpc_demo/"},{"categories":["golang"],"content":"运行测试 serverserver \" server clientclient \" client ","date":"2022-03-05","objectID":"/grpc_demo/:6:0","tags":["golang"],"title":"grpc 入门应用","uri":"/grpc_demo/"},{"categories":["golang"],"content":"示例下载 示例源码地址 ","date":"2022-03-05","objectID":"/grpc_demo/:7:0","tags":["golang"],"title":"grpc 入门应用","uri":"/grpc_demo/"},{"categories":["web"],"content":"最近有个需求在使用 $.ajax 时需要把 cookie 信息也带着，google 下发现可以这么写： $.ajax({ url: \"/nodered/nodes\", headers: { Accept: \"text/html\", }, xhrFields: { withCredentials: true // 携带 cookie 信息 }, success: function (data) { console.log(data) $(\"#red-ui-palette-container\").html(data) }, error: function (jqXHR) { console.log(jqXHR) } }); ","date":"2022-03-01","objectID":"/ajax_req_add_cookie/:0:0","tags":["web","ajax","cookie"],"title":"ajax 在请求时携带 cookie 信息","uri":"/ajax_req_add_cookie/"},{"categories":["golang"],"content":"在 php 中可以直接在 break 和 continue 后加 num ，比如 break 2或 continue 2。 break num 是结束外层第 num 层整个循环体，continue num 是结束外层第 num 层单次循环。 类比 php ，go 中不能直接在关键字后加 num ，但是可以用 label 关键字代替 num。 ","date":"2022-02-16","objectID":"/break_continue_goto_label/:0:0","tags":["golang"],"title":"golang break，continue，goto label 的区别","uri":"/break_continue_goto_label/"},{"categories":["golang"],"content":"continue label package main import ( \"fmt\" \"math\" ) func main() { // 找出 int 切片的最小值 var matrix = []int{10, 2, 4, 0} var min = math.MinInt64 next: for _, v := range matrix { for _, v1 := range matrix { if v \u003e v1 { continue next // 终止当前循环，跳到 label 继续下一次循环 } } min = v } fmt.Println(\"最小值为: \", min) } ","date":"2022-02-16","objectID":"/break_continue_goto_label/:1:0","tags":["golang"],"title":"golang break，continue，goto label 的区别","uri":"/break_continue_goto_label/"},{"categories":["golang"],"content":"break label package main import ( \"fmt\" \"math\" ) func main() { // 获取 index 2 的值，这里使用 2 层循环主要是为了说明问题 var matrix = []int{10, 2, 4, 0} var index2Val = math.MinInt64 next: for _, v := range matrix { fmt.Println(v) for index, v1 := range matrix { index2Val = v1 if index == 2 { break next // 跳出循环到 label 处 } } } fmt.Println(\"index 3 值为: \", index2Val) } ","date":"2022-02-16","objectID":"/break_continue_goto_label/:2:0","tags":["golang"],"title":"golang break，continue，goto label 的区别","uri":"/break_continue_goto_label/"},{"categories":["golang"],"content":"goto label 非必要不使用，可以跳到任何地方。 package main import ( \"fmt\" \"math\" ) func main() { var matrix = []int{10, 2, 4, 0} var index2Val = math.MinInt64 for _, v := range matrix { fmt.Println(v) for index, v1 := range matrix { index2Val = v1 if index == 2 { goto next } } } fmt.Println(\"index 3 值为: \", index2Val) next: fmt.Println(\"goto this....\") } ","date":"2022-02-16","objectID":"/break_continue_goto_label/:3:0","tags":["golang"],"title":"golang break，continue，goto label 的区别","uri":"/break_continue_goto_label/"},{"categories":["golang"],"content":"今天在编译 go 项目时出现了如下错误： /usr/local/go/pkg/tool/linux_amd64/link: running gcc failed: exit status 1 /usr/bin/ld: cannot find -lpthread /usr/bin/ld: cannot find -lc collect2: error: ld returned 1 exit status 解决办法： yum install glibc-static.x86_64 -y ","date":"2022-02-10","objectID":"/build_running_gcc_failed/:0:0","tags":["golang","build"],"title":"running gcc failed: exit status 1","uri":"/build_running_gcc_failed/"},{"categories":["algorithms"],"content":"存在的意义 一致性哈希算法解决了普通余数 Hash 算法伸缩性差的问题，可以保证在上线、下线服务器的情况下尽量有多的请求命中原来路由到的服务器。 ","date":"2022-01-15","objectID":"/consistent_hash/:1:0","tags":["算法"],"title":"一致性 hash","uri":"/consistent_hash/"},{"categories":["algorithms"],"content":"优化 一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。可以通过通过增加虚拟节点来解决数据倾斜问题。 如果存在大量的虚拟节点，节点的查找性能就成为必须考虑的因数。可以使用红黑树 来加快查找速度， ","date":"2022-01-15","objectID":"/consistent_hash/:2:0","tags":["算法"],"title":"一致性 hash","uri":"/consistent_hash/"},{"categories":["algorithms"],"content":"参考 一致性Hash(Consistent Hashing)原理剖析及Java实现 图解一致性哈希算法 golang实现一致性hash环及优化方法 一致性哈希 ","date":"2022-01-15","objectID":"/consistent_hash/:3:0","tags":["算法"],"title":"一致性 hash","uri":"/consistent_hash/"},{"categories":["收藏"],"content":"在线书籍 build-web-application-with-golang Mastering_Go golang 修养之路 Go语言101 PHP扩展开发及内核应用 ","date":"2021-10-17","objectID":"/memo/:1:0","tags":["备忘录"],"title":"书籍/工具收藏","uri":"/memo/"},{"categories":["收藏"],"content":"工具收藏 navicat premium15破解教程 ","date":"2021-10-17","objectID":"/memo/:2:0","tags":["备忘录"],"title":"书籍/工具收藏","uri":"/memo/"},{"categories":["收藏"],"content":"文章收藏 go1.16 embed 用法 ","date":"2021-10-17","objectID":"/memo/:3:0","tags":["备忘录"],"title":"书籍/工具收藏","uri":"/memo/"},{"categories":["golang"],"content":"总结 make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配。 new返回指针，指向新分配的类型 T 的零值。 make返回初始化后的（非零）值。 ","date":"2021-06-21","objectID":"/new_make_difference/:1:0","tags":["golang"],"title":"golang make 和 new 的区别","uri":"/new_make_difference/"},{"categories":["golang"],"content":"参考 make、new操作 Go make 和 new的区别 ","date":"2021-06-21","objectID":"/new_make_difference/:2:0","tags":["golang"],"title":"golang make 和 new 的区别","uri":"/new_make_difference/"},{"categories":["golang"],"content":"server package main import ( \"fmt\" \"net\" \"time\" ) func main() { // 创建监听 socket, err := net.ListenUDP(\"udp4\", \u0026net.UDPAddr{ IP: []byte{127, 0, 0, 1}, Port: 8080, }) if err != nil { fmt.Println(\"监听失败!\", err) return } defer socket.Close() for { // 读取数据 data := make([]byte, 4096) read, remoteAddr, err := socket.ReadFromUDP(data) if err != nil { fmt.Println(\"读取数据失败!\", err) continue } fmt.Println(read, remoteAddr) fmt.Printf(\"接收到客户端数据，%s\\n\\n\", data) // 发送数据 senddata := []byte(\"server send data，hello client!\" + time.Now().Format(\"2006-01-02 15:04:05\")) _, err = socket.WriteToUDP(senddata, remoteAddr) if err != nil { fmt.Println(\"发送数据失败!\", err.Error()) return } } } ","date":"2021-04-01","objectID":"/upd_demo/:1:0","tags":["golang"],"title":"golang udp 示例","uri":"/upd_demo/"},{"categories":["golang"],"content":"client package main import ( \"fmt\" \"net\" \"time\" ) func main() { // 创建连接 socket, err := net.DialUDP(\"udp4\", nil, \u0026net.UDPAddr{ IP: []byte{127, 0, 0, 1}, Port: 8080, }) if err != nil { fmt.Println(\"连接失败!\", err) return } defer socket.Close() // 发送数据 senddata := []byte(\"client send message，hello server!\" + time.Now().Format(\"2006-01-02 15:04:05\")) _, err = socket.Write(senddata) if err != nil { fmt.Println(\"发送数据失败!\", err) return } // 接收数据 data := make([]byte, 4096) read, remoteAddr, err := socket.ReadFromUDP(data) if err != nil { fmt.Println(\"读取数据失败!\", err) return } fmt.Println(read, remoteAddr) fmt.Printf(\"接收到服务器端数据，%s\\n\", data) } ","date":"2021-04-01","objectID":"/upd_demo/:2:0","tags":["golang"],"title":"golang udp 示例","uri":"/upd_demo/"},{"categories":["golang"],"content":"代码地址 源码地址 ","date":"2021-04-01","objectID":"/upd_demo/:3:0","tags":["golang"],"title":"golang udp 示例","uri":"/upd_demo/"},{"categories":["tech","golang"],"content":"常见缓存淘汰策略，淘汰策略的实现，FIFO，LRU，LFU","date":"2020-03-05","objectID":"/common_cache_-strategies/","tags":["golang"],"title":"常见缓存淘汰策略","uri":"/common_cache_-strategies/"},{"categories":["tech","golang"],"content":"常见缓存淘汰策略 ","date":"2020-03-05","objectID":"/common_cache_-strategies/:0:0","tags":["golang"],"title":"常见缓存淘汰策略","uri":"/common_cache_-strategies/"},{"categories":["tech","golang"],"content":"FIFO First In First Out(FIFO)，先进先出，也就是淘汰缓存中最老(最早添加)的记录。FIFO 认为，最早添加的记录，其不再被使用的可能性比刚添加的可能性大。这种算法的实现也非常简单，创建一个队列，新增记录添加到队尾， 每次内存不够时，淘汰队首。但是很多场景下，部分记录虽然是最早添加但也最常被访问，而不得不因为呆的时间太长而被淘汰。这类数据会被频繁地添加进缓存，又被淘汰出去，导致缓存命中率降低。 ","date":"2020-03-05","objectID":"/common_cache_-strategies/:1:0","tags":["golang"],"title":"常见缓存淘汰策略","uri":"/common_cache_-strategies/"},{"categories":["tech","golang"],"content":"LFU Least Frequently Used(LFU)，最少使用，也就是淘汰缓存中访问频率最低的记录。LFU 认为，如果数据过去被访问多次， 那么将来被访问的频率也更高。LFU 的实现需要维护一个按照访问次数排序的队列，每次访问，访问次数加1，队列重新排序， 淘汰时选择访问次数最少的即可。LFU 算法的命中率是比较高的，但缺点也非常明显，维护每个记录的访问次数，对内存的消耗是很高的； 另外，如果数据的访问模式发生变化，LFU 需要较长的时间去适应，也就是说 LFU 算法受历史数据的影响比较大。例如某个数据历史上访问次数奇高，但在某个时间点之后几乎不再被访问，但因为历史访问次数过高，而迟迟不能被淘汰。 ","date":"2020-03-05","objectID":"/common_cache_-strategies/:2:0","tags":["golang"],"title":"常见缓存淘汰策略","uri":"/common_cache_-strategies/"},{"categories":["tech","golang"],"content":"LRU Least Recently Used(LRU)，最近最少使用，相对于仅考虑时间因素的 FIFO 和仅考虑访问频率的 LFU，LRU 算法可以认为是相对平衡的 一种淘汰算法。LRU 认为，如果数据最近被访问过，那么将来被访问的概率也会更高。LRU 算法的实现非常简单，维护一个队列，如果某条记录被访问了， 则移动到队尾，那么队首则是最近最少访问的数据，淘汰该条记录即可。 ","date":"2020-03-05","objectID":"/common_cache_-strategies/:3:0","tags":["golang"],"title":"常见缓存淘汰策略","uri":"/common_cache_-strategies/"},{"categories":["developer"],"content":"申请 证书申请地址 在这里插入图片描述 \" 申请完成页面 在这里插入图片描述 \" 将主机记录解析 在这里插入图片描述 \" 在这里插入图片描述 \" 在这里插入图片描述 \" 将主机记录和记录值填写 在这里插入图片描述 \" 解析成功后下载证书 在这里插入图片描述 \" 我用的是 Apache ,所以下载的是 Apache 在这里插入图片描述 \" ","date":"2019-06-07","objectID":"/ali_ssl/:1:0","tags":["系统"],"title":"阿里云 SSL 免费证书使用","uri":"/ali_ssl/"},{"categories":["developer"],"content":"上传证书 由于本人使用的是 apache ,以下配置是 apache 的通用配置,具体可参看官方 文档 在 apache 的路径下新建一个 cert 目录,其实该目录建在哪里都可以,但是放在 apache 下方便管理。 \" 在 cert 目录下可以建不同的文件夹放在不同域名或子域名的 ssl 文件。 \" 把我们刚才下载的证书上传到服务器上 \" ","date":"2019-06-07","objectID":"/ali_ssl/:2:0","tags":["系统"],"title":"阿里云 SSL 免费证书使用","uri":"/ali_ssl/"},{"categories":["developer"],"content":"配置 这是基本的配置语句 # 添加 SSL 协议支持协议，去掉不安全的协议 SSLProtocol all -SSLv2 -SSLv3 # 修改加密套件如下 SSLCipherSuite HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUM SSLHonorCipherOrder on # 证书公钥配置 SSLCertificateFile cert/a_public.crt # 证书私钥配置 SSLCertificateKeyFile cert/a.key # 证书链配置，如果该属性开头有 '#'字符，请删除掉 SSLCertificateChainFile cert/a_chain.crt 我们将默认的配置 copy 一份出来,取一个跟域名有关的文件名 cp /etc/apache2/sites-available/000-default.conf /etc/apache2/sites-available/www.xiaobinqt.cn.conf 具体配置可参考 \u003cVirtualHost *:80\u003e ServerName www.xiaobinqt.cn Redirect permanent / https://www.xiaobinqt.cn/ \u003c/VirtualHost\u003e \u003cVirtualHost *:443\u003e SSLEngine On # 添加 SSL 协议支持协议，去掉不安全的协议 SSLProtocol all -SSLv2 -SSLv3 # 修改加密套件如下 SSLCipherSuite HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUM SSLHonorCipherOrder on # 证书公钥配置 SSLCertificateFile cert/xiaobinqt.cn/2324042_www.xiaobinqt.cn_public.crt # 证书私钥配置 SSLCertificateKeyFile cert/xiaobinqt.cn/2324042_www.xiaobinqt.cn.key # 证书链配置，如果该属性开头有 '#'字符，请删除掉 SSLCertificateChainFile cert/xiaobinqt.cn/2324042_www.xiaobinqt.cn_chain.crt # etc ServerName www.xiaobinqt.cn ProxyPreserveHost On ProxyRequests Off ProxyPass / http://localhost:30007/ ProxyPassReverse / http://localhost:30007/ \u003c/VirtualHost\u003e 我用的是 docker 服务,如果你的只是项目文件夹可以参考这样配置 \u003cVirtualHost *:80\u003e # The ServerName directive sets the request scheme, hostname and port that # the server uses to identify itself. This is used when creating # redirection URLs. In the context of virtual hosts, the ServerName # specifies what hostname must appear in the request's Host: header to # match this virtual host. For the default virtual host (this file) this # value is not decisive as it is used as a last resort host regardless. # However, you must set it for any further virtual host explicitly. #ServerName www.example.com #ServerAdmin webmaster@localhost ServerName www.xiaobinqt.cn DocumentRoot /var/www/html Redirect permanent / https://www.xiaobinqt.cn/ # Available loglevels: trace8, ..., trace1, debug, info, notice, warn, # error, crit, alert, emerg. # It is also possible to configure the loglevel for particular # modules, e.g. #LogLevel info ssl:warn ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined # For most configuration files from conf-available/, which are # enabled or disabled at a global level, it is possible to # include a line for only one particular virtual host. For example the # following line enables the CGI configuration for this host only # after it has been globally disabled with \"a2disconf\". #Include conf-available/serve-cgi-bin.conf \u003c/VirtualHost\u003e \u003cVirtualHost *:443\u003e SSLEngine On # 添加 SSL 协议支持协议，去掉不安全的协议 SSLProtocol all -SSLv2 -SSLv3 # 修改加密套件如下 SSLCipherSuite HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUM SSLHonorCipherOrder on # 证书公钥配置 SSLCertificateFile cert/xiaobinqt.cn/public.pem # 证书私钥配置 SSLCertificateKeyFile cert/xiaobinqt.cn/214792197160511.key # 证书链配置，如果该属性开头有 '#'字符，请删除掉 SSLCertificateChainFile cert/xiaobinqt.cn/chain.pem # etc ServerName www.xiaobinqt.cn \u003c/VirtualHost\u003e 以上配置全部基于 apache ,如果你用的不是 apache ,以上配置可能不适合你. 关于 apache 服务的一些其他知识可以参考这篇文章,该文章可能需要翻~墙访问. 配置完成后重启服务,可以利用 curl 命令查看是否配置成功. curl -I localhost:xxx \" 对于 ssl 是否配置成功可以通过浏览器查看. \" 可以看到这是我们最新申请的一年的 ssl 证书. \" ","date":"2019-06-07","objectID":"/ali_ssl/:3:0","tags":["系统"],"title":"阿里云 SSL 免费证书使用","uri":"/ali_ssl/"},{"categories":["developer"],"content":"下载系统 首先我们需要一个最小 4G 大的 U 盘 image \" 进入大白菜网站下载大白菜装机版安装到电脑 image \" image \" 将 U 盘插到电脑上,双击打开大白菜装机版,它会自动读到我们插入的 U 盘，自动匹配默认模式,不需要手动选择。 image \" 点击开始制作 –\u003e 确认 image \" 等待写入数据包完成和格式化完成后关掉大白菜软件 image \" image \" image \" 制作完 U 盘启动盘后我们的 U 盘会变成这样说明启动盘已经制作成功 ! image去itellyou下载需要安装的操作系统 ! image \" 比如我们要安装这个版本的 win10 image \" 通过百度网盘下载 ed2k 文件资源,然后再通过百度网盘下载到电脑本地,可以放在除 C 盘外的其他盘中 image \" 下载到本地的文件是这样的光盘映像文件 ! image \" 将我们下载到电脑本地的光盘映像文件复制到刚制作完成的 U 盘启动盘中,复制完成后我们 U 盘启动盘就全部制作完成了 image \" ","date":"2018-10-07","objectID":"/redo_system/:1:0","tags":["系统","windows"],"title":"windows 重做系统","uri":"/redo_system/"},{"categories":["developer"],"content":"重做系统 将我们制作好的 U 盘启动盘插到需要重做系统的电脑上,重启电脑一直按 F12 进入 bios 界面(不同的电脑可能按键不同,可以百度) image \" 选择 usb 方式,回车进入大白菜启动方式,选择 02 方式进入 image \" 进入 u 盘驱动界面,系统默认会选择 C 盘为系统盘,直接点击确定 image \" 确定后进入格式化 C 盘阶段,所有配置为默认配置,直接确定,等待格式化完成! image \" 格式化完成后选择 是 重启电脑,拔出 u 盘 等待电脑重启 ","date":"2018-10-07","objectID":"/redo_system/:2:0","tags":["系统","windows"],"title":"windows 重做系统","uri":"/redo_system/"},{"categories":["developer"],"content":"安装系统完成 image \" image \" ","date":"2018-10-07","objectID":"/redo_system/:3:0","tags":["系统","windows"],"title":"windows 重做系统","uri":"/redo_system/"}]