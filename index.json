[{"categories":["essays"],"content":"有些人朋友是会一辈子在心里的，哪怕几年也不会见一面，吃一顿饭。 ddsdfsfs ","date":"2022-03-16","objectID":"/old_pal/:0:0","tags":["随笔","旧人"],"title":"纪念一位老友","uri":"/old_pal/"},{"categories":["golang"],"content":"进程、线程、协程的区别 ","date":"2022-03-16","objectID":"/gmp_model/:1:0","tags":["golang"],"title":"go GMP 模型","uri":"/gmp_model/"},{"categories":["golang"],"content":"协程的上下文切换比线程的上下文切换代价小 ","date":"2022-03-16","objectID":"/gmp_model/:2:0","tags":["golang"],"title":"go GMP 模型","uri":"/gmp_model/"},{"categories":["golang"],"content":"go 调度器机制 ","date":"2022-03-16","objectID":"/gmp_model/:3:0","tags":["golang"],"title":"go GMP 模型","uri":"/gmp_model/"},{"categories":["golang"],"content":"知识点 Go程序中没有语言级的关键字让你去创建一个内核线程，你只能创建 goroutine，内核线程只能由 runtime 根据实际情况去创建。 Go运行时系统并没有内核调度器的中断能力，内核调度器会发起抢占式调度将长期运行的线程中断并让出CPU资源，让其他线程获得执行机会。 ","date":"2022-03-16","objectID":"/gmp_model/:3:1","tags":["golang"],"title":"go GMP 模型","uri":"/gmp_model/"},{"categories":["golang"],"content":"参考 Go 为什么这么“快” 让你很快就能理解-go的协程调度原理 Golang goroutine与调度器 Go语言的并发模型 ","date":"2022-03-16","objectID":"/gmp_model/:4:0","tags":["golang"],"title":"go GMP 模型","uri":"/gmp_model/"},{"categories":["golang"],"content":"go build 常用命令","date":"2022-03-16","objectID":"/go_build_args/","tags":["golang"],"title":"go build 常用命令","uri":"/go_build_args/"},{"categories":["golang"],"content":"常用编译参数 参数 说明 -o 指定输出可执行文件名 -v 编译时显示包名，可以理解成输出详细编译信息 -race 开启竞态检测 *.go 编译当前目录下的所有go文件，也可以写成 f2.go f2.go … -a 强制重新构建 -w 去掉DWARF调试信息，得到的程序就不能用gdb调试了 -s 去掉符号表,panic时候的stack trace就没有任何文件名/行号信息了，这个等价于普通C/C++程序被strip的效果 -X 设置包中的变量值 -gcflags “-N -l” 编译目标程序的时候会嵌入运行时(runtime)的二进制，禁止优化和内联可以让运行时(runtime)中的函数变得更容易调试。gcflags 其实是给go编译器传入参数，也就是传给go tool compile的参数，因此可以用go tool compile --help查看所有可用的参数 -ldflags 给go链接器传入参数，实际是给go tool link的参数，可以用go tool link --help查看可用的参数。 -ldflags ‘-extldflags “-static”’ 静态编译 ","date":"2022-03-16","objectID":"/go_build_args/:1:0","tags":["golang"],"title":"go build 常用命令","uri":"/go_build_args/"},{"categories":["golang"],"content":"交叉编译 参数 说明 GOOS GOARCH linux 386 / amd64 / arm darwin 386 / amd64 feedbsd 386 / amd64 windows 386 / amd64 对于编译给ARM使用的Go程序，需要根据实际情况配置$GOARM，这是用来控制CPU的浮点协处理器的参数。 $GOARM默认是6，对于不支持VFP使用软件运算的老版本ARM平台要设置成5，支持VFPv1的设置成6，支持VFPv3的设置成7。 示例 GOARM= 7 GOARCH = arm GOOS = linux go build -v -o fca ","date":"2022-03-16","objectID":"/go_build_args/:2:0","tags":["golang"],"title":"go build 常用命令","uri":"/go_build_args/"},{"categories":["golang"],"content":"参考 golang编译时的参数传递（gcflags, ldflags） Golang交叉编译（跨平台编译）简述 交叉编译Go程序 ","date":"2022-03-16","objectID":"/go_build_args/:3:0","tags":["golang"],"title":"go build 常用命令","uri":"/go_build_args/"},{"categories":["developer"],"content":"将google浏览器插件下载到本地","date":"2022-03-16","objectID":"/googe-plugin-download/","tags":["google","开发者工具"],"title":"将google浏览器插件下载到本地","uri":"/googe-plugin-download/"},{"categories":["developer"],"content":"国内的网络太复杂了，在不能访问 google 的情况下，甚至都不能打开网上应用商店，所以我们需要一个方便的方式来下载google浏览器插件并分享 给需要的小伙伴。 我们打开任意一个浏览器插件，如： 浏览器插件 \" URL 地址栏中有一串字符串，这是唯一的，通过这个字符串可以获取到插件的下载地址，如： 插件UUID \" 下载地址为： https://clients2.google.com/service/update2/crx?response=redirect\u0026os=win\u0026arch=x64\u0026os_arch=x86_64\u0026nacl_arch=x86-64\u0026prod=chromecrx\u0026prodchannel=\u0026prodversion=77.0.3865.90\u0026lang=zh-CN\u0026acceptformat=crx2,crx3\u0026x=id%3D{XXXX}%26installsource%3Dondemand%26uc 将以上的 {XXXX} 替换为插件的 ID，就可以下载到本地了。 以下这个地址是Mote：语音笔记和反馈插件的下载地址，成功下载的插件是 .crx 结尾的文件。直接拖到浏览器中就会自动安装。 https://clients2.google.com/service/update2/crx?response=redirect\u0026os=win\u0026arch=x64\u0026os_arch=x86_64\u0026nacl_arch=x86-64\u0026prod=chromecrx\u0026prodchannel=\u0026prodversion=77.0.3865.90\u0026lang=zh-CN\u0026acceptformat=crx2,crx3\u0026x=id%3Dajphlblkfpppdpkgokiejbjfohfohhmk%26installsource%3Dondemand%26uc ","date":"2022-03-16","objectID":"/googe-plugin-download/:0:0","tags":["google","开发者工具"],"title":"将google浏览器插件下载到本地","uri":"/googe-plugin-download/"},{"categories":null,"content":"缘起 11111111111111111111 ","date":"2022-03-06","objectID":"/about/:1:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"职业生涯 222222 33333 ","date":"2022-03-06","objectID":"/about/:2:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":["tech","golang"],"content":"常见缓存淘汰策略，淘汰策略的实现，FIFO，LRU，LFU","date":"2020-03-05","objectID":"/common_cache_-strategies/","tags":["golang"],"title":"常见缓存淘汰策略","uri":"/common_cache_-strategies/"},{"categories":["tech","golang"],"content":"常见缓存淘汰策略 ","date":"2020-03-05","objectID":"/common_cache_-strategies/:0:0","tags":["golang"],"title":"常见缓存淘汰策略","uri":"/common_cache_-strategies/"},{"categories":["tech","golang"],"content":"FIFO First In First Out(FIFO)，先进先出，也就是淘汰缓存中最老(最早添加)的记录。FIFO 认为，最早添加的记录，其不再被使用的可能性比刚添加的可能性大。这种算法的实现也非常简单，创建一个队列，新增记录添加到队尾， 每次内存不够时，淘汰队首。但是很多场景下，部分记录虽然是最早添加但也最常被访问，而不得不因为呆的时间太长而被淘汰。这类数据会被频繁地添加进缓存，又被淘汰出去，导致缓存命中率降低。 ","date":"2020-03-05","objectID":"/common_cache_-strategies/:1:0","tags":["golang"],"title":"常见缓存淘汰策略","uri":"/common_cache_-strategies/"},{"categories":["tech","golang"],"content":"LFU Least Frequently Used(LFU)，最少使用，也就是淘汰缓存中访问频率最低的记录。LFU 认为，如果数据过去被访问多次， 那么将来被访问的频率也更高。LFU 的实现需要维护一个按照访问次数排序的队列，每次访问，访问次数加1，队列重新排序， 淘汰时选择访问次数最少的即可。LFU 算法的命中率是比较高的，但缺点也非常明显，维护每个记录的访问次数，对内存的消耗是很高的； 另外，如果数据的访问模式发生变化，LFU 需要较长的时间去适应，也就是说 LFU 算法受历史数据的影响比较大。例如某个数据历史上访问次数奇高，但在某个时间点之后几乎不再被访问，但因为历史访问次数过高，而迟迟不能被淘汰。 ","date":"2020-03-05","objectID":"/common_cache_-strategies/:2:0","tags":["golang"],"title":"常见缓存淘汰策略","uri":"/common_cache_-strategies/"},{"categories":["tech","golang"],"content":"LRU Least Recently Used(LRU)，最近最少使用，相对于仅考虑时间因素的 FIFO 和仅考虑访问频率的 LFU，LRU 算法可以认为是相对平衡的 一种淘汰算法。LRU 认为，如果数据最近被访问过，那么将来被访问的概率也会更高。LRU 算法的实现非常简单，维护一个队列，如果某条记录被访问了， 则移动到队尾，那么队首则是最近最少访问的数据，淘汰该条记录即可。 ","date":"2020-03-05","objectID":"/common_cache_-strategies/:3:0","tags":["golang"],"title":"常见缓存淘汰策略","uri":"/common_cache_-strategies/"}]