[{"categories":["essays"],"content":"几年前，一位好朋友去世了，九零后，跟我年纪一样。我跟他从小就认识，我们一起上的小学，一起上的初中，高中之后便联系的少了，后来我去外地读书，联系的就更少了。 那还是二零一九，那时我刚从西安来北京。一天夜里，都很晚了，我妈打电话跟我说，他去世了，好像是心梗，让我在外面多注意身体。天啊，当我听到这个消息的时候，我简直不敢相信，我反复确认了几次，无疑的确是他。 那晚我很难过，因为我不久之前还见过他。二零一九的春节，那天应该是初二的早晨，我骑着电瓶车去外公家拜年，外公家跟他老家离的不远，就几步路，那天早晨我在路边看到了他，我没有停下来，心想就几步路，我回来的时候再去找他，但是等我再往回走的时候他就不在家了。如今听到噩耗，再想起这件事，我真的特别后悔当时应该停下来见他一面。后来，我把这件事说给我女朋友听，她也特别感慨的说，想做什么事一定要赶紧去做。是啊，一定要赶紧去做，毕竟世事无常。 我跟他太久没有联系了，没有他的电话，也没有他的微信，后来在QQ 里找到他的联系方式。我尝试着发了一条消息过去，QQ 的那边，他媳妇回了一条消息，说他人已经不在了。后来有个初中同学联系到了我，是他班上的，建了一个微信群，想尽点绵薄之力，我们一人凑了点钱，由一个在老家的同学给他家里送了去，但他妈妈只是领了我们的心意。他实在是太年轻了，而且新婚不久，孩子才一岁。 这张照片是上初中时我们一起去皖南事变烈士陵园拍的，也是我跟他唯一的一张合影。 2020 年时家里发大水，家里的东西都泡水了，这张照片后来也不知所踪。 左三是他\" 左三是他 有一次我回家，我爸还跟我说在一次婚宴上见过他。他过世后，一次在我大舅家吃饭的时候，他家的一个亲戚也在，在聊起他的时候，直夸他在外面干活能吃苦，人不错。 我跟他从小相识，一起在村小学读书，一起在田埂上疯跑，他教我掏鸟窝，网知了，在我眼里，他好像什么都会，他教了我很多技能，带给我很多快乐。上初中的时候，我跟他一起骑车上学，放学也一起回家。他每天早上都是骑着车来我外婆家等我，等我吃完早饭一起走，一路上我们有好几个同学都一起。下午放学他有时也在我外婆家跟我一起做完作业才回家，这些事如今历历在目，但是他却永远不在了。 也许是年纪大了，不知不觉对有些事越来越伤感。几次提笔想写点什么，但是每次都写不出来，心里总记挂这件事，可能是那次我没有停下来见他吧。 2021年10月15日完 ","date":"2022-03-16","objectID":"/old_pal/:0:0","tags":["随笔"],"title":"纪念一位老友","uri":"/old_pal/"},{"categories":[""],"content":"前小端 ","date":"2022-03-19","objectID":"/links/:1:0","tags":[""],"title":"友情链接","uri":"/links/"},{"categories":[""],"content":"MakerLi ","date":"2022-03-19","objectID":"/links/:2:0","tags":[""],"title":"友情链接","uri":"/links/"},{"categories":[""],"content":"西瓜 ","date":"2022-03-19","objectID":"/links/:3:0","tags":[""],"title":"友情链接","uri":"/links/"},{"categories":[""],"content":"liupray ","date":"2022-03-19","objectID":"/links/:4:0","tags":[""],"title":"友情链接","uri":"/links/"},{"categories":["web"],"content":"执行模式 JS的执行模式是单线程的，当有多个任务时必须排队执行，优点是执行环境简单，缺点是性能低下，当有多个任务时，需要等待上一个任务执行完成才能执行下一个任务， 如果某个任务出现了死循环，那么就会导致程序崩溃。 所以JS出现了同步和异步的概念。 ","date":"2022-03-18","objectID":"/js_cb_asyn/:1:0","tags":["js"],"title":"JS运行机制","uri":"/js_cb_asyn/"},{"categories":["web"],"content":"同步 后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的。 ","date":"2022-03-18","objectID":"/js_cb_asyn/:1:1","tags":["js"],"title":"JS运行机制","uri":"/js_cb_asyn/"},{"categories":["web"],"content":"异步 每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序可能是不一致的。 ","date":"2022-03-18","objectID":"/js_cb_asyn/:1:2","tags":["js"],"title":"JS运行机制","uri":"/js_cb_asyn/"},{"categories":["web"],"content":"Event Loop // TODO ","date":"2022-03-18","objectID":"/js_cb_asyn/:2:0","tags":["js"],"title":"JS运行机制","uri":"/js_cb_asyn/"},{"categories":["web"],"content":"Promise Promise 对象代表一个异步操作，then() 第一个参数是成功resolve的回调函数，第二个参数是失败reject的回调函数，当不写第二个 then() 参数时，可以用 catch() 捕获 reject 异常。 ","date":"2022-03-18","objectID":"/js_cb_asyn/:3:0","tags":["js"],"title":"JS运行机制","uri":"/js_cb_asyn/"},{"categories":["web"],"content":"使用 var p1 = new Promise(function (resolve, reject) { // resolve('成功'); reject(\"失败\") }); p1.then(function (res) { console.log(\"第一个fn: \", res) }, function (res) { console.log(\"第二个 fn: \", res) }); resolve和reject除了正常的值外，还可能是另一个promise实例。 const p1 = new Promise(function (resolve, reject) { resolve(1) }); const p2 = new Promise(function (resolve, reject) { // ... resolve(p1); }) p2.then(function (res) { console.log(res) }, function (res) { }) 用 catch 捕获 reject 异常 var p1 = new Promise(function (resolve, reject) { // todo... reject(111111) }); p1.then(function (res) { console.log(\"第一个fn: \", res) }).catch(function (err) { console.log(\"err :\", err) }).finally(function () { console.log(\"finally exec...\") }) ","date":"2022-03-18","objectID":"/js_cb_asyn/:3:1","tags":["js"],"title":"JS运行机制","uri":"/js_cb_asyn/"},{"categories":["web"],"content":"执行顺序 ","date":"2022-03-18","objectID":"/js_cb_asyn/:3:2","tags":["js"],"title":"JS运行机制","uri":"/js_cb_asyn/"},{"categories":["web"],"content":"async/await的用法和理解 async 函数是非常新的语法功能，在 ES7 中可用。 async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。await 作为修饰符，只能放在 async 内部使用。 当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。 await 等待右侧表达式的结果。 如果等到的不是一个 promise 对象，那 await 表达式的运算结果就是它等到的东西。 如果它等到的是一个 promise 对象，它会阻塞后面的代码，等着 promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 async function test() { let promise = new Promise(resolve =\u003e { setTimeout(() =\u003e resolve(\"test\"), 2000); }); await promise.then((ret) =\u003e { console.log(ret) }) let test1Ret = await test1() console.log(test1Ret) console.log(\"test end...\") } function test1() { return \"test1_return\" } test(); console.log('end') 运行结果 \" ","date":"2022-03-18","objectID":"/js_cb_asyn/:4:0","tags":["js"],"title":"JS运行机制","uri":"/js_cb_asyn/"},{"categories":["web"],"content":"宏任务和微任务 // TODO ","date":"2022-03-18","objectID":"/js_cb_asyn/:5:0","tags":["js"],"title":"JS运行机制","uri":"/js_cb_asyn/"},{"categories":["web"],"content":"参考 Javascript异步编程的4种方法 JavaScript 运行机制详解：再谈Event Loop async 函数的含义和用法 JS执行——Promise 你真的了解回调? 回调地狱 js中微任务和宏任务的区别 ","date":"2022-03-18","objectID":"/js_cb_asyn/:6:0","tags":["js"],"title":"JS运行机制","uri":"/js_cb_asyn/"},{"categories":["network"],"content":"http入门","date":"2022-03-17","objectID":"/http_glance/","tags":["http"],"title":"http入门笔记","uri":"/http_glance/"},{"categories":["network"],"content":"该笔记是在学习《透视 HTTP 协议》时整理，还参考了网上的其他资料。鄙人只是网络世界的搬运整理工😂。 ","date":"2022-03-17","objectID":"/http_glance/:0:0","tags":["http"],"title":"http入门笔记","uri":"/http_glance/"},{"categories":["network"],"content":"总览 http总览 \" ","date":"2022-03-17","objectID":"/http_glance/:1:0","tags":["http"],"title":"http入门笔记","uri":"/http_glance/"},{"categories":["network"],"content":"http 协议 http（超文本传输协议）是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。 http 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。 http 不是编程语言，但是可以用编程语言去实现 HTTP，告诉计算机如何用 HTTP 来与外界通信。 在互联网世界里，HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。 HTTP 传输的不是 TCP/UDP 这些底层协议里被切分的杂乱无章的二进制包（datagram），而是完整的、有意义的数据，可以被浏览器、服务器这样的上层应用程序处理。 ","date":"2022-03-17","objectID":"/http_glance/:2:0","tags":["http"],"title":"http入门笔记","uri":"/http_glance/"},{"categories":["network"],"content":"互联网和万维网的区别 我们通常所说的“上网”实际上访问的只是互联网的一个子集“万维网”（World Wide Web），它基于 HTTP 协议，传输 HTML 等超文本资源，能力被限制在 HTTP 协议之内。 互联网上还有许多万维网之外的资源，例如常用的电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等，它们需要用各自的专有协议来访问。 不过由于 HTTP 协议非常灵活、易于扩展，而且“超文本”的表述能力很强，所以很多其他原本不属于 HTTP 的资源也可以“包装”成 HTTP 来访问，这就是我们为什么能够总看到各种“网页应用”——例如“微信网页版”“邮箱网页版”——的原因。 ","date":"2022-03-17","objectID":"/http_glance/:2:1","tags":["http"],"title":"http入门笔记","uri":"/http_glance/"},{"categories":["network"],"content":"TCP/IP TCP/IP 协议实际上是一系列网络通信协议的统称， 其中最核心的两个协议是TCP（Transmission Control Protocol/传输控制协议）和IP（Internet Protocol），其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。 HTTP 是超文本传输协议，TCP 是传输控制协议，都是传输，区别是，HTTP 传输的是完整的、有意义的数据，可以被浏览器、 服务器这样的上层应用程序处理，HTTP 不关心寻址、路由、数据完整性等传输细节，而要求这些工作都由下层（基本都由 TCP）来处理。 TCP 传输的是可靠的、字节流和二进制包。 TCP 是 HTTP 得以实现的基础，HTTP 协议运行在 TCP/IP 上，HTTP 可以更准确地称为 “HTTP over TCP/IP”。 ","date":"2022-03-17","objectID":"/http_glance/:2:2","tags":["http"],"title":"http入门笔记","uri":"/http_glance/"},{"categories":["network"],"content":"URI/URL URI（Uniform Resource Identifier），中文名称是 统一资源标识符，使用它就能够唯一地标记互联网上资源。 URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，这两者几乎是相同的，差异不大，除非写论文，否则不用特意区分。 ","date":"2022-03-17","objectID":"/http_glance/:2:3","tags":["http"],"title":"http入门笔记","uri":"/http_glance/"},{"categories":["network"],"content":"SSL/TSL SSL 的全称是“Secure Socket Layer”，网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“Transport Layer Security”。 所以 TLS 跟 SSL 是一个东西，相当于张君宝的 2.0 版本是张三丰。 SSL 是一个负责加密通信的安全协议，建立在 TCP/IP 之上，在 HTTP 协议之下。 ","date":"2022-03-17","objectID":"/http_glance/:2:4","tags":["http"],"title":"http入门笔记","uri":"/http_glance/"},{"categories":["network"],"content":"Proxy 代理 匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器； 透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端； 正向代理：靠近客户端，代表客户端向服务器发送请求； 正向代理正向代理 \" 正向代理 反向代理：靠近服务器端，代表服务器响应客户端的请求； 反向代理反向代理 \" 反向代理 Tip 如何理解反向代理服务器 ","date":"2022-03-17","objectID":"/http_glance/:2:5","tags":["http"],"title":"http入门笔记","uri":"/http_glance/"},{"categories":["network"],"content":"http 版本 万维网关键技术 URI：即统一资源标识符，作为互联网上资源的唯一身份； HTML：即超文本标记语言，描述超文本文档； HTTP：即超文本传输协议，用来传输超文本。 基于这三项关键技术就可以把超文本系统完美地运行在互联网上，让各地的人们能够自由地共享信息，这个系统称为“万维网”（World Wide Web），也就是我们现在所熟知的 Web。 ","date":"2022-03-17","objectID":"/http_glance/:3:0","tags":["http"],"title":"http入门笔记","uri":"/http_glance/"},{"categories":["network"],"content":"http/0.9 结构简单，设置之初设想系统里的文档都是只读的，所以只允许用 GET 动作从服务器上获取 HTML 纯文本格式的文档，并且在响应请求之后立即关闭连接，功能非常有限。 ","date":"2022-03-17","objectID":"/http_glance/:3:1","tags":["http"],"title":"http入门笔记","uri":"/http_glance/"},{"categories":["network"],"content":"http/1.0 HTTP/1.0 并不是一个标准，只是记录已有实践和模式的一份参考文档，不具有实际的约束力，相当于一个备忘录。 在多方面增强了 0.9 版，形式上已经和我们现在的 HTTP 差别不大了，例如： 增加了 HEAD、POST 等新方法； 增加了响应状态码，标记可能的错误原因； 引入了协议版本号概念； 引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活； 传输的数据不再仅限于文本。 ","date":"2022-03-17","objectID":"/http_glance/:3:2","tags":["http"],"title":"http入门笔记","uri":"/http_glance/"},{"categories":["network"],"content":"http/1.1 是一个正式的标准，而不是一份可有可无的参考文档，只要用到 HTTP 协议，就必须严格遵守这个标准。 主要变更： 增加了 PUT、DELETE 等新的方法； 增加了缓存管理和控制； 明确了连接管理，允许持久连接； 允许响应数据分块（chunked），利于传输大文件； 强制要求 Host 头，让互联网主机托管成为可能。 ","date":"2022-03-17","objectID":"/http_glance/:3:3","tags":["http"],"title":"http入门笔记","uri":"/http_glance/"},{"categories":["network"],"content":"http/2 由 google 主导，基于 google 的 SPDY 协议为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2。 主要特点： 二进制协议，不再是纯文本； 可发起多个请求，废弃了 1.1 里的管道； 使用专用算法压缩头部，减少数据传输量； 允许服务器主动向客户端推送数据； 增强了安全性，“事实上”要求加密通信。 ","date":"2022-03-17","objectID":"/http_glance/:3:4","tags":["http"],"title":"http入门笔记","uri":"/http_glance/"},{"categories":["network"],"content":"http/3 由 google 主导，基于 google 的 QUIC 协议为基础开始制定新版本的 HTTP 协议。 ","date":"2022-03-17","objectID":"/http_glance/:3:5","tags":["http"],"title":"http入门笔记","uri":"/http_glance/"},{"categories":["network"],"content":"网络分层模型 ","date":"2022-03-17","objectID":"/http_glance/:4:0","tags":["http"],"title":"http入门笔记","uri":"/http_glance/"},{"categories":["network"],"content":"TCP/IP TCP/IP分层模型tcp/ip分层模型 \" TCP/IP分层模型 这里的层次顺序是“从下往上”数的，所以第一层就是最下面的一层。 链接层 第一层叫“链接层”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。 网络互联层 第二层叫“网际层”或者“网络互连层”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。 传输层 第三层叫“传输层”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。 TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。 应用层 协议栈的第四层叫“应用层”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP，HTTP 等等。 Tip MAC 层（链接层）的传输单位是帧（frame），IP 层（网络互联层）的传输单位是包（packet），TCP 层传输层的传输单位是段（segment）， HTTP （应用层）的传输单位则是消息或报文（message）。这些名词并没有什么本质的区分，可以统称为数据包。 ","date":"2022-03-17","objectID":"/http_glance/:4:1","tags":["http"],"title":"http入门笔记","uri":"/http_glance/"},{"categories":["network"],"content":"OSI 网络分层模型 OSI 分层模型在发布的时候就明确地表明是一个“参考”，不是强制标准。这是因为 TCP/IP 等协议已经在许多网络上实际运行，不可能推翻重来。 OSI网络模型OSI模型 \" OSI网络模型 第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等； 第二层：数据链路层，它基本相当于 TCP/IP 的链接层； 第三层：网络层，相当于 TCP/IP 里的网际层； 第四层：传输层，相当于 TCP/IP 里的传输层； 第五层：会话层，维护网络中的连接状态，即保持会话和同步； 第六层：表示层，把数据转换为合适、可理解的语法和语义； 第七层：应用层，面向具体的应用传输数据。 对比一下就可以发现，TCP/IP 是一个纯软件的栈，没有网络应有的最根基的电缆、网卡等物理设备的位置。而 OSI 则补足了这个缺失， 在理论层面上描述网络更加完整。 OSI 还为每一层标记了明确了编号，最底层是一层，最上层是七层，而 TCP/IP 的层次从来只有名字而没有编号。 ","date":"2022-03-17","objectID":"/http_glance/:4:2","tags":["http"],"title":"http入门笔记","uri":"/http_glance/"},{"categories":["network"],"content":"两个分层模型的对应关系 两个分层模型的对应关系对应关系 \" 两个分层模型的对应关系 所谓的“四层负载均衡”就是指工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡。 所谓的“七层负载均衡”就是指工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器。 有一个辨别四层和七层比较好的（但不是绝对的）小窍门，“两个凡是”：凡是由操作系统负责处理的就是四层或四层以下，否则，凡是需要由应用程序（也就是你自己写代码）负责处理的就是七层。 ","date":"2022-03-17","objectID":"/http_glance/:4:3","tags":["http"],"title":"http入门笔记","uri":"/http_glance/"},{"categories":["web"],"content":"刚在打包项目时执行 yarn run build 时出现了 oom 的情况，具体报错信息如下： JavaScript heap out of memory \" 我的环境是 win10 专业版 WSL。 解决办法，设置 export NODE_OPTIONS=--max_old_space_size=4096，设置完之后重新执行 yarn run build 即可。 ","date":"2022-03-16","objectID":"/node_oom/:0:0","tags":["web","node"],"title":"JavaScript heap out of memory","uri":"/node_oom/"},{"categories":["web"],"content":"参考 Node.js heap out of memory ","date":"2022-03-16","objectID":"/node_oom/:1:0","tags":["web","node"],"title":"JavaScript heap out of memory","uri":"/node_oom/"},{"categories":["golang"],"content":"进程、线程、协程的区别 ","date":"2022-03-16","objectID":"/gmp_model/:1:0","tags":["golang"],"title":"go GMP 模型","uri":"/gmp_model/"},{"categories":["golang"],"content":"协程的上下文切换比线程的上下文切换代价小 ","date":"2022-03-16","objectID":"/gmp_model/:2:0","tags":["golang"],"title":"go GMP 模型","uri":"/gmp_model/"},{"categories":["golang"],"content":"go 调度器机制 ","date":"2022-03-16","objectID":"/gmp_model/:3:0","tags":["golang"],"title":"go GMP 模型","uri":"/gmp_model/"},{"categories":["golang"],"content":"知识点 Go程序中没有语言级的关键字让你去创建一个内核线程，你只能创建 goroutine，内核线程只能由 runtime 根据实际情况去创建。 Go运行时系统并没有内核调度器的中断能力，内核调度器会发起抢占式调度将长期运行的线程中断并让出CPU资源，让其他线程获得执行机会。 ","date":"2022-03-16","objectID":"/gmp_model/:3:1","tags":["golang"],"title":"go GMP 模型","uri":"/gmp_model/"},{"categories":["golang"],"content":"参考 Go 为什么这么“快” 让你很快就能理解-go的协程调度原理 Golang goroutine与调度器 Go语言的并发模型 ","date":"2022-03-16","objectID":"/gmp_model/:4:0","tags":["golang"],"title":"go GMP 模型","uri":"/gmp_model/"},{"categories":["golang"],"content":"go build 常用命令","date":"2022-03-16","objectID":"/go_build_args/","tags":["golang"],"title":"go build 常用命令","uri":"/go_build_args/"},{"categories":["golang"],"content":"常用编译参数 参数 说明 -o 指定输出可执行文件名 -v 编译时显示包名，可以理解成输出详细编译信息 -race 开启竞态检测 *.go 编译当前目录下的所有go文件，也可以写成 f2.go f2.go … -a 强制重新构建 -w 去掉DWARF调试信息，得到的程序就不能用gdb调试了 -s 去掉符号表,panic时候的stack trace就没有任何文件名/行号信息了，这个等价于普通C/C++程序被strip的效果 -X 设置包中的变量值 -gcflags \"-N -l\" 编译目标程序的时候会嵌入运行时(runtime)的二进制，禁止优化和内联可以让运行时(runtime)中的函数变得更容易调试。gcflags 其实是给go编译器传入参数，也就是传给go tool compile的参数，因此可以用go tool compile --help查看所有可用的参数 -ldflags 给go链接器传入参数，实际是给go tool link的参数，可以用go tool link --help查看可用的参数。 -ldflags '-extldflags \"-static\"' 静态编译 ","date":"2022-03-16","objectID":"/go_build_args/:1:0","tags":["golang"],"title":"go build 常用命令","uri":"/go_build_args/"},{"categories":["golang"],"content":"交叉编译 参数 说明 GOOS GOARCH linux 386 / amd64 / arm darwin 386 / amd64 feedbsd 386 / amd64 windows 386 / amd64 对于编译给ARM使用的Go程序，需要根据实际情况配置$GOARM，这是用来控制CPU的浮点协处理器的参数。 $GOARM默认是6，对于不支持VFP使用软件运算的老版本ARM平台要设置成5，支持VFPv1的设置成6，支持VFPv3的设置成7。 示例 GOARM=7 GOARCH=arm GOOS=linux go build -v -o fca ","date":"2022-03-16","objectID":"/go_build_args/:2:0","tags":["golang"],"title":"go build 常用命令","uri":"/go_build_args/"},{"categories":["golang"],"content":"参考 golang编译时的参数传递（gcflags, ldflags） Golang交叉编译（跨平台编译）简述 交叉编译Go程序 ARM flags GOARM ","date":"2022-03-16","objectID":"/go_build_args/:3:0","tags":["golang"],"title":"go build 常用命令","uri":"/go_build_args/"},{"categories":["developer"],"content":"将google浏览器插件下载到本地","date":"2022-03-16","objectID":"/googe-plugin-download/","tags":["开发者工具"],"title":"将google浏览器插件下载到本地","uri":"/googe-plugin-download/"},{"categories":["developer"],"content":"国内的网络太复杂了，在不能访问 google 的情况下，甚至都不能打开网上应用商店，所以我们需要一个方便的方式来下载google浏览器插件并分享 给需要的小伙伴。 我们打开任意一个浏览器插件，如： 浏览器插件 \" URL 地址栏中有一串字符串，这是唯一的，通过这个字符串可以获取到插件的下载地址，如： 插件UUID \" 下载地址为： https://clients2.google.com/service/update2/crx?response=redirect\u0026os=win\u0026arch=x64\u0026os_arch=x86_64\u0026nacl_arch=x86-64\u0026prod=chromecrx\u0026prodchannel=\u0026prodversion=77.0.3865.90\u0026lang=zh-CN\u0026acceptformat=crx2,crx3\u0026x=id%3D{XXXX}%26installsource%3Dondemand%26uc 将以上的 {XXXX} 替换为插件的 ID，就可以下载到本地了。 以下这个地址是Mote：语音笔记和反馈插件的下载地址，成功下载的插件是 .crx 结尾的文件。直接拖到浏览器中就会自动安装。 https://clients2.google.com/service/update2/crx?response=redirect\u0026os=win\u0026arch=x64\u0026os_arch=x86_64\u0026nacl_arch=x86-64\u0026prod=chromecrx\u0026prodchannel=\u0026prodversion=77.0.3865.90\u0026lang=zh-CN\u0026acceptformat=crx2,crx3\u0026x=id%3Dajphlblkfpppdpkgokiejbjfohfohhmk%26installsource%3Dondemand%26uc ","date":"2022-03-16","objectID":"/googe-plugin-download/:0:0","tags":["开发者工具"],"title":"将google浏览器插件下载到本地","uri":"/googe-plugin-download/"},{"categories":null,"content":"缘起 大学毕业后，为了混口饭吃，便利用自己了解的一点编程知识开始码农之路。大学学的是通信工程，非计算机专业，编程之路困难重重。但好歹自己有自知之明，笨人多努力，相信通过自己的努力，可以让自己的编程技术更加完善。 好记性不如烂笔头，想着把自己工作期间遇到的问题，记录下来，也是记录自己的不足和成长，便有个这个网站。 ","date":"2022-03-06","objectID":"/about/:1:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"职业生涯 2017/4 - 2019/3 在西安一家科技公司从事 PHP 开发。 2019/4 - 2021/3 在北京腾讯外包从事 PHP 和 Go 开发。 2021/4 - 至今 ","date":"2022-03-06","objectID":"/about/:2:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"联系方式 ","date":"2022-03-06","objectID":"/about/:3:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"邮箱：xiaobinqt@163.com ","date":"2022-03-06","objectID":"/about/:3:1","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"Github：@xiaobinqt ","date":"2022-03-06","objectID":"/about/:3:2","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"微信： 个人微信wechat \" 个人微信 ","date":"2022-03-06","objectID":"/about/:3:3","tags":null,"title":"About Me","uri":"/about/"},{"categories":["golang"],"content":"RPC 是一种跨语言的协议，它可以让我们在不同的语言之间进行通信。 远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个 地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。 RPC是一种服务器-客户端（Client/Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。 ","date":"2022-03-05","objectID":"/grpc_demo/:0:0","tags":["golang"],"title":"grpc 入门应用","uri":"/grpc_demo/"},{"categories":["golang"],"content":"安装 go install github.com/golang/protobuf/protoc-gen-go@v1.4.0 go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1 不推荐使用 google.golang.org/protobuf/cmd/protoc-gen-go@v1.26 这个版本太高了，可能会遇到以下这个问题， --go_out: protoc-gen-go: plugins are not supported; use 'protoc --go-grpc_out=...' to generate gRPC See https://grpc.io/docs/languages/go/quickstart/#regenerate-grpc-code for more information. 生成代码遇到的问题 \" 参考解决方案记一次奇妙的go-protobuf包升级之旅 protoc 工具安装 下载地址，下载解压将 bin 目录添加到环境变量中。 protoc \" ","date":"2022-03-05","objectID":"/grpc_demo/:1:0","tags":["golang"],"title":"grpc 入门应用","uri":"/grpc_demo/"},{"categories":["golang"],"content":"定义 proto 文件 syntax = \"proto3\"; // 使用protobuf版本3 option go_package = \"./protobuf\"; // 这个影响生成的目录及go的package命名 // 定义一个计算服务, 输入为CalcRequest, 输出为CalcResponse service CalculatorService { rpc calc(CalcRequest) returns (CalcResponse) {};}// 计算两个数某种运算(如加法)的参数 message CalcRequest { double a = 1; double b = 2; string op = 3;}// 计算结果 message CalcResponse { double r = 1;} ","date":"2022-03-05","objectID":"/grpc_demo/:2:0","tags":["golang"],"title":"grpc 入门应用","uri":"/grpc_demo/"},{"categories":["golang"],"content":"生成 .pb.go 文件 protoc --go_out=plugins=grpc:. calculator.proto 整体目录结构 \" ","date":"2022-03-05","objectID":"/grpc_demo/:3:0","tags":["golang"],"title":"grpc 入门应用","uri":"/grpc_demo/"},{"categories":["golang"],"content":"rpc server package main import ( \"context\" \"fmt\" \"net\" \"go.src/grpc/calculator/protobuf\" \"google.golang.org/grpc\" ) // 实现: CalculatorServiceServer接口, 在calculator.pb.go中定义 type server struct{} func (s server) Calc(ctx context.Context, req *protobuf.CalcRequest) (resp *protobuf.CalcResponse, err error) { a := req.GetA() b := req.GetB() op := req.GetOp() resp = \u0026protobuf.CalcResponse{} switch op { case \"+\": resp.R = a + b case \"-\": resp.R = a - b case \"*\": resp.R = a * b case \"/\": if b == 0 { err = fmt.Errorf(\"divided by zero\") return } resp.R = a / b } return } // 启动rpc server func main() { listener, err := net.Listen(\"tcp\", \"localhost:3233\") if err != nil { panic(err) } s := grpc.NewServer() protobuf.RegisterCalculatorServiceServer(s, \u0026server{}) fmt.Println(\"server start\") err = s.Serve(listener) if err != nil { panic(err) } } ","date":"2022-03-05","objectID":"/grpc_demo/:4:0","tags":["golang"],"title":"grpc 入门应用","uri":"/grpc_demo/"},{"categories":["golang"],"content":"rpc client package main import ( \"context\" \"fmt\" \"log\" \"go.src/grpc/calculator/protobuf\" \"google.golang.org/grpc\" \"google.golang.org/grpc/credentials/insecure\" ) func main() { // 连上grpc server //conn, err := grpc.Dial(\"localhost:3233\", grpc.WithInsecure()) conn, err := grpc.Dial(\"localhost:3233\", grpc.WithTransportCredentials(insecure.NewCredentials())) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() c := protobuf.NewCalculatorServiceClient(conn) // 调用远程方法 resp, err := c.Calc(context.Background(), \u0026protobuf.CalcRequest{ A: 1, B: 2, Op: \"+\", }) if err != nil { fmt.Println(\"calc err: \", err.Error()) return } fmt.Println(\"calc success,respR: \", resp.GetR()) // 3 } ","date":"2022-03-05","objectID":"/grpc_demo/:5:0","tags":["golang"],"title":"grpc 入门应用","uri":"/grpc_demo/"},{"categories":["golang"],"content":"运行测试 serverserver \" server clientclient \" client ","date":"2022-03-05","objectID":"/grpc_demo/:6:0","tags":["golang"],"title":"grpc 入门应用","uri":"/grpc_demo/"},{"categories":["golang"],"content":"示例下载 示例源码地址 ","date":"2022-03-05","objectID":"/grpc_demo/:7:0","tags":["golang"],"title":"grpc 入门应用","uri":"/grpc_demo/"},{"categories":["web"],"content":"最近有个需求在使用 $.ajax 时需要把 cookie 信息也带着，google 下发现可以这么写： $.ajax({ url: \"/nodered/nodes\", headers: { Accept: \"text/html\", }, xhrFields: { withCredentials: true // 携带 cookie 信息 }, success: function (data) { console.log(data) $(\"#red-ui-palette-container\").html(data) }, error: function (jqXHR) { console.log(jqXHR) } }); ","date":"2022-03-01","objectID":"/ajax_req_add_cookie/:0:0","tags":["web"],"title":"ajax 在请求时携带 cookie 信息","uri":"/ajax_req_add_cookie/"},{"categories":["c语言"],"content":" #include \u003cstdio.h\u003e int main(void) { char a[6] = {'F', 'i', 's', 'h', 'C', '\\0'}; // 需要主动加上 \\0 char a1[] = {'F', 'i', 's', 'h', 'C', '\\0'}; // 需要主动加上 \\0 char a2[] = {\"FishC\"}; char a3[] = \"FishC\"; printf(\"a: %s \\n\", a); printf(\"a1: %s \\n\", a1); printf(\"a2: %s \\n\", a2); printf(\"a3: %s \\n\", a3); return 0; } 运行结果： c语言定义字符串 \" ","date":"2022-02-17","objectID":"/c_define_string/:0:0","tags":["c语言"],"title":"C语言定义字符串的方法","uri":"/c_define_string/"},{"categories":["golang"],"content":"在 php 中可以直接在 break 和 continue 后加 num ，比如 break 2或 continue 2。 break num 是结束外层第 num 层整个循环体，continue num 是结束外层第 num 层单次循环。 类比 php ，go 中不能直接在关键字后加 num ，但是可以用 label 关键字代替 num。 ","date":"2022-02-16","objectID":"/break_continue_goto_label/:0:0","tags":["golang"],"title":"golang break，continue，goto label 的区别","uri":"/break_continue_goto_label/"},{"categories":["golang"],"content":"continue label package main import ( \"fmt\" \"math\" ) func main() { // 找出 int 切片的最小值 var matrix = []int{10, 2, 4, 0} var min = math.MinInt64 next: for _, v := range matrix { for _, v1 := range matrix { if v \u003e v1 { continue next // 终止当前循环，跳到 label 继续下一次循环 } } min = v } fmt.Println(\"最小值为: \", min) } ","date":"2022-02-16","objectID":"/break_continue_goto_label/:1:0","tags":["golang"],"title":"golang break，continue，goto label 的区别","uri":"/break_continue_goto_label/"},{"categories":["golang"],"content":"break label package main import ( \"fmt\" \"math\" ) func main() { // 获取 index 2 的值，这里使用 2 层循环主要是为了说明问题 var matrix = []int{10, 2, 4, 0} var index2Val = math.MinInt64 next: for _, v := range matrix { fmt.Println(v) for index, v1 := range matrix { index2Val = v1 if index == 2 { break next // 跳出循环到 label 处 } } } fmt.Println(\"index 3 值为: \", index2Val) } ","date":"2022-02-16","objectID":"/break_continue_goto_label/:2:0","tags":["golang"],"title":"golang break，continue，goto label 的区别","uri":"/break_continue_goto_label/"},{"categories":["golang"],"content":"goto label 非必要不使用，可以跳到任何地方。 package main import ( \"fmt\" \"math\" ) func main() { var matrix = []int{10, 2, 4, 0} var index2Val = math.MinInt64 for _, v := range matrix { fmt.Println(v) for index, v1 := range matrix { index2Val = v1 if index == 2 { goto next } } } fmt.Println(\"index 3 值为: \", index2Val) next: fmt.Println(\"goto this....\") } ","date":"2022-02-16","objectID":"/break_continue_goto_label/:3:0","tags":["golang"],"title":"golang break，continue，goto label 的区别","uri":"/break_continue_goto_label/"},{"categories":["golang"],"content":"今天在编译 go 项目时出现了如下错误： /usr/local/go/pkg/tool/linux_amd64/link: running gcc failed: exit status 1 /usr/bin/ld: cannot find -lpthread /usr/bin/ld: cannot find -lc collect2: error: ld returned 1 exit status 解决办法： yum install glibc-static.x86_64 -y ","date":"2022-02-10","objectID":"/build_running_gcc_failed/:0:0","tags":["golang","build"],"title":"running gcc failed: exit status 1","uri":"/build_running_gcc_failed/"},{"categories":["algorithms"],"content":"存在的意义 一致性哈希算法解决了普通余数 Hash 算法伸缩性差的问题，可以保证在上线、下线服务器的情况下尽量有多的请求命中原来路由到的服务器。 ","date":"2022-01-15","objectID":"/consistent_hash/:1:0","tags":["算法"],"title":"一致性 hash","uri":"/consistent_hash/"},{"categories":["algorithms"],"content":"优化 一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。可以通过通过增加虚拟节点来解决数据倾斜问题。 如果存在大量的虚拟节点，节点的查找性能就成为必须考虑的因数。可以使用红黑树 来加快查找速度， ","date":"2022-01-15","objectID":"/consistent_hash/:2:0","tags":["算法"],"title":"一致性 hash","uri":"/consistent_hash/"},{"categories":["algorithms"],"content":"参考 一致性Hash(Consistent Hashing)原理剖析及Java实现 图解一致性哈希算法 golang实现一致性hash环及优化方法 一致性哈希 ","date":"2022-01-15","objectID":"/consistent_hash/:3:0","tags":["算法"],"title":"一致性 hash","uri":"/consistent_hash/"},{"categories":["收藏"],"content":"在线书籍 build-web-application-with-golang Mastering_Go golang 修养之路 Go语言101 PHP扩展开发及内核应用 JavaScript 标准参考教程 ES6 入门教程 JavaScript 教程 网道 ","date":"2021-10-17","objectID":"/memo/:1:0","tags":["备忘录"],"title":"书籍/工具收藏","uri":"/memo/"},{"categories":["收藏"],"content":"工具收藏 navicat premium15破解教程 ","date":"2021-10-17","objectID":"/memo/:2:0","tags":["备忘录"],"title":"书籍/工具收藏","uri":"/memo/"},{"categories":["收藏"],"content":"文章收藏 go1.16 embed 用法 ","date":"2021-10-17","objectID":"/memo/:3:0","tags":["备忘录"],"title":"书籍/工具收藏","uri":"/memo/"},{"categories":["golang"],"content":"总结 make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配。 new返回指针，指向新分配的类型 T 的零值。 make返回初始化后的（非零）值。 ","date":"2021-06-21","objectID":"/new_make_difference/:1:0","tags":["golang"],"title":"golang make 和 new 的区别","uri":"/new_make_difference/"},{"categories":["golang"],"content":"参考 make、new操作 Go make 和 new的区别 ","date":"2021-06-21","objectID":"/new_make_difference/:2:0","tags":["golang"],"title":"golang make 和 new 的区别","uri":"/new_make_difference/"},{"categories":["git"],"content":"入职新公司，就在 git 的使用上被各种虐。整理一篇文档，对这个问题梳理总结下。 之前用 git 都是直接新建分支，然后 PR review 后合到主分支，现在是先 fork 下，之前没用过 fork 😢 ，其实就是多了一步，从自己仓库的分支提 PR 。 ","date":"2021-04-29","objectID":"/pull_request/:0:0","tags":["git"],"title":"github PR 简单使用","uri":"/pull_request/"},{"categories":["git"],"content":"clone 代码 forkfork \" fork fork 代码后 clone 到本地。 git clone git@github.com:xxxxx/dev-git.git cloneclone \" clone 我们可以用 git remote -v 看下远程仓库情况： git remote -vgit remote -v \" git remote -v ","date":"2021-04-29","objectID":"/pull_request/:1:0","tags":["git"],"title":"github PR 简单使用","uri":"/pull_request/"},{"categories":["git"],"content":"添加远程仓库 用 git remote add 添加远程仓库，这里的远程就是我 fork 的那个仓库。 git remote add upstream git@github.xxxxx/dev-git.git 这里的 upstream 是远程仓库的别名，类似 origin 。 git remoteadd upstream \" git remote 现在我们可以看到已经有 2 个远程仓库地址了，origin 是我自己的远程仓库，upstream 是别人的，也就是真实项目的远程仓库。 ","date":"2021-04-29","objectID":"/pull_request/:2:0","tags":["git"],"title":"github PR 简单使用","uri":"/pull_request/"},{"categories":["git"],"content":"PR 我们现在可以 upstream 远程仓库中提交一个 PR。先 fetch 一下 upstream 远程仓库的代码。确保我们的代码是最新的。 fetch \" 接下来就可以在 ide 上操作了。 ide operate \" 我们可以看到远程分支了 upstream/main 和 origin/main ，upstream 是真正的项目地址，origin 是 fork 到我们仓库的分支。 checkout 下 upstream/main ： ide operate \" \" 再拉下最新的代码 ide operate \" 再切回到我们的 origin/main 分支 从我们的分支 checkout 一个新的开发分支 dev origin main \" dev branch \" rebase 下远程分支的代码 \" 我们简单修改一行，提下代码 add \" push push1 \" push2 \" push 完成后我们的仓库会出现提示 \" 现在我们就可以提一个 PR 了。 \" 成功提了一个 PR \" ","date":"2021-04-29","objectID":"/pull_request/:3:0","tags":["git"],"title":"github PR 简单使用","uri":"/pull_request/"},{"categories":["git"],"content":"更新代码 \" PR 合并之后我们需要更新下代码： checkout 到 upstream-main 分支，拉下代码 \" 再切到 origin/dev 分支 rebase 下 upstream-main \" \" 以上，一个闭环结束。 ","date":"2021-04-29","objectID":"/pull_request/:4:0","tags":["git"],"title":"github PR 简单使用","uri":"/pull_request/"},{"categories":["golang"],"content":"server package main import ( \"fmt\" \"net\" \"time\" ) func main() { // 创建监听 socket, err := net.ListenUDP(\"udp4\", \u0026net.UDPAddr{ IP: []byte{127, 0, 0, 1}, Port: 8080, }) if err != nil { fmt.Println(\"监听失败!\", err) return } defer socket.Close() for { // 读取数据 data := make([]byte, 4096) read, remoteAddr, err := socket.ReadFromUDP(data) if err != nil { fmt.Println(\"读取数据失败!\", err) continue } fmt.Println(read, remoteAddr) fmt.Printf(\"接收到客户端数据，%s\\n\\n\", data) // 发送数据 senddata := []byte(\"server send data，hello client!\" + time.Now().Format(\"2006-01-02 15:04:05\")) _, err = socket.WriteToUDP(senddata, remoteAddr) if err != nil { fmt.Println(\"发送数据失败!\", err.Error()) return } } } ","date":"2021-04-01","objectID":"/upd_demo/:1:0","tags":["golang"],"title":"golang udp 示例","uri":"/upd_demo/"},{"categories":["golang"],"content":"client package main import ( \"fmt\" \"net\" \"time\" ) func main() { // 创建连接 socket, err := net.DialUDP(\"udp4\", nil, \u0026net.UDPAddr{ IP: []byte{127, 0, 0, 1}, Port: 8080, }) if err != nil { fmt.Println(\"连接失败!\", err) return } defer socket.Close() // 发送数据 senddata := []byte(\"client send message，hello server!\" + time.Now().Format(\"2006-01-02 15:04:05\")) _, err = socket.Write(senddata) if err != nil { fmt.Println(\"发送数据失败!\", err) return } // 接收数据 data := make([]byte, 4096) read, remoteAddr, err := socket.ReadFromUDP(data) if err != nil { fmt.Println(\"读取数据失败!\", err) return } fmt.Println(read, remoteAddr) fmt.Printf(\"接收到服务器端数据，%s\\n\", data) } ","date":"2021-04-01","objectID":"/upd_demo/:2:0","tags":["golang"],"title":"golang udp 示例","uri":"/upd_demo/"},{"categories":["golang"],"content":"代码地址 源码地址 ","date":"2021-04-01","objectID":"/upd_demo/:3:0","tags":["golang"],"title":"golang udp 示例","uri":"/upd_demo/"},{"categories":["algorithms"],"content":"常见缓存淘汰策略，淘汰策略的实现，FIFO，LRU，LFU","date":"2020-03-05","objectID":"/common_cache_-strategies/","tags":["algorithms","算法"],"title":"常见缓存淘汰策略","uri":"/common_cache_-strategies/"},{"categories":["algorithms"],"content":"常见缓存淘汰策略 ","date":"2020-03-05","objectID":"/common_cache_-strategies/:0:0","tags":["algorithms","算法"],"title":"常见缓存淘汰策略","uri":"/common_cache_-strategies/"},{"categories":["algorithms"],"content":"FIFO First In First Out(FIFO)，先进先出，也就是淘汰缓存中最老(最早添加)的记录。FIFO 认为，最早添加的记录，其不再被使用的可能性比刚添加的可能性大。这种算法的实现也非常简单，创建一个队列，新增记录添加到队尾， 每次内存不够时，淘汰队首。但是很多场景下，部分记录虽然是最早添加但也最常被访问，而不得不因为呆的时间太长而被淘汰。这类数据会被频繁地添加进缓存，又被淘汰出去，导致缓存命中率降低。 ","date":"2020-03-05","objectID":"/common_cache_-strategies/:1:0","tags":["algorithms","算法"],"title":"常见缓存淘汰策略","uri":"/common_cache_-strategies/"},{"categories":["algorithms"],"content":"LFU Least Frequently Used(LFU)，最少使用，也就是淘汰缓存中访问频率最低的记录。LFU 认为，如果数据过去被访问多次， 那么将来被访问的频率也更高。LFU 的实现需要维护一个按照访问次数排序的队列，每次访问，访问次数加1，队列重新排序， 淘汰时选择访问次数最少的即可。LFU 算法的命中率是比较高的，但缺点也非常明显，维护每个记录的访问次数，对内存的消耗是很高的； 另外，如果数据的访问模式发生变化，LFU 需要较长的时间去适应，也就是说 LFU 算法受历史数据的影响比较大。例如某个数据历史上访问次数奇高，但在某个时间点之后几乎不再被访问，但因为历史访问次数过高，而迟迟不能被淘汰。 ","date":"2020-03-05","objectID":"/common_cache_-strategies/:2:0","tags":["algorithms","算法"],"title":"常见缓存淘汰策略","uri":"/common_cache_-strategies/"},{"categories":["algorithms"],"content":"LRU Least Recently Used(LRU)，最近最少使用，相对于仅考虑时间因素的 FIFO 和仅考虑访问频率的 LFU，LRU 算法可以认为是相对平衡的 一种淘汰算法。LRU 认为，如果数据最近被访问过，那么将来被访问的概率也会更高。LRU 算法的实现非常简单，维护一个队列，如果某条记录被访问了， 则移动到队尾，那么队首则是最近最少访问的数据，淘汰该条记录即可。 ","date":"2020-03-05","objectID":"/common_cache_-strategies/:3:0","tags":["algorithms","算法"],"title":"常见缓存淘汰策略","uri":"/common_cache_-strategies/"},{"categories":["developer"],"content":"申请 证书申请地址 在这里插入图片描述 \" 申请完成页面 在这里插入图片描述 \" 将主机记录解析 在这里插入图片描述 \" 在这里插入图片描述 \" 在这里插入图片描述 \" 将主机记录和记录值填写 在这里插入图片描述 \" 解析成功后下载证书 在这里插入图片描述 \" 我用的是 Apache ,所以下载的是 Apache 在这里插入图片描述 \" ","date":"2019-06-07","objectID":"/ali_ssl/:1:0","tags":["系统"],"title":"阿里云 SSL 免费证书使用","uri":"/ali_ssl/"},{"categories":["developer"],"content":"上传证书 由于本人使用的是 apache ,以下配置是 apache 的通用配置,具体可参看官方 文档 在 apache 的路径下新建一个 cert 目录,其实该目录建在哪里都可以,但是放在 apache 下方便管理。 \" 在 cert 目录下可以建不同的文件夹放在不同域名或子域名的 ssl 文件。 \" 把我们刚才下载的证书上传到服务器上 \" ","date":"2019-06-07","objectID":"/ali_ssl/:2:0","tags":["系统"],"title":"阿里云 SSL 免费证书使用","uri":"/ali_ssl/"},{"categories":["developer"],"content":"配置 这是基本的配置语句 # 添加 SSL 协议支持协议，去掉不安全的协议 SSLProtocol all -SSLv2 -SSLv3 # 修改加密套件如下 SSLCipherSuite HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUM SSLHonorCipherOrder on # 证书公钥配置 SSLCertificateFile cert/a_public.crt # 证书私钥配置 SSLCertificateKeyFile cert/a.key # 证书链配置，如果该属性开头有 '#'字符，请删除掉 SSLCertificateChainFile cert/a_chain.crt 我们将默认的配置 copy 一份出来,取一个跟域名有关的文件名 cp /etc/apache2/sites-available/000-default.conf /etc/apache2/sites-available/www.xiaobinqt.cn.conf 具体配置可参考 \u003cVirtualHost *:80\u003e ServerName www.xiaobinqt.cn Redirect permanent / https://www.xiaobinqt.cn/ \u003c/VirtualHost\u003e \u003cVirtualHost *:443\u003e SSLEngine On # 添加 SSL 协议支持协议，去掉不安全的协议 SSLProtocol all -SSLv2 -SSLv3 # 修改加密套件如下 SSLCipherSuite HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUM SSLHonorCipherOrder on # 证书公钥配置 SSLCertificateFile cert/xiaobinqt.cn/2324042_www.xiaobinqt.cn_public.crt # 证书私钥配置 SSLCertificateKeyFile cert/xiaobinqt.cn/2324042_www.xiaobinqt.cn.key # 证书链配置，如果该属性开头有 '#'字符，请删除掉 SSLCertificateChainFile cert/xiaobinqt.cn/2324042_www.xiaobinqt.cn_chain.crt # etc ServerName www.xiaobinqt.cn ProxyPreserveHost On ProxyRequests Off ProxyPass / http://localhost:30007/ ProxyPassReverse / http://localhost:30007/ \u003c/VirtualHost\u003e 我用的是 docker 服务,如果你的只是项目文件夹可以参考这样配置 \u003cVirtualHost *:80\u003e # The ServerName directive sets the request scheme, hostname and port that # the server uses to identify itself. This is used when creating # redirection URLs. In the context of virtual hosts, the ServerName # specifies what hostname must appear in the request's Host: header to # match this virtual host. For the default virtual host (this file) this # value is not decisive as it is used as a last resort host regardless. # However, you must set it for any further virtual host explicitly. #ServerName www.example.com #ServerAdmin webmaster@localhost ServerName www.xiaobinqt.cn DocumentRoot /var/www/html Redirect permanent / https://www.xiaobinqt.cn/ # Available loglevels: trace8, ..., trace1, debug, info, notice, warn, # error, crit, alert, emerg. # It is also possible to configure the loglevel for particular # modules, e.g. #LogLevel info ssl:warn ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined # For most configuration files from conf-available/, which are # enabled or disabled at a global level, it is possible to # include a line for only one particular virtual host. For example the # following line enables the CGI configuration for this host only # after it has been globally disabled with \"a2disconf\". #Include conf-available/serve-cgi-bin.conf \u003c/VirtualHost\u003e \u003cVirtualHost *:443\u003e SSLEngine On # 添加 SSL 协议支持协议，去掉不安全的协议 SSLProtocol all -SSLv2 -SSLv3 # 修改加密套件如下 SSLCipherSuite HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUM SSLHonorCipherOrder on # 证书公钥配置 SSLCertificateFile cert/xiaobinqt.cn/public.pem # 证书私钥配置 SSLCertificateKeyFile cert/xiaobinqt.cn/214792197160511.key # 证书链配置，如果该属性开头有 '#'字符，请删除掉 SSLCertificateChainFile cert/xiaobinqt.cn/chain.pem # etc ServerName www.xiaobinqt.cn \u003c/VirtualHost\u003e 以上配置全部基于 apache ,如果你用的不是 apache ,以上配置可能不适合你. 关于 apache 服务的一些其他知识可以参考这篇文章,该文章可能需要翻~墙访问. 配置完成后重启服务,可以利用 curl 命令查看是否配置成功. curl -I localhost:xxx \" 对于 ssl 是否配置成功可以通过浏览器查看. \" 可以看到这是我们最新申请的一年的 ssl 证书. \" ","date":"2019-06-07","objectID":"/ali_ssl/:3:0","tags":["系统"],"title":"阿里云 SSL 免费证书使用","uri":"/ali_ssl/"},{"categories":["developer"],"content":"下载系统 首先我们需要一个最小 4G 大的 U 盘 image \" 进入大白菜网站下载大白菜装机版安装到电脑 image \" image \" 将 U 盘插到电脑上,双击打开大白菜装机版,它会自动读到我们插入的 U 盘，自动匹配默认模式,不需要手动选择。 image \" 点击开始制作 –\u003e 确认 image \" 等待写入数据包完成和格式化完成后关掉大白菜软件 image \" image \" image \" 制作完 U 盘启动盘后我们的 U 盘会变成这样说明启动盘已经制作成功 ! image去itellyou下载需要安装的操作系统 ! image \" 比如我们要安装这个版本的 win10 image \" 通过百度网盘下载 ed2k 文件资源,然后再通过百度网盘下载到电脑本地,可以放在除 C 盘外的其他盘中 image \" 下载到本地的文件是这样的光盘映像文件 ! image \" 将我们下载到电脑本地的光盘映像文件复制到刚制作完成的 U 盘启动盘中,复制完成后我们 U 盘启动盘就全部制作完成了 image \" ","date":"2018-10-07","objectID":"/redo_system/:1:0","tags":["系统","windows"],"title":"windows 重做系统","uri":"/redo_system/"},{"categories":["developer"],"content":"重做系统 将我们制作好的 U 盘启动盘插到需要重做系统的电脑上,重启电脑一直按 F12 进入 bios 界面(不同的电脑可能按键不同,可以百度) image \" 选择 usb 方式,回车进入大白菜启动方式,选择 02 方式进入 image \" 进入 u 盘驱动界面,系统默认会选择 C 盘为系统盘,直接点击确定 image \" 确定后进入格式化 C 盘阶段,所有配置为默认配置,直接确定,等待格式化完成! image \" 格式化完成后选择 是 重启电脑,拔出 u 盘 等待电脑重启 ","date":"2018-10-07","objectID":"/redo_system/:2:0","tags":["系统","windows"],"title":"windows 重做系统","uri":"/redo_system/"},{"categories":["developer"],"content":"安装系统完成 image \" image \" ","date":"2018-10-07","objectID":"/redo_system/:3:0","tags":["系统","windows"],"title":"windows 重做系统","uri":"/redo_system/"}]