---
title: "MySQL 可重复读存在的问题"
subtitle: ""

init_date: "2024-06-21T16:21:16+08:00"

date: 2024-06-21

lastmod: 2024-06-21

draft: true

author: "xiaobinqt"
description: "xiaobinqt,"

featuredImage: ""

featuredImagePreview: ""

reproduce: false

translate: false

tags: [ "mysql" ]
categories: [ "mysql" ]
lightgallery: true

series: [ ]

series_weight:

toc: true

math: true
---

<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->

## 临键锁引发死锁

在 MySQL 中，可重复读（Repeatable Read, RR）是四种事务隔离级别之一。它确保在一个事务中，所有读取的数据在该事务的整个生命周期内是可重复的，即同一个事务多次读取同一数据行时，结果是相同的，即使其他事务在期间对数据进行了修改。这种隔离级别虽然能够防止脏读和不可重复读问题，但在 InnoDB 存储引擎中，它通过一种复杂的锁机制来实现，从而引发了所谓的“临键锁”（Next-Key Lock）问题。下面我们来详细探讨为什么可重复读会导致临键锁问题。

### 什么是“临键锁”（Next-Key Lock）？

“临键锁”是 InnoDB 存储引擎使用的一种锁定机制，它锁定的是索引记录和索引记录之间的“间隙”（gap），不仅锁定具体的行，还包括前后记录之间的空间。临键锁是行锁（Record Lock）和间隙锁（Gap Lock）的结合，用于防止幻读（phantom read）。

### 可重复读与临键锁问题的关系

在可重复读隔离级别下，MySQL 使用临键锁来防止幻读现象。幻读是指在同一个事务中，多次执行同一个查询时，如果另一个事务插入了符合查询条件的新行，那么同一个查询会在不同时候返回不同的结果集。在可重复读级别下，InnoDB 通过锁定读取到的记录以及这些记录之间的间隙来防止幻读的发生。

### 例子：为什么临键锁导致问题？

#### 示例表结构

假设我们有一个简单的用户表 `users`：

```sql
CREATE TABLE users
(
    id   INT PRIMARY KEY,
    name VARCHAR(50)
) ENGINE=InnoDB;
```

表中有以下数据：

| id | name    |
|----|---------|
| 1  | Alice   |
| 5  | Bob     |
| 10 | Charlie |
| 15 | Dave    |

#### 示例操作

事务A和事务B并发执行，展示了临键锁是如何工作的：

1. **事务A**：

   ```sql
   START TRANSACTION;
   SELECT * FROM users WHERE id BETWEEN 5 AND 15 FOR UPDATE;
   ```

   事务A执行了一个范围查询，InnoDB 会锁定以下部分：
    - 记录：`[5, 10, 15]`
    - 间隙：`(5, 10)`, `(10, 15)`, `(15, ∞)`

   这些锁会阻止其他事务在锁定的间隙中插入新的记录。

2. **事务B**：

   尝试在锁定的间隙中插入新记录：

   ```sql
   START TRANSACTION;
   INSERT INTO users (id, name) VALUES (8, 'Eve');
   ```

   此时，事务B会被阻塞，因为 `(5, 10)` 间隙已经被事务A锁定。

### 为什么可重复读导致临键锁问题？

在可重复读隔离级别下，MySQL 通过锁定索引记录及其间隙，防止其他事务插入可能引发幻读的新记录。这样做的目的是为了确保在同一个事务中，查询操作的结果集是稳定的，并且能够防止幻读。但是，这也导致了一些问题：

1. **锁定范围扩大**：临键锁锁定的不仅是查询结果中的记录，还有这些记录之间的间隙，这扩大了锁定的范围。

2. **增加了锁冲突的可能性**：由于锁定了更多的间隙，其他事务在这些间隙中的插入操作会被阻塞，增加了锁冲突的可能性。

3. **性能影响**：在高并发的环境中，过多的锁冲突会影响数据库性能，尤其是在有大量插入和更新操作的情况下。

### 总结

- **可重复读隔离级别**：在 MySQL 中，为了实现可重复读隔离级别，InnoDB 使用了临键锁来防止幻读。
- **临键锁的影响**：临键锁锁定了查询到的记录以及这些记录之间的间隙，确保在事务期间查询结果的稳定性。
- **问题和挑战**：临键锁的锁定范围较广，容易导致锁冲突和性能问题，尤其在高并发的场景下。


## 为什么不建议使用可重复读

大部分出现可重复读的需求都是因为代码没有写好，或者说至少可以通过改造业务来实现。既然需要读多次，那么自然可以在第一次读完之后缓存起来。

在业务层面上，幻读一般不会被认为是一个问题，原因有两点：

一是你分不清是不是幻读。比如说你在事务 A 里面读到了一条数据，你判断不出来它是在事务 A 开始之前就插入的，还是在事务 A 开始之后，事务 B 才插入并且提交的。

二是事务提交往往意味着业务已经结束，所以读到一个已经提交的事务的数据，不会损害业务的正确性。也就是说，如果事务 A 在开始之后，事务 B 才插入数据并且提交。那么这个时候事务 A 完全可以认为事务 B 所在的整个业务已经结束了，那么读出来也没什么问题。

万一必须要用可重复读，可以直接在创建事务的时候指定隔离级别。实际上还可以在 Session 或者事务这两个维度上指定隔离级别。



