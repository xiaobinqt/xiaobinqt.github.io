<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>算法 - 标签 - xiaobinqt 博客 - 技术改变生活</title>
        <link>https://www.xiaobinqt.cn/tags/%E7%AE%97%E6%B3%95/</link>
        <description>算法 - 标签 - xiaobinqt 博客 - 技术改变生活</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaobinqt@163.com (xiaobinqt)</managingEditor>
            <webMaster>xiaobinqt@163.com (xiaobinqt)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 15 Jan 2022 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://www.xiaobinqt.cn/tags/%E7%AE%97%E6%B3%95/" rel="self" type="application/rss+xml" /><item>
    <title>一致性哈希算法</title>
    <link>https://www.xiaobinqt.cn/consistent-hash/</link>
    <pubDate>Sat, 15 Jan 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/consistent-hash/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/ecb1b15e9bef4dd4bc7ae3bcf5dcec0a.png" referrerpolicy="no-referrer">
            </div><!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="如何分配请求" class="headerLink">
    <a href="#%e5%a6%82%e4%bd%95%e5%88%86%e9%85%8d%e8%af%b7%e6%b1%82" class="header-mark"></a>如何分配请求</h2><p>大多数网站背后肯定不是只有一台服务器提供服务，因为单机的并发量和数据量都是有限的，所以都会用多台服务器构成集群来对外提供服务。但是这样的话，问题就来了，现在有那么多个节点（后文统称服务器为节点），要如何分配客户端的请求呢&#x2753;</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/2c1d93e9e28d48b1af656fb08cb5ffd3.png" title="大量请求" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/2c1d93e9e28d48b1af656fb08cb5ffd3.png" data-sub-html="<h2>大量请求</h2><p>大量请求</p>">
        
    </a><figcaption class="image-caption">大量请求</figcaption>
    </figure></p>
<p>其实这个问题就是「负载均衡问题」。解决负载均衡问题的算法很多，不同的负载均衡算法，对应的就是不同的分配策略，适应的业务场景也不同。</p>
<p>最简单的方式，引入一个中间的负载均衡层，让它将外界的请求「轮流」的转发给内部的集群。比如集群有 3 个节点，外界请求有 3 个，那么每个节点都会处理 1 个请求，达到了分配请求的目的。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/5c1c50a1b91b484c907f20d423e126c1.png" title="负载均衡层" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/5c1c50a1b91b484c907f20d423e126c1.png" data-sub-html="<h2>负载均衡层</h2><p>负载均衡层</p>">
        
    </a><figcaption class="image-caption">负载均衡层</figcaption>
    </figure></p>
<p>考虑到每个节点的硬件配置有所区别，我们可以引入<strong>权重值</strong>，将硬件配置更好的节点的权重值设高，然后根据各个节点的权重值，按照一定比重分配在不同的节点上，让硬件配置更好的节点承担更多的请求，这种算法叫做<strong>加权轮询</strong>。</p>
<p><strong>加权轮询算法使用场景是建立在每个节点存储的数据都是相同的前提</strong>。所以，每次读数据的请求，访问任意一个节点都能得到结果。但是，加权轮询算法是无法应对「分布式系统」的，因为<strong>分布式系统中，每个节点存储的数据是不同的</strong>。</p>
<p>当我们想提高系统的容量，就会将数据水平切分到不同的节点来存储，也就是将数据分布到了不同的节点。比如一个分布式 KV（key-valu） 缓存系统，某个 key 应该到哪个或者哪些节点上获得，应该是确定的，不是说任意访问一个节点都可以得到缓存结果。</p>
<p>因此，我们要想一个能应对分布式系统的负载均衡算法。</p>
<h2 id="使用哈希算法有什么问题" class="headerLink">
    <a href="#%e4%bd%bf%e7%94%a8%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95%e6%9c%89%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98" class="header-mark"></a>使用哈希算法有什么问题</h2><p>有的同学可能很快就想到了：哈希算法。因为对同一个关键字进行哈希计算，每次计算都是相同的值，这样就可以将某个 key 确定到一个节点了，可以满足分布式系统的负载均衡需求。</p>
<p>哈希算法最简单的做法就是进行取模运算，比如分布式系统中有 3 个节点，基于<code>hash(key) % 3</code>公式对数据进行了映射。如果客户端要获取指定 key 的数据，通过下面的公式可以定位节点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">hash<span class="o">(</span>key<span class="o">)</span> % <span class="m">3</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果经过上面这个公式计算后得到的值是 0，就说明该 key 需要去第一个节点获取。</p>
<p>但是有一个很致命的问题，<strong>如果节点数量发生了变化，也就是在对系统做扩容或者缩容时，必须迁移改变了映射关系的数据</strong>，否则会出现查询不到数据的问题。</p>
<p>举个例子，假设我们有一个由 A、B、C 三个节点组成分布式 KV 缓存系统，基于计算公式<code>hash(key) % 3</code>将数据进行了映射，每个节点存储了不同的数据：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/7fe2de0ff60940d6bfbb10f160256e06.png" title="hash算法" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/7fe2de0ff60940d6bfbb10f160256e06.png" data-sub-html="<h2> </h2><p>hash算法</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<p>现在有 3 个查询 key 的请求，分别查询<code>key-01</code>，<code>key-02</code>，<code>key-03</code> 的数据，这三个 key 分别经过<code>hash()</code>函数计算后的值为<code>hash( key-01) = 6</code>、<code>hash( key-02) = 7</code>、<code>hash(key-03) = 8</code>，然后再对这些值进行取模运算。</p>
<p>通过这样的哈希算法，每个 key 都可以定位到对应的节点。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/9db86d41bd62409784aeb3cc2f62e93f.png" title="正常节点" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/9db86d41bd62409784aeb3cc2f62e93f.png" data-sub-html="<h2> </h2><p>正常节点</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<p>当 3 个节点不能满足业务需求了，这时我们<strong>增加</strong>了一个节点，节点的数量从 3 变化为 4，意味取模哈希函数中<strong>基数的变化</strong>，这样会导致大部分映射关系改变，如下图&#x1f447;</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/722345cfe27c47fb9f8a7a56ccced288.png" title="节点增加" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/722345cfe27c47fb9f8a7a56ccced288.png" data-sub-html="<h2> </h2><p>节点增加</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<p>比如，之前的<code>hash(key-01) % 3 = 0</code>，就变成了<code>hash(key-01) % 4 = 2</code>，查询<code>key-01</code>数据时，寻址到了节点 C，而<code>key-01</code>的数据是存储在节点 A 上的，不是在节点 C，所以会查询不到数据。</p>
<p>同样的道理，如果我们对分布式系统进行缩容，比如移除一个节点，也会因为取模哈希函数中基数的变化，可能出现查询不到数据的问题。</p>
<p>要解决这个问题的办法，就需要我们进行<strong>迁移数据</strong>，比如节点的数量从 3 变化为 4 时，要基于新的计算公式<code>hash(key) % 4</code>，重新对数据和节点做映射。</p>
<p>假设总数据条数为 M，哈希算法在面对节点数量变化时，<strong>最坏情况下所有数据都需要迁移，所以它的数据迁移规模是<code>O(M)</code>，这样数据的迁移成本太高了</strong>。</p>
<p>所以，我们应该要重新想一个新的算法，来避免分布式系统在扩容或者缩容时，发生过多的数据迁移。</p>
<h2 id="使用一致性哈希算法有什么问题" class="headerLink">
    <a href="#%e4%bd%bf%e7%94%a8%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95%e6%9c%89%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98" class="header-mark"></a>使用一致性哈希算法有什么问题</h2><p>一致性哈希算法就很好地解决了分布式系统在扩容或者缩容时，发生过多的数据迁移的问题。</p>
<p>一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而一致哈希算法是对<code>2^32</code>进行取模运算，是一个固定的值。</p>
<p>我们可以把一致哈希算法是对<code>2^32</code>进行取模运算的结果值组织成一个圆环，就像钟表一样。钟表的圆可以理解成由 60 个点组成的圆，而此处我们把这个圆想象成由<code>2^32</code>个点组成的圆，这个圆环被称为哈希环，如下图&#x1f447;</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/0f6d1adc1fa346f29fa1ddcd1ba7a271.png" title="哈希环" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/0f6d1adc1fa346f29fa1ddcd1ba7a271.png" data-sub-html="<h2>哈希环</h2><p>哈希环</p>">
        
    </a><figcaption class="image-caption">哈希环</figcaption>
    </figure></p>
<p>一致性哈希要进行两步哈希：</p>
<ul>
<li>第一步：对存储节点进行哈希计算，也就是对存储节点做哈希映射，比如根据节点的 IP 地址进行哈希；</li>
<li>第二步：当对数据进行存储或访问时，对数据进行哈希映射；</li>
</ul>
<p>所以，<strong>一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上</strong>。</p>
<p>问题来了，对「数据」进行哈希映射得到一个结果要怎么找到存储该数据的节点呢&#x2753;</p>
<p>答案是，映射的结果值往<strong>顺时针的方向找到第一个节点</strong>，就是存储该数据的节点。</p>
<p>举个例子，有 3 个节点经过哈希计算，映射到了如下图的位置：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/58005e781a0f427d9e955da50d493d6f.png" title="示例01" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/58005e781a0f427d9e955da50d493d6f.png" data-sub-html="<h2> </h2><p>示例01</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<p>接着，对要查询的<code>key-01</code>进行哈希计算，确定此<code>key-01</code>映射在哈希环的位置，然后从这个位置往顺时针的方向找到第一个节点，就是存储该<code>key-01</code>数据的节点。</p>
<p>比如，下图中的<code>key-01</code>映射的位置，往顺时针的方向找到第一个节点就是节点 A。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/de39de77b55c47b985f6702ae4eb99a7.png" title="示例02" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/de39de77b55c47b985f6702ae4eb99a7.png" data-sub-html="<h2> </h2><p>示例02</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<p>所以，当需要对指定 key 的值进行读写的时候，要通过下面 2 步进行寻址：</p>
<ul>
<li>首先，对 key 进行哈希计算，确定此 key 在环上的位置；</li>
<li>然后，从这个位置沿着顺时针方向走，遇到的第一节点就是存储 key 的节点。</li>
</ul>
<p>知道了一致哈希寻址的方式，我们来看看，如果增加一个节点或者减少一个节点会发生大量的数据迁移吗？</p>
<p>假设节点数量从 3 增加到了 4，新的节点 D 经过哈希计算后映射到了下图中的位置&#x1f447;</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/a896ece188c54e22a2073563e3b6c69a.png" title="示例03" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/a896ece188c54e22a2073563e3b6c69a.png" data-sub-html="<h2> </h2><p>示例03</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<p>你可以看到<code>key-01</code>、<code>key-03</code>都不受影响，只有<code>key-02</code>需要被迁移节点 D。</p>
<p>假设节点数量从 3 减少到了 2，比如将节点 A 移除&#x1f447;</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/972ee2a16273443c9beae2279aae1137.png" title="示例04" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/972ee2a16273443c9beae2279aae1137.png" data-sub-html="<h2> </h2><p>示例04</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<p>可以看到<code>key-02</code>和<code>key-03</code>不会受到影响，只有<code>key-01</code>需要被迁移节点 B。</p>
<p>因此，在一致哈希算法中，如果增加或者移除一个节点，<strong>仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响</strong>。</p>
<p>上面这些图中 3 个节点映射在哈希环还是比较分散的，所以看起来请求都会「均衡」到每个节点。</p>
<p>但是一致性哈希算法并不保证节点能够在哈希环上分布均匀，这样就会带来一个问题，会有大量的请求集中在一个节点上。</p>
<p>比如，下图中 3 个节点的映射位置都在哈希环的右半边&#x1f447;</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/1c1070a9a49e4ccf99092142cc5e33d1.png" title="示例05" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/1c1070a9a49e4ccf99092142cc5e33d1.png" data-sub-html="<h2> </h2><p>示例05</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<p>这时候有一半以上的数据的寻址都会找节点 A，也就是访问请求主要集中的节点 A 上，这是肯定不行的，说好的负载均衡呢，这种情况一点都不均衡。</p>
<p>另外，在这种节点分布不均匀的情况下，进行容灾与扩容时，哈希环上的相邻节点容易受到过大影响，容易发生雪崩式的连锁反应。</p>
<p>比如，上图中如果节点 A 被移除了，当节点 A 宕机后，根据一致性哈希算法的规则，其上数据应该全部迁移到相邻的节点 B 上，这样，节点 B 的数据量、访问量都会迅速增加很多倍，一旦新增的压力超过了节点 B 的处理能力上限，就会导致节点 B 崩溃，进而形成雪崩式的连锁反应。</p>
<p>所以，<strong>一致性哈希算法虽然减少了数据迁移量，但是存在节点分布不均匀的问题</strong>。</p>
<h2 id="如何通过虚拟节点提高均衡度" class="headerLink">
    <a href="#%e5%a6%82%e4%bd%95%e9%80%9a%e8%bf%87%e8%99%9a%e6%8b%9f%e8%8a%82%e7%82%b9%e6%8f%90%e9%ab%98%e5%9d%87%e8%a1%a1%e5%ba%a6" class="header-mark"></a>如何通过虚拟节点提高均衡度</h2><p>要想解决节点能在哈希环上分配不均匀的问题，就是要有大量的节点，节点数越多，哈希环上的节点分布的就越均匀。</p>
<p>但问题是，实际中我们没有那么多节点。所以这个时候我们就加入虚拟节点，也就是对一个真实节点做多个副本。</p>
<p>具体做法是，<strong>不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点</strong>，所以这里有「两层」映射关系。</p>
<p>比如对每个节点分别设置 3 个虚拟节点：</p>
<ul>
<li>对节点 A 加上编号来作为虚拟节点：A-01、A-02、A-03</li>
<li>对节点 B 加上编号来作为虚拟节点：B-01、B-02、B-03</li>
<li>对节点 C 加上编号来作为虚拟节点：C-01、C-02、C-03</li>
</ul>
<p>引入虚拟节点后，原本哈希环上只有 3 个节点的情况，就会变成有 9 个虚拟节点映射到哈希环上，哈希环上的节点数量多了 3 倍。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/81659d664abb431d87f8d910bde47d65.png" title="虚拟节点" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/81659d664abb431d87f8d910bde47d65.png" data-sub-html="<h2>虚拟节点</h2><p>虚拟节点</p>">
        
    </a><figcaption class="image-caption">虚拟节点</figcaption>
    </figure></p>
<p>我们可以看到，<strong>节点数量多了后，节点在哈希环上的分布就相对均匀了</strong>。这时候，如果有访问请求寻址到「A-01」这个虚拟节点，接着再通过「A-01」虚拟节点找到真实节点 A，这样请求就能访问到真实节点 A 了。</p>
<p>上面为了方便理解，每个真实节点仅包含 3 个虚拟节点，这样能起到的均衡效果其实很有限。而在实际的工程中，虚拟节点的数量会大很多，比如 Nginx 的一致性哈希算法，每个权重为 1 的真实节点就含有160 个虚拟节点。</p>
<p>另外，虚拟节点除了会提高节点的均衡度，还会提高系统的稳定性。<strong>当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高</strong>。</p>
<p>比如，当某个节点被移除时，对应该节点的多个虚拟节点均会移除，而这些虚拟节点按顺时针方向的下一个虚拟节点，可能会对应不同的真实节点，即这些不同的真实节点共同分担了节点变化导致的压力。</p>
<p>而且，有了虚拟节点后，还可以为硬件配置更好的节点增加权重，比如对权重更高的节点增加更多的虚拟机节点即可。</p>
<p>因此，<strong>带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景</strong>。</p>
<h2 id="总结" class="headerLink">
    <a href="#%e6%80%bb%e7%bb%93" class="header-mark"></a>总结</h2><p>不同的负载均衡算法适用的业务场景不同。</p>
<p>轮训这类的策略只能适用于每个节点的数据都是相同的场景，访问任意节点都能请求到数据。但是不适用分布式系统，因为分布式系统意味着数据水平切分到了不同的节点上，访问数据的时候，一定要寻址存储该数据的节点。</p>
<p>哈希算法虽然能建立数据和节点的映射关系，但是每次在节点数量发生变化的时候，最坏情况下所有数据都需要迁移，这样太麻烦了，所以不适用节点数量变化的场景。</p>
<p>为了减少迁移的数据量，就出现了一致性哈希算法。</p>
<p>一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响。</p>
<p>但是一致性哈希算法不能够均匀的分布节点，会出现大量请求都集中在一个节点的情况，在这种情况下进行容灾与扩容时，容易出现雪崩的连锁反应。</p>
<p>为了解决一致性哈希算法不能够均匀的分布节点的问题，就需要引入虚拟节点，对一个真实节点做多个副本。不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。</p>
<p>引入虚拟节点后，可以提高节点的均衡度，还会提高系统的稳定性。所以，带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://bbs.huaweicloud.com/blogs/333158?utm_source=luntan&amp;utm_medium=bbs-ex&amp;utm_campaign=other&amp;utm_content=content" target="_blank" rel="noopener noreferrer">16 张图解 ｜ 一致性哈希算法</a></li>
<li><a href="https://xiaozhuanlan.com/learningalgorithm" target="_blank" rel="noopener noreferrer">程序员算法-心中有树</a></li>
<li><a href="https://blog.csdn.net/suifeng629/article/details/81567777" target="_blank" rel="noopener noreferrer">一致性Hash(Consistent Hashing)原理剖析及Java实现</a></li>
<li><a href="https://segmentfault.com/a/1190000021199728" target="_blank" rel="noopener noreferrer">图解一致性哈希算法</a></li>
<li><a href="http://jintang.zone/2018/08/20/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%8E%AF%E5%8F%8A%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95.html" target="_blank" rel="noopener noreferrer">golang实现一致性hash环及优化方法</a></li>
<li><a href="https://geektutu.com/post/geecache-day4.html" target="_blank" rel="noopener noreferrer">一致性哈希</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/98030096" target="_blank" rel="noopener noreferrer">一致性Hash算法详解</a></li>
</ul>
]]></description>
</item><item>
    <title>常见缓存淘汰策略</title>
    <link>https://www.xiaobinqt.cn/common-cache-strategies/</link>
    <pubDate>Thu, 05 Mar 2020 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/common-cache-strategies/</guid>
    <description><![CDATA[<h2 id="fifo" class="headerLink">
    <a href="#fifo" class="header-mark"></a>FIFO</h2><p>First In First Out(FIFO)，先进先出，也就是淘汰缓存中最老(最早添加)的记录。FIFO 认为，最早添加的记录，其不再被使用的可能性比刚添加的可能性大。这种算法的实现也非常简单，创建一个队列，新增记录添加到队尾， 每次内存不够时，淘汰队首。但是很多场景下，部分记录虽然是最早添加但也最常被访问，而不得不因为呆的时间太长而被淘汰。这类数据会被频繁地添加进缓存，又被淘汰出去，导致缓存命中率降低。</p>
<h2 id="lfu" class="headerLink">
    <a href="#lfu" class="header-mark"></a>LFU</h2><p>Least Frequently Used(LFU)，最少使用，也就是淘汰缓存中访问频率最低的记录。LFU 认为，如果数据过去被访问多次， 那么将来被访问的频率也更高。LFU 的实现需要维护一个按照访问次数排序的队列，每次访问，访问次数加1，队列重新排序， 淘汰时选择访问次数最少的即可。LFU 算法的命中率是比较高的，但缺点也非常明显，维护每个记录的访问次数，对内存的消耗是很高的； 另外，如果数据的访问模式发生变化，LFU 需要较长的时间去适应，也就是说 LFU 算法受历史数据的影响比较大。例如某个数据历史上访问次数奇高，但在某个时间点之后几乎不再被访问，但因为历史访问次数过高，而迟迟不能被淘汰。</p>
<h2 id="lru" class="headerLink">
    <a href="#lru" class="header-mark"></a>LRU</h2><p>Least Recently Used(LRU)，最近最少使用，相对于仅考虑时间因素的 FIFO 和仅考虑访问频率的 LFU，LRU 算法可以认为是相对平衡的 一种淘汰算法。LRU 认为，如果数据最近被访问过，那么将来被访问的概率也会更高。LRU 算法的实现非常简单，维护一个队列，如果某条记录被访问了， 则移动到队尾，那么队首则是最近最少访问的数据，淘汰该条记录即可。</p>
]]></description>
</item></channel>
</rss>
