<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Redis - 标签 - xiaobinqt 博客 - 技术改变生活</title>
        <link>https://www.xiaobinqt.cn/tags/redis/</link>
        <description>Redis - 标签 - xiaobinqt 博客 - 技术改变生活</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaobinqt@163.com (xiaobinqt)</managingEditor>
            <webMaster>xiaobinqt@163.com (xiaobinqt)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Wed, 13 Apr 2022 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://www.xiaobinqt.cn/tags/redis/" rel="self" type="application/rss+xml" /><item>
    <title>Redis 缓存击穿、缓存穿透、缓存雪崩</title>
    <link>https://www.xiaobinqt.cn/redis-break-pierce-avalanche/</link>
    <pubDate>Wed, 13 Apr 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/redis-break-pierce-avalanche/</guid>
    <description><![CDATA[<h2 id="缓存击穿" class="headerLink">
    <a href="#%e7%bc%93%e5%ad%98%e5%87%bb%e7%a9%bf" class="header-mark"></a>缓存击穿</h2><p>高并发流量，访问的这个数据是热点数据，请求的数据在 DB 中存在，但是 Redis 存的那一份已经过期，后端需要从 DB 从加载数据并写到 Redis。</p>
<p>总结起来就是：单一热点数据、高并发、数据失效。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220413/10c8c8557c8b41ea967c82617bef1814.png" title="缓存击穿" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220413/10c8c8557c8b41ea967c82617bef1814.png" data-sub-html="<h2>缓存击穿</h2><p>缓存击穿</p>">
        
    </a><figcaption class="image-caption">缓存击穿</figcaption>
    </figure></p>
<h3 id="解决方案" class="headerLink">
    <a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" class="header-mark"></a>解决方案</h3><h4 id="过期时间heavy_plus_sign随机值" class="headerLink">
    <a href="#%e8%bf%87%e6%9c%9f%e6%97%b6%e9%97%b4heavy_plus_sign%e9%9a%8f%e6%9c%ba%e5%80%bc" class="header-mark"></a>过期时间&#x2795;随机值</h4><p>对于热点数据，我们不设置过期时间，这样就可以把请求都放在缓存中处理，充分把 Redis 高吞吐量性能利用起来。或者过期时间再加一个随机值。</p>
<p>设计缓存的过期时间时，使用公式：<strong>过期时间 = baes 时间 + 随机时间</strong>。</p>
<p>即相同业务数据写缓存时，在基础过期时间之上，再加一个随机的过期时间，让数据在未来一段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过大压力。</p>
<h4 id="预热" class="headerLink">
    <a href="#%e9%a2%84%e7%83%ad" class="header-mark"></a>预热</h4><p>预先把热门数据提前存入 Redis 中，并设热门数据的过期时间超大值。</p>
<h4 id="使用锁" class="headerLink">
    <a href="#%e4%bd%bf%e7%94%a8%e9%94%81" class="header-mark"></a>使用锁</h4><p>当发现缓存失效的时候，不是立即从数据库加载数据。</p>
<p>而是先获取分布式锁，获取锁成功才执行数据库查询和写数据到缓存的操作，获取锁失败，则说明当前有线程在执行数据库查询操作，当前线程睡眠一段时间再重试。这样只让一个请求去数据库读取数据。</p>
<h2 id="缓存穿透" class="headerLink">
    <a href="#%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f" class="header-mark"></a>缓存穿透</h2><p>数据库本就没有这个数据，请求直奔数据库，缓存系统形同虚设。</p>
<p>大量请求的 key 根本<font color="red"><strong>不存在于缓存中也不存在数据库</strong></font>，导致请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成压力而影响正常服务。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220413/19352698c9c047d4a635c3e561b8293b.png" title="缓存穿透" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220413/19352698c9c047d4a635c3e561b8293b.png" data-sub-html="<h2>缓存穿透</h2><p>缓存穿透</p>">
        
    </a><figcaption class="image-caption">缓存穿透</figcaption>
    </figure></p>
<h3 id="解决方案-1" class="headerLink">
    <a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88-1" class="header-mark"></a>解决方案</h3><p>最基本的首先就是做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。</p>
<h4 id="缓存无效的-key" class="headerLink">
    <a href="#%e7%bc%93%e5%ad%98%e6%97%a0%e6%95%88%e7%9a%84-key" class="header-mark"></a>缓存无效的 key</h4><p>如果<strong>缓存和数据库都查不到</strong>
某个 key 的数据就写一个到 Redis 中去并设置过期时间。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，应该尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<h4 id="布隆过滤器" class="headerLink">
    <a href="#%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8" class="header-mark"></a>布隆过滤器</h4><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地<strong>判断一个给定数据是否存在于海量数据中</strong>。我们需要的仅仅就是判断 key 是否合法。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话再走其他的判断流程。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/c81922434bf5420c94e349e07980054b.png" title="布隆过滤器" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/c81922434bf5420c94e349e07980054b.png" data-sub-html="<h2>布隆过滤器</h2><p>布隆过滤器</p>">
        
    </a><figcaption class="image-caption">布隆过滤器</figcaption>
    </figure></p>
<p>需要注意的是布隆过滤器可能会存在误判的情况。</p>
<p><strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，这个元素一定不在</strong>。</p>
<p>这是因为，当一个元素加入布隆过滤器中的时候，会进行如下操作：</p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在数组中把对应下标的值置为 1。</li>
</ol>
<p>当需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>然而，一定会出现这样一种情况：不同的字符串可能哈希出来的位置相同。我们可以适当增加位数组大小或者调整我们的哈希函数来降低概率。</p>
<h2 id="缓存雪崩" class="headerLink">
    <a href="#%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9" class="header-mark"></a>缓存雪崩</h2><p>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。或是有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</p>
<p>而出现该原因主要有两种：</p>
<ul>
<li>大量热点数据同时过期，导致大量请求需要查询数据库并写到缓存。</li>
<li>Redis 故障宕机，缓存系统异常。</li>
</ul>
<h3 id="缓存大量数据同时过期" class="headerLink">
    <a href="#%e7%bc%93%e5%ad%98%e5%a4%a7%e9%87%8f%e6%95%b0%e6%8d%ae%e5%90%8c%e6%97%b6%e8%bf%87%e6%9c%9f" class="header-mark"></a>缓存大量数据同时过期</h3><p>数据保存在缓存系统并设置了过期时间，但是由于在同时一刻，大量数据同时过期。系统就把请求全部打到数据库获取数据，并发量大的话就会导致数据库压力激增。</p>
<p><font color="red"><strong>缓存雪崩是发生在大量数据同时失效的场景，而缓存击穿是在某个热点数据失效的场景，这是他们最大的区别</strong>
</font>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220413/12a33b5773ef4e36be2c71a94b93df11.png" title="缓存大量数据同时过期" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220413/12a33b5773ef4e36be2c71a94b93df11.png" data-sub-html="<h2>缓存大量数据同时过期</h2><p>缓存大量数据同时过期</p>">
        
    </a><figcaption class="image-caption">缓存大量数据同时过期</figcaption>
    </figure></p>
<h4 id="过期时间添加随机值" class="headerLink">
    <a href="#%e8%bf%87%e6%9c%9f%e6%97%b6%e9%97%b4%e6%b7%bb%e5%8a%a0%e9%9a%8f%e6%9c%ba%e5%80%bc" class="header-mark"></a>过期时间添加随机值</h4><p>要避免给大量的数据设置一样的过期时间，过期时间 = baes 时间+ 随机时间（较小的随机数，比如随机增加 1~5 分钟）。</p>
<p>这样一来，就不会导致同一时刻热点数据全部失效，同时过期时间差别也不会太大，既保证了相近时间失效，又能满足业务需求。</p>
<h4 id="接口限流" class="headerLink">
    <a href="#%e6%8e%a5%e5%8f%a3%e9%99%90%e6%b5%81" class="header-mark"></a>接口限流</h4><p>当访问的不是核心数据的时候，在查询的方法上加上接口限流保护。比如设置 10000 req/s。如果访问的是核心数据接口，缓存不存在允许从数据库中查询并设置到缓存中。这样的话，只有部分请求会发送到数据库，减少了压力。</p>
<p><strong>限流，就是指，我们在业务系统的请求入口前端控制每秒进入系统的请求数，避免过多的请求被发送到数据库</strong>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220413/340401972fac48f391fa6906a9444eac.png" title="限流" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220413/340401972fac48f391fa6906a9444eac.png" data-sub-html="<h2>限流</h2><p>限流</p>">
        
    </a><figcaption class="image-caption">限流</figcaption>
    </figure></p>
<h3 id="redis-故障" class="headerLink">
    <a href="#redis-%e6%95%85%e9%9a%9c" class="header-mark"></a>Redis 故障</h3><p>一旦 Redis 故障或宕机，会导致大量请求打到数据库，从而发生缓存雪崩。对于 Redis 故障，主要有以下两种解决方案。</p>
<h4 id="服务熔断和限流" class="headerLink">
    <a href="#%e6%9c%8d%e5%8a%a1%e7%86%94%e6%96%ad%e5%92%8c%e9%99%90%e6%b5%81" class="header-mark"></a>服务熔断和限流</h4><p>在业务系统中，针对高并发的使用服务熔断来有损提供服务从而保证系统的可用性。</p>
<p>服务熔断就是当从缓存获取数据发现异常，则直接返回错误数据给前端，防止所有流量打到数据库导致宕机。</p>
<p>服务熔断和限流属于在发生了缓存雪崩，如何<strong>降低雪崩对数据库造成的影响</strong>的方案。</p>
<h4 id="高可用缓存集群" class="headerLink">
    <a href="#%e9%ab%98%e5%8f%af%e7%94%a8%e7%bc%93%e5%ad%98%e9%9b%86%e7%be%a4" class="header-mark"></a>高可用缓存集群</h4><p>缓存系统一定要构建一套 Redis 高可用集群，比如 <a href="" rel="">Redis 哨兵集群 TODO</a> 或者 <a href="" rel="">Redis Cluster 集群 TODO</a>，如果 Redis 的主节点故障宕机了，从节点还可以切换成为主节点，继续提供缓存服务，避免了由于缓存实例宕机而导致的缓存雪崩问题。</p>
<h2 id="总结" class="headerLink">
    <a href="#%e6%80%bb%e7%bb%93" class="header-mark"></a>总结</h2><ul>
<li>缓存穿透指的是数据库本就没有这个数据，请求直奔数据库，缓存系统形同虚设。</li>
<li>缓存击穿（失效）指的是数据库有数据，缓存本应该也有数据，但是缓存过期了，Redis 这层流量防护屏障被击穿了，请求直奔数据库。</li>
<li>缓存雪崩指的是大量的热点数据无法在 Redis 缓存中处理（大面积热点数据缓存失效、Redis 宕机），流量全部打到数据库，导致数据库极大压力。</li>
</ul>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NDY2MDk4Mw==&amp;mid=2247488270&amp;idx=1&amp;sn=03674abcaa78b027bd12aaafd5a2f6e2" target="_blank" rel="noopener noreferrer">Redis 缓存击穿（失效）、缓存穿透、缓存雪崩怎么解决？</a></li>
</ul>
]]></description>
</item><item>
    <title>Centos 7.9 安装 Redis 6.0.16</title>
    <link>https://www.xiaobinqt.cn/centos-7.9-install-redis-6.0.16/</link>
    <pubDate>Tue, 13 Jul 2021 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/centos-7.9-install-redis-6.0.16/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="服务器版本" class="headerLink">
    <a href="#%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%89%88%e6%9c%ac" class="header-mark"></a>服务器版本</h2><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220713/366f5d82de6e4da6af53042bc19237b3.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="linux version" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220713/366f5d82de6e4da6af53042bc19237b3.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>linux version</h2><p>linux version</p>">
        
    </a><figcaption class="image-caption">linux version</figcaption>
    </figure></p>
<h2 id="下载" class="headerLink">
    <a href="#%e4%b8%8b%e8%bd%bd" class="header-mark"></a>下载</h2><p>可以直接去官网<a href="https://redis.io/download/" target="_blank" rel="noopener noreferrer">下载</a>需要的版本即可，这里已 6.0.16 版本为准。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220713/049679c099254e5997410c5b3ac3320c.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="redis download" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220713/049679c099254e5997410c5b3ac3320c.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>redis download</h2><p>redis download</p>">
        
    </a><figcaption class="image-caption">redis download</figcaption>
    </figure></p>
<h2 id="安装" class="headerLink">
    <a href="#%e5%ae%89%e8%a3%85" class="header-mark"></a>安装</h2><p>我把下载的 tar 包放在了 <code>/root</code> 目录下，这里可以自行修改。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">tar -xzf redis-6.0.16.tar.gz 
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> redis-6.0.16
</span></span><span class="line"><span class="cl">make <span class="o">&amp;&amp;</span> make install
</span></span></code></pre></td></tr></table>
</div>
</div><p>安装成功启动服务：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220713/60ee0e9fb15347e7bb24fd512296201c.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="install success" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220713/60ee0e9fb15347e7bb24fd512296201c.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>install success</h2><p>install success</p>">
        
    </a><figcaption class="image-caption">install success</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220713/610f7cb66b1144fa831debe76fe97613.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="redis start" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220713/610f7cb66b1144fa831debe76fe97613.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>redis start</h2><p>redis start</p>">
        
    </a><figcaption class="image-caption">redis start</figcaption>
    </figure></p>
<h2 id="常见问题" class="headerLink">
    <a href="#%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98" class="header-mark"></a>常见问题</h2><h3 id="cc-command-not-found" class="headerLink">
    <a href="#cc-command-not-found" class="header-mark"></a>cc: command not found</h3><p>需要安装 gcc&#x1f447;</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">yum -y install gcc gcc-c++ libstdc++-devel
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="struct-redisserver-server_xxx" class="headerLink">
    <a href="#struct-redisserver-server_xxx" class="header-mark"></a>struct redisServer server_xxx</h3><p>需要升级 gcc 到 9 版本&#x1f447;</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">yum -y install centos-release-scl
</span></span><span class="line"><span class="cl">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils
</span></span><span class="line"><span class="cl">scl <span class="nb">enable</span> devtoolset-9 bash
</span></span></code></pre></td></tr></table>
</div>
</div><p>设置永久升级</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;source /opt/rh/devtoolset-9/enable&#34;</span> &gt;&gt;/etc/profile
</span></span></code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>Redis 为什么快</title>
    <link>https://www.xiaobinqt.cn/redis-single-thread-why-so-fast/</link>
    <pubDate>Sat, 03 Apr 2021 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/redis-single-thread-why-so-fast/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="阻塞io" class="headerLink">
    <a href="#%e9%98%bb%e5%a1%9eio" class="header-mark"></a>阻塞IO</h2><p>服务端为了处理客户端的连接和请求的数据，写了如下代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">listenfd = socket();   // 打开一个网络通信端口
</span></span><span class="line"><span class="cl">bind(listenfd);        // 绑定
</span></span><span class="line"><span class="cl">listen(listenfd);      // 监听
</span></span><span class="line"><span class="cl">while(1) {
</span></span><span class="line"><span class="cl">  connfd = accept(listenfd);  // 阻塞建立连接
</span></span><span class="line"><span class="cl">  int n = read(connfd, buf);  // 阻塞读数据
</span></span><span class="line"><span class="cl">  doSomeThing(buf);  // 利用读到的数据做些什么
</span></span><span class="line"><span class="cl">  close(connfd);     // 关闭连接，循环等待下一个连接
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码会执行得磕磕绊绊，就像这样。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/%E4%BC%A0%E7%BB%9FIO.gif" title="阻塞IO" data-thumbnail="https://cdn.xiaobinqt.cn/%E4%BC%A0%E7%BB%9FIO.gif" data-sub-html="<h2>阻塞IO</h2><p>阻塞IO</p>">
        
    </a><figcaption class="image-caption">阻塞IO</figcaption>
    </figure></p>
<p>可以看到，服务端的线程阻塞在了两个地方，一个是<code>accept</code>函数，一个是<code>read</code>函数。</p>
<p>如果再把<code>read</code>函数的细节展开，我们会发现其阻塞在了两个阶段。一个阶段是数据从网卡拷贝到内核缓冲区，第二个阶段是数据从内核缓冲区拷贝到用户缓冲区。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/read.gif" title="read 阻塞" data-thumbnail="https://cdn.xiaobinqt.cn/read.gif" data-sub-html="<h2>read 阻塞</h2><p>read 阻塞</p>">
        
    </a><figcaption class="image-caption">read 阻塞</figcaption>
    </figure></p>
<p>这就是传统的阻塞 IO。整体流程如下图&#x1f447;</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221124/631dedf37f5544d2b74214112468e72f.png" title="阻塞IO流程" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221124/631dedf37f5544d2b74214112468e72f.png" data-sub-html="<h2>阻塞IO流程</h2><p>阻塞IO流程</p>">
        
    </a><figcaption class="image-caption">阻塞IO流程</figcaption>
    </figure></p>
<p>如果这个连接的客户端一直不发数据，那么服务端线程将会一直阻塞在<code>read</code>函数上不返回，也无法接受其他客户端连接，这肯定是不行的。</p>
<h2 id="非阻塞io" class="headerLink">
    <a href="#%e9%9d%9e%e9%98%bb%e5%a1%9eio" class="header-mark"></a>非阻塞IO</h2><p>为了解决阻塞 IO 的问题，其关键在于改造<code>read</code>函数。有一种聪明的办法是，每次都创建一个新的进程或线程，去调用<code>read</code>函数，并做业务处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">while(1) {
</span></span><span class="line"><span class="cl">  connfd = accept(listenfd);  // 阻塞建立连接
</span></span><span class="line"><span class="cl">  pthread_create（doWork);  // 创建一个新的线程
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">void doWork() {
</span></span><span class="line"><span class="cl">  int n = read(connfd, buf);  // 阻塞读数据
</span></span><span class="line"><span class="cl">  doSomeThing(buf);  // 利用读到的数据做些什么
</span></span><span class="line"><span class="cl">  close(connfd);     // 关闭连接，循环等待下一个连接
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样，当给一个客户端建立好连接后，就可以立刻等待新的客户端连接，而不用阻塞在原客户端的<code>read</code>请求上。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/%E9%9D%9E%E9%98%BB%E5%A1%9EIO.gif" title="假非阻塞IO" data-thumbnail="https://cdn.xiaobinqt.cn/%E9%9D%9E%E9%98%BB%E5%A1%9EIO.gif" data-sub-html="<h2>假非阻塞IO</h2><p>假非阻塞IO</p>">
        
    </a><figcaption class="image-caption">假非阻塞IO</figcaption>
    </figure></p>
<p>不过，这不叫非阻塞 IO，只不过用了多线程的手段使得主线程没有卡在<code>read</code>函数上不往下走罢了。操作系统为我们提供的<code>read</code>函数<strong>仍然是阻塞的</strong>。</p>
<p>真正的非阻塞 IO，不能是通过我们用户层的小把戏，而是要<strong>恳请操作系统为我们提供一个非阻塞的<code>read</code>函数</strong>。</p>
<p>这个<code>read</code>函数的效果是，如果<strong>没有数据到达</strong>时（到达网卡并拷贝到了内核缓冲区），立刻返回一个错误值（-1），而不是阻塞地等待。操作系统提供了这样的功能，只需要在调用<code>read</code>前，将文件描述符（也就是客户端的连接）设置为非阻塞即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">fcntl(connfd, F_SETFL, O_NONBLOCK);
</span></span><span class="line"><span class="cl">int n = read(connfd, buffer) != SUCCESS);
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样，就需要<strong>用户线程循环调用<code>read</code>，直到返回值不为 -1</strong>，再开始处理业务。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/%E7%9C%9F%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9EIO.gif" title="非阻塞IO" data-thumbnail="https://cdn.xiaobinqt.cn/%E7%9C%9F%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9EIO.gif" data-sub-html="<h2>非阻塞IO</h2><p>非阻塞IO</p>">
        
    </a><figcaption class="image-caption">非阻塞IO</figcaption>
    </figure></p>
<p>这里有一个细节&#x261d;&#xfe0f;。非阻塞的<code>read</code>，指的是在数据到达前，即数据还未到达网卡，或者到达网卡但还没有拷贝到内核缓冲区之前，这个阶段是非阻塞的，一旦数据已到达内核缓冲区，此时调用<code>read</code>函数<strong>仍然是阻塞的</strong>，需要等待数据从内核缓冲区拷贝到用户缓冲区，才能返回。整体流程如下图&#x1f447;</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221124/15b4551071694947a1df10ef9d80208a.png" title="非阻塞IO流程" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221124/15b4551071694947a1df10ef9d80208a.png" data-sub-html="<h2>非阻塞IO流程</h2><p>非阻塞IO流程</p>">
        
    </a><figcaption class="image-caption">非阻塞IO流程</figcaption>
    </figure></p>
<h2 id="io多路复用" class="headerLink">
    <a href="#io%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8" class="header-mark"></a>IO多路复用</h2><p>为每个客户端创建一个线程，服务器端的线程资源很容易被耗光。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221124/1d4069e204fe4c94b059bbaccf8e6262.png" title="线程资源" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221124/1d4069e204fe4c94b059bbaccf8e6262.png" data-sub-html="<h2>线程资源</h2><p>线程资源</p>">
        
    </a><figcaption class="image-caption">线程资源</figcaption>
    </figure></p>
<p>当然还有个聪明的办法，我们可以每个<code>accept</code>客户端连接后，将这个文件描述符（connfd）放到一个数组里。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">fdlist.add(connfd);
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后开一个新的线程去不断遍历这个数组，调用每一个元素的非阻塞<code>read</code>方法。这样，我们就成功用一个线程处理了多个客户端连接。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">while(1) {
</span></span><span class="line"><span class="cl">  for(fd &lt;-- fdlist) {
</span></span><span class="line"><span class="cl">    if(read(fd) != -1) {
</span></span><span class="line"><span class="cl">      doSomeThing();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/fdlist.gif" title="fdlist" data-thumbnail="https://cdn.xiaobinqt.cn/fdlist.gif" data-sub-html="<h2>fdlist</h2><p>fdlist</p>">
        
    </a><figcaption class="image-caption">fdlist</figcaption>
    </figure></p>
<p>这样看起来是不是觉得这有些多路复用的意思？</p>
<p>但这和我们用多线程去将阻塞 IO 改造成看起来是非阻塞 IO 一样，这种遍历方式也只是我们用户自己想出的小把戏，每次遍历遇到<code>read</code>返回 -1 时仍然是一次浪费资源的系统调用。在<code>while</code>循环里做系统调用，是不划算的。所以，还是得恳请操作系统老大，提供给我们一个有这样效果的函数，我们将一批文件描述符通过一次系统调用传给内核，由内核层去遍历，才能真正解决这个问题。</p>
<h3 id="select" class="headerLink">
    <a href="#select" class="header-mark"></a>select</h3><p>select 是操作系统提供的系统调用函数，通过它，我们可以把一个文件描述符的数组发给操作系统，<strong>让操作系统去遍历，确定哪个文件描述符可以读写</strong>，然后告诉我们去处理：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/select.gif" title="select" data-thumbnail="https://cdn.xiaobinqt.cn/select.gif" data-sub-html="<h2>select</h2><p>select</p>">
        
    </a><figcaption class="image-caption">select</figcaption>
    </figure></p>
<p>select系统调用的函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int select(
</span></span><span class="line"><span class="cl">    int nfds,
</span></span><span class="line"><span class="cl">    fd_set *readfds,
</span></span><span class="line"><span class="cl">    fd_set *writefds,
</span></span><span class="line"><span class="cl">    fd_set *exceptfds,
</span></span><span class="line"><span class="cl">    struct timeval *timeout);
</span></span><span class="line"><span class="cl">// nfds:监控的文件描述符集里最大文件描述符加1
</span></span><span class="line"><span class="cl">// readfds：监控有读数据到达文件描述符集合，传入传出参数
</span></span><span class="line"><span class="cl">// writefds：监控写数据到达文件描述符集合，传入传出参数
</span></span><span class="line"><span class="cl">// exceptfds：监控异常发生达文件描述符集合, 传入传出参数
</span></span><span class="line"><span class="cl">// timeout：定时阻塞监控时间，3种情况
</span></span><span class="line"><span class="cl">//  1.NULL，永远等下去
</span></span><span class="line"><span class="cl">//  2.设置timeval，等待固定时间
</span></span><span class="line"><span class="cl">//  3.设置timeval里时间均为0，检查描述字后立即返回，轮询
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么我们的服务端代码，就这样来写，首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">while(1) {
</span></span><span class="line"><span class="cl">  connfd = accept(listenfd);
</span></span><span class="line"><span class="cl">  fcntl(connfd, F_SETFL, O_NONBLOCK);
</span></span><span class="line"><span class="cl">  fdlist.add(connfd);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后，<strong>另一个</strong>线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">while(1) {
</span></span><span class="line"><span class="cl">  // 把一堆文件描述符 list 传给 select 函数
</span></span><span class="line"><span class="cl">  // 有已就绪的文件描述符就返回，nready 表示有多少个就绪的
</span></span><span class="line"><span class="cl">  nready = select(list);
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>不过，<strong>当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list，只不过，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">while(1) {
</span></span><span class="line"><span class="cl">  nready = select(list);
</span></span><span class="line"><span class="cl">  // 用户层依然要遍历，只不过少了很多无效的系统调用
</span></span><span class="line"><span class="cl">  for(fd &lt;-- fdlist) {
</span></span><span class="line"><span class="cl">    if(fd != -1) {
</span></span><span class="line"><span class="cl">      // 只读已就绪的文件描述符
</span></span><span class="line"><span class="cl">      read(fd, buf);
</span></span><span class="line"><span class="cl">      // 总共只有 nready 个已就绪描述符，不用过多遍历
</span></span><span class="line"><span class="cl">      if(--nready == 0) break;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>正如刚刚的动图中所描述的，其直观效果如下。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/select.gif" title="select" data-thumbnail="https://cdn.xiaobinqt.cn/select.gif" data-sub-html="<h2>select</h2><p>select</p>">
        
    </a><figcaption class="image-caption">select</figcaption>
    </figure></p>
<p>可以看出几个细节：</p>
<ol>
<li>
<p>select 调用需要传入 fd 数组，需要<strong>拷贝一份到内核</strong>，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>
</li>
<li>
<p>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p>
</li>
<li>
<p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p>
</li>
</ol>
<p>整个 select 的流程图如下&#x1f447;</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221124/d4914bc01ce140c790589ec87cf3b181.png" title="select流程图" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221124/d4914bc01ce140c790589ec87cf3b181.png" data-sub-html="<h2>select流程图</h2><p>select流程图</p>">
        
    </a><figcaption class="image-caption">select流程图</figcaption>
    </figure></p>
<p>可以看到，这种方式，既做到了一个线程处理多个客户端连接（文件描述符），又减少了系统调用的开销（多个文件描述符只有一次 select 的系统调用 + n 次就绪状态的文件描述符的<code>read</code>系统调用）。</p>
<h3 id="poll" class="headerLink">
    <a href="#poll" class="header-mark"></a>poll</h3><p>poll 也是操作系统提供的系统调用函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int poll(struct pollfd *fds, nfds_tnfds, int timeout);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct pollfd {
</span></span><span class="line"><span class="cl">  intfd; /*文件描述符*/
</span></span><span class="line"><span class="cl">  shortevents; /*监控的事件*/
</span></span><span class="line"><span class="cl">  shortrevents; /*监控事件中满足条件返回的事件*/
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>它和 select 的主要区别就是，去掉了 select 只能监听 1024 个文件描述符的限制。</p>
<h3 id="epoll" class="headerLink">
    <a href="#epoll" class="header-mark"></a>epoll</h3><p>epoll 是最终的大 boss，它解决了 select 和 poll 的一些问题。</p>
<p>还记得上面说的 select 的三个细节么&#x2753;</p>
<ol>
<li>
<p>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>
</li>
<li>
<p>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p>
</li>
<li>
<p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）。</p>
</li>
</ol>
<p>所以 epoll 主要就是针对这三点进行了<strong>改进</strong>。</p>
<ol>
<li>
<p>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</p>
</li>
<li>
<p>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</p>
</li>
<li>
<p>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p>
</li>
</ol>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/epoll.gif" title="epoll" data-thumbnail="https://cdn.xiaobinqt.cn/epoll.gif" data-sub-html="<h2>epoll</h2><p>epoll</p>">
        
    </a><figcaption class="image-caption">epoll</figcaption>
    </figure></p>
<h3 id="小结" class="headerLink">
    <a href="#%e5%b0%8f%e7%bb%93" class="header-mark"></a>小结</h3><p>一切的开始，都起源于这个<code>read</code>函数是操作系统提供的，而且是阻塞的，我们叫它阻塞 IO。为了破这个局，程序员在用户态通过多线程来防止主线程卡死。</p>
<p>后来操作系统发现这个需求比较大，于是在操作系统层面提供了非阻塞的<code>read</code>函数，这样程序员就可以在一个线程内完成多个文件描述符的读取，这就是非阻塞 IO。</p>
<p>但多个文件描述符的读取就需要遍历，当高并发场景越来越多时，用户态遍历的文件描述符也越来越多，相当于在<code>while</code>循环里进行了越来越多的系统调用。</p>
<p>后来操作系统又发现这个场景需求量较大，于是又在操作系统层面提供了这样的遍历文件描述符的机制，这就是 IO 多路复用。</p>
<p>多路复用有三个函数，最开始是 select，然后又发明了 poll 解决了 select 文件描述符的限制，然后又发明了 epoll 解决 select 的三个不足。</p>
<p>所以，IO 模型的演进，其实就是时代的变化，倒逼着操作系统将更多的功能加到自己的内核而已。</p>
<p>如果你建立了这样的思维，很容易发现网上的一些错误。比如好多文章说，多路复用之所以效率高，是因为用一个线程就可以监控多个文件描述符。</p>
<p>这显然是知其然而不知其所以然，多路复用产生的效果，完全可以由用户态去遍历文件描述符并调用其非阻塞的 <code>read</code> 函数实现。而多路复用快的原因在于，操作系统提供了这样的系统调用，使得原来的 <code>while</code> 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符。就好比平时写业务代码，把原来 <code>while</code> 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后一次 rpc 请求就完成了批量添加。</p>
<h2 id="单线程的redis为什么快" class="headerLink">
    <a href="#%e5%8d%95%e7%ba%bf%e7%a8%8b%e7%9a%84redis%e4%b8%ba%e4%bb%80%e4%b9%88%e5%bf%ab" class="header-mark"></a>单线程的Redis为什么快</h2><ul>
<li>纯内存操作</li>
<li>单线程操作，避免了频繁的上下文切换</li>
<li>采用了非阻塞 I/O 多路复用机制</li>
</ul>
<p>Redis 作为一个内存服务器，它需要处理很多来自外部的网络请求，它使用 I/O 多路复用机制同时监听多个文件描述符的可读和可写状态，一旦收到网络请求就会在内存中快速处理，由于绝大多数的操作都是纯内存的，所以处理的速度会非常地快。</p>
<p>在 Redis 4.0 之后的版本，情况就有了一些变动，新版的 Redis 服务在执行一些命令时就会使用『主处理线程』之外的其他线程。虽然 Redis 在较新的版本中引入了多线程，不过是在<strong>部分命令</strong>上引入的，其中包括非阻塞的删除操作，在整体的架构设计上，主处理程序还是单线程模型的。</p>
<h3 id="单线程模型" class="headerLink">
    <a href="#%e5%8d%95%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b" class="header-mark"></a>单线程模型</h3><p>Redis 从一开始就选择使用单线程模型处理来自客户端的绝大多数网络请求，这种考虑其实是多方面的，其中最重要的几个原因如下&#x1f447;</p>
<ul>
<li>使用单线程模型能带来更好的可维护性，方便开发和调试；</li>
<li>使用单线程模型也能并发的处理客户端的请求；</li>
<li>Redis 服务中运行的绝大多数操作的性能瓶颈都不是 CPU；</li>
</ul>
<p>上述三个原因中的最后一个是最终使用单线程模型的决定性因素，其他的两个原因都是使用单线程模型额外带来的好处。</p>
<h3 id="可维护性" class="headerLink">
    <a href="#%e5%8f%af%e7%bb%b4%e6%8a%a4%e6%80%a7" class="header-mark"></a>可维护性</h3><p>可维护性对于一个项目来说非常重要，如果代码难以调试和测试，问题也经常难以复现，这对于任何一个项目来说都会严重地影响项目的可维护性。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，代码的执行过程不再是串行的，多个线程同时访问的变量如果没有谨慎处理就会带来诡异的问题。</p>
<p>引入了多线程，就必须要同时引入并发控制来保证在多个线程同时访问数据时程序行为的正确性，这就需要工程师额外维护并发控制的相关代码，例如，需要在可能被并发读写的变量上增加互斥锁。在访问这些变量或者内存之前也需要先对获取互斥锁，一旦忘记获取锁或者忘记释放锁就可能会导致各种诡异的问题，管理相关的并发控制机制也需要付出额外的研发成本和负担。</p>
<h3 id="性能瓶颈" class="headerLink">
    <a href="#%e6%80%a7%e8%83%bd%e7%93%b6%e9%a2%88" class="header-mark"></a>性能瓶颈</h3><p>多线程技术能够帮助我们充分利用 CPU 的计算资源来并发的执行不同的任务，但是 CPU 资源往往都不是 Redis 服务器的性能瓶颈。哪怕在一个普通的 Linux 服务器上启动 Redis 服务，它也能在 1s 的时间内处理 1,000,000 个用户请求。</p>
<p>Redis 并不是 CPU 密集型的服务，如果不开启 AOF 备份，所有 Redis 的操作都会在内存中完成不会涉及任何的 I/O 操作，这些数据的读写由于只发生在内存中，所以处理速度是非常快的；整个服务的瓶颈在于网络传输带来的延迟和等待客户端的数据传输，也就是网络 I/O，所以使用多线程模型处理全部的外部请求可能不是一个好的方案。</p>
<blockquote>
<p>AOF 是 Redis 的一种持久化机制，它会在每次收到来自客户端的写请求时，将其记录到日志中，每次 Redis 服务器启动时都会重放 AOF 日志构建原始的数据集，保证数据的持久性。</p>
</blockquote>
<p>多线程虽然会帮助我们更充分地利用 CPU 资源，但是操作系统上线程的切换也不是免费的，线程切换其实会带来额外的开销。频繁的对线程的上下文进行切换可能还会导致性能地急剧下降，这可能会导致我们不仅没有提升请求处理的平均速度，反而进行了负优化，所以这也是为什么 Redis 对于使用多线程技术非常谨慎。</p>
<h2 id="引入多线程" class="headerLink">
    <a href="#%e5%bc%95%e5%85%a5%e5%a4%9a%e7%ba%bf%e7%a8%8b" class="header-mark"></a>引入多线程</h2><p>对于 Redis 中的一些超大键值对，几十 MB 或者几百 MB 的数据并不能在几毫秒的时间内处理完，Redis 可能会需要在释放内存空间上消耗较多的时间，这些操作就会阻塞待处理的任务，然而释放内存空间的工作其实可以由后台线程异步进行处理，这也就是 <code>UNLINK</code> 命令的实现原理，它只会将键从元数据中删除，真正的删除操作会在后台异步执行。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://try.redis.io/" target="_blank" rel="noopener noreferrer">在线redis工具</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg%3D%3D&amp;idx=1&amp;mid=2665525639&amp;scene=21&amp;sn=d0881894cfeca626c4e6b0953a32810b" target="_blank" rel="noopener noreferrer">你管这破玩意叫 IO 多路复用？</a></li>
<li><a href="https://draveness.me/whys-the-design-redis-single-thread/" target="_blank" rel="noopener noreferrer">为什么 Redis 选择单线程模型</a></li>
<li><a href="https://www.jianshu.com/p/93ee56195c7d" target="_blank" rel="noopener noreferrer">Redis 常见问题总结</a></li>
</ul>
]]></description>
</item><item>
    <title>Redis 学习笔记</title>
    <link>https://www.xiaobinqt.cn/redis-glance-faq/</link>
    <pubDate>Sat, 20 Feb 2021 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/redis-glance-faq/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/2ecceb8af82e4695938c77dcc452eba2.png" referrerpolicy="no-referrer">
            </div><p>Redis 是一个使用 C 语言开发的数据库，与传统数据库不同的是 Redis 的数据是存在内存中的，我们把这种数据库叫做内存数据库。因为在内存中，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。</p>
<p>Redis 提供了多种数据类型来支持不同的业务场景，所以 Redis 除了做缓存之外，Redis 还经常用来做分布式锁，消息队列等。Redis 还支持事务、持久化、Lua 脚本、多集群方案。</p>
<h2 id="数据结构" class="headerLink">
    <a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="header-mark"></a>数据结构</h2><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/a4e1db3070d54256bc00ae5b8cedc654.png" title="Redis 五种数据结构" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/a4e1db3070d54256bc00ae5b8cedc654.png" data-sub-html="<h2>Redis 五种数据结构</h2><p>Redis 五种数据结构</p>">
        
    </a><figcaption class="image-caption">Redis 五种数据结构</figcaption>
    </figure></p>
<blockquote>
<p>在 Redis 中，所有的 key 都是字符串。</p>
</blockquote>
<h2 id="字符串" class="headerLink">
    <a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2" class="header-mark"></a>字符串</h2><p>字符串类型是 Redis 中最基本的数据类型，一个 key 对应一个 value。</p>
<p>字符串类型是二进制安全的，也就是说 Redis 中的字符串可以包含任何数据。如数字，字符串，jpg 图片或者序列化的对象。</p>
<h3 id="常用命令" class="headerLink">
    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4" class="header-mark"></a>常用命令</h3><ol>
<li>
<p>SET key value：设置指定 key 的值为给定的 value。</p>
</li>
<li>
<p>GET key：获取指定 key 的值。</p>
</li>
<li>
<p>DEL key：删除指定 key 及其对应的值。</p>
</li>
<li>
<p>INCR key：将指定 key 的值递增 1。</p>
</li>
<li>
<p>INCRBY key increment：将指定 key 的值增加指定的 increment 值。</p>
</li>
<li>
<p>DECR key：将指定 key 的值递减 1。</p>
</li>
<li>
<p>DECRBY key decrement：将指定 key 的值减去指定的 decrement 值。</p>
</li>
<li>
<p>APPEND key value：将给定的 value 追加到指定 key 的值的末尾。</p>
</li>
<li>
<p>STRLEN key：返回指定 key 的值的长度。</p>
</li>
<li>
<p>GETRANGE key start end：获取指定 key 的子字符串，从 start 到 end 的位置。</p>
</li>
<li>
<p>SETEX key seconds value：设置指定 key 的值，并指定过期时间（单位为秒）。</p>
</li>
<li>
<p>SETNX key value：只有当指定 key 不存在时，设置 key 的值为给定的 value。</p>
</li>
<li>
<p>MSET key value [key value &hellip;]：设置多个 key-value 对。</p>
</li>
<li>
<p>MGET key [key &hellip;]：获取多个 key 对应的值。</p>
</li>
<li>
<p>STRCMP key1 key2：比较两个字符串类型的 key 的值，如果相同返回 0，否则返回非 0 值。</p>
</li>
<li>
<p>GETSET key value：设置指定 key 的新值，并返回旧值。</p>
</li>
<li>
<p>SETBIT key offset value：设置或清除指定 key 偏移量上的位（bit）。</p>
</li>
<li>
<p>BITCOUNT key [start end]：统计指定 key 的值中，被设置为 1 的位的数量。</p>
</li>
<li>
<p>BITOP operation destkey key [key &hellip;]：对一个或多个 key 进行位操作，并将结果保存到 destkey 中。</p>
</li>
<li>
<p>SETRANGE key offset value：用指定的 value 替换指定 key 值从偏移量 offset 开始的子字符串。</p>
</li>
</ol>
<h2 id="hash" class="headerLink">
    <a href="#hash" class="header-mark"></a>Hash</h2><p>hash 值本身又是一种键值对结构：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/052cc436d66d4ace833d57b4a56b499b.png" title="hash" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/052cc436d66d4ace833d57b4a56b499b.png" data-sub-html="<h2>hash</h2><p>hash</p>">
        
    </a><figcaption class="image-caption">hash</figcaption>
    </figure></p>
<blockquote>
<p>所有 hash 的命令都是 h 开头，如 <code>hget</code>、<code>hset</code>、<code>hdel</code> 等</p>
</blockquote>
<h3 id="常用命令-1" class="headerLink">
    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-1" class="header-mark"></a>常用命令</h3><ol>
<li>
<p>HSET key field value：设置指定 key 中的 field 字段的值为 value。</p>
</li>
<li>
<p>HGET key field：获取指定 key 中的 field 字段的值。</p>
</li>
<li>
<p>HMSET key field value [field value &hellip;]：同时设置多个 field-value 对。</p>
</li>
<li>
<p>HMGET key field [field &hellip;]：获取指定 key 中多个字段的值。</p>
</li>
<li>
<p>HDEL key field [field &hellip;]：删除指定 key 中的一个或多个字段。</p>
</li>
<li>
<p>HLEN key：获取指定 key 中字段的数量。</p>
</li>
<li>
<p>HEXISTS key field：检查指定 key 是否存在指定的 field。</p>
</li>
<li>
<p>HINCRBY key field increment：将指定 key 中的 field 字段的值增加指定的 increment 值。</p>
</li>
<li>
<p>HINCRBYFLOAT key field increment：将指定 key 中的 field 字段的值增加指定的浮点数 increment 值。</p>
</li>
<li>
<p>HKEYS key：获取指定 key 中所有字段的名称。</p>
</li>
<li>
<p>HVALS key：获取指定 key 中所有字段的值。</p>
</li>
<li>
<p>HGETALL key：获取指定 key 中所有字段和对应的值，返回一个包含所有字段和值的列表。</p>
</li>
<li>
<p>HSTRLEN key field：获取指定 key 中指定 field 字段的值的长度。</p>
</li>
<li>
<p>HSCAN key cursor [MATCH pattern] [COUNT count]：迭代指定 key 中的 Hash 字段。</p>
</li>
</ol>
<h2 id="list" class="headerLink">
    <a href="#list" class="header-mark"></a>List</h2><p>List 就是链表（redis 使用双端链表实现的 List），是有序的，value可以重复，可以通过下标取出对应的 value 值，左右两边都能进行插入和删除数据。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/576c692e2a984a0ea9bab845ae6d7039.png" title="List" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/576c692e2a984a0ea9bab845ae6d7039.png" data-sub-html="<h2>List</h2><p>List</p>">
        
    </a><figcaption class="image-caption">List</figcaption>
    </figure></p>
<p>List 在 Redis 中是一个非常实用的数据结构，可以用于实现消息队列、任务队列、最新消息列表等场景。它的插入和删除操作都是常数时间复杂度，支持从两端进行操作，非常高效。</p>
<h3 id="常用命令-2" class="headerLink">
    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-2" class="header-mark"></a>常用命令</h3><ol>
<li>
<p>LPUSH key element [element &hellip;]：将一个或多个元素从列表的左侧插入（推入）。</p>
</li>
<li>
<p>RPUSH key element [element &hellip;]：将一个或多个元素从列表的右侧插入（推入）。</p>
</li>
<li>
<p>LPOP key：移除并获取列表的最左侧元素。</p>
</li>
<li>
<p>RPOP key：移除并获取列表的最右侧元素。</p>
</li>
<li>
<p>LINDEX key index：获取列表在给定索引上的元素。</p>
</li>
<li>
<p>LLEN key：获取列表的长度（元素数量）。</p>
</li>
<li>
<p>LRANGE key start stop：获取列表中指定范围内的元素，根据 start 和 stop 的索引位置获取。</p>
</li>
<li>
<p>LINSERT key BEFORE|AFTER pivot element：在列表中某个元素的前面或后面插入新的元素。</p>
</li>
<li>
<p>LSET key index element：将列表在给定索引上的元素设置为新的值。</p>
</li>
<li>
<p>LREM key count element：从列表中删除指定数量的元素。</p>
</li>
<li>
<p>LTRIM key start stop：修剪（截取）列表，只保留指定范围内的元素。</p>
</li>
<li>
<p>RPOPLPUSH source destination：将源列表中的最右侧元素弹出并推入目标列表的最左侧。</p>
</li>
<li>
<p>BLPOP key [key &hellip;] timeout：阻塞式地从多个列表的最左侧弹出元素。</p>
</li>
<li>
<p>BRPOP key [key &hellip;] timeout：阻塞式地从多个列表的最右侧弹出元素。</p>
</li>
<li>
<p>BRPOPLPUSH source destination timeout：阻塞式地将源列表中的最右侧元素弹出并推入目标列表的最左侧。</p>
</li>
<li>
<p>LLEN key：获取列表的长度（元素数量）。</p>
</li>
</ol>
<h3 id="使用技巧" class="headerLink">
    <a href="#%e4%bd%bf%e7%94%a8%e6%8a%80%e5%b7%a7" class="header-mark"></a>使用技巧</h3><ul>
<li><code>lpush</code> + <code>lpop</code> = Stack（栈）</li>
<li><code>lpush</code> + <code>rpop</code> = Queue（队列）</li>
<li><code>lpush</code> + <code>ltrim</code> = Capped Collection（有限集合）</li>
<li><code>lpush</code> + <code>brpop</code> = Message Queue（消息队列）</li>
</ul>
<h2 id="set" class="headerLink">
    <a href="#set" class="header-mark"></a>Set</h2><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/a0cf4be1efc5403290a055a92d3350ca.png" title="Set" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/a0cf4be1efc5403290a055a92d3350ca.png" data-sub-html="<h2>Set</h2><p>Set</p>">
        
    </a><figcaption class="image-caption">Set</figcaption>
    </figure></p>
<p>集合类型也是用来保存多个字符串的元素，但和列表有几个不同的点：</p>
<ul>
<li>&#x1f449; 不允许有重复的元素</li>
<li>&#x1f449; 集合中的元素是无序的，不能通过索引下标获取元素</li>
<li>&#x1f449; 支持集合间的操作，可以取多个集合取交集、并集、差集</li>
</ul>
<h3 id="常用命令-3" class="headerLink">
    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-3" class="header-mark"></a>常用命令</h3><ol>
<li>
<p>SADD key member [member &hellip;]：将一个或多个元素添加到集合中。</p>
</li>
<li>
<p>SMEMBERS key：获取集合中所有的成员（元素）。</p>
</li>
<li>
<p>SISMEMBER key member：检查一个元素是否是集合的成员。</p>
</li>
<li>
<p>SCARD key：获取集合的成员数量。</p>
</li>
<li>
<p>SREM key member [member &hellip;]：从集合中移除一个或多个元素。</p>
</li>
<li>
<p>SPOP key [count]：随机移除并获取集合中一个或多个元素。</p>
</li>
<li>
<p>SRANDMEMBER key [count]：随机获取集合中一个或多个元素，但不移除它们。</p>
</li>
<li>
<p>SMOVE source destination member：将一个元素从源集合移动到目标集合。</p>
</li>
<li>
<p>SINTER key [key &hellip;]：计算多个集合的交集。</p>
</li>
<li>
<p>SINTERSTORE destination key [key &hellip;]：将多个集合的交集存储到新的集合中。</p>
</li>
<li>
<p>SUNION key [key &hellip;]：计算多个集合的并集。</p>
</li>
<li>
<p>SUNIONSTORE destination key [key &hellip;]：将多个集合的并集存储到新的集合中。</p>
</li>
<li>
<p>SDIFF key [key &hellip;]：计算多个集合的差集。</p>
</li>
<li>
<p>SDIFFSTORE destination key [key &hellip;]：将多个集合的差集存储到新的集合中。</p>
</li>
<li>
<p>SSCAN key cursor [MATCH pattern] [COUNT count]：迭代集合中的元素。</p>
</li>
</ol>
<h2 id="zset" class="headerLink">
    <a href="#zset" class="header-mark"></a>ZSet</h2><p>有序集合和集合有着必然的联系，保留了集合不能有重复成员的特性。</p>
<p>区别是，有序集合中的<strong>元素是可以排序的</strong>，它给每个元素设置一个分数，作为排序的依据。</p>
<blockquote>
<p>有序集合中的元素不可以重复，但是 score 分数可以重复，就和一个班里的同学学号不能重复，但考试成绩可以相同。</p>
</blockquote>
<h3 id="常用命令-4" class="headerLink">
    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-4" class="header-mark"></a>常用命令</h3><ol>
<li>
<p>ZADD key score member [score member &hellip;]：将一个或多个成员及其对应的分数添加到有序集合中。</p>
</li>
<li>
<p>ZRANGE key start stop [WITHSCORES]：按照元素的分数从低到高，获取有序集合中指定范围内的元素。如果使用 WITHSCORES 参数，还会返回元素的分数。</p>
</li>
<li>
<p>ZREVRANGE key start stop [WITHSCORES]：按照元素的分数从高到低，获取有序集合中指定范围内的元素。如果使用 WITHSCORES 参数，还会返回元素的分数。</p>
</li>
<li>
<p>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]：根据分数范围获取有序集合中的元素。可以指定最小和最大分数，并可选地使用 WITHSCORES 参数返回元素的分数，也可以使用 LIMIT 参数限制结果数量。</p>
</li>
<li>
<p>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]：根据分数范围从高到低获取有序集合中的元素。</p>
</li>
<li>
<p>ZCOUNT key min max：统计有序集合中分数在给定范围内的元素数量。</p>
</li>
<li>
<p>ZCARD key：获取有序集合中元素的数量。</p>
</li>
<li>
<p>ZSCORE key member：获取有序集合中指定成员的分数。</p>
</li>
<li>
<p>ZINCRBY key increment member：为有序集合中的指定成员增加分数。</p>
</li>
<li>
<p>ZREM key member [member &hellip;]：从有序集合中移除一个或多个成员。</p>
</li>
<li>
<p>ZREMRANGEBYRANK key start stop：根据元素在有序集合中的排名范围，移除元素。</p>
</li>
<li>
<p>ZREMRANGEBYSCORE key min max：根据分数范围，移除有序集合中的元素。</p>
</li>
<li>
<p>ZRANK key member：获取有序集合中指定成员的排名（从低到高）。</p>
</li>
<li>
<p>ZREVRANK key member：获取有序集合中指定成员的排名（从高到低）。</p>
</li>
<li>
<p>ZSCAN key cursor [MATCH pattern] [COUNT count]：迭代有序集合中的元素。</p>
</li>
</ol>
<h2 id="faq" class="headerLink">
    <a href="#faq" class="header-mark"></a>FAQ</h2><h3 id="分布式缓存" class="headerLink">
    <a href="#%e5%88%86%e5%b8%83%e5%bc%8f%e7%bc%93%e5%ad%98" class="header-mark"></a>分布式缓存</h3><p>分布式缓存主要解决的是<strong>单机缓存的容量受服务器限制并且无法保存通用的信息</strong>
，因为，本地缓存只在当前服务里有效。比如部署了两个相同的服务，他们两者之间的缓存数据是无法共同的。</p>
<p>分布式缓存的话，使用的较多的较多的解决方案是是 Memcached 和 Redis。不过，随着近些年 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 而放弃 Memcached。</p>
<h3 id="redis-和-memcached-的区别" class="headerLink">
    <a href="#redis-%e5%92%8c-memcached-%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-mark"></a>Redis 和 Memcached 的区别</h3><h4 id="共同点" class="headerLink">
    <a href="#%e5%85%b1%e5%90%8c%e7%82%b9" class="header-mark"></a>共同点</h4><ul>
<li>都是基于内存的数据库。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ul>
<h4 id="区别" class="headerLink">
    <a href="#%e5%8c%ba%e5%88%ab" class="header-mark"></a>区别</h4><ul>
<li>Redis 支持更丰富的数据类型，也就是说可以支持更复杂的应用场景。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 <code>list</code>，<code>set</code>，<code>zset</code>，<code>hash</code> 等数据结构的存储。而 Memcached
<strong>只支持</strong>最简单的 k/v 数据类型。</li>
<li>Redis 的容灾更好，支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memecache 把数据全部存在内存中。</li>
<li>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据，但是 Redis 目前是原生支持 cluster 模式的。</li>
<li>&#x26a0;&#xfe0f;Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。而 Memcached 在服务器内存使用完之后，就会直接报异常。</li>
<li>Memcached 是多线程，非阻塞 IO 复用的网络模型，Redis 使用单线程的多路 IO 复用模型（Redis 6.0 引入了多线程 IO ）。</li>
<li>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</li>
<li>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。</li>
</ul>
<h3 id="redis-如何判断数据是否过期" class="headerLink">
    <a href="#redis-%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e6%95%b0%e6%8d%ae%e6%98%af%e5%90%a6%e8%bf%87%e6%9c%9f" class="header-mark"></a>Redis 如何判断数据是否过期</h3><p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个key（键），过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<h3 id="过期删除策略" class="headerLink">
    <a href="#%e8%bf%87%e6%9c%9f%e5%88%a0%e9%99%a4%e7%ad%96%e7%95%a5" class="header-mark"></a>过期删除策略</h3><p>如果 Redis 中一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p>
<ul>
<li>惰性删除：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是<strong>可能会造成太多过期 key 没有被删除</strong>。</li>
<li>定期删除：每隔一段时间抽取一批 key 执行删除过期 key 操作。Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ul>
<p><strong>定期删除对内存更加友好，惰性删除对 CPU 更加友好</strong>。Redis 采用的是定期删除&#x2795;惰性删除。</p>
<h3 id="内存淘汰机制" class="headerLink">
    <a href="#%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0%e6%9c%ba%e5%88%b6" class="header-mark"></a>内存淘汰机制</h3><p>我们通过给 key 设置过期时间还是有问题的，因为还是可能存在定期删除和惰性删除<strong>漏掉</strong>
了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 OOM 了，Redis 的数据淘汰机制可以解决这个问题。</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>volatile-lru</code></td>
<td>（least recently used），从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td><code>volatile-ttl</code></td>
<td>从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选将要过期的数据淘汰</td>
</tr>
<tr>
<td><code>volatile-random</code></td>
<td>从已设置过期时间的数据集（<code>server.db[i].expires</code>）中任意选择数据淘汰</td>
</tr>
<tr>
<td><code>allkeys-lru</code></td>
<td>（least recently used），当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</td>
</tr>
<tr>
<td><code>allkeys-random</code></td>
<td>从数据集（<code>server.db[i].dict</code>）中任意选择数据淘汰</td>
</tr>
<tr>
<td><code>no-eviction</code></td>
<td>禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错&#x1f631;。</td>
</tr>
<tr>
<td><code>volatile-lfu</code></td>
<td>（least frequently used），从已设置过期时间的数据集(<code>server.db[i].expires</code>)中挑选最不经常使用的数据淘汰</td>
</tr>
<tr>
<td><code>allkeys-lfu</code></td>
<td>（least frequently used），当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</td>
</tr>
</tbody>
</table>
<blockquote>
<p>LRU 是基于最近的<strong>访问时间</strong>来淘汰键，即淘汰最近最少被使用的键。</p>
<p>LFU 是基于<strong>访问频率</strong>来淘汰键，即淘汰访问次数最少的键。</p>
</blockquote>
<h3 id="持久化机制" class="headerLink">
    <a href="#%e6%8c%81%e4%b9%85%e5%8c%96%e6%9c%ba%e5%88%b6" class="header-mark"></a>持久化机制</h3><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了备份数据，比如为了防止系统故障而将数据备份到一个另一台机器。</p>
<p>Redis 两种不同的持久化操作。一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）。</p>
<h4 id="rdb" class="headerLink">
    <a href="#rdb" class="header-mark"></a>RDB</h4><p>快照持久化是 Redis <strong>默认采用</strong>的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">save 900 1     # 在 900 秒(15分钟)之后，如果至少有 1 个 key 发生变化，Redis 就会自动触发 BGSAVE 命令创建快照。
</span></span><span class="line"><span class="cl">save 300 10    # 在 300 秒(5分钟)之后，如果至少有 10 个key发生变化，Redis 就会自动触发 BGSAVE 命令创建快照。
</span></span><span class="line"><span class="cl">save 60 10000  # 在 60 秒(1分钟)之后，如果至少有 10000 个key发生变化，Redis 就会自动触发 BGSAVE 命令创建快照。
</span></span></code></pre></td></tr></table>
</div>
</div><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。</p>
<p>Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本，还可以将快照留在原地以便重启服务器的时候使用。</p>
<h4 id="aof" class="headerLink">
    <a href="#aof" class="header-mark"></a>AOF</h4><p>与快照持久化 RDB 相比，AOF 持久化 的<strong>实时性更好</strong>，基本已成为主流的持久化方案。<strong>默认情况下 Redis 没有开启 AOF方式的持久化</strong>。</p>
<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。</p>
<p>Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">appendfsync always    # 每次有数据修改发生时都会写入 AOF 文件,这样会严重降低 Redis 的速度
</span></span><span class="line"><span class="cl">appendfsync everysec  # 每秒同步一次，显示地将多个写命令同步到硬盘
</span></span><span class="line"><span class="cl">appendfsync no        # 让操作系统决定何时进行同步
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>为了兼顾数据和写入性能，可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。
这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。</p>
</blockquote>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="http://redisdoc.com/index.html" target="_blank" rel="noopener noreferrer">Redis 命令参考</a></li>
<li><a href="https://www.cnblogs.com/haoprogrammer/p/11065461.html" target="_blank" rel="noopener noreferrer">Redis(一)、Redis五种数据结构</a></li>
<li><a href="https://blog.csdn.net/weixin_43230682/category_10241824.html" target="_blank" rel="noopener noreferrer">Redis</a></li>
</ul>
]]></description>
</item></channel>
</rss>
