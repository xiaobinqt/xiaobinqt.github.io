<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Session - 标签 - xiaobinqt 博客 - 技术改变生活</title>
        <link>https://www.xiaobinqt.cn/tags/session/</link>
        <description>Session - 标签 - xiaobinqt 博客 - 技术改变生活</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaobinqt@163.com (xiaobinqt)</managingEditor>
            <webMaster>xiaobinqt@163.com (xiaobinqt)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 11 Jun 2022 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://www.xiaobinqt.cn/tags/session/" rel="self" type="application/rss+xml" /><item>
    <title>session cookie token 的区别</title>
    <link>https://www.xiaobinqt.cn/session-cookie-token-difference/</link>
    <pubDate>Sat, 11 Jun 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/session-cookie-token-difference/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220824/ee39a9cb19524d918d984db89b1661a5.png" referrerpolicy="no-referrer">
            </div><!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="cookie-和-session" class="headerLink">
    <a href="#cookie-%e5%92%8c-session" class="header-mark"></a>Cookie 和 Session</h2><p>HTTP 协议是一种<code>无状态协议</code>，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录；Session 和 Cookie 的主要目的就是为了弥补 HTTP 的无状态特性。</p>
<h3 id="session-是什么" class="headerLink">
    <a href="#session-%e6%98%af%e4%bb%80%e4%b9%88" class="header-mark"></a>Session 是什么</h3><p>客户端请求服务端，服务端会为这次请求开辟一块<code>内存空间</code>，这个对象便是 Session 对象，存储结构为 <code>ConcurrentHashMap</code>。Session 弥补了 HTTP 无状态特性，服务器可以利用 Session 存储客户端在同一个会话期间的一些操作记录。</p>
<h3 id="session-如何判断是否是同一会话" class="headerLink">
    <a href="#session-%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e6%98%af%e5%90%a6%e6%98%af%e5%90%8c%e4%b8%80%e4%bc%9a%e8%af%9d" class="header-mark"></a>Session 如何判断是否是同一会话</h3><p>服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 <code>sessionId</code> ，并通过响应头的 <strong>Set-Cookie：JSESSIONID=XXXXXXX</strong> 命令，向客户端发送要求设置 Cookie 的响应；客户端收到响应后，在本机客户端设置了一个 <strong>JSESSIONID=XXXXXXX</strong> 的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220824/50c3ccd67e62465ab1beaa691995ed06.png" title="会话" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220824/50c3ccd67e62465ab1beaa691995ed06.png" data-sub-html="<h2>会话</h2><p>会话</p>">
        
    </a><figcaption class="image-caption">会话</figcaption>
    </figure></p>
<p>接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie 信息（包含 sessionId ），然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。</p>
<h3 id="session-的缺点" class="headerLink">
    <a href="#session-%e7%9a%84%e7%bc%ba%e7%82%b9" class="header-mark"></a>Session 的缺点</h3><p>Session 机制有个缺点，比如 A 服务器存储了 Session，就是做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。</p>
<h3 id="cookies-是什么" class="headerLink">
    <a href="#cookies-%e6%98%af%e4%bb%80%e4%b9%88" class="header-mark"></a>Cookies 是什么</h3><p>HTTP 协议中的 Cookie 包括 <code>Web Cookie</code> 和<code>浏览器 Cookie</code>，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。</p>
<blockquote>
<p>HTTP Cookie 机制是 HTTP 协议无状态的一种补充和改良</p>
</blockquote>
<p>Cookie 主要用于下面三个目的</p>
<ul>
<li><code>会话管理</code></li>
</ul>
<p>登陆、购物车、游戏得分或者服务器应该记住的其他内容</p>
<ul>
<li><code>个性化</code></li>
</ul>
<p>用户偏好、主题或者其他设置</p>
<ul>
<li><code>追踪</code></li>
</ul>
<p>记录和分析用户行为</p>
<p>Cookie 曾经用于一般的客户端存储。虽然这是合法的，因为它们是在客户端上存储数据的唯一方法，但如今建议使用现代存储 API。Cookie 随每个请求一起发送，因此它们<strong>可能会降低性能</strong>（尤其是对于移动数据连接而言）。</p>
<h3 id="创建-cookie" class="headerLink">
    <a href="#%e5%88%9b%e5%bb%ba-cookie" class="header-mark"></a>创建 Cookie</h3><p>当接收到客户端发出的 HTTP 请求时，服务器可以发送带有响应的 <code>Set-Cookie</code> 标头，Cookie 通常由浏览器存储，然后将 Cookie 与 HTTP 标头一同向服务器发出请求。</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Max-Age</code></td>
<td>设置 cookie 的过期时间，单位为秒</td>
</tr>
<tr>
<td><code>Domain</code></td>
<td>指定了 Cookie 所属的域名</td>
</tr>
<tr>
<td><code>Path</code></td>
<td>指定了 Cookie 所属的路径</td>
</tr>
<tr>
<td><code>HttpOnly</code></td>
<td>告诉浏览器此 Cookie 只能靠浏览器 Http 协议传输,禁止其他方式访问</td>
</tr>
<tr>
<td><code>Secure</code></td>
<td>告诉浏览器此 Cookie 只能在 Https 安全协议中传输,如果是 Http 则禁止传输</td>
</tr>
</tbody>
</table>
<h4 id="set-cookie-和-cookie-标头" class="headerLink">
    <a href="#set-cookie-%e5%92%8c-cookie-%e6%a0%87%e5%a4%b4" class="header-mark"></a>Set-Cookie 和 Cookie 标头</h4><p><code>Set-Cookie</code> HTTP 响应标头将 cookie 从服务器发送到用户代理。下面是一个发送 Cookie 的例子</p>
<p><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/68ec0f0d662d4a8ea816a2e4b1f301e3.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/68ec0f0d662d4a8ea816a2e4b1f301e3.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/68ec0f0d662d4a8ea816a2e4b1f301e3.png">
        
    </a></p>
<p>此标头告诉客户端存储 Cookie</p>
<p>现在，随着对服务器的每个新请求，浏览器将使用 Cookie 头将所有以前存储的 Cookie 发送回服务器。</p>
<p><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/88919b06618940d9b5c0bae71d0cfb86.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/88919b06618940d9b5c0bae71d0cfb86.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/88919b06618940d9b5c0bae71d0cfb86.png">
        
    </a></p>
<p>有两种类型的 Cookies，一种是 <strong><ruby>Session Cookies<rt>会话 cookie</rt></ruby></strong>，一种是 <strong><ruby>Persistent Cookies<rt>永久 cookie</rt></ruby></strong>，如果 Cookie 不包含到期日期，则将其视为会话 Cookie。会话 Cookie 存储在内存中，永远不会写入磁盘，当浏览器关闭时，此后 Cookie 将永久丢失。如果 Cookie 包含<code>有效期</code> ，则将其视为持久性 Cookie。在到期指定的日期，Cookie 将从磁盘中删除。</p>
<p>还有一种是 Cookie 的 <code>Secure</code> 和 <code>HttpOnly</code> 标记。</p>
<h4 id="会话-cookies" class="headerLink">
    <a href="#%e4%bc%9a%e8%af%9d-cookies" class="header-mark"></a>会话 Cookies</h4><p>上面的示例创建的是会话 Cookie ，会话 Cookie 有个特征，客户端关闭时 Cookie 会删除，因为它<strong>没有指定</strong><code>Expires</code>或 <code>Max-Age</code> 指令。</p>
<p>但是，Web 浏览器可能会使用会话还原，这会使大多数会话 Cookie 保持永久状态，就像从未关闭过浏览器一样。</p>
<h4 id="永久性-cookies" class="headerLink">
    <a href="#%e6%b0%b8%e4%b9%85%e6%80%a7-cookies" class="header-mark"></a>永久性 Cookies</h4><p>永久性 Cookie 不会在客户端关闭时过期，而是在<code>特定日期（Expires）</code>或<code>特定时间长度（Max-Age）</code>外过期。例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="cookie-的-secure-和-httponly-标记" class="headerLink">
    <a href="#cookie-%e7%9a%84-secure-%e5%92%8c-httponly-%e6%a0%87%e8%ae%b0" class="header-mark"></a>Cookie 的 Secure 和 HttpOnly 标记</h4><p>安全的 Cookie 需要经过 HTTPS 协议通过加密的方式发送到服务器。即使是安全的，也不应该将敏感信息存储在cookie 中，因为它们本质上是不安全的，并且此标志不能提供真正的保护。</p>
<p><strong>HttpOnly 的作用</strong></p>
<ul>
<li>
<p>会话 Cookie 中缺少 HttpOnly 属性会导致攻击者可以通过程序( JS 脚本、Applet 等)获取到用户的 Cookie 信息，造成用户 Cookie 信息泄露，增加攻击者的跨站脚本攻击威胁。</p>
</li>
<li>
<p>HttpOnly 是微软对 Cookie 做的扩展，该值指定 Cookie 是否可通过客户端脚本访问。</p>
</li>
<li>
<p>如果在 Cookie 中<strong>没有设置</strong> <code>HttpOnly</code> 属性为 true，可能导致 Cookie 被窃取。窃取的 Cookie 可以包含标识站点用户的敏感信息，如 ASP.NET 会话 ID 或 Forms 身份验证票证，攻击者可以重播窃取的 Cookie，以便伪装成用户或获取敏感信息，进行跨站脚本攻击等。</p>
</li>
</ul>
<h3 id="cookie-的作用域" class="headerLink">
    <a href="#cookie-%e7%9a%84%e4%bd%9c%e7%94%a8%e5%9f%9f" class="header-mark"></a>Cookie 的作用域</h3><p><code>Domain</code> 和 <code>Path</code> 标识定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。</p>
<p><code>Domain</code> 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前主机(<strong>不包含子域名</strong>）。如果指定了<code>Domain</code>，则一般包含子域名。</p>
<p>例如，如果设置 <code>Domain=mozilla.org</code>，则 Cookie 也包含在子域名中（如<code>developer.mozilla.org</code>）。</p>
<p>例如，设置 <code>Path=/docs</code>，则以下地址都会匹配：</p>
<ul>
<li><code>/docs</code></li>
<li><code>/docs/Web/</code></li>
<li><code>/docs/Web/HTTP</code></li>
</ul>
<h2 id="json-web-token-和-session-cookies-的对比" class="headerLink">
    <a href="#json-web-token-%e5%92%8c-session-cookies-%e7%9a%84%e5%af%b9%e6%af%94" class="header-mark"></a>JSON Web Token 和 Session Cookies 的对比</h2><p><code>JSON Web Token</code>，简称 <code>JWT</code>，它和 <code>Session</code>都可以为网站提供用户的身份认证，但是它们不是一回事。</p>
<h3 id="jwt-和-session-cookies-的相同之处" class="headerLink">
    <a href="#jwt-%e5%92%8c-session-cookies-%e7%9a%84%e7%9b%b8%e5%90%8c%e4%b9%8b%e5%a4%84" class="header-mark"></a>JWT 和 Session Cookies 的相同之处</h3><p>在探讨 JWT 和 Session Cookies 之前，有必要需要先去理解一下它们的相同之处。</p>
<p>它们既可以对用户进行身份验证，也可以用来在用户单击进入不同页面时以及登陆网站或应用程序后进行身份验证。</p>
<p>如果没有这两者，那你可能需要在每个页面切换时都需要进行登录了。因为 HTTP 是一个无状态的协议。这也就意味着当你访问某个网页，然后单击同一站点上的另一个页面时，服务器的<code>内存中</code>将不会记住你之前的操作。</p>
<p><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/dcc63c8881794018b714769f214547c3.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/dcc63c8881794018b714769f214547c3.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/dcc63c8881794018b714769f214547c3.png">
        
    </a></p>
<p>因此，如果你登录并访问了你有权访问的另一个页面，由于 HTTP 不会记录你刚刚登录的信息，因此你将再次登录。</p>
<p><strong>JWT 和 Session Cookies 就是用来处理在不同页面之间切换，保存用户登录信息的机制</strong>。</p>
<p>也就是说，这两种技术都是<strong>用来保存你的登录状态</strong>，能够让你在浏览任意受密码保护的网站。通过在每次产生新的请求时对用户数据进行身份验证来解决此问题。</p>
<p>所以 JWT 和 Session Cookies 的相同之处是什么？那就是它们能够支持你在发送不同请求之间，记录并验证你的登录状态的一种机制。</p>
<h3 id="什么是-session-cookies" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-session-cookies" class="header-mark"></a>什么是 Session Cookies</h3><p>Session Cookies 也称为<code>会话 Cookies</code>，在 Session Cookies 中，用户的登录状态会保存在<code>服务器</code>的<code>内存</code>中。当用户登录时，Session 就被服务端安全的创建。</p>
<p>在每次请求时，服务器都会从会话 Cookie 中读取 SessionId，如果服务端的数据和读取的 SessionId 相同，那么服务器就会发送响应给浏览器，允许用户登录。</p>
<p>&#x26a0;&#xfe0f; 下图有点问题，域名应该一致。</p>
<p><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/7de5d6b609354be5b1a8346b66e2643d.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/7de5d6b609354be5b1a8346b66e2643d.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/7de5d6b609354be5b1a8346b66e2643d.png">
        
    </a></p>
<h3 id="什么是-json-web-tokens" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-json-web-tokens" class="header-mark"></a>什么是 Json Web Tokens</h3><p>Json Web Token 的简称就是 JWT，通常可以称为 <code>Json 令牌</code>。它是<code>RFC 7519</code> 中定义的用于<code>安全的</code>将信息作为 <code>Json 对象</code>进行传输的一种形式。JWT 中存储的信息是经过<code>数字签名</code>的，因此可以被信任和理解。可以使用 HMAC 算法或使用 RSA/ECDSA 的公用/专用密钥对 JWT 进行签名。</p>
<p>使用 JWT 主要用来下面两点</p>
<ul>
<li>
<p><code>认证(Authorization)</code>：这是使用 JWT 最常见的一种情况，一旦用户登录，后面每个请求都会包含 JWT，从而允许用户访问该令牌所允许的路由、服务和资源。<code>单点登录</code>是当今广泛使用 JWT 的一项功能，因为它的开销很小。</p>
</li>
<li>
<p><code>信息交换(Information Exchange)</code>：JWT 是能够安全传输信息的一种方式。通过使用公钥/私钥对 JWT 进行签名认证。此外，由于签名是使用 <code>head</code> 和 <code>payload</code>计算的，因此你还可以验证内容是否遭到篡改。</p>
</li>
</ul>
<h4 id="jwt-的格式" class="headerLink">
    <a href="#jwt-%e7%9a%84%e6%a0%bc%e5%bc%8f" class="header-mark"></a>JWT 的格式</h4><p>下面，我们会探讨一下 JWT 的组成和格式是什么</p>
<p>JWT 主要由三部分组成，每个部分用 <code>.</code> 进行分割，各个部分分别是</p>
<ul>
<li><code>Header</code></li>
<li><code>Payload</code></li>
<li><code>Signature</code></li>
</ul>
<p>因此，一个非常简单的 JWT 组成会是下面这样</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/e32110689a834f6b86911766f9080ad3.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/e32110689a834f6b86911766f9080ad3.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/e32110689a834f6b86911766f9080ad3.png" data-sub-html="<h2>JWT 组成</h2>">
        
    </a><figcaption class="image-caption">JWT 组成</figcaption>
    </figure></p>
<p><strong>Header</strong></p>
<p>Header 是 JWT 的标头，它通常由两部分组成：<code>令牌的类型(即 JWT)</code>和使用的 <code>签名算法</code>，例如 <code>HMAC SHA256</code>（写成 HS256） 或 <code>RSA</code>。</p>
<p>例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;alg&#34;: &#34;HS256&#34;,
</span></span><span class="line"><span class="cl">  &#34;typ&#34;: &#34;JWT&#34;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>指定类型和签名算法后，Json 块被 <code>Base64Url</code> 编码形成 JWT 的第一部分。</p>
<p><strong>Payload</strong></p>
<p>Token 的第二部分是 <code>Payload</code>，Payload 中包含一个声明。声明是有关实体（通常是用户）和其他数据的声明。共有三种类型的声明：<strong><code>registered</code>, <code>public</code> 和 <code>private</code></strong> 声明。</p>
<ul>
<li><code>registered 声明</code>： 包含一组建议使用的预定义声明，主要包括</li>
</ul>
<table>
<thead>
<tr>
<th>ISS</th>
<th>签发人</th>
</tr>
</thead>
<tbody>
<tr>
<td>iss (issuer)</td>
<td>签发人</td>
</tr>
<tr>
<td>exp (expiration time)</td>
<td>过期时间</td>
</tr>
<tr>
<td>sub (subject)</td>
<td>主题</td>
</tr>
<tr>
<td>aud (audience)</td>
<td>受众</td>
</tr>
<tr>
<td>nbf (Not Before)</td>
<td>生效时间</td>
</tr>
<tr>
<td>iat (Issued At)</td>
<td>签发时间</td>
</tr>
<tr>
<td>jti (JWT ID)</td>
<td>编号</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>public 声明</code>：公共的声明，可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密。</p>
</li>
<li>
<p><code>private 声明</code>：自定义声明，旨在在同意使用它们的各方之间共享信息，既不是注册声明也不是公共声明。</p>
</li>
</ul>
<p>例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;sub&#34;: &#34;1234567890&#34;,
</span></span><span class="line"><span class="cl">  &#34;name&#34;: &#34;John Doe&#34;,
</span></span><span class="line"><span class="cl">  &#34;admin&#34;: true
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后 payload Json 块会被<code>Base64Url</code> 编码形成 JWT 的第二部分。</p>
<p><strong>signature</strong></p>
<p>JWT 的第三部分是一个签证信息，这个签证信息由三部分组成</p>
<ul>
<li>header (base64后的)</li>
<li>payload (base64后的)</li>
<li>secret</li>
</ul>
<p>比如我们需要 HMAC SHA256 算法进行签名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">HMACSHA256</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">base64UrlEncode</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&#34;.&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">  <span class="n">base64UrlEncode</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="n">secret</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>签名用于验证消息在此过程中没有更改，并且对于使用私钥进行签名的令牌，它还可以验证 JWT 的发送者的真实身份</p>
<h4 id="拼凑在一起" class="headerLink">
    <a href="#%e6%8b%bc%e5%87%91%e5%9c%a8%e4%b8%80%e8%b5%b7" class="header-mark"></a>拼凑在一起</h4><p>现在我们把上面的三个由点分隔的 Base64-URL 字符串部分组成在一起，这个字符串可以在 HTML 和 HTTP 环境中轻松传递这些字符串。</p>
<p>下面是一个完整的 JWT 示例，它对 header 和 payload 进行编码，然后使用 signature 进行签名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
</span></span></code></pre></td></tr></table>
</div>
</div><p><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/00f5b92c8950490fa0d836e532dff8d0.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/00f5b92c8950490fa0d836e532dff8d0.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20231009/00f5b92c8950490fa0d836e532dff8d0.png">
        
    </a></p>
<p>如果想自己测试编写的话，可以访问 JWT 官网 <a href="https://jwt.io/#debugger-io" target="_blank" rel="noopener noreferrer">https://jwt.io/#debugger-io</a></p>
<h3 id="jwt-和-session-cookies-的不同" class="headerLink">
    <a href="#jwt-%e5%92%8c-session-cookies-%e7%9a%84%e4%b8%8d%e5%90%8c" class="header-mark"></a>JWT 和 Session Cookies 的不同</h3><p>JWT 和 Session Cookies 都提供安全的用户身份验证，但是它们有以下几点不同</p>
<h4 id="密码签名" class="headerLink">
    <a href="#%e5%af%86%e7%a0%81%e7%ad%be%e5%90%8d" class="header-mark"></a>密码签名</h4><p>JWT 具有加密签名，而 Session Cookies 则没有。</p>
<h4 id="json-是无状态的" class="headerLink">
    <a href="#json-%e6%98%af%e6%97%a0%e7%8a%b6%e6%80%81%e7%9a%84" class="header-mark"></a>JSON 是无状态的</h4><p>JWT 是<code>无状态</code>的，因为声明被存储在<code>客户端</code>，而不是服务端内存中。</p>
<p>身份验证可以在<code>本地</code>进行，而不是在请求必须通过服务器数据库或类似位置中进行。 这意味着可以对用户进行多次身份验证，而无需与站点或应用程序的数据库进行通信，也无需在此过程中消耗大量资源。</p>
<h4 id="可扩展性" class="headerLink">
    <a href="#%e5%8f%af%e6%89%a9%e5%b1%95%e6%80%a7" class="header-mark"></a>可扩展性</h4><p>Session Cookies 是存储在服务器内存中，这就意味着如果网站或者应用很大的情况下会耗费大量的资源。由于 JWT 是无状态的，在许多情况下，它们可以节省服务器资源。因此 JWT 要比 Session Cookies 具有更强的<code>可扩展性</code>。</p>
<h4 id="jwt-支持跨域认证" class="headerLink">
    <a href="#jwt-%e6%94%af%e6%8c%81%e8%b7%a8%e5%9f%9f%e8%ae%a4%e8%af%81" class="header-mark"></a>JWT 支持跨域认证</h4><p>Session Cookies 只能用在<code>单个节点的域</code>或者它的<code>子域</code>中有效。如果它们尝试通过第三个节点访问，就会被禁止。如果你希望自己的网站和其他站点建立安全连接时，这是一个问题。</p>
<p>使用 JWT 可以解决这个问题，使用 JWT 能够通过<code>多个节点</code>进行用户认证，也就是我们常说的<code>跨域认证</code>。</p>
<h3 id="jwt-和-session-cookies-的选型" class="headerLink">
    <a href="#jwt-%e5%92%8c-session-cookies-%e7%9a%84%e9%80%89%e5%9e%8b" class="header-mark"></a>JWT 和 Session Cookies 的选型</h3><p>我们上面探讨了 JWT 和 Cookies 的不同点，相信你也会对选型有了更深的认识，大致来说</p>
<p>对于只需要登录用户并访问存储在站点数据库中的一些信息的中小型网站来说，Session Cookies 通常就能满足。</p>
<p>如果你有企业级站点，应用程序或附近的站点，并且需要处理大量的请求，尤其是第三方或很多第三方（包括位于不同域的API），则 JWT 显然更适合。</p>
<h2 id="jwt-解码" class="headerLink">
    <a href="#jwt-%e8%a7%a3%e7%a0%81" class="header-mark"></a>JWT 解码</h2><p>JWT（JSON Web Token）的解码包括以下步骤：</p>
<ol>
<li>
<p>将 JWT 字符串分为头部、负载和签名三个部分。</p>
</li>
<li>
<p>使用 Base64URL 解码头部和负载，以获取原始的 JSON 数据。</p>
</li>
<li>
<p>使用头部中的算法信息（通常在 <code>alg</code> 字段中）来验证签名。在这种情况下，头部指定了使用 HS256 算法，这意味着需要使用相同的密钥对头部和负载部分进行签名，并验证签名是否匹配。</p>
</li>
</ol>
<p>以下是使用 Golang 进行 JWT 解码的示例代码，不使用第三方包，但假设你已经有了密钥。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;encoding/base64&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;encoding/json&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strings&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义JWT结构体来解析头部和负载
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">JWT</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Header</span>    <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Payload</span>   <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Signature</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 要解码的JWT字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">jwtString</span> <span class="o">:=</span> <span class="s">&#34;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2OTY5MDY5MTcsInVzZXJfaWQiOjF9.-CGzj1oGoQtk3PfY1ppkzGkaArGbvNX5eQIkKNGR4EE&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 使用点号分割JWT字符串，得到头部、负载和签名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">parts</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">jwtString</span><span class="p">,</span> <span class="s">&#34;.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">parts</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Invalid JWT format&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 解码头部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">headerJSON</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">base64</span><span class="p">.</span><span class="nx">RawURLEncoding</span><span class="p">.</span><span class="nf">DecodeString</span><span class="p">(</span><span class="nx">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Error decoding header:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 解码负载
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">payloadJSON</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">base64</span><span class="p">.</span><span class="nx">RawURLEncoding</span><span class="p">.</span><span class="nf">DecodeString</span><span class="p">(</span><span class="nx">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Error decoding payload:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 解码头部和负载中的JSON数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">headerData</span><span class="p">,</span> <span class="nx">payloadData</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">headerJSON</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">headerData</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Error unmarshaling header:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">payloadJSON</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">payloadData</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Error unmarshaling payload:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 解析签名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">signature</span> <span class="o">:=</span> <span class="nx">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建JWT结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">jwt</span> <span class="o">:=</span> <span class="nx">JWT</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Header</span><span class="p">:</span>    <span class="nx">headerData</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Payload</span><span class="p">:</span>   <span class="nx">payloadData</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Signature</span><span class="p">:</span> <span class="nx">signature</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 打印解析结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Header:&#34;</span><span class="p">,</span> <span class="nx">jwt</span><span class="p">.</span><span class="nx">Header</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Payload:&#34;</span><span class="p">,</span> <span class="nx">jwt</span><span class="p">.</span><span class="nx">Payload</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Signature:&#34;</span><span class="p">,</span> <span class="nx">jwt</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此示例假定你已经有用于验证签名的密钥，并且使用的是 HS256 算法。要验证签名是否有效，你需要使用相同的密钥对头部和负载部分进行签名，并比较得到的签名与 JWT 中的签名是否匹配。如果匹配，JWT 就是有效的。如果不匹配，说明 JWT 被篡改或无效。</p>
<h2 id="faq" class="headerLink">
    <a href="#faq" class="header-mark"></a>FAQ</h2><h4 id="如何禁用-cookies-后使用-session" class="headerLink">
    <a href="#%e5%a6%82%e4%bd%95%e7%a6%81%e7%94%a8-cookies-%e5%90%8e%e4%bd%bf%e7%94%a8-session" class="header-mark"></a>如何禁用 Cookies 后，使用 Session</h4><ul>
<li>如果禁用了 Cookies，服务器仍会将 sessionId 以 cookie 的方式发送给浏览器，但是，浏览器不再保存这个 cookie （即 sessionId） 了。</li>
<li>如果想要继续使用 session，需要采用 <code>URL 重写</code>的方式来实现，可以参考 <a href="https://www.cnblogs.com/Renyi-Fan/p/11012086.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/Renyi-Fan/p/11012086.html</a></li>
</ul>
<h3 id="jwt-前端解码" class="headerLink">
    <a href="#jwt-%e5%89%8d%e7%ab%af%e8%a7%a3%e7%a0%81" class="header-mark"></a>JWT 前端解码</h3><p>在线解密工具<a href="https://www.box3.cn/tools/jwt.html" target="_blank" rel="noopener noreferrer">https://www.box3.cn/tools/jwt.html</a></p>
<p>npm 包<a href="https://www.npmjs.com/package/jwt-decode" target="_blank" rel="noopener noreferrer">https://www.npmjs.com/package/jwt-decode</a></p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://juejin.cn/post/6844904115080790023" target="_blank" rel="noopener noreferrer">看完这篇 Session、Cookie、Token，和面试官扯皮就没问题了</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener noreferrer">JSON Web Token 入门教程</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/193090304" target="_blank" rel="noopener noreferrer">认证方式的前世今生，以及 JWT 的使用</a></li>
</ul>
]]></description>
</item></channel>
</rss>
