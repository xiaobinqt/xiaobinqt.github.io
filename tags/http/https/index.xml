<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Http/Https - 标签 - xiaobinqt 博客 - 技术改变生活</title>
        <link>https://www.xiaobinqt.cn/tags/http/https/</link>
        <description>Http/Https - 标签 - xiaobinqt 博客 - 技术改变生活</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaobinqt@163.com (xiaobinqt)</managingEditor>
            <webMaster>xiaobinqt@163.com (xiaobinqt)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 29 Mar 2022 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://www.xiaobinqt.cn/tags/http/https/" rel="self" type="application/rss+xml" /><item>
    <title>禁止Google浏览器强制跳转https</title>
    <link>https://www.xiaobinqt.cn/stop-chrome-auto-redirect-2-https/</link>
    <pubDate>Tue, 29 Mar 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/stop-chrome-auto-redirect-2-https/</guid>
    <description><![CDATA[<p>这几天在使用 google 浏览器打开公司的一个网站时，发现总是自动跳转到 https，以至于出现下面这个页面：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220330/3bc5e2df037f497fb589a7927540f8f5.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="ERR_SSL_PROTOCOL_ERROR" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220330/3bc5e2df037f497fb589a7927540f8f5.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>ERR_SSL_PROTOCOL_ERROR</h2><p>ERR_SSL_PROTOCOL_ERROR</p>">
        
    </a><figcaption class="image-caption">ERR_SSL_PROTOCOL_ERROR</figcaption>
    </figure></p>
<p>有时候浏览器太智能了也不是一件好事&#x1f923;。</p>
<h2 id="解决方法" class="headerLink">
    <a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95" class="header-mark"></a>解决方法</h2><p>复制链接 <code>chrome://net-internals/#hsts</code>用 Google 浏览器打开，这个页面，在最下面的 <strong>Delete domain security policies</strong>
填上需要禁止跳转的网站，然后点击<strong>Delete</strong>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220330/1dfabae20c7d4e3fb31303c1f99334fa.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="Delete domain security policies" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220330/1dfabae20c7d4e3fb31303c1f99334fa.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>Delete domain security policies</h2><p>Delete domain security policies</p>">
        
    </a><figcaption class="image-caption">Delete domain security policies</figcaption>
    </figure></p>
<p>然后<strong>重启浏览器，重启浏览器，重启浏览器</strong>，不然可能不生效。</p>
<p>这里有个需要<strong>注意</strong>的地方是，如果我们的网址是 <code>http://g.xiaobinqt.cn:8000</code>，那么<code>Domain</code> 的值填的是 <code>xiaobinqt.cn</code>。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://howchoo.com/chrome/stop-chrome-from-automatically-redirecting-https" target="_blank" rel="noopener noreferrer">How to Stop Chrome from Automatically Redirecting to https</a></li>
</ul>
]]></description>
</item><item>
    <title>http入门笔记</title>
    <link>https://www.xiaobinqt.cn/http-glance/</link>
    <pubDate>Thu, 17 Mar 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/http-glance/</guid>
    <description><![CDATA[<p>该笔记是在学习《透视 HTTP 协议》时整理，还参考了网上的其他资料。鄙人只是网络世界的搬运整理工&#x1f602;。</p>
<h2 id="总览" class="headerLink">
    <a href="#%e6%80%bb%e8%a7%88" class="header-mark"></a>总览</h2><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/6935d109cbc64fa58c3177a90fd33098.png?imageView2/0/interlace/1/q/50%7cimageslim" title="http总览" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/6935d109cbc64fa58c3177a90fd33098.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2> </h2><p>http总览</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<h2 id="http-协议" class="headerLink">
    <a href="#http-%e5%8d%8f%e8%ae%ae" class="header-mark"></a>http 协议</h2><p>http（超文本传输协议）是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</p>
<p>http 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。</p>
<p>http 不是编程语言，但是可以用编程语言去实现 HTTP，告诉计算机如何用 HTTP 来与外界通信。</p>
<p>在互联网世界里，HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。</p>
<blockquote>
<p>HTTP 传输的不是 TCP/UDP 这些底层协议里被切分的杂乱无章的二进制包（datagram），而是完整的、有意义的数据，可以被浏览器、服务器这样的上层应用程序处理。</p>
</blockquote>
<h3 id="互联网和万维网的区别" class="headerLink">
    <a href="#%e4%ba%92%e8%81%94%e7%bd%91%e5%92%8c%e4%b8%87%e7%bb%b4%e7%bd%91%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-mark"></a>互联网和万维网的区别</h3><p>我们通常所说的“上网”实际上访问的只是互联网的一个子集“万维网”（World Wide Web），它基于 HTTP 协议，传输 HTML 等超文本资源，能力被限制在 HTTP 协议之内。</p>
<p>互联网上还有许多万维网之外的资源，例如常用的电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等，它们需要用各自的专有协议来访问。</p>
<p>不过由于 HTTP 协议非常灵活、易于扩展，而且“超文本”的表述能力很强，所以很多其他原本不属于 HTTP 的资源也可以“包装”成 HTTP 来访问，这就是我们为什么能够总看到各种“网页应用”——例如“微信网页版”“邮箱网页版”——的原因。</p>
<h3 id="tcpip" class="headerLink">
    <a href="#tcpip" class="header-mark"></a>TCP/IP</h3><p>TCP/IP 协议实际上是一系列网络通信协议的统称， 其中最核心的两个协议是TCP（Transmission Control Protocol/传输控制协议）和IP（Internet Protocol），其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。</p>
<blockquote>
<p>HTTP 是超文本传输协议，TCP 是传输控制协议，都是传输，区别是，HTTP 传输的是完整的、有意义的数据，可以被浏览器、
服务器这样的上层应用程序处理，HTTP 不关心寻址、路由、数据完整性等传输细节，而要求这些工作都由下层（基本都由 TCP）来处理。 TCP 传输的是可靠的、字节流和二进制包。</p>
</blockquote>
<p>TCP 是 HTTP 得以实现的基础，HTTP 协议运行在 TCP/IP 上，HTTP 可以更准确地称为 “HTTP over TCP/IP”。</p>
<h3 id="uriurl" class="headerLink">
    <a href="#uriurl" class="header-mark"></a>URI/URL</h3><p>URI（Uniform Resource Identifier），中文名称是 统一资源标识符，使用它就能够唯一地标记互联网上资源。</p>
<p>URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，这两者几乎是相同的，差异不大，除非写论文，否则不用特意区分。</p>
<h3 id="ssltsl" class="headerLink">
    <a href="#ssltsl" class="header-mark"></a>SSL/TSL</h3><p>SSL 的全称是“Secure Socket Layer”，网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“Transport Layer Security”。 所以 TLS 跟 SSL 是一个东西，相当于张君宝的 2.0 版本是张三丰。</p>
<p>SSL 是一个负责加密通信的安全协议，建立在 TCP/IP 之上，在 HTTP 协议之下。</p>
<h3 id="proxy-代理" class="headerLink">
    <a href="#proxy-%e4%bb%a3%e7%90%86" class="header-mark"></a>proxy 代理</h3><ul>
<li>匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；</li>
<li>透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；</li>
<li>正向代理：靠近客户端，代理的对象是客户端，代表客户端向服务器发送请求；</li>
</ul>
<p>正向代理是一个位于客户端和原始服务器（origin server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器，比如 Google），然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/22475408cd734b9c861b345040e356f4.png?imageView2/0/interlace/1/q/50%7cimageslim" title="正向代理" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/22475408cd734b9c861b345040e356f4.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2>正向代理</h2><p>正向代理</p>">
        
    </a><figcaption class="image-caption">正向代理</figcaption>
    </figure></p>
<ul>
<li>反向代理：靠近服务器端，代理代理的对象是服务端，代表服务器响应客户端的请求</li>
</ul>
<p>反向代理指的是代理服务器根据客户端的请求，从其关系的一组或多组后端服务器（如 Web 服务器）上获取资源，然后再将这些资源返回给客户端的过程，客户端只会得知代理服务器的 IP 地址，而不知道在代理服务器后面的服务器集群的存在。</p>
<p>当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/6a2b4d26c0bf43cd9494df793c48a814.png?imageView2/0/interlace/1/q/50%7cimageslim" title="反向代理" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/6a2b4d26c0bf43cd9494df793c48a814.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2>反向代理</h2><p>反向代理</p>">
        
    </a><figcaption class="image-caption">反向代理</figcaption>
    </figure></p>
<h2 id="http-版本" class="headerLink">
    <a href="#http-%e7%89%88%e6%9c%ac" class="header-mark"></a>http 版本</h2><p>万维网关键技术</p>
<ul>
<li>URI：即统一资源标识符，作为互联网上资源的唯一身份；</li>
<li>HTML：即超文本标记语言，描述超文本文档；</li>
<li>HTTP：即超文本传输协议，用来传输超文本。</li>
</ul>
<p>基于这三项关键技术就可以把超文本系统完美地运行在互联网上，让各地的人们能够自由地共享信息，这个系统称为“万维网”（World Wide Web），也就是我们现在所熟知的 Web。</p>
<h3 id="http09" class="headerLink">
    <a href="#http09" class="header-mark"></a>http/0.9</h3><p>结构简单，设置之初设想系统里的文档都是只读的，所以只允许用 GET 动作从服务器上获取 HTML 纯文本格式的文档，并且在响应请求之后立即关闭连接，功能非常有限。</p>
<h3 id="http10" class="headerLink">
    <a href="#http10" class="header-mark"></a>http/1.0</h3><p>HTTP/1.0 并不是一个标准，只是记录已有实践和模式的一份参考文档，不具有实际的约束力，相当于一个备忘录。</p>
<p>在多方面增强了 0.9 版，形式上已经和我们现在的 HTTP 差别不大了，例如：</p>
<ul>
<li>增加了 HEAD、POST 等新方法；</li>
<li>增加了响应状态码，标记可能的错误原因；</li>
<li>引入了协议版本号概念；</li>
<li>引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</li>
<li>传输的数据不再仅限于文本。</li>
</ul>
<h3 id="http11" class="headerLink">
    <a href="#http11" class="header-mark"></a>http/1.1</h3><p>是一个正式的标准，而不是一份可有可无的参考文档，只要用到 HTTP 协议，就必须严格遵守这个标准。</p>
<p>主要变更：</p>
<ul>
<li>增加了 PUT、DELETE 等新的方法；</li>
<li>增加了缓存管理和控制；</li>
<li>明确了连接管理，允许持久连接；</li>
<li>允许响应数据分块（chunked），利于传输大文件；</li>
<li>强制要求 Host 头，让互联网主机托管成为可能。</li>
</ul>
<h3 id="http2" class="headerLink">
    <a href="#http2" class="header-mark"></a>http/2</h3><p>由 google 主导，基于 google 的 SPDY 协议为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2。</p>
<p>主要特点：</p>
<ul>
<li>二进制协议，不再是纯文本；</li>
<li>可发起多个请求，废弃了 1.1 里的管道；</li>
<li>使用专用算法压缩头部，减少数据传输量；</li>
<li>允许服务器主动向客户端推送数据；</li>
<li>增强了安全性，“事实上”要求加密通信。</li>
</ul>
<h3 id="http3" class="headerLink">
    <a href="#http3" class="header-mark"></a>http/3</h3><p>由 google 主导，基于 google 的 QUIC 协议为基础开始制定新版本的 HTTP 协议。</p>
<h2 id="网络分层模型" class="headerLink">
    <a href="#%e7%bd%91%e7%bb%9c%e5%88%86%e5%b1%82%e6%a8%a1%e5%9e%8b" class="header-mark"></a>网络分层模型</h2><h3 id="tcpip-1" class="headerLink">
    <a href="#tcpip-1" class="header-mark"></a>TCP/IP</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/87869e9a3d0d4eaba7c9d6fe0798674f.png?imageView2/0/interlace/1/q/50%7cimageslim" title="tcp/ip分层模型" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/87869e9a3d0d4eaba7c9d6fe0798674f.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2>TCP/IP分层模型</h2><p>tcp/ip分层模型</p>">
        
    </a><figcaption class="image-caption">TCP/IP分层模型</figcaption>
    </figure></p>
<p>这里的层次顺序是“从下往上”数的，所以第一层就是最下面的一层。</p>
<h4 id="链接层" class="headerLink">
    <a href="#%e9%93%be%e6%8e%a5%e5%b1%82" class="header-mark"></a>链接层</h4><p>第一层叫“链接层”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。</p>
<h4 id="网络互联层" class="headerLink">
    <a href="#%e7%bd%91%e7%bb%9c%e4%ba%92%e8%81%94%e5%b1%82" class="header-mark"></a>网络互联层</h4><p>第二层叫“网际层”或者“网络互连层”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。</p>
<h4 id="传输层" class="headerLink">
    <a href="#%e4%bc%a0%e8%be%93%e5%b1%82" class="header-mark"></a>传输层</h4><p>第三层叫“传输层”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。</p>
<p>TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。</p>
<h4 id="应用层" class="headerLink">
    <a href="#%e5%ba%94%e7%94%a8%e5%b1%82" class="header-mark"></a>应用层</h4><p>协议栈的第四层叫“应用层”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP，HTTP 等等。</p>
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>Tip<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">MAC 层（链接层）的传输单位是帧（frame），IP 层（网络互联层）的传输单位是包（packet），TCP 层传输层的传输单位是段（segment）， HTTP （应用层）的传输单位则是消息或报文（message）。这些名词并没有什么本质的区分，可以统称为数据包。</div>
        </div>
    </div>
<h3 id="osi-网络分层模型" class="headerLink">
    <a href="#osi-%e7%bd%91%e7%bb%9c%e5%88%86%e5%b1%82%e6%a8%a1%e5%9e%8b" class="header-mark"></a>OSI 网络分层模型</h3><p>OSI 分层模型在发布的时候就明确地表明是一个“参考”，不是强制标准。这是因为 TCP/IP 等协议已经在许多网络上实际运行，不可能推翻重来。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/4ddd78194c284518a2ce2db4cfab2a3c.png?imageView2/0/interlace/1/q/50%7cimageslim" title="OSI模型" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/4ddd78194c284518a2ce2db4cfab2a3c.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2>OSI网络模型</h2><p>OSI模型</p>">
        
    </a><figcaption class="image-caption">OSI网络模型</figcaption>
    </figure></p>
<ul>
<li>第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；</li>
<li>第二层：数据链路层，它基本相当于 TCP/IP 的链接层；</li>
<li>第三层：网络层，相当于 TCP/IP 里的网际层；</li>
<li>第四层：传输层，相当于 TCP/IP 里的传输层；</li>
<li>第五层：会话层，维护网络中的连接状态，即保持会话和同步；</li>
<li>第六层：表示层，把数据转换为合适、可理解的语法和语义；</li>
<li>第七层：应用层，面向具体的应用传输数据。</li>
</ul>
<p>对比一下就可以发现，TCP/IP 是一个纯软件的栈，没有网络应有的最根基的电缆、网卡等物理设备的位置。而 OSI 则补足了这个缺失， 在理论层面上描述网络更加完整。</p>
<p>OSI 还为每一层标记了明确了编号，最底层是一层，最上层是七层，而 TCP/IP 的层次从来只有名字而没有编号。</p>
<h3 id="两个分层模型的对应关系" class="headerLink">
    <a href="#%e4%b8%a4%e4%b8%aa%e5%88%86%e5%b1%82%e6%a8%a1%e5%9e%8b%e7%9a%84%e5%af%b9%e5%ba%94%e5%85%b3%e7%b3%bb" class="header-mark"></a>两个分层模型的对应关系</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/539751215a0b45ada0a373f8289ca232.png?imageView2/0/interlace/1/q/50%7cimageslim" title="对应关系" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220317/539751215a0b45ada0a373f8289ca232.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2>两个分层模型的对应关系</h2><p>对应关系</p>">
        
    </a><figcaption class="image-caption">两个分层模型的对应关系</figcaption>
    </figure></p>
<p>所谓的“四层负载均衡”就是指工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡。</p>
<p>所谓的“七层负载均衡”就是指工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器。</p>
<p>有一个辨别四层和七层比较好的（但不是绝对的）小窍门，“两个凡是”：<strong>凡是由操作系统负责处理的就是四层或四层以下</strong>，否则，<strong>凡是需要由应用程序（也就是你自己写代码）负责处理的就是七层</strong>。</p>
<h2 id="http协议核心" class="headerLink">
    <a href="#http%e5%8d%8f%e8%ae%ae%e6%a0%b8%e5%bf%83" class="header-mark"></a>http协议核心</h2><p>由于 HTTP 是在 TCP/IP 协议之上的，而 TCP/IP 协议负责底层的具体传输工作，所以 http 在传输方面不用太操心，TCP/IP 会去解决，所以 HTTP 关心的就只有他所传输的报文内容，又因为 HTTP 是“纯文本”的，包括头信息都是 ASCII 码的文本，不用借助程序解析可以直接阅读。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220321/619a6b063a5e4ced936d156d155f3fed.png?imageView2/0/interlace/1/q/50%7cimageslim" title="http报文" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220321/619a6b063a5e4ced936d156d155f3fed.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2> </h2><p>http报文</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<h3 id="常用头字段" class="headerLink">
    <a href="#%e5%b8%b8%e7%94%a8%e5%a4%b4%e5%ad%97%e6%ae%b5" class="header-mark"></a>常用头字段</h3><h4 id="注意事项" class="headerLink">
    <a href="#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9" class="header-mark"></a>注意事项</h4><ul>
<li>字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</li>
<li>字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；</li>
<li>字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；</li>
</ul>
<h4 id="分类" class="headerLink">
    <a href="#%e5%88%86%e7%b1%bb" class="header-mark"></a>分类</h4><ul>
<li>通用字段：在请求头和响应头里都可以出现；</li>
<li>请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；</li>
<li>响应字段：仅能出现在响应头里，补充说明响应报文的信息；</li>
<li>实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。</li>
</ul>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Host</code></td>
<td>请求字段</td>
<td>唯一一个 HTTP/1.1 规范里要求<strong>必须出现</strong>的字段，如果请求头里没有 Host，那这就是一个错误的报文。Host 字段告诉服务器这个请求应该由哪个主机来处理</td>
</tr>
<tr>
<td><code>User-Agent</code></td>
<td>请求字段</td>
<td>描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面</td>
</tr>
<tr>
<td><code>Date</code></td>
<td>通用字段</td>
<td>表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略</td>
</tr>
<tr>
<td><code>Server</code></td>
<td>响应字段</td>
<td>告诉客户端当前正在提供 Web 服务的软件名称和版本号</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>实体字段</td>
<td>报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输</td>
</tr>
</tbody>
</table>
<h3 id="请求方式" class="headerLink">
    <a href="#%e8%af%b7%e6%b1%82%e6%96%b9%e5%bc%8f" class="header-mark"></a>请求方式</h3><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220321/c113e062fccf4d18959dc52d90e59c1b.png?imageView2/0/interlace/1/q/50%7cimageslim" title="请求方式" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220321/c113e062fccf4d18959dc52d90e59c1b.png?imageView2/0/interlace/1/q/50|imageslim" data-sub-html="<h2> </h2><p>请求方式</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>获取资源，可以理解为读取或者下载数据</td>
</tr>
<tr>
<td>HEAD</td>
<td>获取资源的元信息，不会返回请求的实体数据，只会传回响应头</td>
</tr>
<tr>
<td>POST</td>
<td>向资源提交数据，相当于写入或上传数据</td>
</tr>
<tr>
<td>PUT</td>
<td>类似 POST</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除资源</td>
</tr>
<tr>
<td>CONNECT</td>
<td>建立特殊的连接隧道</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>列出可对资源实行的方法</td>
</tr>
<tr>
<td>TRACE</td>
<td>追踪请求 - 响应的传输路径</td>
</tr>
</tbody>
</table>
<h3 id="状态码" class="headerLink">
    <a href="#%e7%8a%b6%e6%80%81%e7%a0%81" class="header-mark"></a>状态码</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>1×x</code></td>
<td>提示信息，表示目前是协议处理的中间状态，还需要后续的操作</td>
</tr>
<tr>
<td><code>2××</code></td>
<td>成功，报文已经收到并被正确处理</td>
</tr>
<tr>
<td><code>3××</code></td>
<td>重定向，资源位置发生变动，需要客户端重新发送请求</td>
</tr>
<tr>
<td><code>4××</code></td>
<td>客户端错误，请求报文有误，服务器无法处理</td>
</tr>
<tr>
<td><code>5××</code></td>
<td>服务器错误，服务器在处理请求时内部发生了错误</td>
</tr>
</tbody>
</table>
<p>一些常用状态码说明</p>
<table>
<thead>
<tr>
<th>status code</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>301</td>
<td>永久重定向，含义是此次请求的资源已经不存在了，需要改用改用新的 URI 再次访问</td>
</tr>
<tr>
<td>302</td>
<td>临时重定向，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是“永久”的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS。 再比如，今天夜里网站后台要系统维护，服务暂时不可用，这就属于“临时”的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）</td>
</tr>
<tr>
<td>405</td>
<td>不允许使用某些方法操作资源，例如不允许 POST 只能 GET</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable 资源无法满足客户端请求的条件，例如请求中文但只有英文</td>
</tr>
<tr>
<td>408</td>
<td>Request Timeout：请求超时，服务器等待了过长的时间</td>
</tr>
<tr>
<td>409</td>
<td>Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large：请求报文里的 body 太大</td>
</tr>
<tr>
<td>414</td>
<td>Request-URI Too Long：请求行里的 URI 太大</td>
</tr>
<tr>
<td>429</td>
<td>Too Many Requests 客户端发送了太多的请求，通常是由于服务器的限连策略</td>
</tr>
<tr>
<td>431</td>
<td>Request Header Fields Too Large 请求头某个字段或总体太大</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error 与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented 表示客户端请求的功能还不支持，这个错误码比 500 要温和一些，和“即将开业，敬请期待”的意思差不多，不过具体什么时候“开业”就不好说了</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable 表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503</td>
</tr>
</tbody>
</table>
<h3 id="http-特点" class="headerLink">
    <a href="#http-%e7%89%b9%e7%82%b9" class="header-mark"></a>http 特点</h3><ul>
<li>HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能。</li>
<li>HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达。</li>
<li>HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据。</li>
<li>HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求。</li>
<li>HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。</li>
</ul>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://baijiahao.baidu.com/s?id=1738680012806649947" target="_blank" rel="noopener noreferrer">什么是反向代理，反向代理是如何工作的？</a></li>
<li><a href="https://blog.csdn.net/weixin_45775963/article/details/104440190" target="_blank" rel="noopener noreferrer">什么是正向代理和反向代理</a></li>
<li><a href="https://www.jianshu.com/p/23b6775fbb91" target="_blank" rel="noopener noreferrer">如何理解反向代理服务器</a></li>
</ul>]]></description>
</item><item>
    <title>透视 HTTPS</title>
    <link>https://www.xiaobinqt.cn/what-is-https/</link>
    <pubDate>Tue, 27 Oct 2020 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/what-is-https/</guid>
    <description><![CDATA[<p>为什么有 HTTPS？<strong>因为 HTTP 不安全！</strong> 现在的互联网已经不再是 “田园时代”，“黑暗森林”
已经到来。上网的记录会被轻易截获，网站是否真实也无法验证，黑客可以伪装成银行网站，盗取真实姓名、密码、银行卡等敏感信息，威胁人身安全和财产安全。</p>
<p>上网的时候必须步步为营、处处小心，否则就会被不知道埋伏在哪里的黑客所“猎杀”。</p>
<p>HTTPS 如何实现安全通信？如何构建出固若金汤的网络城堡？主要涉及的知识点如下：</p>
<ul>
<li>什么是 HTTPS</li>
<li>什么样的才是安全的通信</li>
<li>对称加密与非对称加密、摘要算法、数字签名、完整性校验是什么</li>
<li>迁移 HTTPS 的必要性</li>
</ul>
<h2 id="什么是安全" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%ae%89%e5%85%a8" class="header-mark"></a>什么是安全</h2><p>在通信过程中，具备以下特性则认为安全：<strong>机密性</strong>、<strong>完整性</strong>、<strong>不可否认</strong>、<strong>身份认证</strong>。</p>
<ul>
<li>
<p>机密性：数据必须保密，只能有信任的人读取，其他人是不可见的秘密。就是不能让不相关的人看到不该看的东西。</p>
</li>
<li>
<p>完整性：也叫作一致性，也就是数据在传输过程中没有被非法篡改，内容不能多也不能少，一五一十的保持原状。</p>
</li>
<li>
<p>不可否认：不可抵赖，不能否认已经发生过的事情。</p>
</li>
<li>
<p>身份验证：确认对方的真实身份，“证明你是真的是你”，保证消息发送到可信的人，而不是非法之徒。</p>
</li>
</ul>
<p>所以同时具备了机密性、完整性、身份认证、不可否认四个特性，通信双方的安全才有保证，才是真正的安全。</p>
<h2 id="什么是-https" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-https" class="header-mark"></a>什么是 HTTPS</h2><p>HTTPS 其实是一个“非常简单”的协议，规定了<strong>新的协议名“https”，默认端口号 443</strong>，至于其他的什么请求 - 应答模式、报文结构、请求方法、URI、头字段、连接管理等等都完全沿用
HTTP，没有任何新的东西。唯一的差别就是端口号不同、去掉明文传输。</p>
<p>那 HTTPS 凭啥就变得安全了呢？</p>
<p>就是因为他在 TCP/IP 与 HTTP 之间加上了 SSL/TLS ，从原来的 <strong>HTTP over TCP/IP</strong> 变成了 <strong>HTTP over SSL/TLS</strong>，让 HTTP 运行在 安全的 SSL/TLS 协议上。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220414/c2bc9b02fbbf4829b5bdcdbb481cdb53.png" title="http 与 https" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220414/c2bc9b02fbbf4829b5bdcdbb481cdb53.png" data-sub-html="<h2>http 与 https</h2><p>http 与 https</p>">
        
    </a><figcaption class="image-caption">http 与 https</figcaption>
    </figure></p>
<h2 id="ssltls" class="headerLink">
    <a href="#ssltls" class="header-mark"></a>SSL/TLS</h2><p>SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层），由网景公司于 1994 年发明，有 v2 和 v3 两个版本，而 v1 因为有严重的缺陷从未公开过。</p>
<p>SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以
<strong>TLS1.0 实际上就是 SSLv3.1</strong>。</p>
<p>TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。</p>
<p>浏览器与服务器在使用 TLS 建立连接的时候实际上就是选了一组加密算法实现安全通信，这些算法组合叫做 “密码套件（cipher suite）”。</p>
<p>套件命名很有规律，比如“ECDHE-RSA-AES256-GCM-SHA384”。按照 密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法”组成的.</p>
<p>所以这个套件的意思就是：使用 ECDHE 算法进行密钥交换，使用 RSA 签名和身份验证，握手后使用 AES 对称加密，密钥长度 256 位，分组模式 GCM，消息认证和随机数生成使用摘要算法 SHA384。</p>
<h3 id="对称加密和非对称加密" class="headerLink">
    <a href="#%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e5%92%8c%e9%9d%9e%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86" class="header-mark"></a>对称加密和非对称加密</h3><p>前面提到四个实现安全的必要条件，先说<strong>机密性</strong>，也就是消息只能给想给的人看到并且看得懂。</p>
<p>实现机密性的手段就是<strong>加密（encrypt）</strong>，也就是将原本明文消息使用加密算法转换成别人看不懂的密文，只有掌握特有的<strong>密钥</strong>的人才能解密出原始内容。</p>
<p>钥匙也就是<strong>密钥（key）</strong>，未加密的消息叫做<strong>明文 （plain text/clear text）</strong>，加密后的内容叫做<strong>密文（cipher text）</strong>，通过密钥解密出原文的过程叫做<strong>解密（decrypt）</strong>
，而加解密的整个过程就是<strong>加密算法</strong>。</p>
<p>由于 HTTPS、TLS 都运行在计算机上，所以“密钥”就是一长串的数字，但约定俗成的<strong>度量单位是“位”（bit），而不是“字节”（byte）</strong>。比如，说密钥长度是 128（位），就是 16 字节的二进制串，密钥长度
1024（位），就是 128 字节的二进制串。</p>
<p><strong>加密算法通常有两大类：对称加密和非对称加密。</strong></p>
<h4 id="对称加密" class="headerLink">
    <a href="#%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86" class="header-mark"></a>对称加密</h4><p>加密和解密使用的密钥都是同一个，是 “对称的”。双方只要保证不会有泄露其他人知道这个密钥，通信就具有机密性。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220414/6ed371961ce540e9846bde25bcf67622.png" title="对称加密" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220414/6ed371961ce540e9846bde25bcf67622.png" data-sub-html="<h2>对称加密</h2><p>对称加密</p>">
        
    </a><figcaption class="image-caption">对称加密</figcaption>
    </figure></p>
<p>对称加密算法常见的有 RC4、DES、3DES、AES、ChaCha20 等，但前三种算法都被认为是不安全的，通常都禁止使用，<strong>目前常用的只有 AES 和 ChaCha20</strong>。</p>
<p>AES 的意思是“高级加密标准”（Advanced Encryption Standard），密钥长度可以是 128、192 或 256。它是 DES 算法的替代者，安全强度很高，性能也很好，而且有的硬件还会做特殊优化，所以非常流行，是**
应用最广泛的对称加密算法**。</p>
<h4 id="加密分组模式" class="headerLink">
    <a href="#%e5%8a%a0%e5%af%86%e5%88%86%e7%bb%84%e6%a8%a1%e5%bc%8f" class="header-mark"></a>加密分组模式</h4><p>对称算法还有一个 “分组模式”的概念，目的是通过算法用固定长度的密钥加密任意长度的明文。</p>
<p>最新的分组模式被称为 AEAD（Authenticated Encryption with Associated Data），在加密的同时增加了认证的功能，常用的是 GCM、CCM 和 Poly1305。</p>
<h4 id="非对称加密" class="headerLink">
    <a href="#%e9%9d%9e%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86" class="header-mark"></a>非对称加密</h4><p>有对称加密，为何还搞出一个非对称加密呢？</p>
<p>对称加密确实解决了机密性，只有相关的人才能读取出信息。但是最大的问题是：如何安全的把密钥传递对方，专业术语 <strong>“密钥交换”</strong>。</p>
<p>所以为了解决秘钥交换，非对称加密诞生了。</p>
<p>非对称加密由两个密钥组成，分别是<strong>公钥（public key）<strong>和</strong>“私钥（private key）”</strong>，两个密钥是不一样的，这也就是不对称的由来，公钥可以任何人使用，私钥则自己保密。</p>
<p>这里需要注意的是：<strong>公钥和私钥都可以用来加密解密，公钥加密的密文只能用私钥解密，反之亦然。</strong></p>
<p>服务端保存私钥，在互联网上分发公钥，当访问服务器网站的时候使用授予的公钥加密明文即可，服务端则使用对应的私钥来解密。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220414/12536823ed034d3b888f85c30bda8651.png" title="非对称加密" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220414/12536823ed034d3b888f85c30bda8651.png" data-sub-html="<h2>非对称加密</h2><p>非对称加密</p>">
        
    </a><figcaption class="image-caption">非对称加密</figcaption>
    </figure></p>
<p>TLS 中常见的加密算法有 DH、RSA、ECC、DSA 等。其中的 RSA 最常用，它的安全性基于“<strong>整数分解</strong>”的数学难题，使用两个超大素数的乘积作为生成密钥的材料，想要从公钥推算出私钥是非常困难的。</p>
<p>ECC（Elliptic Curve Cryptography）是非对称加密里的“后起之秀”，它基于“<strong>椭圆曲线离散对数</strong>”的数学难题，使用特定的曲线方程和基点生成公钥和私钥，子算法 ECDHE 用于密钥交换，ECDSA 用于数字签名。</p>
<p>比起 RSA，ECC 在安全强度和性能上都有明显的优势。160 位的 ECC 相当于 1024 位的 RSA，而 224 位的 ECC 则相当于 2048 位的
RSA。因为密钥短，所以相应的计算量、消耗的内存和带宽也就少，加密解密的性能就上去了，对于现在的移动互联网非常有吸引力。</p>
<p>现在我们为了机密性从对称加密到非对称加密，而非对称加密还解决了密钥交换不安全的问题。那么是否可以直接使用非对称加密来实现机密性呢？</p>
<p>答案是否定的！</p>
<p>因为<strong>非对称加密运算速度比较慢</strong>。所以需要两者结合，混合模式实现机密性问题，同时又有很好的性能。</p>
<h3 id="混合加密流程" class="headerLink">
    <a href="#%e6%b7%b7%e5%90%88%e5%8a%a0%e5%af%86%e6%b5%81%e7%a8%8b" class="header-mark"></a>混合加密流程</h3><ol>
<li>先创建一个随机数的对称加密密钥，<strong>会话密钥（session key）</strong>；</li>
<li>使用会话密钥加密需要传输的明文消息，因为对称加密性能较好，接着再<strong>使用非对称加密的公钥对会话密钥加密</strong>，因为会话密钥很短，通常只有 16 字节或 32 字节，所以加密也不会太慢 。
<strong>这里主要就是解决了非对称加密的性能问题，同时实现了会话密钥的机密交换。</strong></li>
<li>另一方接收到密文后使用非对称加密的<strong>私钥</strong>解密出上一步加密的<strong>会话密钥</strong>，接着使用<strong>会话密钥</strong>解密出加密的消息明文。</li>
</ol>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220414/4a88136750224ae6bd15174cd1c7e0ec.png" title="混合加密" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220414/4a88136750224ae6bd15174cd1c7e0ec.png" data-sub-html="<h2>混合加密</h2><p>混合加密</p>">
        
    </a><figcaption class="image-caption">混合加密</figcaption>
    </figure></p>
<p><strong>总结一下就是使用非对称加密算法来加密会话密钥，使用对称加密算法来加密消息明文，接收方则使用非对称加密算法的私钥解密出会话密钥，再利用会话密钥解密消息密文。</strong></p>
<p>这样混合加密就解决了对称加密算法的密钥交换问题，而且安全和性能兼顾，完美地实现了机密性。</p>
<p>后面还有完整性、身份认证、不可否认等特性没有实现，所以现在的通信还不是绝对安全。</p>
<h3 id="摘要算法与完整性" class="headerLink">
    <a href="#%e6%91%98%e8%a6%81%e7%ae%97%e6%b3%95%e4%b8%8e%e5%ae%8c%e6%95%b4%e6%80%a7" class="header-mark"></a>摘要算法与完整性</h3><p>摘要算法的主要目的就是实现完整性，通过常见的<strong>散列函数</strong>、<strong>哈希函数</strong>实现。</p>
<p>我们可以简单理解成这是一种特殊的压缩算法，<strong>将任意长度的明文数据处理成固定长度</strong>、又是独一无二的“摘要”字符串，就是该数据的指纹。</p>
<p><strong>同时摘要算法是单向加密算法，没有密钥，加密后的数据也无法解密，也就是不能从“摘要”推导出明文。</strong></p>
<p>比如我们听过或者用过的 <code>MD5（Message-Digest 5）</code>、<code>SHA-1（Secure Hash Algorithm 1）</code>，它们就是最常用的两个摘要算法，能够生成 16 字节和 20 字节长度的数字摘要。</p>
<h4 id="完整性实现" class="headerLink">
    <a href="#%e5%ae%8c%e6%95%b4%e6%80%a7%e5%ae%9e%e7%8e%b0" class="header-mark"></a>完整性实现</h4><p>有了摘要算法生成的数字摘要，那么我们只需要在明文数据附上对应的摘要，就能保证数据的完整性。</p>
<p>但是由于摘要算法不具有机密性，不能明文传输，否则黑客可以修改消息后把摘要也一起改了，网站还是鉴别不出完整性。</p>
<p>所以完整性还是要建立在机密性上，我们结合之前提到的混合加密使用 ”会话密钥“ <strong>加密明文消息 + 摘要</strong>，这样的话黑客也就无法得到明文，无法做修改了。这里有个专业术语叫“哈希消息认证码（HMAC）”。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220414/95ad964986964ce68e58ef18a82afcbd.png" title="哈希消息认证码（HMAC）" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220414/95ad964986964ce68e58ef18a82afcbd.png" data-sub-html="<h2>哈希消息认证码（HMAC）</h2><p>哈希消息认证码（HMAC）</p>">
        
    </a><figcaption class="image-caption">哈希消息认证码（HMAC）</figcaption>
    </figure></p>
<blockquote>
<p>比如诸葛亮使用上面提到的混合加密过程给关二爷发消息：“明天攻城” + “SHA-2
摘要”，关二爷收到后使用密钥将解密出来的会话密钥解密出明文消息，同时对明文消息使用解密出来的摘要算法进行摘要计算，接着比对两份“摘要”字符串是否一致，如果一致就说明消息完整可信，没有被敌军修改过。</p>
<p>消息被修改是很危险的，要以史为鉴，比如赵高与李斯伪造遗诏，直接把扶苏给送西天了，这太可怕了。</p>
</blockquote>
<p>总结下就是通过摘要比对防止篡改，同时利用混合加密实现密文与摘要的安全传输。</p>
<h3 id="数字签名和-ca" class="headerLink">
    <a href="#%e6%95%b0%e5%ad%97%e7%ad%be%e5%90%8d%e5%92%8c-ca" class="header-mark"></a>数字签名和 CA</h3><p>到这里已经很安全了，但是还是有漏洞，就是通信的两头。黑客可以伪装成网站来窃取信息。而反过来，他也可以伪装成你，向网站发送支付、转账等消息，网站没有办法确认你的身份，钱可能就这么被偷走了。</p>
<p>现在如何实现身份认证呢？</p>
<p>现实生活中，解决身份认证的手段是签名和印章，只要在纸上写下签名或者盖个章，就能够证明这份文件确实是由本人而不是其他人发出的。</p>
<p>非对称加密依然可以解决此问题，只不过跟之前反过来用，使用私钥再加上摘要算法，就能够实现“<strong>数字签名</strong>”，同时实现“身份认证”和“不可否认”。</p>
<p>就是把公钥私钥的用法反过来，之前是公钥加密、私钥解密，现在是私钥加密、公钥解密。但又因为非对称加密效率太低，所以私钥只加密原文的摘要，这样运算量就小的多，而且得到的数字签名也很小，方便保管和传输。</p>
<p><strong>重点就是使用非对称加密的“私钥”加密原文的摘要，对方则使用非对称加密的公钥解密出摘要，再比对解密出的原文通过摘要算法计算摘要与解密出的摘要比对是否一致。</strong></p>
<p>这样就能像签署文件一样证明消息确实是你发送的。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220414/128bcef85358414e822eb2838ae630c0.png" title="签名验签" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220414/128bcef85358414e822eb2838ae630c0.png" data-sub-html="<h2>签名验签</h2><p>签名验签</p>">
        
    </a><figcaption class="image-caption">签名验签</figcaption>
    </figure></p>
<p>只要你和网站互相交换公钥，就可以用“签名”和“验签”来确认消息的真实性，因为私钥保密，黑客不能伪造签名，就能够保证通信双方的身份。</p>
<h4 id="ca" class="headerLink">
    <a href="#ca" class="header-mark"></a>CA</h4><p>到这里似乎已经大功告成，可惜还不是。</p>
<p>综合使用对称加密、非对称加密和摘要算法，我们已经实现了安全的四大特性，是不是已经完美了呢？</p>
<p>不是的，这里还有一个“<strong>公钥的信任</strong>”问题。因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么来判断这个公钥就是你的公钥呢？</p>
<p>我们常说的<strong>CA</strong>（Certificate Authority，证书认证机构），它就像网络世界里的公安局、教育部、公证中心，具有极高的可信度，由它来给各个公钥签名，用自身的信誉来保证公钥无法伪造，是可信的。</p>
<p>CA 对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还要包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“<strong>数字证书</strong>”（Certificate）。</p>
<h3 id="openssl" class="headerLink">
    <a href="#openssl" class="header-mark"></a>OpenSSL</h3><p>它是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现 TLS 功能，包括常用的 Web 服务器 Apache、Nginx 等。</p>
<p>由于 OpenSSL 是开源的，所以它还有一些代码分支，比如 Google 的 BoringSSL、OpenBSD 的 LibreSSL，这些分支在 OpenSSL
的基础上删除了一些老旧代码，也增加了一些新特性，虽然背后有“大金主”，但离取代 OpenSSL 还差得很远。</p>
<p>总结下就是：<strong>OpenSSL 是著名的开源密码学工具包，是 SSL/TLS 的具体实现</strong>。</p>
<h2 id="迁移-https-必要性" class="headerLink">
    <a href="#%e8%bf%81%e7%a7%bb-https-%e5%bf%85%e8%a6%81%e6%80%a7" class="header-mark"></a>迁移 HTTPS 必要性</h2><p>如果你做移动应用开发的话，那么就一定知道，Apple、Android、某信等开发平台在 2017 年就相继发出通知，要求所有的应用必须使用 HTTPS 连接，禁止不安全的 HTTP。</p>
<p>在台式机上，主流的浏览器 Chrome、Firefox 等也早就开始“强推”HTTPS，把 HTTP 站点打上“不安全”的标签，给用户以“心理压力”。</p>
<p>Google 等搜索巨头还利用自身的“话语权”优势，降低 HTTP 站点的排名，而给 HTTPS 更大的权重，力图让网民只访问到 HTTPS 网站。</p>
<p>这些手段都逐渐“挤压”了纯明文 HTTP 的生存空间，“迁移到 HTTPS”已经不是“要不要做”的问题，而是“要怎么做”的问题了。HTTPS 的大潮无法阻挡，如果还是死守着 HTTP，那么无疑会被冲刷到互联网的角落里。</p>
<h2 id="顾虑" class="headerLink">
    <a href="#%e9%a1%be%e8%99%91" class="header-mark"></a>顾虑</h2><p>阻碍 HTTPS 实施的因素还有一些这样、那样的顾虑，三个比较流行的观点：“慢、贵、难”。</p>
<p>而“慢”则是惯性思维，拿以前的数据来评估 HTTPS 的性能，认为 HTTPS 会增加服务器的成本，增加客户端的时延，影响用户体验。</p>
<p>其实现在服务器和客户端的运算能力都已经有了很大的提升，性能方面完全没有担心的必要，而且还可以应用很多的优化解决方案</p>
<p>所谓“贵”，主要是指证书申请和维护的成本太高，网站难以承担。</p>
<p>这也属于惯性思维，在早几年的确是个问题，向 CA 申请证书的过程不仅麻烦，而且价格昂贵，每年要交几千甚至几万元。</p>
<p>但现在就不一样了，为了推广 HTTPS，很多云服务厂商都提供了一键申请、价格低廉的证书，而且还出现了专门颁发免费证书的 CA，其中最著名的就是“<strong>Let’s Encrypt</strong>”。</p>
<p>所谓的“难”，是指 HTTPS 涉及的知识点太多、太复杂，有一定的技术门槛，不能很快上手。</p>
<h2 id="总结" class="headerLink">
    <a href="#%e6%80%bb%e7%bb%93" class="header-mark"></a>总结</h2><p>HTTPS 主要就是通过 SSL/TLS 实现安全，而安全又有对称加密与非对称加密，非对称加密性能较弱，所以我们使用非对称加密来加密对称加密的“会话密钥”，利用会话密钥加密明文解决了性能问题。</p>
<p>通过混合加密实现了机密性，利用摘要算法实现了完整性，通过数字签名使用非对称加密的“私钥”加密原文的摘要，对方则使用非对称加密的公钥解密出摘要，再比对解密出的原文通过摘要算法计算摘要与解密出的摘要比对是否一致实现了身份认证与不可否认。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&amp;mid=2247487718&amp;idx=1&amp;sn=6806b36bb1454c3354b7cf5168973422" target="_blank" rel="noopener noreferrer">透视HTTPS建造固若金汤的城堡</a></li>
</ul>
]]></description>
</item></channel>
</rss>
