<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>mysql - 标签 - xiaobinqt 博客 - 技术改变生活</title>
        <link>https://www.xiaobinqt.cn/tags/mysql/</link>
        <description>mysql - 标签 - xiaobinqt 博客 - 技术改变生活</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaobinqt@163.com (xiaobinqt)</managingEditor>
            <webMaster>xiaobinqt@163.com (xiaobinqt)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 11 Jul 2022 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://www.xiaobinqt.cn/tags/mysql/" rel="self" type="application/rss+xml" /><item>
    <title>MySQL 常见问题（三）</title>
    <link>https://www.xiaobinqt.cn/mysql-faq-3/</link>
    <pubDate>Mon, 11 Jul 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/mysql-faq-3/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="innodbmyisam的区别" class="headerLink">
    <a href="#innodbmyisam%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-mark"></a>InnoDB、MyISAM的区别</h2><ul>
<li>磁盘文件不同：</li>
</ul>
<p>MyISAM 引擎的表会生成三个磁盘文件：</p>
<p><code>table_name.frm</code> 该文件中存储表的结构信息。<code>table_name.MYD</code> 该文件中存储表的行数据。<code>table_name.MYI</code> 该文件中存储表的索引数据。</p>
<p>而 InnoDB 引擎的表只会生成两个磁盘文件：</p>
<p><code>table_name.frm</code> 该文件中存储表的结构信息。<code>table_name.ibd</code> 该文件中存储表的行数据和索引数据。</p>
<ul>
<li>InnoDB 支持聚簇索引，而 MyISAM 只支持非聚簇索引，因为 MyISAM 索引数据和表数据是<strong>分开存储</strong>的。</li>
<li>InnoDB 基于 Undo-log 日志实现了事务机制，但 MyISAM 没有，所以 MyISAM 不支持事务。</li>
<li>InnoDB 基于 Redo-log 日志实现了故障恢复机制，但 MyISAM 则只能依靠 Bin-log，因此会有丢失数据的风险。</li>
<li>InnoDB 可以基于聚簇索引实现行锁，同时还兼容表锁，但 MyISAM 仅支持表锁。</li>
<li>InnoDB 因为支持行锁以及 MVCC 机制，所以并发场景下的性能会远超 MyISAM 引擎。</li>
<li>InnoDB 由于设计了 BufferPool 缓冲池，所以内存利用度会远超 MyISAM 引擎。</li>
</ul>
<h2 id="行锁和表锁的区别" class="headerLink">
    <a href="#%e8%a1%8c%e9%94%81%e5%92%8c%e8%a1%a8%e9%94%81%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-mark"></a>行锁和表锁的区别</h2><p>主要是粒度不同，表锁是指对一整张表加锁，当加锁后，其他来访问该表的事务都会被阻塞，而行锁的粒度则小很多，是指针对于一条/多条数据加锁，并不会阻塞操作同一表的事务，而仅仅<strong>只会阻塞操作相同行数据的事务</strong>。</p>
<h2 id="共享锁和排他锁的区别" class="headerLink">
    <a href="#%e5%85%b1%e4%ba%ab%e9%94%81%e5%92%8c%e6%8e%92%e4%bb%96%e9%94%81%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-mark"></a>共享锁和排他锁的区别</h2><p>共享锁允许多个事务一起持有，而排他锁在同一时间内只能允许一个事务持有，也就是但凡出现排他锁的场景，其他事务都需要阻塞等待。</p>
<h2 id="表锁行锁有哪些" class="headerLink">
    <a href="#%e8%a1%a8%e9%94%81%e8%a1%8c%e9%94%81%e6%9c%89%e5%93%aa%e4%ba%9b" class="header-mark"></a>表锁、行锁有哪些</h2><p>表锁有元数据锁、意向锁、自增锁、全局锁这四种，行锁有记录锁、间隙锁、临键锁、插入意向锁这四类，行锁在 MySQL 中是 InnoDB 引擎独有的，并且 InnoDB 的行锁和表锁之间，是相互兼容的。</p>
<h2 id="记录锁间隙锁临键锁这三种行锁有什么区别" class="headerLink">
    <a href="#%e8%ae%b0%e5%bd%95%e9%94%81%e9%97%b4%e9%9a%99%e9%94%81%e4%b8%b4%e9%94%ae%e9%94%81%e8%bf%99%e4%b8%89%e7%a7%8d%e8%a1%8c%e9%94%81%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" class="header-mark"></a>记录锁、间隙锁、临键锁这三种行锁有什么区别</h2><p>记录锁是指对一条数据上锁、当我们针对主键或者唯一索引加锁的时候， MySQL 默认会对查询的这一行数据加行锁，避免其他事务对这一行数据进行修改。</p>
<p>间隙锁，就是锁定一个索引区间。在普通索引或者唯一索引列上，由于索引是基于 B+ 树的结构存储，所以默认会存在一个索引区间。而间隙锁，就是某个事务对索引列加锁的时候，默认锁定对应索引的<strong>左右开区间</strong>范围。在基于索引列的范围查询，无论是否是唯一索引，都会自动触发间隙锁。比如基于<code>between</code>的范围查询，就会产生一个左右开区间的间隙锁。</p>
<p>临键锁，它相当于「行锁+间隙锁」的组合，也就是它的锁定范围既包含了索引记录，也包含了索引区间，它会锁定一个<strong>左开右闭区间</strong>的数据范围。比如我们使用非唯一索引列进行查询的时候，默认会加一个临键锁，锁定一个左开右闭区间的范围。</p>
<p>总的来说，记录锁、临键锁、间隙锁只是表示锁定数据的范围，最终目的是<strong>为了解决幻读</strong>的问题。而临键锁相当于「行锁+间隙锁」，因此当我们使用非唯一索引进行精准匹配的时候，会默认加临键锁，因为它需要锁定匹配的这一行数据，还需要锁定这一行数据对应的左开右闭区间。因此在实际应用中，尽可能使用唯一索引或者主键索引进行查询，避免大面积的锁定造成性能影响。</p>
<h2 id="隐式锁或手动加锁后什么时候释放锁" class="headerLink">
    <a href="#%e9%9a%90%e5%bc%8f%e9%94%81%e6%88%96%e6%89%8b%e5%8a%a8%e5%8a%a0%e9%94%81%e5%90%8e%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e9%87%8a%e6%94%be%e9%94%81" class="header-mark"></a>隐式锁或手动加锁后，什么时候释放锁</h2><p>几乎所有释放锁的工作都是 MySQL 自动完成的，但不同事务隔离级别中，释放锁的时机也不同，如果目前是读未提交级别，MySQL 执行完一条语句后就会立马释放锁。如果是其他级别中，基本上都需要等待持有锁的事务结束（commit/rollback）后才会释放。</p>
<h2 id="mysql57的共享排他锁是什么" class="headerLink">
    <a href="#mysql57%e7%9a%84%e5%85%b1%e4%ba%ab%e6%8e%92%e4%bb%96%e9%94%81%e6%98%af%e4%bb%80%e4%b9%88" class="header-mark"></a>MySQL5.7的共享排他锁是什么</h2><p>因为索引树的结构会发生变更，比如一个无序数据插入时，就会导致树节点的分裂，这时需要挪动树中的一些节点位置，为了防止其他事务再次破坏树结构，或从索引树中读到不对的数据，所以会对整棵树上锁，这个问题被称为<code>SMO</code>问题，共享排他锁主要就是用来解决<code>SMO</code>问题。</p>
<h2 id="死锁发生的原因该如何避免" class="headerLink">
    <a href="#%e6%ad%bb%e9%94%81%e5%8f%91%e7%94%9f%e7%9a%84%e5%8e%9f%e5%9b%a0%e8%af%a5%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d" class="header-mark"></a>死锁发生的原因，该如何避免</h2><p>死锁，简单来说就是两个或者两个以上的线程在执行的过程中，争夺同一个共享资源造成的相互等待的现象。</p>
<p>如果没有外部干预，线程会一直阻塞无法往下执行，这些一直处于相互等待资源的线程就称为死锁线程。</p>
<p>导致死锁的条件有四个，也就是这四个条件<strong>同时满足</strong>就会产生死锁👇</p>
<ul>
<li>互斥条件，共享资源 X 和 Y 只能被一个线程占用</li>
<li>请求和保持条件，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X</li>
<li>不可抢占条件，其他线程不能强行抢占线程 T1 占有的资源</li>
<li>循环等待条件，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待</li>
</ul>
<p>导致死锁之后，只能通过人工干预来解决，比如重启服务，或者杀掉某个线程。所以，只能在写代码的时候，去规避可能出现的死锁问题。</p>
<p>按照死锁发生的四个条件，<strong>只需要破坏其中的任何一个</strong>，就可以解决，但是，互斥条件是没办法破坏的，因为这是互斥锁的基本约束，其他三方条件都有办法来破坏：</p>
<ul>
<li>对于“请求和保持”这个条件，可以一次性申请所有的资源，这样就不存在等待了。</li>
<li>对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</li>
<li>对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</li>
</ul>
<h2 id="有哪些常见索引" class="headerLink">
    <a href="#%e6%9c%89%e5%93%aa%e4%ba%9b%e5%b8%b8%e8%a7%81%e7%b4%a2%e5%bc%95" class="header-mark"></a>有哪些常见索引</h2><p><strong>聚簇索引</strong>，在聚簇索引中，索引数据和表数据在磁盘中的位置是一起的。聚簇索引存的是主键和当前行的数据，一张表中只能存在一个聚簇索引，一般都会选用主键作为聚簇索引。一般聚簇索引要求索引必须是<strong>非空唯一</strong>索引才行。</p>
<p><strong>唯一索引</strong>，索引中的索引节点值不允许重复，一般配合唯一约束使用。</p>
<p><strong>主键索引</strong>，是一种特殊的唯一索引，和普通唯一索引的区别在于<strong>不允许有空值</strong>。</p>
<p><strong>普通索引</strong>，通过<code>KEY</code>、<code>INDEX</code>关键字创建的索引就是这个类型，没什么限制，就是单纯的可以让查询快一点。</p>
<p><strong>全文索引</strong>在 5.7 版本之前，只有 MyISAM 引擎支持。全文索引只能创建在<code>CHAR</code>、<code>VARCHAR</code>、<code>TEXT</code>等这些文本类型字段上，而且使用全文索引查询时，条件字符数量必须<strong>大于</strong> 3 才生效。如果想要创建出的全文索引支持中文，需要在最后指定解析器<code>with parser ngram</code>。</p>
<h2 id="什么是索引覆盖和索引下推" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%b4%a2%e5%bc%95%e8%a6%86%e7%9b%96%e5%92%8c%e7%b4%a2%e5%bc%95%e4%b8%8b%e6%8e%a8" class="header-mark"></a>什么是索引覆盖和索引下推</h2><p><strong>覆盖索引</strong></p>
<p>比如有个联合索引为<code>user_name、user_sex、password</code>，那么 SQL:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">SELECT</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">user_name</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">user_sex</span><span class="o">`</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">password</span><span class="o">`</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;1234&#34;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="o">`</span><span class="n">user_sex</span><span class="o">`</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;男&#34;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>虽然不符合联合索引的最左前缀匹配原则的，但是也可以用到索引，这就是索引覆盖。也就是：查询的列，在使用的索引中已经包含，被所使用的索引覆盖，这种情况称之为索引覆盖。</p>
<p><strong>索引下推</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    [&#34;熊猫&#34;,&#34;女&#34;,&#34;6666&#34;] : 1,
</span></span><span class="line"><span class="cl">    [&#34;竹子&#34;,&#34;男&#34;,&#34;1234&#34;] : 2,
</span></span><span class="line"><span class="cl">    [&#34;子竹&#34;,&#34;男&#34;,&#34;4321&#34;] : 3,
</span></span><span class="line"><span class="cl">    [&#34;1111&#34;,&#34;男&#34;,&#34;4321&#34;] : 4,
</span></span><span class="line"><span class="cl">    [&#34;竹竹&#34;,&#34;女&#34;,&#34;8888&#34;] : 5
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>比如 zz_users 表中有数据☝️，索引<code>user_name、user_sex、password</code>，查询 SQL：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="o">`</span><span class="n">user_name</span><span class="o">`</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s2">&#34;竹%&#34;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="o">`</span><span class="n">user_sex</span><span class="o">`=</span><span class="s2">&#34;男&#34;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于使用了模糊查询，但<code>%</code>在结尾，因此可以使用<code>竹</code>这个字作为条件在联合索引中查询，整个查询过程如下：</p>
<ul>
<li>① 利用联合索引中的<code>user_name</code>字段找出「竹子、竹竹」两个索引节点。</li>
<li>② 返回索引节点存储的值「2、5」给<code>Server</code>层，然后去逐一做回表扫描。</li>
<li>③ 在<code>Server</code>层中根据<code>user_sex=&quot;男&quot;</code>这个条件逐条判断，最终筛选到「竹子」这条数据。</li>
</ul>
<p>那么为什么<code>user_sex=&quot;男&quot;</code>这个条件不在联合索引中处理呢？因为前面是模糊查询，所以拼接起来是这样的<code>竹X男</code>，由于这个<code>X</code>是未知的，因此无法根据最左前缀原则去匹配数据，最终这里只能使用联合索引中<code>user_name</code>字段的一部分，后续的<code>user_sex=&quot;男&quot;</code>还需要回到<code>Server</code>层处理。</p>
<p>所谓的索引下推，就是将<code>Server</code>层筛选数据的工作，下推到引擎层处理。</p>
<p>MySQL5.6 后加入索引下推机制后，其执行过程就是下面的顺序：</p>
<ul>
<li>① 利用联合索引中的<code>user_name</code>字段找出「竹子、竹竹」两个索引节点。</li>
<li>② 根据<code>user_sex=&quot;男&quot;</code>这个条件在索引节点中逐个判断，从而得到「竹子」这个节点。</li>
<li>③ 最终将「竹子」这个节点对应的「2」返回给<code>Server</code>层，然后聚簇索引中回表拿数据。</li>
</ul>
<p>相较于没有索引下推之前，原本需要做「2、5」两次回表查询，但在拥有索引下推之后，仅需做「2」一次回表查询。</p>
<h2 id="什么是脏读幻读不可重复读" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%84%8f%e8%af%bb%e5%b9%bb%e8%af%bb%e4%b8%8d%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb" class="header-mark"></a>什么是脏读、幻读、不可重复读</h2><p><strong>脏读</strong>：指一个事务读到了其他事务还未提交的数据，也就是当前事务读到的数据，由于还未提交，因此有可能会回滚。</p>
<p><strong>幻读</strong>：另外一个事务在第一个事务要处理的目标数据范围之内<strong>新增</strong>了数据，然后先于第一个事务提交造成的问题。<strong>幻读仅专指 “新插入的行”</strong>。</p>
<p>幻读是对自己来说的，比如，事务 A 在对表中多行数据进行修改，将性别「男、女」改为「0、1」，此时事务 B 又插入了一条性别为男的数据，当事务 A 提交后，再次查询表时，会发现表中依旧存在一条性别为男的数据。</p>
<p><strong>不可重复读</strong>：指在一个事务中，多次读取同一数据，先后读取到的数据不一致。</p>
<p>事务 A 执行下单业务时，因为添加物流信息的时候出错了，导致整个事务回滚，事务回滚完成后，事务 A 就结束了。但事务 B 却并未结束，在事务 B 中，在事务 A 执行时读取了一次剩余库存，然后在事务 A 回滚后又读取了一次剩余库存，仔细想想：B 事务第一次读到的剩余库存是扣减之后的，第二次读到的剩余库存则是扣减之前的（因为 A 事务回滚又加回去了），导致两次读取的数据不一致，这就是不可重复读。</p>
<h2 id="什么是脏写" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%84%8f%e5%86%99" class="header-mark"></a>什么是脏写</h2><p>多个事务一起操作同一条数据，例如两个事务同时向表中添加一条<code>ID=88</code>的数据，此时就会造成数据覆盖，或者主键冲突的问题，这个问题也被称之为更新丢失问题。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://juejin.cn/post/7149074488649318431" target="_blank" rel="noopener noreferrer">建立索引的正确姿势与使用索引的最佳指南！</a></li>
<li><a href="https://juejin.cn/post/7152765784299667487" target="_blank" rel="noopener noreferrer">ACID原则、事务隔离级别及事务机制原理剖析</a></li>
<li><a href="https://juejin.cn/post/7156111610589741063" target="_blank" rel="noopener noreferrer">全解MySQL之死锁问题分析、事务隔离与锁机制的底层原理剖析</a></li>
</ul>
]]></description>
</item><item>
    <title>MySQL 常见问题（二）</title>
    <link>https://www.xiaobinqt.cn/mysql-faq-2/</link>
    <pubDate>Sat, 21 May 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/mysql-faq-2/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="索引数据结构为什么不使用红黑树或b树" class="headerLink">
    <a href="#%e7%b4%a2%e5%bc%95%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e4%bd%bf%e7%94%a8%e7%ba%a2%e9%bb%91%e6%a0%91%e6%88%96b%e6%a0%91" class="header-mark"></a>索引数据结构为什么不使用红黑树或B树</h2><p>在 InnoDB 引擎中，索引的底层数据结构是 B+ 树。MySQL 的数据是存储在硬盘的，在查询时一般是不能「一次性」把全部数据加载到内存中。红黑树是「二叉查找树」的变种，一个 Node 节点只能存储一个<code>Key</code>和一个<code>Value</code>。B 和 B+ 树跟红黑树不一样，它们算是「多路搜索树」，相较于「二叉搜索树」而言，一个 Node 节点可以存储的信息会更多，「多路搜索树」的高度会比「二叉搜索树」更低。</p>
<p>了解了区别之后，其实就很容易发现，在数据不能一次加载至内存的场景下，数据需要被检索出来，选择 B 或 B+ 树的理由就很充分了，一个 Node 节点存储信息更多（相较于二叉搜索树）， 树的高度更低，
<strong>树的高度影响检索的速度</strong>。</p>
<p>B+ 树相对于 B 树而言，它又有两种特性：</p>
<ul>
<li>
<p>B+ 树非叶子节点不存储数据，在相同的数据量下，B+ 树更加矮壮。数据都存储在叶子节点上，非叶子节点的存储能存储更多的索引，所以整棵树就更加矮壮。<strong>树的高度能够决定磁盘 IO 的次数</strong>，磁盘 IO 次数越少，对于性能的提升就越大。</p>
</li>
<li>
<p>因为叶子节点存储所有数据，所以 B+ 树的全局扫描能力更强一些，因为它只需要扫描叶子节点。但是 B 树需要遍历整个树。B+ 树叶子节点之间组成一个链表，方便于遍历查询，遍历操作在 MySQL 中比较常见。</p>
</li>
</ul>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221201/b768c90fe50b48aa8d7deec33efd7e8c.png" title="b&#43;树" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221201/b768c90fe50b48aa8d7deec33efd7e8c.png" data-sub-html="<h2>b&#43;树</h2><p>b&#43;树</p>">
        
    </a><figcaption class="image-caption">b+树</figcaption>
    </figure></p>
<p>在 MySQL InnoDB 引擎下，每创建一个索引，相当于生成了一颗 B+ 树。如果该索引是「聚集（聚簇）索引」，那当前 B+ 树的叶子节点存储着「主键和当前行的数据」，如果该索引是「非聚簇索引」，那当前 B+ 树的叶子节点存储着「主键和当前索引列值」</p>
<p>比如写了一句👇</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="k">select</span> * from user where id &gt;<span class="o">=</span> <span class="m">10</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>那只要定位到 id 为 10 的记录，然后在叶子节点之间通过遍历链表（叶子节点组成的链表），即可找到往后的记录了。由于 B 树是会在非叶子节点也存储数据，要遍历的时候可能就得<strong>跨层</strong>检索，相对麻烦些。基于树的层级以及业务使用场景的特性，所以 MySQL 选择了 B+ 树作为索引的底层数据结构。</p>
<h2 id="什么叫做回表" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e5%8f%ab%e5%81%9a%e5%9b%9e%e8%a1%a8" class="header-mark"></a>什么叫做回表</h2><p>当我们使用索引查询数据时，检索出来的数据可能包含其他列，但走的索引树，叶子节点只能查到当前列值以及主键 ID，所以需要根据主键 ID 再去查一遍数据，得到SQL 所需的列。</p>
<p>举个例子，如果给订单号字段<code>orderId</code>建了个索引，但查询的 SQL 是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="k">select</span> orderId,orderName from orderdetail where <span class="nv">orderId</span> <span class="o">=</span> <span class="m">123</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<code>orderId</code>的索引树的叶子节点只有<code>orderId</code>和主键<code>Id</code>，而我们还想检索出<code>orderName</code>，所以 MySQL 会拿到 ID 再去查出<code>orderName</code>给我们返回，这种操作就叫回表。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221201/89f82e92055d4bd78318ab9baa4d9dd5.png" title="回表" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221201/89f82e92055d4bd78318ab9baa4d9dd5.png" data-sub-html="<h2>回表</h2><p>回表</p>">
        
    </a><figcaption class="image-caption">回表</figcaption>
    </figure></p>
<p>想要避免回表，也可以使用覆盖索引（能使用就使用，因为可以避免回表操作）。</p>
<p>所谓的覆盖索引，实际上就是你想要查出的列刚好在叶子节点上都存在，比如建了<code>orderId</code>和<code>orderName</code>联合索引，刚好我需要查询也是<code>orderId</code>和<code>orderName</code>，这些数据都存在索引树的叶子节点上，就不需要回表操作了。所以，如果查询的字段恰好命中联合索引的字段，则可以避免回表操作。</p>
<h2 id="什么是最左匹配原则" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%9c%80%e5%b7%a6%e5%8c%b9%e9%85%8d%e5%8e%9f%e5%88%99" class="header-mark"></a>什么是最左匹配原则</h2><p>如果有联合索引 (a,b,c,d)，实际上其实新建了 <code>a</code>，<code>ab</code>，<code>abc</code>，<code>abcb</code> 四个索引，因此只要查询中使用了这 4 组字段，都可以让联合索引生效。</p>
<p>查询条件 <code>a=1 and b=2 and c&gt;3 and d=4</code>，这里只能使用<code>a</code>，<code>b</code>和<code>a、b</code>索引，而不能使用<code>a、b、c</code>或<code>a、b、c、d</code>索引。</p>
<p>先匹配最左边的，索引只能用于查找<code>key</code>是否存在或相等，遇到范围查询<code>&gt;</code>、<code>&lt;</code>、<code>between</code>、<code>like</code>左匹配等就不能进一步匹配了，后续退化为线性查找，这就是最左匹配原则。</p>
<h2 id="实际项目中如何生成主键" class="headerLink">
    <a href="#%e5%ae%9e%e9%99%85%e9%a1%b9%e7%9b%ae%e4%b8%ad%e5%a6%82%e4%bd%95%e7%94%9f%e6%88%90%e4%b8%bb%e9%94%ae" class="header-mark"></a>实际项目中如何生成主键</h2><p>用自增主键。首先主键得保证它的唯一性和空间尽可能短，这两块是需要考虑的。由于索引的有序特性，id 本身具有连续性使得对应的数据也会按照顺序存储在磁盘上，写入性能和检索性能都很高。如果使用 uuid 这种随机 id，那么在频繁插入数据的时候，就会导致随机磁盘 IO，从而导致性能较低。</p>
<h2 id="如何理解innodb引擎中的事务" class="headerLink">
    <a href="#%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3innodb%e5%bc%95%e6%93%8e%e4%b8%ad%e7%9a%84%e4%ba%8b%e5%8a%a1" class="header-mark"></a>如何理解InnoDB引擎中的事务</h2><p>事务可以使「一组操作」要么全部成功，要么全部失败。事务其目的是为了「保证数据最终的一致性」。</p>
<h2 id="事务的特性" class="headerLink">
    <a href="#%e4%ba%8b%e5%8a%a1%e7%9a%84%e7%89%b9%e6%80%a7" class="header-mark"></a>事务的特性</h2><p>ACID，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p>
<p><strong>原子性</strong>指的是：当前事务的操作要么同时成功，要么同时失败。原子性由 undo log 日志来保证，因为 undo log 记载着数据修改前的信息。</p>
<p>比如我们要 insert 一条数据了，那 undo log 会记录的一条对应的 delete 日志。我们要 update 一条记录时，那 undo log 会记录之前的「旧值」的 update 记录。</p>
<p>如果执行事务过程中出现异常的情况，那执行「回滚」。InnoDB 引擎就是利用 undo log 记录下的数据，来将数据「恢复」到事务开始之前。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/8a8fcedc257b42c8ad74a868363fdafe.png" title="原子性" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/8a8fcedc257b42c8ad74a868363fdafe.png" data-sub-html="<h2>原子性</h2><p>原子性</p>">
        
    </a><figcaption class="image-caption">原子性</figcaption>
    </figure></p>
<p><strong>隔离性</strong>指的是：在事务「并发」执行时，他们内部的操作不能互相干扰。如果多个事务可以同时操作一个数据，那么就会产生脏读、不可重复读、幻读的问题。于是，事务与事务之间需要存在「一定」的隔离。</p>
<p>在 InnoDB 引擎中，定义了四种隔离级别供我们使用，分别是：<strong><ruby>read uncommitted<rt>读未提交</rt></ruby></strong>、<strong><ruby>read committed<rt>读已提交</rt></ruby></strong>、<strong><ruby>repeatable read<rt>可重复复读</rt></ruby></strong>、<strong><ruby>serializable<rt>串行</rt></ruby></strong>。</p>
<p>不同的隔离级别对事务之间的隔离性是不一样的，级别越高事务隔离性越好，但性能就越低，而隔离性是由 MySQL 的各种锁来实现的，只是它屏蔽了加锁的细节。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/20d805b51694457d955fbf985e0e9adb.png" title="隔离性" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/20d805b51694457d955fbf985e0e9adb.png" data-sub-html="<h2>隔离性</h2><p>隔离性</p>">
        
    </a><figcaption class="image-caption">隔离性</figcaption>
    </figure></p>
<p><strong>持久性</strong>指的就是：一旦提交了事务，它对数据库的改变就应该是永久性的。说白了就是，会将数据持久化在硬盘上。</p>
<p>而持久性由 redo log 日志来保证。当我们要修改数据时，MySQL 是先把这条记录所在的「页」找到，然后把该页加载到内存中，将对应记录进行修改。</p>
<p>为了防止内存修改完了，MySQL 就挂掉的问题。如果内存改完，直接挂掉，那这次的修改相当于就丢失了。对于这个问题，MySQL引入了 redo log，内存写完了，然后会写一份 redo log，这份 redo log 记载着这次在某个页上做了什么修改。即便 MySQL 在中途挂了，我们还可以根据 redo log 来对数据进行恢复。redo log 是顺序写的，写入速度很快。并且它记录的是物理修改（xxxx 页做了 xxx 修改），文件的体积很小，恢复速度很快。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/a58e871764ee402e933beb1c10adae7c.png" title="持久性" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/a58e871764ee402e933beb1c10adae7c.png" data-sub-html="<h2>持久性</h2><p>持久性</p>">
        
    </a><figcaption class="image-caption">持久性</figcaption>
    </figure></p>
<p><strong>一致性</strong>任何一个事务发生的前后，库中的数据变化必须一致。可以理解为我们使用事务的「目的」，而「隔离性」「原子性」「持久性」均是为了保障「一致性」的手段，保证一致性需要由应用程序代码来保证。比如，如果事务在发生的过程中，出现了异常情况，此时你就得回滚事务，而不是强行提交事务来导致数据不一致。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/4702334e18194c00b62d4001d1100e13.png" title="一致性" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/4702334e18194c00b62d4001d1100e13.png" data-sub-html="<h2>一致性</h2><p>一致性</p>">
        
    </a><figcaption class="image-caption">一致性</figcaption>
    </figure></p>
<h2 id="什么是两阶段提交" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e4%b8%a4%e9%98%b6%e6%ae%b5%e6%8f%90%e4%ba%a4" class="header-mark"></a>什么是两阶段提交</h2><p>MySQL 的 bin log 只能用于归档，不足以实现<strong><ruby>崩溃恢复<rt>crash-safe</rt></ruby></strong>，需要借助 InnoDB 引擎的 redo log 才能拥有崩溃恢复的能力。所谓崩溃恢复就是，即使在数据库宕机的情况下，也不会出现操作一半的情况。</p>
<p><strong>bin log 和 redo log 的区别</strong>👇</p>
<p>bin log 是 MySQL 的 Server 层实现的，对所有引擎都可以使用，而 redo log 是 InnoDB 引擎特有的。</p>
<p>bin log 是可以追加写入的。“追加写” 是指 bin log 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志，保存的是全量的日志。但是这就会导致一个问题，就是没有标志能让 InnoDB 从 bin log 中判断哪些数据已经刷入磁盘了，哪些数据还没有。</p>
<p>redo log 是循环写的，redo log 只会记录未刷入磁盘的日志，已经刷入磁盘的数据都会从 redo log 这个有限大小的日志文件里删除。</p>
<p>bin log 因为是全量日志，所以可以作为恢复数据使用，主从复制搭建。redo log 可以作为异常宕机或者故障后的数据恢复使用。</p>
<p>以下面的 SQL 语句为例，来解释下执行器和 InnoDB 存储引擎在更新时做了哪些事情：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">update table <span class="nb">set</span> <span class="nv">age</span> <span class="o">=</span> age + <span class="m">1</span> where <span class="nv">id</span> <span class="o">=</span> 1<span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221206/0fa9678f6b214a63bfdd8506cabe8a28.png" title="两阶段提交" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221206/0fa9678f6b214a63bfdd8506cabe8a28.png" data-sub-html="<h2>两阶段提交</h2><p>两阶段提交</p>">
        
    </a><figcaption class="image-caption">两阶段提交</figcaption>
    </figure></p>
<p>所谓两阶段提交，其实就是把 redo log 的写入拆分成了两个步骤<code>prepare</code>和<code>commit</code>。根据两阶段提交，崩溃恢复时的判断规则是这样的：</p>
<p>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交。</p>
<p>如果 redo log 里面的事务处于 prepare 状态，则判断对应的事务 binlog 是否存在并完整。</p>
<ol>
<li>如果 binlog 存在并完整，则提交事务；</li>
<li>否则，回滚事务。</li>
</ol>
<h2 id="为什么需要两阶段提交" class="headerLink">
    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e4%b8%a4%e9%98%b6%e6%ae%b5%e6%8f%90%e4%ba%a4" class="header-mark"></a>为什么需要两阶段提交</h2><p>两阶段提交主要是<strong>为了解决主从数据同步的问题</strong>。如果没有两阶段提交，那么 binlog 和 redolog 的提交，无非就是两种形式👇</p>
<ol>
<li>先写 bin-log 再写 redo-log</li>
<li>先写 redo-log 再写 bin-log</li>
</ol>
<p>假设我们要向表中插入一条记录 R，如果是先写 bin-log 再写 redo-log，那么假设 bin-log 写完后崩溃了，此时 redo-log 还没写。那么重启恢复的时候就会出问题：bin-log 中已经有 R 的记录了，当从机从主机同步数据的时候或者我们使用 bin-log 恢复数据的时候，就会同步到 R 这条记录；但是 redo-log 中没有关于 R 的记录，所以崩溃恢复之后，插入 R 记录的这个事务是无效的，即数据库中没有该行记录，这就造成了数据不一致。</p>
<p>相反，假设我们要向表中插入一条记录 R，如果是先写 redo-log 再写 bin-log，那么假设 redo-log 写完后崩溃了，此时 bin-log 还没写。那么重启恢复的时候也会出问题：redo-log 中已经有 R 的记录了，所以崩溃恢复之后，插入 R 记录的这个事务是有效的，通过该记录将数据恢复到数据库中；但是 bin-log 中还没有关于 R 的记录，所以当从机从主机同步数据的时候或者我们使用 bin-log 恢复数据的时候，就不会同步到 R 这条记录，这就造成了数据不一致。</p>
<h2 id="四种隔离级别" class="headerLink">
    <a href="#%e5%9b%9b%e7%a7%8d%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab" class="header-mark"></a>四种隔离级别</h2><ol>
<li>Read uncommitted/RU：读未提交，处于该隔离级别的数据库，脏读、不可重复读、幻读问题都有可能发生。</li>
<li>Read committed/RC：读已提交，处于该隔离级别的数据库，解决了脏读问题，不可重复读、幻读问题依旧存在。</li>
<li>Repeatable read/RR：可重复读，处于该隔离级别的数据库，解决了脏读、不可重复读、幻读问题。</li>
<li>Serializable：序列化/串行化，处于该隔离级别的数据库，解决了脏读、不可重复读、幻读问题都不存在。</li>
</ol>
<p>数据库事务的隔离级别，<strong>由低到高</strong>依次为 Read uncommitted 、Read committed、Repeatable read 、Serializable。</p>
<p>上述四个级别，越靠后并发控制度越高，也就是在多线程并发操作的情况下，出现问题的几率越小，但对应的也性能越差，MySQL 的事务隔离级别， 默认为第三级别：<code>Repeatable read</code>可重复读。</p>
<p>首先来看下<strong><ruby>read uncommitted<rt>读未提交</rt></ruby></strong>。比如说：A 向 B 转账，A 执行了转账语句，但 A 还没有提交事务，B 读取数据，发现自己账户钱变多了！B 跟 A 说，我已经收到钱了。A 回滚事务【rollback】，等 B 再查看账户的钱时，发现钱并没有多。</p>
<p>简单的定义就是：事务 B 读取到了事务 A 还没提交的数据，这种用专业术语来说叫做「<strong>脏读</strong>」。</p>
<p>对于锁的维度而言，其实就是在 read uncommitted 隔离级别下，读不会加任何锁，而写会加排他锁。读什么锁都不加，这就让排他锁无法排它了。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/06ccfe53f21143e8a3a9093f0864ac46.png" title="读未提交" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/06ccfe53f21143e8a3a9093f0864ac46.png" data-sub-html="<h2>读未提交</h2><p>读未提交</p>">
        
    </a><figcaption class="image-caption">读未提交</figcaption>
    </figure></p>
<p>而我们知道，对于更新操作而言，InnoDB 是肯定会加写锁的（数据库是不可能允许在同一时间，更新同一条记录的）。而读操作，如果不加任何锁，那就会造成上面的脏读。</p>
<p>脏读在生产环境下肯定是无法接受的，那如果读加锁的话，那意味着：当更新数据的时，就没办法读取了，这会极大地降低数据库性能。</p>
<p>在 MySQL InnoDB 引擎层面，有新的解决方案，解决加锁后读写性能问题，叫做<strong><ruby>MVCC<rt>Multi-Version Concurrency Control</rt></ruby></strong>多版本并发控制。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/0e52740b759b4aa490ef6e37497de964.png" title="MVCC" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/0e52740b759b4aa490ef6e37497de964.png" data-sub-html="<h2>MVCC</h2><p>MVCC</p>">
        
    </a><figcaption class="image-caption">MVCC</figcaption>
    </figure></p>
<p>在 MVCC 下，就可以做到读写不阻塞，且避免了类似脏读这样的问题。那 MVCC 是怎么做的呢❓</p>
<p>MVCC 通过生成数据<strong><ruby>快照<rt>Snapshot</rt></ruby></strong>，并用这个快照来提供一定级别（语句级或事务级）的一致性读取。</p>
<p>回到事务隔离级别下，针对于<strong><ruby>read committed<rt>读已提交</rt></ruby></strong> 隔离级别，它生成的就是<strong>语句级快照</strong>，而针对于<strong><ruby>repeatable read<rt>可重复读</rt></ruby></strong>，它生成的就是<strong>事务级的快照</strong>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/00282fd01288429b8b03a1407b7c5227.png" title="MVCC2" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/00282fd01288429b8b03a1407b7c5227.png" data-sub-html="<h2> </h2><p>MVCC2</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<p>前面提到过 read uncommitted 隔离级别下会产生脏读，而<strong><ruby>read committed<rt>读已提交</rt></ruby></strong> 隔离级别解决了脏读。思想其实很简单：在读取的时候生成一个 “版本号”，等到其他事务 commit 了之后，才会读取最新已 commit 的 “版本号” 数据。</p>
<p>比如说：事务 A 读取了记录（生成版本号），事务 B 修改了记录，此时加了写锁，事务 A 再读取的时候，是依据最新的版本号来读取的（当事务 B 执行 commit 了之后，会生成一个新的版本号），如果事务 B 还没有 commit，那事务 A 读取的还是之前版本号的数据。</p>
<p>通过「版本」的概念，这样就解决了脏读的问题，而「版本」其实就是对应快照的数据。</p>
<p><strong><ruby>read committed<rt>读已提交</rt></ruby></strong> 解决了脏读，但也会有其他并发的问题。「不可重复读」：一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改。</p>
<p>不可重复读的例子：A 查询数据库得到数据，B 去修改数据库的数据，导致 A 多次查询数据库的结果都不一样【危害：A 每次查询的结果都是受 B 的影响的】</p>
<p>了解 MVCC 之后，就很容易想到<strong><ruby>repeatable read<rt>可重复复读</rt></ruby></strong> 隔离级别是怎么避免不可重复读的问题了。</p>
<p><strong><ruby>repeatable read<rt>可重复复读</rt></ruby></strong>隔离级别是「事务级别」的快照！每次读取的都是「当前事务的版本」，即使当前数据被其他事务修改了（commit），也只会读取当前事务版本的数据。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/c8d49279d79f4b5fb09d26aba8a809bd.png" title="MVCC3" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/c8d49279d79f4b5fb09d26aba8a809bd.png" data-sub-html="<h2> </h2><p>MVCC3</p>">
        
    </a><figcaption class="image-caption"> </figcaption>
    </figure></p>
<p>而<strong><ruby>repeatable read<rt>可重复复读</rt></ruby></strong> 隔离级别会存在幻读的问题，「幻读」指的是指在一个事务内读取到了别的事务<strong>插入</strong>的数据，导致前后读取不一致。</p>
<p>在 InnoDB 引擎下的的<strong><ruby>repeatable read<rt>可重复复读</rt></ruby></strong>隔离级别下，快照读 MVCC 影响下，已经解决了幻读的问题（因为它是读历史版本的数据）。</p>
<p>而如果是当前读（指的是<code>select * from table for update</code>），则需要配合间隙锁来解决幻读的问题。</p>
<p>剩下的就是<strong><ruby>serializable<rt>串行</rt></ruby></strong>隔离级别了，它的最高的隔离级别，相当于不允许事务的并发，事务与事务之间执行是串行的，它的效率最低，但同时也是最安全的。</p>
<h2 id="事务隔离机制的底层实现" class="headerLink">
    <a href="#%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb%e6%9c%ba%e5%88%b6%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0" class="header-mark"></a>事务隔离机制的底层实现</h2><p>每种隔离级别都是基于锁和 MVCC 机制实现的👇</p>
<ul>
<li>读未提交/RU：写操作加排他锁，读操作不加锁。</li>
<li>读已提交/RC：写操作加排他锁，读操作使用 MVCC，但每次 select 都生成读视图。</li>
<li>可重复读/RR：写操作加排他锁，读操作依旧采用 MVCC 机制，但一次事务中只生成一个读视图。</li>
<li>序列化/Serializable：所有写操作加临键锁（具备互斥特性），所有读操作加共享锁。</li>
</ul>
<h2 id="mvcc原理" class="headerLink">
    <a href="#mvcc%e5%8e%9f%e7%90%86" class="header-mark"></a>MVCC原理</h2><p>MVCC 的主要是通过 read view 和 undo log 来实现的。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/3f80906689ea4930bbf75288bd905d3c.png" title="mvcc原理" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/3f80906689ea4930bbf75288bd905d3c.png" data-sub-html="<h2>mvcc原理</h2><p>mvcc原理</p>">
        
    </a><figcaption class="image-caption">mvcc原理</figcaption>
    </figure></p>
<p>undo log 会记录修改数据之前的信息，事务中的原子性就是通过 undo log 来实现的。所以有 undo log 可以帮我们找到「版本」的数据。</p>
<p>而 read view 实际上就是在查询时，InnoDB 会生成一个 read view，read view 有几个重要的字段，分别是：</p>
<ul>
<li><code>trx_ids</code> 尚未提交 commit 的事务版本号集合</li>
<li><code>up_limit_id</code> 下一次要生成的事务 ID 值</li>
<li><code>low_limit_id</code> 尚未提交版本号的事务 ID 最小值</li>
<li><code>creator_trx_id</code> 当前的事务版本号</li>
</ul>
<p>在每行数据有两列隐藏的字段，分别是<code>DB_TRX_ID</code>（记录着当前 ID）以及<code>DB_ROLL_PTR</code> 指向上一个版本数据在 undo log 里的位置指针，到这里，很容易就发现，MVCC 其实就是靠「比对版本」来实现读写不阻塞，而版本的数据存在于 undo log 中。</p>
<p>而针对于不同的隔离级别 read committed 和 repeatable read，无非就是 read committed 隔离级别下，每次都获取一个新的 read view，repeatable read 隔离级别则每次事务只获取一个 read view。</p>
<h2 id="工作中如何建索引" class="headerLink">
    <a href="#%e5%b7%a5%e4%bd%9c%e4%b8%ad%e5%a6%82%e4%bd%95%e5%bb%ba%e7%b4%a2%e5%bc%95" class="header-mark"></a>工作中如何建索引</h2><p>如果表有一定的数据量，那就应该要创建对应的索引，创建索引需要注意的点，比如说👇</p>
<ol>
<li>
<p>是否能使用「覆盖索引」，减少「回表」所消耗的时间。意味着，我们在 select 的时候，一定要指明对应的列，而不是<code>select *</code></p>
</li>
<li>
<p>考虑是否组建「联合索引」，如果组建「联合索引」，尽量将区分度最高的放在最左边，并且需要考虑「最左匹配原则」</p>
</li>
<li>
<p>对索引进行函数操作或者表达式计算会导致索引失效</p>
</li>
<li>
<p>利用子查询优化超多分页场景。比如<code>limit offset</code>, n 在 MySQL 是获取 offset + n 的记录，再返回 n 条。而利用子查询则是查出 n 条，通过 ID 检索对应的记录出来，提高查询效率。</p>
</li>
<li>
<p>通过 explain 命令来查看 SQL 的执行计划，看看自己写的 SQL 是否走了索引，走了什么索引。通过 show profile 来查看 SQL 对系统资源的损耗情况（不过一般还是比较少用到）</p>
</li>
<li>
<p>在开启事务后，在事务内尽可能只操作数据库，并有意识地减少锁的持有时间。比如在事务内需要插入和修改数据，那可以先插入后修改。因为修改是更新操作，会加行锁。如果先更新，那并发下可能会导致多个事务的请求等待行锁释放。</p>
</li>
</ol>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/7a6c78d1a5ac42e587ffd82ced372440.png" title="索引" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/7a6c78d1a5ac42e587ffd82ced372440.png" data-sub-html="<h2>索引</h2><p>索引</p>">
        
    </a><figcaption class="image-caption">索引</figcaption>
    </figure></p>
<h2 id="线上用的是什么隔离级别" class="headerLink">
    <a href="#%e7%ba%bf%e4%b8%8a%e7%94%a8%e7%9a%84%e6%98%af%e4%bb%80%e4%b9%88%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab" class="header-mark"></a>线上用的是什么隔离级别</h2><p>我们这边用的是<strong><ruby>Read committed<rt>读已提交</rt></ruby></strong>，MySQL 默认用的是 <strong><ruby>Repeatable read<rt>可重复读</rt></ruby></strong>。</p>
<p>选用什么隔离级别，主要看应用场景，因为隔离级别越低，事务并发性能越高。一般互联网公司都选择 Read committed 作为主要的隔离级别。</p>
<p>像<strong><ruby>Repeatable read<rt>可重复读</rt></ruby></strong>隔离级别，就有可能因为「间隙锁」导致的死锁问题。</p>
<p>MySQL 默认的隔离级别为 Repeatable read。很大一部分原因是在最开始的时候，MySQL 的 binlog 没有 row 模式（记录具体出现变更的数据，也会包含数据所在的分区以及所位于的数据页），在 read committed 隔离级别下会存在「主从数据不一致」的问题。binlog 记录了数据库表结构和表数据「变更」，比如<code>update/delete/insert/truncate/create</code>。在 MySQL 中，主从同步实际上就是应用了 binlog 来实现的。有了该历史原因，所以 MySQL 就将默认的隔离级别设置为 Repeatable read。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/acbe1fc753c84d1e9a9ccbd047f8afc9.png" title="隔离级别" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/acbe1fc753c84d1e9a9ccbd047f8afc9.png" data-sub-html="<h2>隔离级别</h2><p>隔离级别</p>">
        
    </a><figcaption class="image-caption">隔离级别</figcaption>
    </figure></p>
<h2 id="为什么走了索引查询还是慢" class="headerLink">
    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%b5%b0%e4%ba%86%e7%b4%a2%e5%bc%95%e6%9f%a5%e8%af%a2%e8%bf%98%e6%98%af%e6%85%a2" class="header-mark"></a>为什么走了索引查询还是慢</h2><p>如果走对了索引，但查询还是慢，那一般来说就是表的数据量实在是太大了。</p>
<p>首先，考虑能不能把「旧的数据」给 “删掉” 😢 如果「旧的数据」已经没有查询的业务了，那最简单的办法肯定是 “删掉” 部分数据咯。数据量降低了，那自然，检索速度就快了&hellip;.</p>
<p>其实，只有极少部分业务可以删掉数据&hellip;</p>
<p>那么，就考虑另一种情况，能不能在查询之前，直接走一层缓存（Redis）。</p>
<p>而走缓存的话，又要看业务能不能忍受读取的「非真正实时」的数据（毕竟 Redis 和 MySQL 的数据一致性需要保证），如果查询条件相对复杂且多变的话（涉及各种 group by 和 sum ），那走缓存也不是一种好的办法，维护起来就不方便了…</p>
<p>再看看是不是有「字符串」检索的场景导致查询低效，如果是的话，可以考虑把表的数据导入至 Elasticsearch 类的搜索引擎，后续的线上查询就直接走 Elasticsearch 了。</p>
<p><code>MySQL-&gt;Elasticsearch</code> 需要有对应的同步程序（一般就是监听 MySQL 的 binlog，解析 binlog 后导入到 Elasticsearch)。</p>
<p>如果还不是的话，那考虑要不要根据查询条件的维度，做相对应的聚合表，线上的请求就查询聚合表的数据，不走原表。</p>
<p>比如，用户下单后，有一份订单明细，而订单明细表的量级太大。但在产品侧（前台）透出的查询功能是以「天」维度来展示的，那就可以将每个用户的每天数据聚合起来，在聚合表就是一个用户一天只有一条汇总后的数据。查询走聚合后的表，那速度肯定很快的（聚合后的表数据量肯定比原始表要少很多）。</p>
<p>思路大致的就是「以空间换时间」，相同的数据换别的地方也存储一份，提高查询效率。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/9861ea4c29cb40a583593ce747b146d6.png" title="空间换时间" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/9861ea4c29cb40a583593ce747b146d6.png" data-sub-html="<h2>空间换时间</h2><p>空间换时间</p>">
        
    </a><figcaption class="image-caption">空间换时间</figcaption>
    </figure></p>
<h2 id="写性能的瓶颈如何处理" class="headerLink">
    <a href="#%e5%86%99%e6%80%a7%e8%83%bd%e7%9a%84%e7%93%b6%e9%a2%88%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86" class="header-mark"></a>写性能的瓶颈如何处理</h2><p>如果在 MySQL 读写都有瓶颈，那首先看下目前 MySQL 的架构是怎么样的。</p>
<p>如果是单库的，那是不是可以考虑升级至主从架构，实现读写分离。</p>
<p>简单理解就是：主库接收写请求，从库接收读请求。从库的数据由主库发送的 binlog 进而更新，实现主从数据一致（在一般场景下，主从的数据是通过异步来保证最终一致性的）。</p>
<p>如果在主从架构下，读写仍存在瓶颈，那就要考虑是否要分库分表了。</p>
<p>我这里讲的分库分表的含义是：在原来的某个库的某个表进而拆分。</p>
<p>比如，现在我有一张业务订单表，这张订单表在广告库中，假定这张业务订单表已经有 1 亿数据量了，现在我要分库分表，那就会将这张表的数据分至多个广告库以及多张表中。</p>
<p>分库分表的最明显的好处就是把请求进行均摊（本来单个库单个表有一亿的数据，那假设我分开 8 个库，那每个库 1200+W 的数据量，每个库下分 8 张表，那每张表就 150W 的数据量）。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/6583d2b4aed24774a316bced6d17e38b.png" title="分库分表" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/6583d2b4aed24774a316bced6d17e38b.png" data-sub-html="<h2>分库分表</h2><p>分库分表</p>">
        
    </a><figcaption class="image-caption">分库分表</figcaption>
    </figure></p>
<h2 id="常以什么作为分库键" class="headerLink">
    <a href="#%e5%b8%b8%e4%bb%a5%e4%bb%80%e4%b9%88%e4%bd%9c%e4%b8%ba%e5%88%86%e5%ba%93%e9%94%ae" class="header-mark"></a>常以什么作为分库键</h2><p>一般来说是按照<code>userId</code>，因为按照用户的维度查询比较多，如果要按照其他的维度进行查询，那还是参照上面的的思路（以空间换时间）。</p>
<h2 id="分库分表后的id是怎么生成的" class="headerLink">
    <a href="#%e5%88%86%e5%ba%93%e5%88%86%e8%a1%a8%e5%90%8e%e7%9a%84id%e6%98%af%e6%80%8e%e4%b9%88%e7%94%9f%e6%88%90%e7%9a%84" class="header-mark"></a>分库分表后的ID是怎么生成的</h2><p>这就涉及到分布式 ID 生成的方式了，思路有很多。有借助 MySQL 自增的，有借助 Redis 自增的，有基于「雪花算法」自增的。具体使用哪种方式，那就看公司的技术栈了，一般使用 Redis 和基于「雪花算法」实现用得比较多。</p>
<blockquote>
<p>至于为什么强调自增，还是跟索引是有序有关，可以看前面</p>
</blockquote>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/059ac16a9707417a91f9342bb8f9330c.png" title="分库分表的主键" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221202/059ac16a9707417a91f9342bb8f9330c.png" data-sub-html="<h2>分库分表的主键</h2><p>分库分表的主键</p>">
        
    </a><figcaption class="image-caption">分库分表的主键</figcaption>
    </figure></p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/74lPw8-keqM_niBDoOXSCQ" target="_blank" rel="noopener noreferrer">MySQL 索引</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5Mg==&amp;mid=2247485997&amp;idx=1&amp;sn=b05b4a56d0248e9c7108bd01eb95438d" target="_blank" rel="noopener noreferrer">MySQL 事务、锁和MVCC</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5Mg==&amp;mid=2247486035&amp;idx=1&amp;sn=7878dd9b45bc79e210eca1478ac2d9be" target="_blank" rel="noopener noreferrer">MySQL 调优</a></li>
<li><a href="https://juejin.cn/post/6844904199952531463" target="_blank" rel="noopener noreferrer">redo log/binlog/两阶段提交</a></li>
</ul>
]]></description>
</item><item>
    <title>MySQL 为什么使用 B&#43; 树索引</title>
    <link>https://www.xiaobinqt.cn/why-mysql-index-use-btree/</link>
    <pubDate>Fri, 20 May 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/why-mysql-index-use-btree/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221127/8018e68746b147a8bba7dac0c65ae308.png" referrerpolicy="no-referrer">
            </div><!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="前言" class="headerLink">
    <a href="#%e5%89%8d%e8%a8%80" class="header-mark"></a>前言</h2><p>为什么 MySQL 采用 B+ 树作为索引？</p>
<p>如果纯粹的猜测 MySQL 数据库索引为什么使用 B+ 树？那么围绕这个问题的回答通常一定是围绕 B+ 树本身是什么，有什么优势这两点去解释这个问题。</p>
<p>这不是我开始这么去想的，看了很多文章都是从这一维度问答，这些回答让我失望。直到那天问了坐在我旁边那个整天摸鱼的 5 年程序员；他慵懒的回答：你想为什么是使用的是树结构呢？咦，听到这回答，一下打开了我的思绪，有点意思！</p>
<p>先抛开 B+ 树是什么，有什么优势，这些先入为主的答案。我想要的是为什么❓</p>
<p>为什么 MySQL 的索引有那么多的数据结构可选，偏偏选树结构？为什么那么多的树结构？为什么又偏偏采用 B+ 树作为索引?</p>
<p>这才是我要想明白的！我想要的是不只是答案，还要答案背后的脉络！我想要的不仅是要知其然，更想要知其所以然。</p>
<h2 id="那么多数据结构为什么选树结构" class="headerLink">
    <a href="#%e9%82%a3%e4%b9%88%e5%a4%9a%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%ba%e4%bb%80%e4%b9%88%e9%80%89%e6%a0%91%e7%bb%93%e6%9e%84" class="header-mark"></a>那么多数据结构，为什么选树结构？</h2><p>众多的数据结构在逻辑层面可分为：<strong>线性结构</strong>和<strong>非线性结构</strong>。</p>
<p>线性结构有：<strong>数组</strong>、<strong>链表</strong>，基于它们衍生出的有<strong>哈希表</strong>（哈希表也称散列表）、<strong>栈</strong>、<strong>队列</strong>等。</p>
<p>非线性结构有：<strong>树</strong>、<strong>图</strong>。</p>
<p>还有其他数据结构如：<strong>跳表</strong>、<strong>位图</strong> 也都由基础数据结构演化而来，不同的数据结构存在即都是为了解决某些场景问题。</p>
<p>如果要知道索引适合什么数据结构，那我们得先来回答索引需要来解决什么样的问题（痛点）？和发挥着什么样的作用？其次再才是选择什么样的数据结构。后者只是果，前者才是因。</p>
<p>我们都知道 MySQL 存储的数据是在磁盘里，因为即使设备断电，放在磁盘的数据是不会有影响的，保障了数据不丢失，这意味着 MySQL 在磁盘上的数据是持久化的。</p>
<p>但数据存储在磁盘得到保障的同时也是有代价的，这代价就是磁盘的处理速度是毫秒级别的，相比<strong>内存纳秒级别</strong>的速度，简直是小巫见大巫。</p>
<p>你可能对时间单位没什么概念，可以看 1 毫秒能慢上纳秒几万倍。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/f12d0ec3934f47c49269efd3c57283a0.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/f12d0ec3934f47c49269efd3c57283a0.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/f12d0ec3934f47c49269efd3c57283a0.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>索引虽然存储在磁盘上，但使用索引查找数据时，可以从磁盘先读取索引放到内存中，再通过索引从磁盘找到数据；再然后将磁盘读取到的数据也放到内存里。索引就让磁盘和内存强强联手，趁机搭上了内存的车，感受了一把纳秒级别速度的推背感。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/134c7c03e62d4c8bbc867daa00cbc789.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/134c7c03e62d4c8bbc867daa00cbc789.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/134c7c03e62d4c8bbc867daa00cbc789.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>但是不管查询的过程中怎么优化，只要根还在磁盘，就避免不了会发生多次磁盘 I/O ，而磁盘 I/O 次数越多，消耗的时间也越多。聪明的你这会儿可以看出这其实就是个需要考虑解决的痛点了。</p>
<ul>
<li><strong>要尽少在磁盘做 I/O 操作</strong></li>
</ul>
<p>但还有那么多的数据结构可选呢。其实索引需要发挥的目的已经决定了有哪些数据结构可选，那么就可以缩小选择其他数据结构的范围。从为什么要建索引本身的首要目的出发。</p>
<ul>
<li><strong>要能尽快的按照区间高效地范围查找</strong></li>
</ul>
<p>当然索引首要目的<strong>能支持高效范围查询，还要有插入更新等操作的动态数据结构</strong>。</p>
<p>所以有满足以这两条主要条件的除了树结构你还会想到其他什么数据结构？还有就是哈希表、跳表</p>
<h3 id="哈希表" class="headerLink">
    <a href="#%e5%93%88%e5%b8%8c%e8%a1%a8" class="header-mark"></a>哈希表</h3><p>哈希表的物理存储是一个数组⚠️，而数组在内存中是<strong>连续地址</strong>的空间。</p>
<p>数据以 <code>Key</code>、<code>Value</code> 的方式存储。哈希表拥有精确的查询，所以时间复杂度是 <code>O(1)</code>。</p>
<p>而哈希表之所以能这么快是通过 <code>Key </code>计算数组下标来快速找到 <code>Value</code>。</p>
<p>最简单的计算的方式是 <strong>余数法</strong>，通过先计算<code>key</code>的 <code>HashCode</code>，再通过<strong>哈希表的数组长度</strong>对 <code>HashCode</code> 求余，求余得出的余数就是数组下标，最后由下标访问到哈希表中存的<code>Key、Value</code>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/c9364955db264236a436b221756a1a1a.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/c9364955db264236a436b221756a1a1a.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/c9364955db264236a436b221756a1a1a.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>但是 <code>Key</code> 计算出的下标<strong>可能会有相同</strong>的情况，例如 <code>HashCode 1010</code> 对 <code>6</code> 取余是 <code>2</code>，但是 <code>HashCode 1112</code> 对 <code>6</code> 取余也是 <code>2</code>。</p>
<p>哈希算法随机计算出 HashCode 取余数组长度可能出现数组下标相同的情况，就是所谓的 <strong><code>哈希冲突</code></strong>。</p>
<p>而 <code>哈希冲突</code> 常用 <code>链表</code> 的方法解决。当发生 <code>哈希冲突</code>，相同下标的数据元素会替换成存储指针，而不同 <code>Key</code> 的数据元素添加到链表中。查找时通过指针遍历这个链表，再匹配出正确的 <code>Key</code> 就可以。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/7cdd6369532c417a9843dcf83fcfa584.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/7cdd6369532c417a9843dcf83fcfa584.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/7cdd6369532c417a9843dcf83fcfa584.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>如上图所示，<code>Key</code> 是 &ldquo;一颗剽悍的种子&rdquo; 的字符串 ，<code>Value</code> 是 &ldquo;不要忘了关注、点赞、评论&rdquo;。我们通过计算<code>key</code>为 <code>HashCode（1010）</code> 的整数型值<code>int</code>。然后用 <code>HashCode（1010）</code> 对长度为 <code>6</code> 的哈希表数组长度做取余得出 <code>2</code>，这 <code>2</code> 的值元素就是 ( Key = &ldquo;一颗剽悍的种子&rdquo;,Value = &ldquo;不要忘了关注、点赞、评论&rdquo;) 。</p>
<p>虽然哈希表虽然可以高效的等值查询。例如SQL：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">select * from weixin where username = &#34;一颗剽悍的种子&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是<strong>不支持区间查询</strong>。例如SQL：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">select * from weixin where age &lt; 18
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么如果哈希表用来做成索引，当进行范围查询时意味着要全部扫描。类似 Redis 存储形式是 KV 的 NoSQL 数据库，会适合等值查询的场景。</p>
<h3 id="跳表" class="headerLink">
    <a href="#%e8%b7%b3%e8%a1%a8" class="header-mark"></a>跳表</h3><p>跳表似乎对于我们来说是一个比较陌生的数据结构，但是在 Redis 中却是比较常用的数据结构之一。跳表底层实质就是可以进行二分查找的<strong>有序链表</strong>，他在链表基础加上索引层，即能支持插入、删除等动态操作，也支持按区间高效查询。而且不管是查找、插入、删除对应的时间复杂度都是 <code>O(logn)</code>。</p>
<p>要理解跳表，先来看链表，假设链表存储是有序的数据，我们要想查询某一个数据，在最差的情况下要从头全遍历整个链表，时间复杂度是 <code>O(n)</code>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/8b760ec0cec045aea1302676ec385eaf.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/8b760ec0cec045aea1302676ec385eaf.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/8b760ec0cec045aea1302676ec385eaf.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>如下图所示，跳表是在链表基础上加了索引层。可以起到支持区间查询的作用。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/de330e29044d428c93fcaa5b6f1669d8.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/de330e29044d428c93fcaa5b6f1669d8.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/de330e29044d428c93fcaa5b6f1669d8.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>从上图所示，我们如果要查询一个 <code>26</code> 的节点，跳表就可以先从索引层遍历，当遍历到在索引层的 <code>21</code> 节点，会发现下一个索引层的节点是 <code>36</code> 节点时，很明显要找的 <code>26</code>
的节点就在这区间。此时我们只要再通过索引层指向原始链表的指针往下移到原始链这一层遍历，只要遍历 <code>2</code> 个节点即可找到 <code>26</code> 了。<del>如果用原来的链表需要遍历 <code>10</code> 个节点，现在只要遍历 <code>8</code> 个节点</del>。如果用原来的链表需要遍历 <code>8</code> 个节点，现在也只要遍历 <code>8</code> 个节点（<code>5-&gt;10-&gt;16-&gt;21-&gt;36-&gt;21-&gt;21-&gt;26</code>
），但是对于大量数据来说，是可以节省查询时间的。（原文应该是有误，这是按照我的理解写的，具体可以参看<a href="https://juejin.cn/post/7081065180301361183#heading-3:~:text=%E5%A6%82%E6%9E%9C%E7%94%A8%E5%8E%9F%E6%9D%A5%E7%9A%84%E9%93%BE%E8%A1%A8%E9%9C%80%E8%A6%81%E9%81%8D%E5%8E%86%2010%20%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%8F%AA%E8%A6%81%E9%81%8D%E5%8E%86%208%20%E4%B8%AA%E8%8A%82%E7%82%B9%E3%80%82" target="_blank" rel="noopener noreferrer">原文</a>）。</p>
<p>如下图中，一图胜千言。当数据量大时，一个包含多个结点的链表，在建立了五级索引后可以突显的看到索引层的优势。同时注意道这样一个规律 <strong>“加一层索引，查询所需要遍历的节点个数减少，查询效率也就提高了。”</strong></p>
<p>从用户的角度就是，跳表这家伙其实就是在告诉链表从什么地方开始找比较快。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/03cc278b5ef545138f52074efec2999b.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/03cc278b5ef545138f52074efec2999b.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/03cc278b5ef545138f52074efec2999b.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>看到这，跳表似乎也很适合用来作为索引的数据结构。但是不要忘了还有首个条件没满足，就是 <strong>&ldquo;要尽少在磁盘做 I/O 操作。&rdquo;</strong>
而跳表显然没能满足这一条件，<strong>跳表在随数据量增多的情况，索引层也会随着增高，相应的就会增加读取I/O的次数，从而影响性能</strong>。</p>
<p>那么回到 “那么多数据结构，为什么选树结构的问题？”，我们发现哈希表和跳表并不能很好的满足解决磁盘痛点和索引目的的这两个主要条件。那么我们来看为什么要来选树结构。</p>
<h3 id="树结构" class="headerLink">
    <a href="#%e6%a0%91%e7%bb%93%e6%9e%84" class="header-mark"></a>树结构</h3><p>我们先来看现实中一颗树都有哪些部分组成，首先要有根、树枝、还有树叶。那抽象成树结构也是一样的，树结构的顶端是 <code>根节点（root）</code>，左侧的节点称为 <code>左子树</code>，右子树对应的在右侧的节点，树的末端没有节点的称为 <code>叶子节点</code>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/06fe0d461c284c218f616c98b0d14dff.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/06fe0d461c284c218f616c98b0d14dff.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/06fe0d461c284c218f616c98b0d14dff.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>从树的层级关系可以分为上下级和同级节点，如下图，<code>D、E</code>是<code>B</code>节点的子节点，那么<code>B</code> 节点就是它们的父节点，跟<code>B</code>节点在同一层级的<code>C</code>节点是<code>B</code>节点的兄弟节点。</p>
<p>同时树的最大层级数，称为树的高度（深度），图下的树高度是<strong>3</strong>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/316bcf4e06bd4b15a480b56eb5665b99.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/316bcf4e06bd4b15a480b56eb5665b99.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/316bcf4e06bd4b15a480b56eb5665b99.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>从树结构的层级角度看，其实树结构是不是跟前面的跳表还有点相似。而跳表之所以这么快是因为有能按区间高效查询的索引层。</p>
<p>而树结构其特性决定了遍历数据方式本身就纯天然的支持按区间查询。再加上树是非线性结构的优势相比于线性结构的数组，不必像数组的数据是连续存放的。那么当树结构在插入新数据时就不用像数组插入数据前时，需要将数据所在往后的所有数据节点都得往后挪动的开销。所以树结构更适合插入更新等动态操作的数据结构。</p>
<p>树结构在满足了索引目的和其他条件的情况下，至于减少磁盘查询操作的痛点其实我们就可以在基于树结构的数据结构中去选择。</p>
<h2 id="那么多的树结构为什么偏偏采用-b-树作为索引" class="headerLink">
    <a href="#%e9%82%a3%e4%b9%88%e5%a4%9a%e7%9a%84%e6%a0%91%e7%bb%93%e6%9e%84%e4%b8%ba%e4%bb%80%e4%b9%88%e5%81%8f%e5%81%8f%e9%87%87%e7%94%a8-b-%e6%a0%91%e4%bd%9c%e4%b8%ba%e7%b4%a2%e5%bc%95" class="header-mark"></a>那么多的树结构？为什么偏偏采用 B+ 树作为索引?</h2><p>那么多的树结构中，除了B+树，你还会想到哪些树结构？二叉树查找树、自平衡二叉树、B树。</p>
<h3 id="二叉树" class="headerLink">
    <a href="#%e4%ba%8c%e5%8f%89%e6%a0%91" class="header-mark"></a>二叉树</h3><p>在了解二叉查找树或者自平衡二叉树前需要先简单知道什么是二叉树，什么是二分查找树。因为你看二叉查找树不就是这两棵树的合并吗。</p>
<p>我们先来看看二叉树，二叉树的树结构中定义的是每个节点的可以是<code>0个子节</code>或<code>1个子节点</code>，但是最多不超<code>2个子节点</code>。</p>
<p>而二叉树还有两个形式：<strong>满二叉树、完全二叉树</strong></p>
<p><strong>满二叉树</strong></p>
<p>满二叉树的定义是一棵二叉树的所有非叶子节点都存在左右子节点，并且所有子节点在同一层级。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/a5ecaccfda4246f086a976cdd3988a54.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/a5ecaccfda4246f086a976cdd3988a54.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/a5ecaccfda4246f086a976cdd3988a54.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p><strong>完全二叉树</strong></p>
<p>完全二叉树是指从左至右填充节点，直到最后一层，且最后一层的节点都靠左对齐。因此，满二叉树的所有层都可能被填充满，而完全二叉树虽然最后一层不一定满，但是尽可能填充到最左侧。如下图。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/90538ecd70fc4c439054eed2e33b93c6.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/90538ecd70fc4c439054eed2e33b93c6.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/90538ecd70fc4c439054eed2e33b93c6.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<h3 id="二叉查找树" class="headerLink">
    <a href="#%e4%ba%8c%e5%8f%89%e6%9f%a5%e6%89%be%e6%a0%91" class="header-mark"></a>二叉查找树</h3><p>此二叉查找树的 “二” 非彼二，因为此 “二” 既可以说是表示二叉的树，也可以表示二分查找，因为二叉查找树既是二叉也融合了二分查找。</p>
<p>先简单的看看二分查找，二分查找可以避免有序的数组从头依次的遍历查询，因为我们知道这种情况如果要查找一个数最差的情况时间复杂就是<code>O(n)</code>
，整体查询效率不高。而如果数组是<strong>有序</strong>的，就可以通过二分查找将每次的查询范围减半，时间复杂度自然就是<code>O(logn)</code>。如下图所示。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/1689be2bb3d24f7da12fbf2d4ec37736.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/1689be2bb3d24f7da12fbf2d4ec37736.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/1689be2bb3d24f7da12fbf2d4ec37736.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>所以说，二叉查找树不同于普通二叉查找树，是将小于根节点的元素放在左子树，而右子树正好相反是放大于根节点的元素。说白了就是根节点是左子树和右子树的中位数，左边放小于中位数的，右边放大于中位数，这不就是二分查找算法的奥义。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/cbb74bc84a5c4c88abde473347b77dd6~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.gif" title="640.gif" data-thumbnail="https://cdn.xiaobinqt.cn/cbb74bc84a5c4c88abde473347b77dd6~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.gif" data-sub-html="<h2>图片</h2><p>640.gif</p>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>如上动图所示，二分查找树在查找数据时，只需要将需要查找的元素与树节点元素进行比较，当元素大于根节点则往右子树中查找，元素小于根节点则往左子树中查找，元素如果正好是中位数那么就是正好是根节点，所以二叉查找树具备高效查询。</p>
<p>但是二叉树也有明显<strong>弊端</strong>，在极端情况下，如果每次插入的数据都是最小或者都是最大的元素，那么树结构会退化成一条链表。查询数据是的时间复杂度就会是<code>O(n)</code>，如下图所示。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/2fa9c648547f4c15a87959a2b3459dfa.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/2fa9c648547f4c15a87959a2b3459dfa.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/2fa9c648547f4c15a87959a2b3459dfa.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>当二分查找树退化成链表时，我们知道链表不仅不能高效查询而且也增加了磁盘 IO 操作，所以我们得划向下一个树型数据结构。</p>
<h3 id="自平衡二叉树avl树" class="headerLink">
    <a href="#%e8%87%aa%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%a0%91avl%e6%a0%91" class="header-mark"></a>自平衡二叉树/AVL树</h3><p>自平衡二叉树就是来解决二叉查找树极端下退化成链表的问题，自平衡二叉树也称<strong>平衡二叉查找树</strong>（AVL树）。</p>
<blockquote>
<p>可以看到从简单的二叉树，一步步演化到二分查找树再到现在的自平衡二叉树。一个简单的东西慢慢的逐渐走向复杂。如果只知道答案，我们是不会知道来龙去脉的。</p>
</blockquote>
<p>平衡二叉查找树其实主要就是在二叉查找树的基础上加上约束：<strong>让每个节点的左右子树高度差不能超过 1</strong>。那么这样让可以让左右子树都保持平衡，让查询数据操作的时间复杂度在 <code>O(logn)</code>。</p>
<p>如下图所示，平衡二叉查找树将每次插入的元素数据都会维持自平衡。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/202308053871d3e8b2e34eaa8253be7643052ae1~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.gif" title="640.gif" data-thumbnail="https://cdn.xiaobinqt.cn/202308053871d3e8b2e34eaa8253be7643052ae1~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.gif" data-sub-html="<h2>图片</h2><p>640.gif</p>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>如下图所示，普通非平衡二叉树和平衡二叉树的对比。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/87466af324fb41dbae9f8bd27e91ecfc.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/87466af324fb41dbae9f8bd27e91ecfc.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/87466af324fb41dbae9f8bd27e91ecfc.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>还有在 Java 中集合类常见的红黑树，也是自平衡二叉树中的一种。</p>
<p>但是不管自平衡树是平衡二叉查找树还是红黑树，都会<strong>随着插入的元素增多，而导致树的高度变高</strong>，这同样意味着磁盘 I/O 操作次数多，影响到整体查询的效率。</p>
<h3 id="b树" class="headerLink">
    <a href="#b%e6%a0%91" class="header-mark"></a>B树</h3><p>我们平时看到<code>B+树</code>还有<code>B-树</code>，不免就会将<code>B-树</code>读成<code>B减树</code> ，但<code>B-树</code>其<code>-</code>横线只是连接符，所以<code>B-树</code>就是称为<code>B树</code>。</p>
<p>自平衡二叉树虽然查找的时间复杂度在<code>O(logn)</code>，前面也说过它本身是一个二叉树，每个节点只能有2个子节点，那么随着数据量增大的时候，节点个数越多，树高度也会增高（也就是树的深度越深），增加磁盘 I/O 次数，影响查询效率。</p>
<p>那么你如果从树形结构的二叉树这一路的进阶过程中可以看到，二叉树每一次为了解决一个新的问题都会创造出新的<code>bug</code>或者创造一个又个的痛点。看到这就不难猜到，B树的出现可以解决树高度的问题。</p>
<p>之所以是 B 树，而并不是名称中 “xxx二叉树”，就是它<strong>不再限制一个父节点中只能有两个子节点</strong>，而是允许 <code>M</code> 个子节点<code>（M &gt; 2）</code>。不仅如此，<strong>B树的一个节点可以存储多个元素</strong>，相比较于前面的那些二叉树数据结构又将整体的树高度降低了。</p>
<p>B 树的节点可以包含有多个子节点，所以<strong>B树是一棵多叉树</strong>，它的每一个节点包含的最多子节点数量的称为B树的<strong>阶</strong>。如下图是一颗 3 阶的 B 树。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/e0c9903e46ab49558dd38d7e803da058.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/e0c9903e46ab49558dd38d7e803da058.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/e0c9903e46ab49558dd38d7e803da058.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<blockquote>
<p>上图中每一个节点称为页，在 mysql 中数据读取的基本单位是页，而页就是我们上面所说的磁盘块。磁盘块中的 p 节点是指向子节点的指针。</p>
<p>指针在树结构中都有，在前面的二叉树中也都是有的。</p>
</blockquote>
<p>那我们来看一下上图所示，当一颗 3 阶的B树查找 <code>90</code> 这个的元素时的流程是怎么样的？</p>
<p>先从根节点出发，也就是 <code>磁盘块1</code>，判断 <code>90</code> 在<code>17 ~ 35</code>之间，通过<code>磁盘块1</code>中的指针 <code>p3</code> 找到<code>磁盘块4</code>。还是按照原来的步骤，在<code>磁盘块4</code>中的<code>65 ~ 87</code>之间相比较，最后<code>磁盘4</code>的指针<code>p3</code>找到<code>磁盘块11</code>。也就找到有匹配<code>90</code>的键值。</p>
<p>可以发现一颗 3 阶的 B 树在查找叶子节点时，由于树高度只有 <code>3</code>，所以查找过程最多只需要<code>3次</code>的磁盘 I/O 操作。</p>
<p>数据量不大时可能不太真切。但当数据量大时，节点也会随着增多；此时如果还是前面的自平衡二叉树的场景下，由于二叉树只能最多<code>2</code>个叶子节点的约束，也只能纵向去的去扩展子节点，树的高度会很高，意味着需要更多的操作磁盘 I/O 次数。而 B 树则可以通过横向扩展节点从而降低树的高度，所以效率自然要比二叉树效率更高。直白说就是变矮胖了。</p>
<p>看到这，相信你也知道如果 B 树这么适合，也就没有接下来 B+ 树的什么事了。</p>
<p>接着，那为什么不用 B 树，而用 了B+ 树呢？</p>
<p>其实，B 树其实已经满足了我们最前面所要满足的条件，减少磁盘 I/O 操作，同时支持按区间查找。但注意，虽然 <strong>B 树支持按区间查找，但并不高效</strong>。</p>
<p>例如上面的例子中，B树能高效的通过<strong>等值查询</strong> <code>90</code>这个值，但不方便查询出一个区间内比如，<code>3 ~ 10</code> 区间内所有数的结果。因为当B树做范围查询时需要使用中序遍历，那么父节点和子节点也就需要不断的来回切换涉及了多个节点会给磁盘 I/O 带来很多负担。</p>
<h3 id="b树-1" class="headerLink">
    <a href="#b%e6%a0%91-1" class="header-mark"></a>B+树</h3><p>B+ 树从<code>+</code>的符号可以看出是 B 树的升级版，MySQL 中 innoDB 引擎中的索引底层数据结构采用的正是 B+ 树。</p>
<p>B+ 树相比于 B 树，做了这样的升级：<strong>B+ 树中的非叶子节点都不存储数据，而是只作为索引</strong>。</p>
<p>由叶子节点存放整棵树的所有数据。而叶子节点之间构成一个从小到大有序的链表互相指向相邻的叶子节点，也就是叶子节点之间形成了有序的双向链表。如下图 B+ 树的结构。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/f8eec821424f49598a2d62e82f63e711.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/f8eec821424f49598a2d62e82f63e711.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230805/f8eec821424f49598a2d62e82f63e711.png" data-sub-html="<h2>图片</h2>">
        
    </a><figcaption class="image-caption">图片</figcaption>
    </figure></p>
<p>B+ 树是不是有点像前面的跳表，数据底层是数据，上层都是按底层区间构成的索引层，只不过它不像跳表是纵向扩展，而是横向扩展的 “跳表”。这么做的好处即减少磁盘的 IO 操作又提高了范围查找的效率。</p>
<p>接着再来看 B+ 树的插入和删除，B+ 树做了大量冗余节点，从上面可以发现父节点的所有元素都会在子节点中出现，这样当删除一个节点时，可以直接从叶子节点中删除，这样效率更快。</p>
<p>B 树相比于 B+ 树，B 树没有冗余节点，删除节点时会发生复杂的<strong>树变形</strong>，而 B+ 树有冗余节点，不会涉及到复杂的树变形。而且 B+ 树的插入也是如此，最多只涉及树的一条分支路径。B+ 树也不用更多复杂算法，可以类似黑红树的旋转去自动平衡。</p>
<h2 id="总结" class="headerLink">
    <a href="#%e6%80%bb%e7%bb%93" class="header-mark"></a>总结</h2><p>从文章的题目开始就是一个问题，我们并没有直接回答为什么MySQL 采用 B+ 树作为索引的答案，而是相反的问出了两个问题，一个问题是那么多数据结构，为什么选树结构？另一个问题是那么多的树结构，又为什么偏偏采用 B+ 树？</p>
<p>要得到果，得先知道因，我们从两个方面开始出发，因为 MySQL 的数据是放在磁盘的，而磁盘的处理速度是毫秒级别的，如果在磁盘 IO 做过多查询操作，会给查询带来负担，所以要尽少在磁盘 I/O 操作中做查询。另一个是从索引本身的首要目的，要能按区间高效地范围查找。</p>
<p>有了因，我们就开始去探索果，我们就可以先来回答第一个问题，<strong>“那么多数据结构，为什么选树结构？”</strong>
在其他数据结构中按逻辑结构的线性结构有哈希表和跳表。哈希表底层基于数组，虽然可以高效查询，但是只能等值查询，而不能支持范围查询。而跳表底层是链表，通过索引层可以实现高效的区间查询，但是随着数据量的递增，索引层也随着数据量的增多而增加。所以采用树的数据结构，树结构其特性决定了遍历数据方式本身就纯天然的支持按区间查询。树结构在插入等操作不用线性结构数组的开销，所以更适合插入更新等动态操作的数据结构。</p>
<p>接着我们另一个问题，<strong>“那么多的树结构，又为什么偏偏采用B+树？”</strong> 我们从树结构中父节点最多只能有两个子节点的二叉树，再从二叉树加上二分查找的二叉查找树，二叉树展现了高效的查询能力；但二叉查找树在<strong>极端情况下会退化成链表</strong>，所以进阶到自平衡二叉树，自平衡二叉树约束了每个节点的左右子树相差不能大于 1，但是二叉树因为只能最多是两个子节点，所以树的高度过高会导致磁盘做过多 I/O 的查询操作负担。</p>
<p>所以最后真正到了 B 树，B 树是多叉树，但只能高效单查询，并不能高效区间查询。所以才有 B+ 树，B+ 树是 B 树的升级，所有非叶子节点都用来做索引，只有叶子节点存储数据而且是有序双向的链表，树节点做了冗余，相比于 B 树既能支持高效的区间查询，插入和删除都比 B 树更加出色。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/zzti_erlie/article/details/82973742" target="_blank" rel="noopener noreferrer">MySQL索引为什么要用B+树实现</a></li>
<li><a href="https://www.cnblogs.com/cqqfboy/p/15323462.html" target="_blank" rel="noopener noreferrer">MySQL 为什么使用 B+ 树来作索引？MySQL 为什么使用 B+ 树来作索引？</a></li>
<li><a href="https://ivanzz1001.github.io/records/post/data-structure/2018/06/16/ds-bplustree" target="_blank" rel="noopener noreferrer">B+树详解</a></li>
<li><a href="https://www.bilibili.com/video/BV1HX4y1N7v6/" target="_blank" rel="noopener noreferrer">【干货】数据库索引为什么使用B+Tree？</a></li>
<li><a href="https://juejin.cn/post/7081065180301361183" target="_blank" rel="noopener noreferrer">MySQL 为什么采用 B+树作为索引？5年经验程序员回答让我悟了</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/152285749" target="_blank" rel="noopener noreferrer">满二叉树和完全二叉树的区别</a></li>
</ul>
]]></description>
</item><item>
    <title>mysql workbench 查看触发器</title>
    <link>https://www.xiaobinqt.cn/mysql-workbench-show-triggers/</link>
    <pubDate>Wed, 20 Apr 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/mysql-workbench-show-triggers/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<p>mysql <a href="https://dev.mysql.com/downloads/workbench/" target="_blank" rel="noopener noreferrer">workbench</a> 是官方推荐的数据库工具，用了很长时间却一直不知道触发器在哪儿😢。</p>
<p>触发器是对单个表的操作，而不是整个数据库的操作，所以 <code>Alter Table </code>就可以看到触发器：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220420/795d688e27b34d9d8f7b512a99721148.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="图1" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220420/795d688e27b34d9d8f7b512a99721148.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>图1</h2><p>图1</p>">
        
    </a><figcaption class="image-caption">图1</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220420/f3c5261baeba4b99abf32e5ad9411cc3.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="图2" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220420/f3c5261baeba4b99abf32e5ad9411cc3.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>图2</h2><p>图2</p>">
        
    </a><figcaption class="image-caption">图2</figcaption>
    </figure></p>
<p>点这个扳手图标也可以看到触发器，跟 <code>Alter Table </code>效果一样：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220420/ac8c3ed5178346a59c61a187b398ef0b.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="图3" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220420/ac8c3ed5178346a59c61a187b398ef0b.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>图3</h2><p>图3</p>">
        
    </a><figcaption class="image-caption">图3</figcaption>
    </figure></p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://www.youtube.com/watch?v=X8o0gETy-OQ" target="_blank" rel="noopener noreferrer">MySQL Workbench : How to Configure Triggers in MySQL</a></li>
</ul>
]]></description>
</item><item>
    <title>Docker 安装 mysql8.0</title>
    <link>https://www.xiaobinqt.cn/docker-install-mysql8.0/</link>
    <pubDate>Wed, 08 Sep 2021 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/docker-install-mysql8.0/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="设置镜像源" class="headerLink">
    <a href="#%e8%ae%be%e7%bd%ae%e9%95%9c%e5%83%8f%e6%ba%90" class="header-mark"></a>设置镜像源</h2><p>国内的网络环境，使用官方的镜像源，下载速度很慢，所以我们需要使用国内的镜像源。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cat /etc/docker/daemon.json
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果没有<code>daemon.json</code>文件可以手动创建一个。可以设置中国区镜像或是网易镜像，也可以设置阿里云镜像（推荐使用阿里云的加速器，因为快🤣）。</p>
<ul>
<li>中国区镜像</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;registry-mirrors&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;https://registry.docker-cn.com&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>网易镜像</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;registry-mirrors&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;https://hub-mirror.c.163.com&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>阿里云镜像</li>
</ul>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/db638d8f1d5447bca5e54227203de932.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="阿里云镜像地址" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/db638d8f1d5447bca5e54227203de932.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>阿里云镜像地址</h2><p>阿里云镜像地址</p>">
        
    </a><figcaption class="image-caption">阿里云镜像地址</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/96866e63f1ca4b9d9f5e3b129c405cd4.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="设置镜像源" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/96866e63f1ca4b9d9f5e3b129c405cd4.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>设置镜像源</h2><p>设置镜像源</p>">
        
    </a><figcaption class="image-caption">设置镜像源</figcaption>
    </figure></p>
<p>设置完成后，重启docker服务。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">systemctl restart docker
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以通过 <code>docker info</code> 查看镜像源是否设置成功。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker info <span class="p">|</span> grep Mirrors -A <span class="m">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/bd599a600ab44a73a6f21de4167a4446.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="查看镜像源" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/bd599a600ab44a73a6f21de4167a4446.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>查看镜像源</h2><p>查看镜像源</p>">
        
    </a><figcaption class="image-caption">查看镜像源</figcaption>
    </figure></p>
<h2 id="下载镜像" class="headerLink">
    <a href="#%e4%b8%8b%e8%bd%bd%e9%95%9c%e5%83%8f" class="header-mark"></a>下载镜像</h2><p>可以去 <a href="https://hub.docker.com/_/mysql/tags" target="_blank" rel="noopener noreferrer">https://hub.docker.com/_/mysql/tags</a> 仓库找需要的 mysql 版本👇</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/09ed0f1adae443d3a22a34796c8b3c0e.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="镜像下载" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/09ed0f1adae443d3a22a34796c8b3c0e.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>镜像下载</h2><p>镜像下载</p>">
        
    </a><figcaption class="image-caption">镜像下载</figcaption>
    </figure></p>
<p>通过 <code>docker pull</code>下载需要的镜像。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/569c7174b200474f9e20724d2f7c4e35.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="下载镜像" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/569c7174b200474f9e20724d2f7c4e35.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>下载镜像</h2><p>下载镜像</p>">
        
    </a><figcaption class="image-caption">下载镜像</figcaption>
    </figure></p>
<h2 id="配置并启动容器" class="headerLink">
    <a href="#%e9%85%8d%e7%bd%ae%e5%b9%b6%e5%90%af%e5%8a%a8%e5%ae%b9%e5%99%a8" class="header-mark"></a>配置并启动容器</h2><h3 id="主机挂载目录" class="headerLink">
    <a href="#%e4%b8%bb%e6%9c%ba%e6%8c%82%e8%bd%bd%e7%9b%ae%e5%bd%95" class="header-mark"></a>主机挂载目录</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir -p mysql8.0/<span class="o">{</span>conf,data<span class="o">}</span> <span class="c1"># conf 存放配置文件,data 存放数据库文件</span>
</span></span><span class="line"><span class="cl">touch mysql8.0/conf/my.cnf <span class="c1"># 创建配置文件</span>
</span></span><span class="line"><span class="cl">chown -R 999:999 mysql8.0 <span class="c1"># 修改权限</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将<code>my.cnf</code>文件中写入以下配置</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="o">[</span>mysqld<span class="o">]</span>
</span></span><span class="line"><span class="cl">pid-file        <span class="o">=</span> /var/run/mysqld/mysqld.pid
</span></span><span class="line"><span class="cl"><span class="nv">socket</span>          <span class="o">=</span> /var/run/mysqld/mysqld.sock
</span></span><span class="line"><span class="cl"><span class="nv">datadir</span>         <span class="o">=</span> /var/lib/mysql
</span></span><span class="line"><span class="cl">secure-file-priv<span class="o">=</span> /var/lib/mysql
</span></span></code></pre></td></tr></table>
</div>
</div><p>具体可以参考<a href="https://github.com/docker-library/mysql/blob/master/8.0/config/my.cnf" target="_blank" rel="noopener noreferrer">https://github.com/docker-library/mysql/blob/master/8.0/config/my.cnf</a></p>
<p><code>secure-file-priv</code> 设置为 <code>/var/lib/mysql</code>是为了解决 <a href="https://github.com/docker-library/mysql/issues/541" target="_blank" rel="noopener noreferrer">MySQL 8 docker-compose :Failed to access directory for &ndash;secure-file-priv</a> 问题。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/014c2fb94bb74b0b8f42178efaff315c.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="设置挂载目录" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/014c2fb94bb74b0b8f42178efaff315c.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>设置挂载目录</h2><p>设置挂载目录</p>">
        
    </a><figcaption class="image-caption">设置挂载目录</figcaption>
    </figure></p>
<h3 id="启动容器" class="headerLink">
    <a href="#%e5%90%af%e5%8a%a8%e5%ae%b9%e5%99%a8" class="header-mark"></a>启动容器</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker run -d <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -p 3310:3306 <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --name mysql8.0 <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -v /root/weibin/mysql8.0/conf/my.cnf:/etc/mysql/my.cnf <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -v /root/weibin/mysql8.0/data:/var/lib/mysql <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    -e <span class="nv">MYSQL_ROOT_PASSWORD</span><span class="o">=</span><span class="m">123456</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    mysql:8.0
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/2c0a7dbf9628400a98fcfaaa341c6970.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="启动容器" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/2c0a7dbf9628400a98fcfaaa341c6970.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>启动容器</h2><p>启动容器</p>">
        
    </a><figcaption class="image-caption">启动容器</figcaption>
    </figure></p>
<p>这里还可以在启动容器时初始化一些工作，比如建库建表，可以把 sql 或是 sh 文件放在容器的<code>/docker-entrypoint-initdb.d</code>目录下，可以直接通过宿主机映射到容器目录，比如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-v /root/dockerdata/mysql/docker-entrypoint-initdb.d:/docker-entrypoint-initdb.d
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230307/f4a351ea0e654164b078634826de0033.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230307/f4a351ea0e654164b078634826de0033.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230307/f4a351ea0e654164b078634826de0033.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>docker-entrypoint-initdb.d 目录</h2>">
        
    </a><figcaption class="image-caption">docker-entrypoint-initdb.d 目录</figcaption>
    </figure></p>
<h2 id="开启远程连接" class="headerLink">
    <a href="#%e5%bc%80%e5%90%af%e8%bf%9c%e7%a8%8b%e8%bf%9e%e6%8e%a5" class="header-mark"></a>开启远程连接</h2><p>如果不能远程连接可以进入容器后连接数据库，修改 mysql 库的 user 表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker <span class="nb">exec</span> -it 容器ID bash
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/c086da058f074cfc96f93ce87d8d2cfb.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="进入容器" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/c086da058f074cfc96f93ce87d8d2cfb.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>进入容器</h2><p>进入容器</p>">
        
    </a><figcaption class="image-caption">进入容器</figcaption>
    </figure></p>
<p>查看 user 表中的<code>user='root'</code>的账号的 host 是否是<code>%</code>，如果不是则设置为<code>%</code>。如果已存在多个 root 账号，其中只要有一个的 host 为<code>%</code>就可以了。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/534fccacb5c44d9e8dcc9db8df1d6ee3.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="设置host" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/534fccacb5c44d9e8dcc9db8df1d6ee3.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>设置host</h2><p>设置host</p>">
        
    </a><figcaption class="image-caption">设置host</figcaption>
    </figure></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">update user <span class="nb">set</span> <span class="nv">host</span><span class="o">=</span><span class="s1">&#39;%&#39;</span> where <span class="nv">user</span> <span class="o">=</span> <span class="s1">&#39;root&#39;</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果修改了用户需要执行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">flush privileges<span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样在不重启的 mysql 服务的情况下就可以生效。</p>
<h2 id="修改密码" class="headerLink">
    <a href="#%e4%bf%ae%e6%94%b9%e5%af%86%e7%a0%81" class="header-mark"></a>修改密码</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ALTER USER <span class="s1">&#39;root&#39;</span>@<span class="s1">&#39;localhost&#39;</span> IDENTIFIED WITH caching_sha2_password BY <span class="s1">&#39;yourpasswd&#39;</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/3ca7bd00dfaf402d871581aca72d2e93.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="修改密码" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/3ca7bd00dfaf402d871581aca72d2e93.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>修改密码</h2><p>修改密码</p>">
        
    </a><figcaption class="image-caption">修改密码</figcaption>
    </figure></p>
<h2 id="faq" class="headerLink">
    <a href="#faq" class="header-mark"></a>FAQ</h2><ul>
<li>❓ <strong>secure-file-priv</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Failed to access directory <span class="k">for</span> --secure-file-priv. Please make sure that directory exists and is accessible by MySQL Server. Supplied value : /var/lib/mysql-files
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/22c2b7f4e7f24aaba10ede6b043cbb55.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="FAQ1" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/22c2b7f4e7f24aaba10ede6b043cbb55.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>FAQ1</h2><p>FAQ1</p>">
        
    </a><figcaption class="image-caption">FAQ1</figcaption>
    </figure></p>
<p>宿主机的映射目录需要设置用户和用户组为<code>999:999</code>，因为 docker 容器里的用户也是 999，可以启动一个临时容器进去查看。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/8591686d90444944a3b3aaefed189b26.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="999:999" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221121/8591686d90444944a3b3aaefed189b26.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>999:999</h2><p>999:999</p>">
        
    </a><figcaption class="image-caption">999:999</figcaption>
    </figure></p>
<ul>
<li>❓ <strong>flush privileges</strong></li>
</ul>
<p><code>flush privileges</code>命令本质上的作用是将当前 user 和 privilige 表中的用户信息/权限设置从 mysql 库中提取到内存里。</p>
<p>MySQL 用户数据和权限有修改后，希望在<strong>不重启MySQL服务</strong>的情况下直接生效，就可以执行这个命令。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://gist.github.com/y0ngb1n/7e8f16af3242c7815e7ca2f0833d3ea6" target="_blank" rel="noopener noreferrer">Docker Hub 镜像加速器</a></li>
<li><a href="https://github.com/docker-library/mysql/issues/541" target="_blank" rel="noopener noreferrer">MySQL 8 docker-compose :Failed to access directory for &ndash;secure-file-priv</a></li>
<li><a href="https://www.jianshu.com/p/000fee62e786" target="_blank" rel="noopener noreferrer">docker安装mysql 8</a></li>
<li><a href="https://stackoverflow.com/questions/50691977/how-to-reset-the-root-password-in-mysql-8-0-11" target="_blank" rel="noopener noreferrer">How to reset the root password in MySQL 8.0.11?</a></li>
<li><a href="https://www.atlantic.net/dedicated-server-hosting/how-to-create-a-new-user-and-grant-permissions-in-mysql8-on-centos8/" target="_blank" rel="noopener noreferrer">How To Create a New User and Grant Permissions in MySQL8 on CentOS8</a></li>
</ul>
]]></description>
</item><item>
    <title>Mysql 服务端如何处理客户端请求</title>
    <link>https://www.xiaobinqt.cn/mysql-server-exec-client-raw-sql/</link>
    <pubDate>Sun, 20 Dec 2020 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/mysql-server-exec-client-raw-sql/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<p>不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：客户端进程向服务器进程发送一段文本（MySQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）。</p>
<p>那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？客户端可以向服务器发送增删改查各类请求，这里以查询请求为例，图示一下大致的过程👇</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220517/e3f164a15a2e49bdb4481b4bfced866d.png" title="client-server" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220517/e3f164a15a2e49bdb4481b4bfced866d.png" data-sub-html="<h2>client-server</h2><p>client-server</p>">
        
    </a><figcaption class="image-caption">client-server</figcaption>
    </figure></p>
<h2 id="连接管理" class="headerLink">
    <a href="#%e8%bf%9e%e6%8e%a5%e7%ae%a1%e7%90%86" class="header-mark"></a>连接管理</h2><p>每当有一个客户端进程连接到服务器进程时，服务器进程都会<strong>创建一个线程</strong>来专门处理与这个客户端的交互，当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。这样就起到了不频繁创建和销毁线程的效果，从而节省开销。</p>
<p>MySQL服务器会为每一个连接进来的客户端分配一个线程，但是线程分配的太多了会严重影响系统性能，所以也需要限制一下可以同时连接到服务器的客户端数量。<code>max_connections</code>可以设置允许同时连入的客户端数量。</p>
<p>在客户端程序发起连接的时候，需要携带主机信息、用户名、密码，服务器程序会对客户端程序提供的这些信息进行认证，如果认证失败，服务器程序会拒绝连接。</p>
<p>当连接建立后，与该客户端关联的服务器线程会一直等待客户端发送过来的请求，MySQL服务器接收到的请求只是一个文本消息，该文本消息还要经过各种处理。</p>
<h2 id="解析与优化" class="headerLink">
    <a href="#%e8%a7%a3%e6%9e%90%e4%b8%8e%e4%bc%98%e5%8c%96" class="header-mark"></a>解析与优化</h2><h3 id="查询缓存" class="headerLink">
    <a href="#%e6%9f%a5%e8%af%a2%e7%bc%93%e5%ad%98" class="header-mark"></a>查询缓存</h3><p>MySQL服务器程序处理查询请求时，会把刚刚处理过的查询请求和结果缓存起来，如果下一次有一模一样的请求过来，直接从缓存中查找结果就好了，就不用再去底层的表中查找了。这个查询缓存可以在不同客户端之间共享，也就是说如果客户端A刚刚查询了一个语句，而客户端B之后发送了同样的查询请求，那么客户端B的这次查询就可以直接使用查询缓存中的数据。</p>
<p>当然，MySQL服务器并没有人聪明，如果两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。另外，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 <code>mysql</code>
、<code>information_schema</code>、 <code>performance_schema</code> 数据库中的表，那这个请求就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数<code>NOW</code>
，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的！</p>
<p>既然是缓存，就有缓存失效的时候。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了<code>INSERT</code>、 <code>UPDATE</code>、<code>DELETE</code>、<code>TRUNCATE TABLE</code>、<code>ALTER TABLE</code>
、<code>DROP TABLE</code>或 <code>DROP DATABASE</code>语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！</p>
<blockquote>
<p>虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL
8.0中删除。</p>
</blockquote>
<h3 id="语法解析" class="headerLink">
    <a href="#%e8%af%ad%e6%b3%95%e8%a7%a3%e6%9e%90" class="header-mark"></a>语法解析</h3><p>如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。因为客户端程序发送过来的请求只是一段文本，所以MySQL服务器程序首先要对这段文本做分析，判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到MySQL服务器<strong>内部使用的一些数据结构上来</strong>。</p>
<h3 id="查询优化" class="headerLink">
    <a href="#%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96" class="header-mark"></a>查询优化</h3><p>语法解析之后，服务器程序获得到了需要的信息，比如要查询的列是哪些，表是哪个，搜索条件是什么等等，但光有这些是不够的，因为我们写的MySQL语句执行起来效率可能并不是很高，MySQL的优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化等。</p>
<p>优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是什么样的。可以使用<code>EXPLAIN</code>语句来查看某个语句的执行计划。</p>
<h2 id="存储引擎" class="headerLink">
    <a href="#%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e" class="header-mark"></a>存储引擎</h2><p>当服务器程序完成了查询优化，这时还没有真正的去访问真实的数据表，MySQL服务器把数据的<strong>存储和提取操作</strong>都封装到了一个叫存储引擎的模块里。</p>
<p>我们知道表是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是存储引擎负责的事情。为了实现不同的功能，MySQL提供了各式各样的存储引擎，不同存储引擎管理的表具体的存储结构可能不同，采用的存取算法也可能不同。</p>
<p>为了管理方便，把<code>连接管理</code>、<code>查询缓存</code>、<code>语法解析</code>、<code>查询优化</code>这些并不涉及真实数据存储的功能划分为<code>MySQL server</code>的功能，把真实存取数据的功能划分为存储引擎的功能。各种不同的存储引擎向上边的<code>MySQL server</code>
层提供统一的调用接口（也就是存储引擎API），包含了几十个底层函数，像&quot;读取索引第一条内容&quot;、&ldquo;读取索引下一条内容&rdquo;、&ldquo;插入记录&quot;等等。</p>
<p>所以在<code>MySQL server</code>完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。</p>
]]></description>
</item><item>
    <title>mysql 存储程序</title>
    <link>https://www.xiaobinqt.cn/mysql-stored-routine/</link>
    <pubDate>Thu, 08 Oct 2020 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/mysql-stored-routine/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="总览" class="headerLink">
    <a href="#%e6%80%bb%e8%a7%88" class="header-mark"></a>总览</h2><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220419/e92bc705bec14bcba089f2a8848359b2.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="存储程序" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220419/e92bc705bec14bcba089f2a8848359b2.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>存储程序</h2><p>存储程序</p>">
        
    </a><figcaption class="image-caption">存储程序</figcaption>
    </figure></p>
<p>存储程序可以封装一些语句，然后给用户提供一种简单的方式来调用这个存储程序，从而间接地执行某些语句。根据调用方式的不同，可以把存储程序分为<code>存储例程</code>、<code>触发器</code>和<code>事件</code>，存储例程又分为<code>存储函数</code>和<code>存储过程</code>，如☝️
上图。</p>
<h2 id="存储函数" class="headerLink">
    <a href="#%e5%ad%98%e5%82%a8%e5%87%bd%e6%95%b0" class="header-mark"></a>存储函数</h2><p>存储函数<strong>只有一个返回值</strong>，可以从 mysql 内置的函数理解，所有 mysql 内置的函数都是只有一个返回值，比如：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220420/b1bfc8c3ac9a45dea2dfdc1fb901e54f.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="mysql 内置函数" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220420/b1bfc8c3ac9a45dea2dfdc1fb901e54f.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>mysql 内置函数</h2><p>mysql 内置函数</p>">
        
    </a><figcaption class="image-caption">mysql 内置函数</figcaption>
    </figure></p>
<p>存储函数很好理解，就是一个函数，跟普通函数一样有<code>函数名</code>，<code>函数体</code>，<code>参数列表</code>和<code>返回值</code>。创建存储函数语句如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">FUNCTION</span><span class="w"> </span><span class="err">存储函数名称</span><span class="p">([</span><span class="err">参数列表</span><span class="p">])</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">RETURNS</span><span class="w"> </span><span class="err">返回值类型</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">BEGIN</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="err">函数体内容</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">END</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th>CMD</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SHOW FUNCTION STATUS [LIKE 需要匹配的函数名]</code></td>
<td>查看所有存储函数</td>
</tr>
<tr>
<td><code>SHOW CREATE FUNCTION 函数名</code></td>
<td>查看某个存储函数</td>
</tr>
<tr>
<td><code>DROP FUNCTION 函数名</code></td>
<td>删除某个存储函数</td>
</tr>
</tbody>
</table>
<h3 id="示例" class="headerLink">
    <a href="#%e7%a4%ba%e4%be%8b" class="header-mark"></a>示例</h3><p>现在写一个存储函数，输入用户名 <code>name</code>，返回用户手机号 <code>phone</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">FUNCTION</span><span class="w"> </span><span class="n">get_phone</span><span class="p">(</span><span class="n">qname</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="w"> </span><span class="p">(</span><span class="mi">45</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">RETURNS</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">BEGIN</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">RETURN</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">phone</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">from</span><span class="w"> </span><span class="n">t</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">where</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">qname</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">END</span><span class="w"> </span><span class="n">EOF</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>存储函数的调用跟普通函数的调用也是一样的👇</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220419/fbbd1bb4c54341368ccda472619df5d2.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="效果" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220419/fbbd1bb4c54341368ccda472619df5d2.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>效果</h2><p>效果</p>">
        
    </a><figcaption class="image-caption">效果</figcaption>
    </figure></p>
<h2 id="局部变量和自定义变量" class="headerLink">
    <a href="#%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e5%92%8c%e8%87%aa%e5%ae%9a%e4%b9%89%e5%8f%98%e9%87%8f" class="header-mark"></a>局部变量和自定义变量</h2><p>在存储函数中可以使用局部变量和自定义变量，二者的区别是，局部变量用 <code>DECLARE</code> 申明，不用加 <code>@</code>符，局部变量随着函数调用结束，变量销毁且只能在存储函数中使用。自定义变量需要加 <code>@</code> 符，且可以在函数外调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">CREATE FUNCTION get_phone<span class="o">(</span>qname VARCHAR <span class="o">(</span>45<span class="o">))</span>
</span></span><span class="line"><span class="cl">    RETURNS VARCHAR<span class="o">(</span>11<span class="o">)</span>
</span></span><span class="line"><span class="cl">BEGIN
</span></span><span class="line"><span class="cl">    DECLARE ph varchar<span class="o">(</span>11<span class="o">)</span> default <span class="s2">&#34;&#34;</span><span class="p">;</span> <span class="c1"># 局部变量</span>
</span></span><span class="line"><span class="cl">    SET @ii <span class="o">=</span> 100<span class="p">;</span> <span class="c1"># 自定义变量</span>
</span></span><span class="line"><span class="cl">    SET <span class="nv">ph</span> <span class="o">=</span> <span class="o">(</span><span class="k">select</span> phone from t where <span class="nv">name</span> <span class="o">=</span> qname<span class="o">)</span><span class="p">;</span> <span class="c1"># 给局部变量赋值</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    RETURN  ph <span class="p">;</span>
</span></span><span class="line"><span class="cl">END EOF
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220419/40c4689ff9214887a6cfd46c761df53d.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="局部变量和自定义变量" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220419/40c4689ff9214887a6cfd46c761df53d.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>局部变量和自定义变量</h2><p>局部变量和自定义变量</p>">
        
    </a><figcaption class="image-caption">局部变量和自定义变量</figcaption>
    </figure></p>
<p>☝️ 可知，在存储函数<code>get_phone</code>中有一个局部变量 <code>ph</code>和自定义变量 <code>@ii</code>，函数调用结束后 <code>@ii</code> 被赋值为<code>100</code> 且可以在函数执行完后访问，但是 <code>@ph</code> 是空的。</p>
<h2 id="存储过程" class="headerLink">
    <a href="#%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b" class="header-mark"></a>存储过程</h2><p>存储函数侧重于执行某些语句并<strong>返回一个值</strong>，而存储过程更侧重于单纯的去执行这些语句。存储过程的定义<strong>不需要声明返回值类型</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">PROCEDURE</span><span class="w"> </span><span class="err">存储过程名称</span><span class="p">([</span><span class="err">参数列表</span><span class="p">])</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">BEGIN</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="err">需要执行的语句</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">END</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>调用存储过程使用 <code>CALL</code> 关键字。</p>
<table>
<thead>
<tr>
<th>CMD</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SHOW PROCEDURE STATUS [LIKE 需要匹配的存储过程名称]</code></td>
<td>查看所有存储过程</td>
</tr>
<tr>
<td><code>SHOW CREATE PROCEDURE 存储过程名称</code></td>
<td>查看某个存储过程</td>
</tr>
<tr>
<td><code>DROP PROCEDURE 存储过程名称</code></td>
<td>删除某个存储过程</td>
</tr>
</tbody>
</table>
<h3 id="示例-1" class="headerLink">
    <a href="#%e7%a4%ba%e4%be%8b-1" class="header-mark"></a>示例</h3><p>以下示例定义了一个 <code>my_operate</code> 的存储过程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">CREATE PROCEDURE my_operate<span class="o">(</span>pname varchar <span class="o">(</span>45<span class="o">))</span>
</span></span><span class="line"><span class="cl">BEGIN
</span></span><span class="line"><span class="cl">     SELECT * FROM t<span class="p">;</span>
</span></span><span class="line"><span class="cl">     INSERT INTO t<span class="o">(</span>phone, name<span class="o">)</span> VALUES<span class="o">(</span><span class="s2">&#34;15214254125&#34;</span>, <span class="s2">&#34;卢俊义&#34;</span><span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     SELECT * FROM t<span class="p">;</span>
</span></span><span class="line"><span class="cl">     SELECT * from t where <span class="nv">name</span> <span class="o">=</span> pname<span class="p">;</span>
</span></span><span class="line"><span class="cl">END EOF
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220419/283408a351b74a758648f47b08fa347c.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="存储过程" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220419/283408a351b74a758648f47b08fa347c.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>存储过程</h2><p>存储过程</p>">
        
    </a><figcaption class="image-caption">存储过程</figcaption>
    </figure></p>
<p>☝️ <code>my_operate</code> 定义并执行了 4 条 sql，完美诠释了存储过程更侧重于单纯的去执行这些语句。</p>
<h2 id="存储过程的参数前缀" class="headerLink">
    <a href="#%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b%e7%9a%84%e5%8f%82%e6%95%b0%e5%89%8d%e7%bc%80" class="header-mark"></a>存储过程的参数前缀</h2><p>存储过程在定义参数的时候可以选择添加一些前缀👇，如果不写，<strong>默认的前缀是<code>IN</code></strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">参数类型 <span class="o">[</span>IN <span class="p">|</span> OUT <span class="p">|</span> INOUT<span class="o">]</span> 参数名 数据类型
</span></span></code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th>前缀   <div style="width: 55px;"></th>
<th>实际参数是否必须是变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IN</code></td>
<td>否</td>
<td>用于调用者向存储过程传递数据，如果<code>IN</code>参数在过程中被修改，调用者不可见。</td>
</tr>
<tr>
<td><code>OUT</code></td>
<td>是</td>
<td>用于把存储过程运行过程中产生的数据赋值给<code>OUT</code>参数，存储过程执行结束后，调用者可以访问到<code>OUT</code>参数。</td>
</tr>
<tr>
<td><code>INOUT</code></td>
<td>是</td>
<td>综合<code>IN</code>和<code>OUT</code>的特点，既可以用于调用者向存储过程传递数据，也可以用于存放存储过程中产生的数据以供调用者使用。</td>
</tr>
</tbody>
</table>
<p>👇以下的示例，综合了 <code>in</code>，<code>out</code>，<code>inout</code> 参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">CREATE PROCEDURE my_arg<span class="o">(</span>
</span></span><span class="line"><span class="cl">            in pname varchar <span class="o">(</span>45<span class="o">)</span>,
</span></span><span class="line"><span class="cl">            out ophone char<span class="o">(</span>11<span class="o">)</span>,
</span></span><span class="line"><span class="cl">            inout io_name varchar<span class="o">(</span>45<span class="o">)</span>
</span></span><span class="line"><span class="cl">          <span class="o">)</span>
</span></span><span class="line"><span class="cl">BEGIN
</span></span><span class="line"><span class="cl">     SELECT * FROM t<span class="p">;</span>
</span></span><span class="line"><span class="cl">     INSERT INTO t<span class="o">(</span>phone, name<span class="o">)</span> VALUES<span class="o">(</span><span class="s2">&#34;15225632145&#34;</span>, <span class="s2">&#34;公孙胜&#34;</span><span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     SELECT * FROM t<span class="p">;</span>
</span></span><span class="line"><span class="cl">     SELECT phone from t where <span class="nv">name</span> <span class="o">=</span> pname into ophone<span class="p">;</span>
</span></span><span class="line"><span class="cl">     SET <span class="nv">pname</span> <span class="o">=</span> <span class="s2">&#34;公孙胜&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     SET <span class="nv">io_name</span> <span class="o">=</span> <span class="s2">&#34;公孙胜&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">END EOF
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220420/c792415cd0e1476eb60c2f831a4f2fa6.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="综合示例" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220420/c792415cd0e1476eb60c2f831a4f2fa6.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>综合示例</h2><p>综合示例</p>">
        
    </a><figcaption class="image-caption">综合示例</figcaption>
    </figure></p>
<p>由☝️可以看出，虽然在存储过程中修改了 <code>pname</code> 的值为 <code>公孙胜</code>，但是并<strong>没有生效</strong>，值依然是最初的<code>宋江</code>。<code>IN</code>参数只能被用于读取，对它赋值是不会被调用者看到的。</p>
<p><code>out</code> 参数 <code>ophone</code> 最初是空的，通过存储过程赋值成功为<code>公孙胜</code>。</p>
<p><code>inout</code> 参数 <code>io_name</code> 最初是空的，通过存储过程赋值成功为<code>公孙胜</code>，这里如果 <code>io_name</code> 不为空，也会被修改为<code>公孙胜</code>。</p>
<h2 id="存储过程和存储函数的区别" class="headerLink">
    <a href="#%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b%e5%92%8c%e5%ad%98%e5%82%a8%e5%87%bd%e6%95%b0%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-mark"></a>存储过程和存储函数的区别</h2><ul>
<li>存储函数在定义时需要显式用<code>RETURNS</code>语句标明返回的数据类型，而且在函数体中必须使用<code>RETURN</code>语句来显式指定返回的值，而存储过程不需要。</li>
<li>存储函数只支持<code>IN</code>参数，而存储过程支持<code>IN</code>参数、<code>OUT</code>参数、和<code>INOUT</code>参数。</li>
<li>存储函数<font style="color:red"><strong>只能返回一个值</strong></font>，而存储过程可以通过设置多个<code>OUT</code>参数或者<code>INOUT</code>参数来返回多个结果。</li>
<li>存储函数执行过程中产生的结果集并<strong>不会</strong>被显示到客户端，而存储过程执行过程中产生的结果集<strong>会</strong>被显示到客户端。</li>
<li>存储函数直接在表达式中调用，而存储过程只能通过<code>CALL</code>语句来显式调用。</li>
</ul>
<h2 id="游标" class="headerLink">
    <a href="#%e6%b8%b8%e6%a0%87" class="header-mark"></a>游标</h2><p>游标是为了方便访问结果集中的某一条记录，可以理解成循环。如果某个结果集中有 10 条记录，使用游标后，会一条一条的去访问这 10 条记录。</p>
<p>游标可以在存储函数和存储过程中使用。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220420/71873b26746f48f69a00761f46d21328.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="cursor" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220420/71873b26746f48f69a00761f46d21328.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>cursor</h2><p>cursor</p>">
        
    </a><figcaption class="image-caption">cursor</figcaption>
    </figure></p>
<p>使用游标分为 4 步：</p>
<ol>
<li>创建游标：<code>DECLARE 游标名称 CURSOR FOR 查询语句;</code></li>
<li>打开游标：<code>OPEN 游标名称;</code></li>
<li>通过游标访问记录</li>
<li>关闭游标：<code>CLOSE 游标名称;</code></li>
</ol>
<blockquote>
<p>不显式的使用<code>CLOSE</code>语句关闭游标的话，在该存储函数或存储过程执行完之后会自动关闭游标。</p>
</blockquote>
<p>可以使用👇来获取结果集中的记录：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">FETCH 游标名 INTO 变量1, 变量2, ... 变量n
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="示例-2" class="headerLink">
    <a href="#%e7%a4%ba%e4%be%8b-2" class="header-mark"></a>示例</h3><p>🤑以下创建一个存储过程，在存储过程中使用游标。</p>
<p>创建游标<code>t_cursor</code>，游标执行语句为 <code>SELECT phone, name FROM t</code>。</p>
<p><code>DECLARE CONTINUE HANDLER FOR NOT FOUND 处理语句;</code> 的作用是结果集遍历结束后会自动执行这句，这里也可以使用 <code>WHILE</code> 循环遍历，但是 <code>while</code>
有个弊端是需要提前知道结束条件，比如结果集的总数是多少。这样写的好处是直接遍历，遍历结束自动处理，将 <code>done</code> 变量设置为 <code>1</code>，也就是说只要 <code>done = 1</code> 就说明遍历结束了，利用 <code>LEAVE</code> 关键字跳出循环。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">CREATE PROCEDURE my_cursor<span class="o">()</span>
</span></span><span class="line"><span class="cl">BEGIN
</span></span><span class="line"><span class="cl">    DECLARE v_phone char<span class="o">(</span>11<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    DECLARE v_name varchar<span class="o">(</span>45<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    DECLARE <span class="k">done</span> INT DEFAULT 0<span class="p">;</span>
</span></span><span class="line"><span class="cl">    DECLARE t_cursor CURSOR FOR SELECT <span class="sb">`</span>phone<span class="sb">`</span>, <span class="sb">`</span>name<span class="sb">`</span> FROM t<span class="p">;</span>
</span></span><span class="line"><span class="cl">    DECLARE CONTINUE HANDLER FOR NOT FOUND SET <span class="k">done</span> <span class="o">=</span> 1<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    OPEN t_cursor<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    flag: LOOP
</span></span><span class="line"><span class="cl">        FETCH t_cursor INTO v_phone, v_name<span class="p">;</span>
</span></span><span class="line"><span class="cl">        IF <span class="k">done</span> <span class="o">=</span> <span class="m">1</span> THEN
</span></span><span class="line"><span class="cl">            LEAVE flag<span class="p">;</span>
</span></span><span class="line"><span class="cl">        END IF<span class="p">;</span>
</span></span><span class="line"><span class="cl">        SELECT v_phone, v_name, <span class="k">done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    END LOOP flag<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    CLOSE t_cursor<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">END EOF
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220420/5dfc58f6432548ff9ce5d3dd7b5dcec4.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="执行结果" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220420/5dfc58f6432548ff9ce5d3dd7b5dcec4.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>执行结果</h2><p>执行结果</p>">
        
    </a><figcaption class="image-caption">执行结果</figcaption>
    </figure></p>
<h2 id="触发器和事件" class="headerLink">
    <a href="#%e8%a7%a6%e5%8f%91%e5%99%a8%e5%92%8c%e4%ba%8b%e4%bb%b6" class="header-mark"></a>触发器和事件</h2><p>存储例程是需要手动调用的，而触发器和事件是 MySQL 服务器在特定情况下自动调用的。</p>
<h2 id="触发器" class="headerLink">
    <a href="#%e8%a7%a6%e5%8f%91%e5%99%a8" class="header-mark"></a>触发器</h2><p>创建触发器</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">CREATE TRIGGER 触发器名
</span></span><span class="line"><span class="cl"><span class="o">{</span>BEFORE<span class="p">|</span>AFTER<span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">{</span>INSERT<span class="p">|</span>DELETE<span class="p">|</span>UPDATE<span class="o">}</span>
</span></span><span class="line"><span class="cl">ON 表名
</span></span><span class="line"><span class="cl">FOR EACH ROW
</span></span><span class="line"><span class="cl">BEGIN
</span></span><span class="line"><span class="cl">    触发器内容
</span></span><span class="line"><span class="cl">END
</span></span></code></pre></td></tr></table>
</div>
</div><p>MySQL 目前只支持对<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>这三种类型的语句设置触发器。</p>
<p><code>FOR EACH ROW BEGIN ... END</code>表示对具体语句影响的每一条记录都执行触发器内容。</p>
<p>对于<code>INSERT</code>语句来说，<code>FOR EACH ROW</code>影响的记录就是准备插入的那些新记录。</p>
<p>对于<code>DELETE</code>语句和<code>UPDATE</code>语句来说，<code>FOR EACH ROW</code>影响的记录就是符合条件的那些记录。</p>
<p>针对每一条受影响的记录，需要一种访问该记录中的内容的方式，MySQL提供了<code>NEW</code>和<code>OLD</code>两个单词来分别代表新记录和旧记录，它们在不同语句中的含义不同：</p>
<ul>
<li>对于<code>INSERT</code>语句设置的触发器来说，<code>NEW</code>代表准备插入的记录，<code>OLD</code>无效。</li>
<li>对于<code>DELETE</code>语句设置的触发器来说，<code>OLD</code>代表删除前的记录，<code>NEW</code>无效。</li>
<li>对于<code>UPDATE</code>语句设置的触发器来说，<code>NEW</code>代表修改后的记录，<code>OLD</code>代表修改前的记录。</li>
</ul>
<h3 id="示例-3" class="headerLink">
    <a href="#%e7%a4%ba%e4%be%8b-3" class="header-mark"></a>示例</h3><p>🤦‍♂️以下示例，对表 <code>t</code> 创建一个 <code>my_trigger</code>触发器，表 <code>t</code> 有三个字段，<code>name</code>，<code>phone</code>，<code>my_join</code>，对于每条 <code>insert</code> 的语句，在执行 <code>insert</code>
之前判断如果
<code>name = admin</code> 那么将即将插入的 <code>name</code> 值改为 <code>valid</code>，如果 <code>name</code> 值为<code>空</code>，将即将插入的 <code>name</code> 值改为<code>无名氏</code>，除此之外将 <code>name</code> 和 <code>phone</code> 拼接后赋给 <code>my_join</code>
字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">CREATE TRIGGER my_trigger
</span></span><span class="line"><span class="cl">     BEFORE INSERT ON t
</span></span><span class="line"><span class="cl">     FOR EACH ROW
</span></span><span class="line"><span class="cl">     BEGIN
</span></span><span class="line"><span class="cl">         IF NEW.name <span class="o">=</span> <span class="s1">&#39;admin&#39;</span> THEN
</span></span><span class="line"><span class="cl">             SET NEW.name <span class="o">=</span> <span class="s1">&#39;valid&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">         ELSEIF NEW.name <span class="o">=</span> <span class="s1">&#39;&#39;</span> THEN
</span></span><span class="line"><span class="cl">            SET NEW.name <span class="o">=</span> <span class="s1">&#39;无名氏&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">         ELSE
</span></span><span class="line"><span class="cl">            SET NEW.my_join <span class="o">=</span> CONCAT<span class="o">(</span>NEW.name, <span class="s2">&#34;--&#34;</span>, NEW.phone<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">         END IF<span class="p">;</span>
</span></span><span class="line"><span class="cl"> END EOF
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220420/f7108f5048cc42b9b3a4effb62dfd34c.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="示例演示" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220420/f7108f5048cc42b9b3a4effb62dfd34c.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>示例演示</h2><p>示例演示</p>">
        
    </a><figcaption class="image-caption">示例演示</figcaption>
    </figure></p>
<table>
<thead>
<tr>
<th>CMD</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SHOW TRIGGERS;</code></td>
<td>查看所有触发器</td>
</tr>
<tr>
<td><code>SHOW CREATE TRIGGER 触发器名;</code></td>
<td>查看某个触发器</td>
</tr>
<tr>
<td><code>DROP TRIGGER 触发器名;</code></td>
<td>删除某个触发器</td>
</tr>
</tbody>
</table>
<h3 id="注意事项" class="headerLink">
    <a href="#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9" class="header-mark"></a>注意事项</h3><ul>
<li>触发器内容中不能有输出结果集的语句。</li>
<li>触发器内容中<code>NEW</code>代表记录的列的值可以被更改，<code>OLD</code>代表记录的列的值无法更改。</li>
<li>在<code>BEFORE</code>触发器中，我们可以使用<code>SET NEW.列名 = 某个值</code>的形式来更改待插入记录或者待更新记录的某个列的值，但是这种操作不能在<code>AFTER</code>触发器中使用，因为在执行<code>AFTER</code>
触发器的内容时记录已经被插入完成或者更新完成了。</li>
<li>如果我们的<code>BEFORE</code>触发器内容执行过程中遇到了错误，那这个触发器对应的具体语句将无法执行；如果具体的操作语句执行过程中遇到了错误，那与它对应的<code>AFTER</code>触发器的内容将无法执行。</li>
</ul>
<h2 id="事件" class="headerLink">
    <a href="#%e4%ba%8b%e4%bb%b6" class="header-mark"></a>事件</h2><p>事件可以让 MySQL 服务器在某个时间点或者每隔一段时间自动地执行一些语句。</p>
<p>默认情况下，MySQL服务器并不会帮助我们执行事件，需要手动开启该功能：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">SET GLOBAL <span class="nv">event_scheduler</span> <span class="o">=</span> ON<span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220421/2892ec357bc54b3e90d1009886e36d26.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="开启事件功能" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220421/2892ec357bc54b3e90d1009886e36d26.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>开启事件功能</h2><p>开启事件功能</p>">
        
    </a><figcaption class="image-caption">开启事件功能</figcaption>
    </figure></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">CREATE EVENT 事件名
</span></span><span class="line"><span class="cl">ON SCHEDULE
</span></span><span class="line"><span class="cl"><span class="o">{</span>
</span></span><span class="line"><span class="cl">    AT 某个确定的时间点<span class="p">|</span> 
</span></span><span class="line"><span class="cl">    EVERY 期望的时间间隔 <span class="o">[</span>STARTS datetime<span class="o">][</span>END datetime<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">DO
</span></span><span class="line"><span class="cl">BEGIN
</span></span><span class="line"><span class="cl">    具体的语句
</span></span><span class="line"><span class="cl">END
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="某个时间点执行" class="headerLink">
    <a href="#%e6%9f%90%e4%b8%aa%e6%97%b6%e9%97%b4%e7%82%b9%e6%89%a7%e8%a1%8c" class="header-mark"></a>某个时间点执行</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">CREATE EVENT insert_t1_event
</span></span><span class="line"><span class="cl">ON SCHEDULE
</span></span><span class="line"><span class="cl">AT <span class="s1">&#39;2022-01-03 11:20:11&#39;</span> <span class="c1"># 或者 AT DATE_ADD(NOW(), INTERVAL 2 DAY)</span>
</span></span><span class="line"><span class="cl">DO
</span></span><span class="line"><span class="cl">BEGIN
</span></span><span class="line"><span class="cl">    INSERT INTO t<span class="o">(</span>phone, name<span class="o">)</span> VALUES<span class="o">(</span><span class="s1">&#39;15210214254&#39;</span>, <span class="s1">&#39;宋江&#39;</span><span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">END
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="每隔一段时间执行" class="headerLink">
    <a href="#%e6%af%8f%e9%9a%94%e4%b8%80%e6%ae%b5%e6%97%b6%e9%97%b4%e6%89%a7%e8%a1%8c" class="header-mark"></a>每隔一段时间执行</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">CREATE EVENT insert_t1
</span></span><span class="line"><span class="cl">ON SCHEDULE
</span></span><span class="line"><span class="cl">EVERY <span class="m">1</span> HOUR STARTS <span class="s1">&#39;2019-09-04 15:48:54&#39;</span> ENDS <span class="s1">&#39;2019-09-16 15:48:54&#39;</span>
</span></span><span class="line"><span class="cl">DO
</span></span><span class="line"><span class="cl">BEGIN
</span></span><span class="line"><span class="cl">    INSERT INTO t<span class="o">(</span>phone, name<span class="o">)</span> VALUES<span class="o">(</span><span class="s1">&#39;15210214254&#39;</span>, <span class="s1">&#39;宋江&#39;</span><span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">END
</span></span></code></pre></td></tr></table>
</div>
</div><p>在创建好事件之后，到了指定时间，MySQL 服务器会自动执行。</p>
<table>
<thead>
<tr>
<th>CMD</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SHOW EVENTS;</code></td>
<td>查看所有事件</td>
</tr>
<tr>
<td><code>SHOW CREATE EVENT 事件名;</code></td>
<td>查看某个事件</td>
</tr>
<tr>
<td><code>DROP EVENT 事件名;</code></td>
<td>删除某个事件</td>
</tr>
</tbody>
</table>
]]></description>
</item><item>
    <title>MySQL 常见问题（一）</title>
    <link>https://www.xiaobinqt.cn/mysql-simple-faq/</link>
    <pubDate>Thu, 03 Oct 2019 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/mysql-simple-faq/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221117/6d5a8e4d284a409ea3e415a46fcbb393.png" referrerpolicy="no-referrer">
            </div><!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="主键和-unique-的区别" class="headerLink">
    <a href="#%e4%b8%bb%e9%94%ae%e5%92%8c-unique-%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-mark"></a>主键和 UNIQUE 的区别</h2><p>主键和<code>UNIQUE</code>约束都能保证某个列或者列组合的唯一性，但是：</p>
<ul>
<li>一张表中只能定义一个主键，却可以定义多个<code>UNIQUE</code>约束！</li>
<li>主键列不允许存放<code>NULL</code>，而声明了<code>UNIQUE</code>属性的列可以存放<code>NULL</code>，而且<code>NULL</code>可以重复地出现在多条记录中。</li>
</ul>
<h2 id="结束符" class="headerLink">
    <a href="#%e7%bb%93%e6%9d%9f%e7%ac%a6" class="header-mark"></a>结束符</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">delimiter EOF  <span class="c1"># 将结束符改为 EOF</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220419/fdd2e38117284a7f8b46ba3af60c26c9.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="修改结束符" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220419/fdd2e38117284a7f8b46ba3af60c26c9.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>修改结束符</h2><p>修改结束符</p>">
        
    </a><figcaption class="image-caption">修改结束符</figcaption>
    </figure></p>
<p>由☝️图可知，将默认的结束符从 <code>;</code> 改为 <code>EOF</code>。</p>
<h2 id="什么是外键" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%a4%96%e9%94%ae" class="header-mark"></a>什么是外键</h2><p>如果<code>A</code>表中的某个列或者某些列依赖与<code>B</code>表中的某个列或者某些列，那么就称<code>A</code>表为子表，<code>B</code>表为父表。子表和父表可以使用外键来关联起来。</p>
<p><strong>父表中被子表依赖的列或者列组合必须建立索引</strong>，如果该列或者列组合已经是主键或者有<code>UNIQUE</code>属性，那么也就被默认建立了索引。</p>
<p>定义外键的语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CONSTRAINT</span><span class="w"> </span><span class="p">[</span><span class="err">外键名称</span><span class="p">]</span><span class="w"> </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="p">(</span><span class="err">列</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="err">列</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="err">父表名</span><span class="p">(</span><span class="err">父列</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="err">父列</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="示例" class="headerLink">
    <a href="#%e7%a4%ba%e4%be%8b" class="header-mark"></a>示例</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">student_score</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">number</span><span class="w">  </span><span class="nb">INT</span><span class="p">,</span><span class="w"> </span><span class="c1">-- 学号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">subject</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">score</span><span class="w">   </span><span class="n">TINYINT</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="nb">number</span><span class="p">,</span><span class="w"> </span><span class="n">subject</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="nb">number</span><span class="p">)</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">student_info</span><span class="w"> </span><span class="p">(</span><span class="nb">number</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>☝️ 如上，在对<code>student_score</code>表插入数据的时候，MySQL 都会检查插入的学号是否能在<code>student_info</code>
表中找到，如果找不到则会报错，因为<code>student_score</code>表中的<code>number</code>
列依赖于<code>student_info</code>表的<code>number</code>列，也就是，如果没有这个学生，何来成绩？</p>
<h2 id="zerofill" class="headerLink">
    <a href="#zerofill" class="header-mark"></a>ZEROFILL</h2><p>对于<strong>无符号整数类型</strong>的列，可以在查询数据的时候让数字左边补 0，如果想实现这个效果需要给该列加一个<code>ZEROFILL</code>属性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">zerofill_table</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">i1</span><span class="w"> </span><span class="nb">INT</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="n">UNSIGNED</span><span class="w"> </span><span class="n">ZEROFILL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">i2</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="n">UNSIGNED</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>INT后边的<code>(5)</code>，这个 5 就是显示宽度，默认是10，也就是 <code>INT</code> 也 <code>INT(10)</code> 效果是一样的。</p>
<h3 id="注意" class="headerLink">
    <a href="#%e6%b3%a8%e6%84%8f" class="header-mark"></a>注意</h3><ul>
<li>该列必须是整数类型</li>
<li>该列必须有 <code>UNSIGNED ZEROFILL</code>的属性</li>
<li>该列的实际值的位数必须小于显示宽度</li>
<li>在创建表的时候，如果声明了<code>ZEROFILL</code>属性的列没有声明<code>UNSIGNED</code>属性，MySQL 会为该列自动生成<code>UNSIGNED</code>属性</li>
<li><strong>显示宽度并不会影响实际类型的实际存储空间</strong></li>
<li>对于没有声明<code>ZEROFILL</code>属性的列，显示宽度没有任何作用，只有在查询声明了<code>ZEROFILL</code>属性的列时，显示宽度才会起作用，否则<strong>可以忽略</strong>显示宽度这个东西的存在。</li>
</ul>
<h2 id="limitoffset-区别" class="headerLink">
    <a href="#limitoffset-%e5%8c%ba%e5%88%ab" class="header-mark"></a>limit、offset 区别</h2><blockquote>
<p>从 0 开始计数，第1条记录在 MYSQL 中是第 0 条。</p>
</blockquote>
<p>limit 和 offset 都可以用来限制查询条数，一般用做分页。</p>
<ul>
<li>当 limit 后面跟一个参数的时候，该参数表示要取的数据的数量</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">from</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">limit</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>表示直接取前三条数据。</p>
<ul>
<li>当 limit 后面跟两个参数的时候，第一个数表示<strong>开始行</strong>，后一位表示要取的数量，例如</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">from</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">limit</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>从 0 行开始计算，取第 1 - 3 条数据，也就是取 1,2,3 三条数据。</p>
<ul>
<li>当 limit 和 offset 组合使用的时候，limit 后面只能有一个参数，表示要取的的数量，offset 表示开始行。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">from</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">limit</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">offset</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>从 0 行开始计算，取第 1 - 3 条数据，也就是取 1,2,3 三条数据。</p>
<h2 id="常用函数" class="headerLink">
    <a href="#%e5%b8%b8%e7%94%a8%e5%87%bd%e6%95%b0" class="header-mark"></a>常用函数</h2><h3 id="文本处理函数" class="headerLink">
    <a href="#%e6%96%87%e6%9c%ac%e5%a4%84%e7%90%86%e5%87%bd%e6%95%b0" class="header-mark"></a>文本处理函数</h3><table>
<thead>
<tr>
<th>名称</th>
<th>调用示例</th>
<th>示例结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LEFT</code></td>
<td><code>LEFT('abc123', 3)</code></td>
<td><code>abc</code></td>
<td>给定字符串从左边取指定长度的子串</td>
</tr>
<tr>
<td><code>RIGHT</code></td>
<td><code>RIGHT('abc123', 3)</code></td>
<td><code>123</code></td>
<td>给定字符串从右边取指定长度的子串</td>
</tr>
<tr>
<td><code>LENGTH</code></td>
<td><code>LENGTH('abc')</code></td>
<td><code>3</code></td>
<td>给定字符串的长度</td>
</tr>
<tr>
<td><code>LOWER</code></td>
<td><code>LOWER('ABC')</code></td>
<td><code>abc</code></td>
<td>给定字符串的小写格式</td>
</tr>
<tr>
<td><code>UPPER</code></td>
<td><code>UPPER('abc')</code></td>
<td><code>ABC</code></td>
<td>给定字符串的大写格式</td>
</tr>
<tr>
<td><code>LTRIM</code></td>
<td><code>LTRIM(' abc')</code></td>
<td><code>abc</code></td>
<td>给定字符串左边空格去除后的格式</td>
</tr>
<tr>
<td><code>RTRIM</code></td>
<td><code>RTRIM('abc ')</code></td>
<td><code>abc</code></td>
<td>给定字符串右边空格去除后的格式</td>
</tr>
<tr>
<td><code>SUBSTRING</code></td>
<td><code>SUBSTRING('abc123', 2, 3)</code></td>
<td><code>bc1</code></td>
<td>给定字符串从指定位置截取指定长度的子串</td>
</tr>
<tr>
<td><code>CONCAT </code></td>
<td><code>CONCAT('abc', '123', 'xyz')</code></td>
<td><code>abc123xyz</code></td>
<td>将给定的各个字符串拼接成一个新字符串</td>
</tr>
</tbody>
</table>
<h3 id="时间处理函数" class="headerLink">
    <a href="#%e6%97%b6%e9%97%b4%e5%a4%84%e7%90%86%e5%87%bd%e6%95%b0" class="header-mark"></a>时间处理函数</h3><table>
<thead>
<tr>
<th>名称</th>
<th>调用示例</th>
<th>示例结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NOW</code></td>
<td><code>NOW()</code></td>
<td><code>2019-08-16 17:10:43</code></td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td><code>CURDATE</code></td>
<td><code>CURDATE()</code></td>
<td><code>2019-08-16</code></td>
<td>返回当前日期</td>
</tr>
<tr>
<td><code>CURTIME</code></td>
<td><code>CURTIME()</code></td>
<td><code>17:10:43</code></td>
<td>返回当前时间</td>
</tr>
<tr>
<td><code>DATE</code></td>
<td><code>DATE('2019-08-16 17:10:43')</code></td>
<td><code>2019-08-16</code></td>
<td>将给定日期和时间值的日期提取出来</td>
</tr>
<tr>
<td><code>DATE_ADD</code></td>
<td><code>DATE_ADD('2019-08-16 17:10:43', INTERVAL 2 DAY)</code></td>
<td><code>2019-08-18 17:10:43</code></td>
<td>将给定的日期和时间值添加指定的时间间隔</td>
</tr>
<tr>
<td><code>DATE_SUB</code></td>
<td><code>DATE_SUB('2019-08-16 17:10:43', INTERVAL 2 DAY)</code></td>
<td><code>2019-08-14 17:10:43</code></td>
<td>将给定的日期和时间值减去指定的时间间隔</td>
</tr>
<tr>
<td><code>DATEDIFF</code></td>
<td><code>DATEDIFF('2019-08-16', '2019-08-17')</code></td>
<td><code>-1</code></td>
<td>返回两个日期之间的天数（负数代表前一个参数代表的日期比较小）</td>
</tr>
<tr>
<td><code>DATE_FORMAT</code></td>
<td><code>DATE_FORMAT(NOW(),'%m-%d-%Y')</code></td>
<td><code>08-16-2019</code></td>
<td>用给定的格式显示日期和时间</td>
</tr>
</tbody>
</table>
<p>常见时间单位</p>
<table>
<thead>
<tr>
<th>时间单位</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MICROSECOND</code></td>
<td>毫秒</td>
</tr>
<tr>
<td><code>SECOND</code></td>
<td>秒</td>
</tr>
<tr>
<td><code>MINUTE</code></td>
<td>分钟</td>
</tr>
<tr>
<td><code>HOUR</code></td>
<td>小时</td>
</tr>
<tr>
<td><code>DAY</code></td>
<td>天</td>
</tr>
<tr>
<td><code>WEEK</code></td>
<td>星期</td>
</tr>
<tr>
<td><code>MONTH</code></td>
<td>月</td>
</tr>
<tr>
<td><code>QUARTER</code></td>
<td>季度</td>
</tr>
<tr>
<td><code>YEAR</code></td>
<td>年</td>
</tr>
</tbody>
</table>
<h3 id="数值处理函数" class="headerLink">
    <a href="#%e6%95%b0%e5%80%bc%e5%a4%84%e7%90%86%e5%87%bd%e6%95%b0" class="header-mark"></a>数值处理函数</h3><table>
<thead>
<tr>
<th>名称</th>
<th>调用示例</th>
<th>示例结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ABS</code></td>
<td><code>ABS(-1)</code></td>
<td><code>1</code></td>
<td>取绝对值</td>
</tr>
<tr>
<td><code>Pi</code></td>
<td><code>PI()</code></td>
<td><code>3.141593</code></td>
<td>返回圆周率</td>
</tr>
<tr>
<td><code>COS</code></td>
<td><code>COS(PI())</code></td>
<td><code>-1</code></td>
<td>返回一个角度的余弦</td>
</tr>
<tr>
<td><code>EXP</code></td>
<td><code>EXP(1)</code></td>
<td><code>2.718281828459045</code></td>
<td>返回e的指定次方</td>
</tr>
<tr>
<td><code>MOD</code></td>
<td><code>MOD(5,2)</code></td>
<td><code>1</code></td>
<td>返回除法的余数</td>
</tr>
<tr>
<td><code>RAND</code></td>
<td><code>RAND()</code></td>
<td><code>0.7537623539136372</code></td>
<td>返回一个随机数</td>
</tr>
<tr>
<td><code>SIN</code></td>
<td><code>SIN(PI()/2)</code></td>
<td><code>1</code></td>
<td>返回一个角度的正弦</td>
</tr>
<tr>
<td><code>SQRT</code></td>
<td><code>SQRT(9)</code></td>
<td><code>3</code></td>
<td>返回一个数的平方根</td>
</tr>
<tr>
<td><code>TAN</code></td>
<td><code>TAN(0)</code></td>
<td><code>0</code></td>
<td>返回一个角度的正切</td>
</tr>
</tbody>
</table>
<h2 id="count-函数" class="headerLink">
    <a href="#count-%e5%87%bd%e6%95%b0" class="header-mark"></a>COUNT 函数</h2><p>COUNT函数使用来统计<strong>行数</strong>的，有下边两种使用方式：</p>
<ul>
<li><code>COUNT(*)</code>：对表中行的数目进行计数，不管列的值是不是NULL。</li>
<li><code>COUNT(列名)</code>：对特定的列进行计数，会忽略掉该列为NULL的行。</li>
</ul>
<p><strong>两者的区别是会不会忽略统计列的值为NULL的行</strong>。</p>
<h2 id="查询" class="headerLink">
    <a href="#%e6%9f%a5%e8%af%a2" class="header-mark"></a>查询</h2><p><code>where</code> 竟然可以这么写😇</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">from</span><span class="w"> </span><span class="n">edge</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="p">(</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="k">mode</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;192.168.50.101&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>in</code> 竟然可以这么写😂</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">from</span><span class="w"> </span><span class="n">edge</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="p">(</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="k">mode</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="k">select</span><span class="w"> </span><span class="s1">&#39;192.168.50.101&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="判断语句" class="headerLink">
    <a href="#%e5%88%a4%e6%96%ad%e8%af%ad%e5%8f%a5" class="header-mark"></a>判断语句</h2><h3 id="if-then" class="headerLink">
    <a href="#if-then" class="header-mark"></a>if then</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">IF 表达式 THEN
</span></span><span class="line"><span class="cl">    处理语句列表
</span></span><span class="line"><span class="cl"><span class="o">[</span>ELSEIF 表达式 THEN
</span></span><span class="line"><span class="cl">    处理语句列表<span class="o">]</span>
</span></span><span class="line"><span class="cl">... <span class="c1"># 这里可以有多个ELSEIF语句</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>ELSE
</span></span><span class="line"><span class="cl">    处理语句列表<span class="o">]</span>
</span></span><span class="line"><span class="cl">END IF<span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="case-when" class="headerLink">
    <a href="#case-when" class="header-mark"></a>case when</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">CASE WHEN 表达式 THEN 处理语句
</span></span><span class="line"><span class="cl">    <span class="k">else</span> 表达式 end
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">## 或者</span>
</span></span><span class="line"><span class="cl">CASE when 表达式 <span class="k">then</span> 处理语句
</span></span><span class="line"><span class="cl">    when 表达式 <span class="k">then</span> 处理语句
</span></span><span class="line"><span class="cl">    ... 可以与多个 when 表达式 <span class="k">then</span> 处理语句
</span></span><span class="line"><span class="cl">   END
</span></span></code></pre></td></tr></table>
</div>
</div><p>示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="k">select</span> *,
</span></span><span class="line"><span class="cl">	CASE WHEN <span class="nv">name</span><span class="o">=</span><span class="s1">&#39;大彬&#39;</span> THEN <span class="s1">&#39;角色1&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="s1">&#39;角色2&#39;</span> end as processed_name ,
</span></span><span class="line"><span class="cl">    <span class="k">case</span> when <span class="nv">status</span> <span class="o">=</span> <span class="m">1</span> <span class="k">then</span> <span class="s1">&#39;已处理&#39;</span>
</span></span><span class="line"><span class="cl">    when <span class="nv">status</span> <span class="o">=</span> <span class="m">0</span> <span class="k">then</span> <span class="s1">&#39;未处理&#39;</span>
</span></span><span class="line"><span class="cl">    when <span class="nv">status</span> <span class="o">=</span> <span class="m">2</span> <span class="k">then</span> <span class="s1">&#39;待处理&#39;</span> end as processed_status
</span></span><span class="line"><span class="cl">    from user<span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="循环语句" class="headerLink">
    <a href="#%e5%be%aa%e7%8e%af%e8%af%ad%e5%8f%a5" class="header-mark"></a>循环语句</h2><h3 id="while" class="headerLink">
    <a href="#while" class="header-mark"></a>WHILE</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">WHILE 表达式 DO
</span></span><span class="line"><span class="cl">    处理语句列表
</span></span><span class="line"><span class="cl">END WHILE<span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="repeat" class="headerLink">
    <a href="#repeat" class="header-mark"></a>REPEAT</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">REPEAT
</span></span><span class="line"><span class="cl">    处理语句列表
</span></span><span class="line"><span class="cl">UNTIL 表达式 END REPEAT<span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="loop" class="headerLink">
    <a href="#loop" class="header-mark"></a>LOOP</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">LOOP
</span></span><span class="line"><span class="cl">    处理语句列表
</span></span><span class="line"><span class="cl">END LOOP<span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在使用 <code>LOOP</code> 时可以使用<code>RETURN</code>语句直接让函数结束就可以达到停止循环的效果，也可以使用<code>LEAVE</code>语句，不过使用<code>LEAVE</code>
时，需要先在<code>LOOP</code>语句前边放置一个所谓的标记。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">CREATE FUNCTION sum_all<span class="o">(</span>n INT UNSIGNED<span class="o">)</span>
</span></span><span class="line"><span class="cl">RETURNS INT
</span></span><span class="line"><span class="cl">BEGIN
</span></span><span class="line"><span class="cl">    DECLARE result INT DEFAULT 0<span class="p">;</span>
</span></span><span class="line"><span class="cl">    DECLARE i INT DEFAULT 1<span class="p">;</span>
</span></span><span class="line"><span class="cl">    flag:LOOP
</span></span><span class="line"><span class="cl">        IF i &gt; n THEN
</span></span><span class="line"><span class="cl">            LEAVE flag<span class="p">;</span>
</span></span><span class="line"><span class="cl">        END IF<span class="p">;</span>
</span></span><span class="line"><span class="cl">        SET <span class="nv">result</span> <span class="o">=</span> result + i<span class="p">;</span>
</span></span><span class="line"><span class="cl">        SET <span class="nv">i</span> <span class="o">=</span> i + 1<span class="p">;</span>
</span></span><span class="line"><span class="cl">    END LOOP flag<span class="p">;</span>
</span></span><span class="line"><span class="cl">    RETURN result<span class="p">;</span>
</span></span><span class="line"><span class="cl">END
</span></span></code></pre></td></tr></table>
</div>
</div><p>☝️示例中，在<code>LOOP</code>语句前加了一个<code>flag:</code>，相当于为这个循环打了一个名叫<code>flag</code>的标记，然后在对应的<code>END LOOP</code>
语句后边也把这个标记名<code>flag</code>
给写上了。在存储函数的函数体中使用<code>LEAVE flag</code>语句来结束<code>flag</code>这个标记所代表的循环。</p>
<blockquote>
<p>标记主要是为了可以跳到指定的语句中</p>
</blockquote>
<h2 id="duplicate-key-update" class="headerLink">
    <a href="#duplicate-key-update" class="header-mark"></a>DUPLICATE KEY UPDATE</h2><p>对于<strong>主键</strong>或者有<strong>唯一性约束</strong>的列或列组合来说，新插入的记录如果和表中已存在的记录重复的话，我们可以选择的策略不仅仅是忽略（<code>INSERT IGNORE</code>）该条记录的插入，也可以选择更新这条重复的旧记录。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">`</span><span class="n">t</span><span class="o">`</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">idt</span><span class="o">`</span><span class="w">   </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="n">AUTO_INCREMENT</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">phone</span><span class="o">`</span><span class="w"> </span><span class="nb">char</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w">    </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">name</span><span class="o">`</span><span class="w">  </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">idt</span><span class="o">`</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">UNIQUE</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="o">`</span><span class="n">idt_UNIQUE</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">idt</span><span class="o">`</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">UNIQUE</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="o">`</span><span class="n">phone_UNIQUE</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">phone</span><span class="o">`</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w"> </span><span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="w"> </span><span class="n">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">2</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如上表，<code>idt</code> 是唯一主键，<code>phone</code> 是 UNIQUE 唯一约束。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220419/1ba316643e874fcb9e90dcaa9b333f60.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="图1" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220419/1ba316643e874fcb9e90dcaa9b333f60.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>图1</h2><p>图1</p>">
        
    </a><figcaption class="image-caption">图1</figcaption>
    </figure></p>
<p>表里有条记录 <code>phone = 15212124125</code>，<code>name = '吴彦祖'</code>，现在再添加一条记录，phone 跟 <code>name = '吴彦祖'</code>
是一样的，但是 <code>name='宋江'</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">(</span><span class="n">phone</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;15212124125&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;宋江&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">DUPLICATE</span><span class="w"> </span><span class="k">KEY</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">UPDATE</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;宋江&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- 对于批量插入可以这么写，`VALUES(列名)`的形式来引用待插入记录中对应列的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">(</span><span class="n">phone</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;15212124125&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;宋江&#39;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="p">(</span><span class="s1">&#39;15212124126&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;李逵&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">DUPLICATE</span><span class="w"> </span><span class="k">KEY</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">UPDATE</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">name</span><span class="o">`</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>结果：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220419/6998e509ee9f4c3eacb72f9c5b42080b.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="图2" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220419/6998e509ee9f4c3eacb72f9c5b42080b.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>图2</h2><p>图2</p>">
        
    </a><figcaption class="image-caption">图2</figcaption>
    </figure></p>
<p>由结果可知，phone 电话的值没有改变，但是 name 被修改成了宋江。</p>
<p>也就是说，如果 <code>t</code> 表中已经存在 <code>phone</code> 的列值为 <code>15212124125</code> 的记录（因为 <code>phone</code>列具有<code>UNIQUE</code>
约束），那么就把该记录的 <code>name</code>列更新为<code>'宋江'</code>。</p>
<p>对于那些是主键或者具有UNIQUE约束的列或者列组合来说，如果表中已存在的记录中有与待插入记录在这些列或者列组合上重复的值，我们可以使用<code>VALUES(列名)</code>的形式来引用待插入记录中对应列的值</p>
<h2 id="自定义变量" class="headerLink">
    <a href="#%e8%87%aa%e5%ae%9a%e4%b9%89%e5%8f%98%e9%87%8f" class="header-mark"></a>自定义变量</h2><h3 id="单个变量" class="headerLink">
    <a href="#%e5%8d%95%e4%b8%aa%e5%8f%98%e9%87%8f" class="header-mark"></a>单个变量</h3><p>设置单个变量可以使用 <code>SET</code> 关键字。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220419/7d7a7bc57efa43e1ba30412b76c53917.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="设置单个变量" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220419/7d7a7bc57efa43e1ba30412b76c53917.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>设置单个变量</h2><p>设置单个变量</p>">
        
    </a><figcaption class="image-caption">设置单个变量</figcaption>
    </figure></p>
<h3 id="多个变量" class="headerLink">
    <a href="#%e5%a4%9a%e4%b8%aa%e5%8f%98%e9%87%8f" class="header-mark"></a>多个变量</h3><p>设置多个变量可以使用 <code>INTO</code> 关键字。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220419/9c894c060ac34628abd1b9071d4e7e27.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="设置多个变量" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220419/9c894c060ac34628abd1b9071d4e7e27.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>设置多个变量</h2><p>设置多个变量</p>">
        
    </a><figcaption class="image-caption">设置多个变量</figcaption>
    </figure></p>
<h2 id="索引建立原则" class="headerLink">
    <a href="#%e7%b4%a2%e5%bc%95%e5%bb%ba%e7%ab%8b%e5%8e%9f%e5%88%99" class="header-mark"></a>索引建立原则</h2><ul>
<li>频繁用作查询条件的字段应酌情考虑为其创建索引。</li>
<li>表的主外键或连表字段，必须建立索引，因为能很大程度提升连表查询的性能。</li>
<li>建立索引的字段，一般值的区分性要足够高，这样才能提高索引的检索效率。</li>
<li>建立索引的字段，值不应该过长，如果较长的字段要建立索引，可以选择前缀索引。</li>
<li>建立联合索引，应当遵循最左前缀原则，将多个字段之间按优先级顺序组合。</li>
<li>经常根据范围取值、排序、分组的字段应建立索引，因为索引有序，能加快排序时间。</li>
<li>对于唯一索引，如果确认不会利用该字段排序，那可以将结构改为<code>Hash</code>结构。</li>
<li>尽量使用联合索引代替单值索引，联合索引比多个单值索引查询效率要高。</li>
</ul>
<h2 id="新建索引需要注意哪些" class="headerLink">
    <a href="#%e6%96%b0%e5%bb%ba%e7%b4%a2%e5%bc%95%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e5%93%aa%e4%ba%9b" class="header-mark"></a>新建索引需要注意哪些</h2><ul>
<li>值经常会增删改的字段，不合适建立索引，因为每次改变后需维护索引结构。</li>
<li>一个字段存在大量的重复值时，不适合建立索引，比如性别字段。</li>
<li>索引不能参与计算，因此经常带函数查询的字段，并不适合建立索引。</li>
<li>一张表中的索引数量并不是越多越好，一般控制在<strong>3</strong>个，最多不能超过<strong>5</strong>个。</li>
<li>建立联合索引时，一定要考虑优先级，查询频率最高的字段应当放首位。</li>
<li>当表的数据较少，不应当建立索引，因为数据量不大时，维护索引反而开销更大。</li>
<li>索引的字段值无序时，不推荐建立索引，因为会造成页分裂，尤其是主键索引。</li>
</ul>
<h2 id="如何正确使用索引哪些情况会导致索引失效" class="headerLink">
    <a href="#%e5%a6%82%e4%bd%95%e6%ad%a3%e7%a1%ae%e4%bd%bf%e7%94%a8%e7%b4%a2%e5%bc%95%e5%93%aa%e4%ba%9b%e6%83%85%e5%86%b5%e4%bc%9a%e5%af%bc%e8%87%b4%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88" class="header-mark"></a>如何正确使用索引，哪些情况会导致索引失效</h2><ul>
<li>查询 SQL 中尽量不要使用<code>OR</code>关键字，可以使用子查询代替。</li>
<li>模糊查询尽量不要以<code>%</code>开头，如果实在要实现这个功能可以建立全文索引。</li>
<li>⚠️编写 SQL 时一定要注意字段的数据类型，否则 MySQL 的隐式转换会导致索引失效。</li>
<li>一定不要在编写 SQL 时让索引字段执行计算工作，尽量将计算工作放在客户端中完成。</li>
<li>对于索引字段尽量不要使用计算类函数，一定要使用时请记得将函数计算放在<code>=</code>后面。</li>
<li>多条件的查询 SQL 一定要使用联合索引中的第一个字段，否则会打破最左匹配原则。</li>
<li>对于需要对比多个字段的查询业务时，可以拆分为连表查询，使用临时表代替。</li>
<li>在 SQL 中不要使用反范围性的查询条件，大部分反范围性、不等性查询都会让索引失效。</li>
</ul>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://juejin.cn/post/7149074488649318431" target="_blank" rel="noopener noreferrer">建立索引的正确姿势与使用索引的最佳指南！</a></li>
</ul>
]]></description>
</item><item>
    <title>mysql 常见数据类型</title>
    <link>https://www.xiaobinqt.cn/mysql-data-type/</link>
    <pubDate>Sat, 15 Jun 2019 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/mysql-data-type/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<blockquote>
<p>MySQL 是以字节为单位存储数据的，一个字节拥有8个比特位。如果存储的不足 1 个字节，MySQL 会自动填充成 1 个字节。</p>
</blockquote>
<ul>
<li>字符（Character）是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。</li>
<li>字符集（Character set）是一个系统支持的所有抽象字符的集合。</li>
<li>字符编码（Character encoding）是把字符集中的字符编码为特定的二进制数，以便在计算机中存储。每个字符集中的字符都对应一个唯一的二进制编码。</li>
</ul>
<h2 id="字符编码" class="headerLink">
    <a href="#%e5%ad%97%e7%ac%a6%e7%bc%96%e7%a0%81" class="header-mark"></a>字符编码</h2><p>字符是面向人的概念，字节是面向计算机的概念。如果想在计算机中表示字符，那就需要将该字符与一个特定的字节序列对应起来，这个映射过程称之为编码。但是，这种映射关系并不是唯一的，不同的人制作了不同的编码方案。</p>
<p>根据表示一个字符使用的字节数量是不是固定的，编码方案可以分为以下两种：</p>
<h3 id="定长编码" class="headerLink">
    <a href="#%e5%ae%9a%e9%95%bf%e7%bc%96%e7%a0%81" class="header-mark"></a>定长编码</h3><p>表示不同的字符所需要的字节数量是相同的。比如 ASCII 编码方案采用 1 个字节来编码一个字符，ucs2 采用 2 个字节来编码一个字符。</p>
<h3 id="变长编码" class="headerLink">
    <a href="#%e5%8f%98%e9%95%bf%e7%bc%96%e7%a0%81" class="header-mark"></a>变长编码</h3><p>表示不同的字符所需要的字节数量是不同的。比方说 utf8 编码方案采用 1~3 个字节来编码一个字符，gb2312 采用 1~2 个字节来编码一个字符。</p>
<p>对于不同的字符编码方案来说，同一个字符可能被编码成不同的字节序列。比如同样一个字符：<code>我</code>，在 utf8 和 gb2312 这两种编码方案下被映射成如下的字节序列：</p>
<ul>
<li>utf8 编码方案</li>
</ul>
<p>字符<code>我</code>被编码成 <code>111001101000100010010001</code>，共占用 3 个字节，用十六进制表示就是：<code>0xE68891</code>。</p>
<ul>
<li>gb2312 编码方案</li>
</ul>
<p>字符<code>我</code>被编码成 <code>1100111011010010</code>，共占用 2 个字节，用十六进制表示就是：<code>0xCED2</code>。</p>
<p>MySQL 对编码方案和字符集这两个概念并没做什么区分，也就是说 utf8 字符集指的就是 utf8 编码方案，gb2312 字符集指的也就是 gb2312 编码方案。</p>
<blockquote>
<p>正宗的 utf8 字符集是使用 1~4 个字节来编码一个字符的，不过MySQL中对utf8字符集做了阉割，编码一个字符最多使用3个字节。
如果有存储使用4个字节来编码的字符的情景，可以使用一种称之为utf8mb4的字符集，它才是正宗的utf8字符集。</p>
</blockquote>
<h2 id="整数" class="headerLink">
    <a href="#%e6%95%b4%e6%95%b0" class="header-mark"></a>整数</h2><table>
<thead>
<tr>
<th>类型</th>
<th>占用空间</th>
<th>无符号数取值范围</th>
<th>有符号数取值范围</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>1</td>
<td><code>0 ~ 2⁸-1</code></td>
<td><code>-2⁷ ~ 2⁷-1</code></td>
<td>非常小的整数</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2</td>
<td><code>0 ~ 2¹⁶-1</code></td>
<td><code>-2¹⁵ ~ 2¹⁵-1</code></td>
<td>小的整数</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3</td>
<td><code>0 ~ 2²⁴-1</code></td>
<td><code>-2²³ ~ 2²³-1</code></td>
<td>中等大小的整数</td>
</tr>
<tr>
<td>INT（别名：INTEGER）</td>
<td>4</td>
<td><code>0 ~ 2³²-1</code></td>
<td><code>-2³¹ ~ 2³¹-1</code></td>
<td>标准的整数</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8</td>
<td><code>0 ~ 2⁶⁴-1</code></td>
<td><code>-2⁶³ ~ 2⁶³-1</code></td>
<td>大整数</td>
</tr>
</tbody>
</table>
<h2 id="浮点数" class="headerLink">
    <a href="#%e6%b5%ae%e7%82%b9%e6%95%b0" class="header-mark"></a>浮点数</h2><table>
<thead>
<tr>
<th>类型</th>
<th>占用空间</th>
<th>绝对值最小非0值</th>
<th>绝对值最大非0值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>FLOAT</td>
<td>4</td>
<td><code>±1.175494351E-38</code></td>
<td><code>±3.402823466E+38</code></td>
<td>单精度浮点数</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8</td>
<td><code>±2.2250738585072014E-308</code></td>
<td><code>±1.7976931348623157E+308</code></td>
<td>双精度浮点数</td>
</tr>
</tbody>
</table>
<p>有的十进制小数，比如 1.875 可以被很容易的转换成二进制数 1.111 ，但是更多的小数是无法直接转换成二进制的，比如说 0.3 ，它转换成的二进制小数就是一个无限小数，但是现在只能用 4 个字节或者 8
个字节来表示这个小数，所以只能进行一些舍入来近似的表示，所以说计算机的浮点数表示有时是不精确的。</p>
<h3 id="设置最大最小位数" class="headerLink">
    <a href="#%e8%ae%be%e7%bd%ae%e6%9c%80%e5%a4%a7%e6%9c%80%e5%b0%8f%e4%bd%8d%e6%95%b0" class="header-mark"></a>设置最大最小位数</h3><p>可以使用 <code>FLOAT(M, D)</code>或者 <code>DOUBLE(M, D)</code> 来限制可以存储到本列中的小数范围。其中：</p>
<p><code>M</code>表示该小数最多需要的十进制有效数字个数。</p>
<p><code>D</code>表示该小数的小数点后的十进制数字个数。</p>
<p><code>M</code>的取值范围是<code>1~255</code>，<code>D</code>的取值范围是<code>0~30</code>，而且<code>D</code>的值必须不大于<code>M</code>。</p>
<p><code>M</code>和<code>D</code>都是可选的，如果省略，它们的值按照机器支持的最大值来存储。</p>
<blockquote>
<p>计算十进制有效数字个数时，不计入正负号，不计入最左边的 0，也不计入小数点。所以 <code>-2.3</code> 来说有效数字个数就是 2，<code>0.9</code> 有效数字个数就是 1。</p>
</blockquote>
<h2 id="定点数" class="headerLink">
    <a href="#%e5%ae%9a%e7%82%b9%e6%95%b0" class="header-mark"></a>定点数</h2><p>因为用浮点数表示小数可能会有不精确的情况，在一些情况下我们必须保证小数是精确的，可以使用定点数的数据类型。</p>
<p>与浮点数相比，定点数需要更多的空间来存储数据，所以如果不是在某些需要存储精确小数的场景下，一般的小数用浮点数表示就足够了。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>占用空间</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>DECIMAL(M, D)</td>
<td>取决于M和D</td>
<td>取决于M和D</td>
</tr>
</tbody>
</table>
<p>DECIMAL 如果不指定精度，默认的 M 的值是 10 ，默认的 D 的值是 0，也就是说下列等式是成立的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nv">DECIMAL</span> <span class="o">=</span> DECIMAL<span class="o">(</span>10<span class="o">)</span> <span class="o">=</span> DECIMAL<span class="o">(</span>10, 0<span class="o">)</span>
</span></span><span class="line"><span class="cl">DECIMAL<span class="o">(</span>n<span class="o">)</span> <span class="o">=</span> DECIMAL<span class="o">(</span>n, 0<span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>M 的范围是 <code>1~65</code>，D的范围是<code>0~30</code>，且<code>D</code>的值不能超过<code>M</code>。</p>
<h2 id="无符号数值" class="headerLink">
    <a href="#%e6%97%a0%e7%ac%a6%e5%8f%b7%e6%95%b0%e5%80%bc" class="header-mark"></a>无符号数值</h2><p>对于数值类型，包括整数、浮点数和定点数，有些情况下只需要用到无符号数（就是非负数）。</p>
<p>MySQL 提供了一个表示无符号数值类型的方式，就是在原数值类型后加一个单词<code>UNSIGNED</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">数值类型 UNSIGNED
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以把它当成一种新类型对待，比如<code>INT UNSIGNED</code>就表示无符号整数，<code>FLOAT UNSIGNED</code>表示无符号浮点数，<code>DECIMAL UNSIGNED</code>表示无符号定点数。</p>
<blockquote>
<p>在使用的存储空间大小相同的情况下，无符号整数可以表示的正整数范围比有符号整数能表示的正整数范围大一倍。
不过受浮点数和定点数具体的存储格式影响，无符号浮点数和定点数并不能提升正数的表示范围。</p>
</blockquote>
<h2 id="时间和日期" class="headerLink">
    <a href="#%e6%97%b6%e9%97%b4%e5%92%8c%e6%97%a5%e6%9c%9f" class="header-mark"></a>时间和日期</h2><table>
<thead>
<tr>
<th>类型</th>
<th>存储空间</th>
<th>取值范围</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>YEAR</td>
<td>1</td>
<td><code>1901</code>~<code>2155</code></td>
<td>年份值</td>
</tr>
<tr>
<td>DATE</td>
<td>3</td>
<td><code>1000-01-01</code>~<code>9999-12-31</code></td>
<td>日期值</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td><code>-838:59:59</code>~<code>838:59:59</code></td>
<td>时间值</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
<td><code>1000-01-01 00:00:00</code>~<code>9999-12-31 23:59:59</code></td>
<td>日期加时间值</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4</td>
<td><code>1970-01-01 00:00:01</code>~<code>2038-01-19 03:14:07</code></td>
<td>时间戳</td>
</tr>
</tbody>
</table>
<p><code>TIME</code>表示时间，格式是<code>hh:mm:ss[.uuuuuu]</code>或者<code>hhh:mm:ss[.uuuuuu]</code></p>
<p>用时间戳存储时间的好处就是，它展示的值可以随着时区的变化而变化。</p>
<blockquote>
<p>DATETIME 中的时间部分表示的是一天内的时间(00:00:00 ~ 23:59:59)，而 TIME 表示的是一段时间，而且可以表示负值。</p>
</blockquote>
<h2 id="字符串" class="headerLink">
    <a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2" class="header-mark"></a>字符串</h2><table>
<thead>
<tr>
<th>类型</th>
<th>最大长度</th>
<th>存储空间要求</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR(M)</td>
<td>M个字符</td>
<td>M×W个字节</td>
<td>固定长度的字符串</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>M个字符</td>
<td>L+1 或 L+2 个字节</td>
<td>可变长度的字符串</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>2⁸-1 个字节</td>
<td>L+1个字节</td>
<td>非常小型的字符串</td>
</tr>
<tr>
<td>TEXT</td>
<td>2¹⁶-1 个字节</td>
<td>L+2 个字节</td>
<td>小型的字符串</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>2²⁴-1 个字节</td>
<td>L+3个字节</td>
<td>中等大小的字符串</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>2³²-1 个字节</td>
<td>L+4个字节</td>
<td>大型的字符串</td>
</tr>
</tbody>
</table>
<p><code>M</code> 代表该数据类型最多能存储的字符数量，<code>L</code> 代表我们实际向该类型的属性中存储的字符串在特定字符集下所占的字节数，<code>W</code>代表在该特定字符集下，编码一个字符最多需要的字节数。</p>
<p><code>VARCHAR(M)</code> 中的<code>M</code>也是代表该类型最多可以存储的字符数量，理论上的取值范围是 1~65535。但是MySQL中还有一个规定，表中某一行包含的所有列中存储的数据大小总共不得超过 65535
个字节，也就是说 <strong><code>VARCHAR(M)</code>
类型实际能够容纳的字符数量是小于 65535 的</strong>。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://tool.oschina.net/hexconvert/" target="_blank" rel="noopener noreferrer">在线进制转换</a></li>
<li><a href="https://juejin.cn/book/6844733802426662926/section/6844733802611245070" target="_blank" rel="noopener noreferrer">MySQL数据类型</a></li>
</ul>
]]></description>
</item><item>
    <title>Mysql 常用函数备忘</title>
    <link>https://www.xiaobinqt.cn/mysql-common-func-memo/</link>
    <pubDate>Thu, 08 Nov 2018 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/mysql-common-func-memo/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="时间戳与日期格式转换" class="headerLink">
    <a href="#%e6%97%b6%e9%97%b4%e6%88%b3%e4%b8%8e%e6%97%a5%e6%9c%9f%e6%a0%bc%e5%bc%8f%e8%bd%ac%e6%8d%a2" class="header-mark"></a>时间戳与日期格式转换</h2><p>UNIX时间戳转换为日期用函数： <code>FROM_UNIXTIME()</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="nf">FROM_UNIXTIME</span><span class="p">(</span><span class="mi">1156219870</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220511/16f68bfe754148f1bd995b6aa0b2e74c.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="FROM_UNIXTIME" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220511/16f68bfe754148f1bd995b6aa0b2e74c.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>FROM_UNIXTIME</h2><p>FROM_UNIXTIME</p>">
        
    </a><figcaption class="image-caption">FROM_UNIXTIME</figcaption>
    </figure></p>
<p>日期转换为UNIX时间戳用函数： <code>UNIX_TIMESTAMP()</code></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220511/d1182fbf011d43bf95af2b195956f88b.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="UNIX_TIMESTAMP" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220511/d1182fbf011d43bf95af2b195956f88b.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>UNIX_TIMESTAMP</h2><p>UNIX_TIMESTAMP</p>">
        
    </a><figcaption class="image-caption">UNIX_TIMESTAMP</figcaption>
    </figure></p>
]]></description>
</item></channel>
</rss>
