<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>IO多路复用 - 标签 - xiaobinqt 博客 - 技术改变生活</title>
        <link>https://www.xiaobinqt.cn/tags/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link>
        <description>IO多路复用 - 标签 - xiaobinqt 博客 - 技术改变生活</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaobinqt@163.com (xiaobinqt)</managingEditor>
            <webMaster>xiaobinqt@163.com (xiaobinqt)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 03 Apr 2021 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://www.xiaobinqt.cn/tags/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" rel="self" type="application/rss+xml" /><item>
    <title>Redis 为什么快</title>
    <link>https://www.xiaobinqt.cn/redis-single-thread-why-so-fast/</link>
    <pubDate>Sat, 03 Apr 2021 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/redis-single-thread-why-so-fast/</guid>
    <description><![CDATA[阻塞IO服务端为了处理客户端的连接和请求的数据，写了如下代码。 1 2 3 4 5 6 7 8 9 listenfd = socket(); // 打开一个网络通信端口 bind(listenfd); // 绑定 listen(listenfd); // 监听 while(1) { connfd = accept(listenfd); // 阻塞建立连接 int n = read(connfd, buf); // 阻塞读数据 doSomeThing(buf); // 利用读到的数据做些什么 close(connfd); //]]></description>
</item></channel>
</rss>
