<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on xiaobinqt 博客 - 技术改变生活</title>
    <link>https://www.xiaobinqt.cn/tags/golang/</link>
    <description>Recent content in Golang on xiaobinqt 博客 - 技术改变生活</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <managingEditor>xiaobinqt@163.com (xiaobinqt)</managingEditor>
    <webMaster>xiaobinqt@163.com (xiaobinqt)</webMaster>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Tue, 15 Oct 2024 19:43:40 +0800</lastBuildDate>
    <atom:link href="https://www.xiaobinqt.cn/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go channel 使用分析</title>
      <link>https://www.xiaobinqt.cn/go-channel-principle/</link>
      <pubDate>Wed, 11 Oct 2023 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/go-channel-principle/</guid>
      <description>&lt;!-- author： xiaobinqt --&gt;&#xA;&lt;!-- email： xiaobinqt@163.com --&gt;&#xA;&lt;!-- https://xiaobinqt.github.io --&gt;&#xA;&lt;!-- https://www.xiaobinqt.cn --&gt;&#xA;&lt;h2 id=&#34;概念&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#%e6%a6%82%e5%bf%b5&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;16 概念&lt;/h2&gt;&lt;p&gt;Go 中的 channel 是一个队列，遵循先进先出的原则，负责协程之间的通信。Go 语言提倡不要通过共享内存来通信，而要通过通信来实现内存共享，CSP（Communicating Sequential Process）并发模型，就是通过 goroutine 和 channel 来实现的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go Slice 实现原理</title>
      <link>https://www.xiaobinqt.cn/go-slice-principle/</link>
      <pubDate>Tue, 10 Oct 2023 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/go-slice-principle/</guid>
      <description>&lt;!-- author： xiaobinqt --&gt;&#xA;&lt;!-- email： xiaobinqt@163.com --&gt;&#xA;&lt;!-- https://xiaobinqt.github.io --&gt;&#xA;&lt;!-- https://www.xiaobinqt.cn --&gt;&#xA;&lt;h2 id=&#34;什么是-slice&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af-slice&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;16 什么是 slice&lt;/h2&gt;&lt;p&gt;切片是基于数组实现的，它的底层是数组，可以理解为对底层数组的抽象。&lt;/p&gt;&#xA;&lt;p&gt;源码包中 src/runtime/slice.go 定义了 slice 的数据结构：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang 内存逃逸</title>
      <link>https://www.xiaobinqt.cn/escape-heap/</link>
      <pubDate>Tue, 10 Oct 2023 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/escape-heap/</guid>
      <description>&lt;!-- author： xiaobinqt --&gt;&#xA;&lt;!-- email： xiaobinqt@163.com --&gt;&#xA;&lt;!-- https://xiaobinqt.github.io --&gt;&#xA;&lt;!-- https://www.xiaobinqt.cn --&gt;&#xA;&lt;p&gt;在 C/C++ 开发中，动态分配内存（new/malloc）需要开发者手动释放资源。这样做的好处是，需要申请多少内存空间可以很好的掌握怎么分配。但是这有个缺点，如果忘记释放内存，则会导致内存泄漏。在很多高级语言中（python/Go/java）都加上了垃圾回收机制。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 编译标签 build tag</title>
      <link>https://www.xiaobinqt.cn/go-build-tag/</link>
      <pubDate>Sat, 28 Jan 2023 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/go-build-tag/</guid>
      <description>&lt;!-- author： xiaobinqt --&gt;&#xA;&lt;!-- email： xiaobinqt@163.com --&gt;&#xA;&lt;!-- https://xiaobinqt.github.io --&gt;&#xA;&lt;!-- https://www.xiaobinqt.cn --&gt;&#xA;&lt;p&gt;在 Go 中，build tag 是添加到代码中第一行，来标识编译相关信息的，build tag 决定了当前文件是否会被当前 package 所包含，用于限制一整个文件是否应该被编译入最终的二进制文件，而不是一个文件中的部分代码片段。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go1.18 sync.Map 解读</title>
      <link>https://www.xiaobinqt.cn/go-sync-map/</link>
      <pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/go-sync-map/</guid>
      <description>&lt;!-- author： xiaobinqt --&gt;&#xA;&lt;!-- email： xiaobinqt@163.com --&gt;&#xA;&lt;!-- https://xiaobinqt.github.io --&gt;&#xA;&lt;!-- https://www.xiaobinqt.cn --&gt;&#xA;&lt;h2 id=&#34;背景&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#%e8%83%8c%e6%99%af&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;46 背景&lt;/h2&gt;&lt;p&gt;项目中遇到了需要使用高并发的 map 的场景，众所周知 Go 官方的原生 map 是不支持并发读写的，直接并发的读写很容易触发 panic。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go GC 垃圾回收</title>
      <link>https://www.xiaobinqt.cn/go-gc/</link>
      <pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/go-gc/</guid>
      <description>&lt;p&gt;垃圾回收（Garbage Collection，GC）是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC 过程中无需程序员手动执行。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go GMP 调度模型</title>
      <link>https://www.xiaobinqt.cn/gmp-model/</link>
      <pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/gmp-model/</guid>
      <description>&lt;h2 id=&#34;进程线程协程的区别&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#%e8%bf%9b%e7%a8%8b%e7%ba%bf%e7%a8%8b%e5%8d%8f%e7%a8%8b%e7%9a%84%e5%8c%ba%e5%88%ab&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;37 进程、线程、协程的区别&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;：进程是操作系统为应用程序分配资源的最小单元。每个进程有独立的内存空间和状态。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;：线程是进程中的一个独立执行单元。在 Go 中，一个进程可以启动多个线程，以并行执行任务。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 常用命令</title>
      <link>https://www.xiaobinqt.cn/go-build-args/</link>
      <pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/go-build-args/</guid>
      <description>&lt;h2 id=&#34;常用编译参数&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#%e5%b8%b8%e7%94%a8%e7%bc%96%e8%af%91%e5%8f%82%e6%95%b0&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;1 常用编译参数&lt;/h2&gt;&#xA;&lt;div class=&#34;table-wrapper&#34;&gt;&#xA;  &lt;table&gt;&#xA;    &lt;thead&gt;&#xA;        &lt;tr&gt;&#xA;            &lt;th style=&#34;text-align: &#34;&gt;参数&lt;/th&gt;&#xA;            &lt;th style=&#34;text-align: &#34;&gt;说明&lt;/th&gt;&#xA;        &lt;/tr&gt;&#xA;    &lt;/thead&gt;&#xA;    &lt;tbody&gt;&#xA;        &lt;tr&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;-o&lt;/td&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;指定输出可执行文件名&lt;/td&gt;&#xA;        &lt;/tr&gt;&#xA;        &lt;tr&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;-v&lt;/td&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;编译时显示包名，可以理解成输出详细编译信息&lt;/td&gt;&#xA;        &lt;/tr&gt;&#xA;        &lt;tr&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;-u&lt;/td&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;不加&lt;code&gt;-u&lt;/code&gt;标记，执行 go get 一个已有的代码包，会发现命令什么都不执行。加了&lt;code&gt;-u&lt;/code&gt;才会去拉取最新的代码包的最新版本&lt;/td&gt;&#xA;        &lt;/tr&gt;&#xA;        &lt;tr&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;-race&lt;/td&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;开启竞态检测&lt;/td&gt;&#xA;        &lt;/tr&gt;&#xA;        &lt;tr&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;*.go&lt;/td&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;编译当前目录下的所有go文件，也可以写成 f2.go f2.go &amp;hellip;&lt;/td&gt;&#xA;        &lt;/tr&gt;&#xA;        &lt;tr&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;-a&lt;/td&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;该选项用于强制重新编译所有的依赖项，即使它们似乎是最新的或未更改。这对于确保所有依赖项都与最新的代码一致非常有用。使用 &lt;code&gt;-a&lt;/code&gt; 标志可以防止使用缓存的依赖项，从而确保每个依赖项都会被重新编译，并与最新的代码进行链接。&lt;/td&gt;&#xA;        &lt;/tr&gt;&#xA;        &lt;tr&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;-w&lt;/td&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;该选项用于禁用链接器产生的警告信息。当构建可执行文件时，链接器通常会生成一些警告，例如未使用的变量或未导出的符号等。使用 &lt;code&gt;-w&lt;/code&gt; 标志可以禁用这些警告信息，以减小可执行文件的大小。&lt;/td&gt;&#xA;        &lt;/tr&gt;&#xA;        &lt;tr&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;-s&lt;/td&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;&lt;code&gt;-s&lt;/code&gt; 参数会告诉链接器在构建可执行文件时不生成符号表和调试信息。符号表包含了源代码中的符号（如变量名、函数名等）和对应的地址信息，而调试信息则包含了用于调试程序的相关信息（如源代码文件路径、行号等）。&lt;br/&gt; 禁用符号表和调试信息的生成可以减小最终生成的可执行文件的大小，同时也可以增强代码的安全性，因为这些信息对于攻击者来说可能是有价值的。&lt;/td&gt;&#xA;        &lt;/tr&gt;&#xA;        &lt;tr&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;-X&lt;/td&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;设置包中的变量值&lt;/td&gt;&#xA;        &lt;/tr&gt;&#xA;        &lt;tr&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;&lt;code&gt;-gcflags &amp;quot;-N -l&amp;quot;&lt;/code&gt;&lt;/td&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;&lt;code&gt;-N&lt;/code&gt;：该标志告诉编译器不进行优化。优化是编译器对代码进行的一系列转换和重组，旨在提高代码的执行效率。通过禁用优化，可执行文件的生成将更符合源代码的结构，便于调试。&lt;br/&gt; &lt;code&gt;-l&lt;/code&gt;：该标志告诉编译器禁用内联优化。内联优化是编译器将函数调用替换为函数体内容的一种优化技术，可以减少函数调用的开销。禁用内联优化可以确保函数调用保持不变，使得调试过程中可以精确地跟踪函数的执行。&lt;br/&gt;这两个标志的组合 &lt;code&gt;-gcflags &amp;quot;-N -l&amp;quot;&lt;/code&gt; 一起使用，可以在构建过程中禁用优化和内联优化，从而产生更容易调试的可执行文件。&lt;/td&gt;&#xA;        &lt;/tr&gt;&#xA;        &lt;tr&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;-ldflags&lt;/td&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;给 go 链接器传入参数，实际是给 go tool link 的参数，可以用 &lt;code&gt;go tool link --help&lt;/code&gt; 查看可用的参数。&lt;/td&gt;&#xA;        &lt;/tr&gt;&#xA;        &lt;tr&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;&lt;code&gt;-ldflags &#39;-extldflags &amp;quot;-static&amp;quot;&#39; &lt;/code&gt;&lt;/td&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;静态编译。告诉链接器在构建可执行文件时使用静态链接。静态链接意味着将所有的依赖项（包括系统库）都包含在最终的可执行文件中，以便在其他系统上运行时不需要依赖外部的库。&lt;/td&gt;&#xA;        &lt;/tr&gt;&#xA;    &lt;/tbody&gt;&#xA;  &lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;交叉编译&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#%e4%ba%a4%e5%8f%89%e7%bc%96%e8%af%91&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;2 交叉编译&lt;/h2&gt;&#xA;&lt;div class=&#34;table-wrapper&#34;&gt;&#xA;  &lt;table&gt;&#xA;    &lt;thead&gt;&#xA;        &lt;tr&gt;&#xA;            &lt;th style=&#34;text-align: &#34;&gt;参数&lt;/th&gt;&#xA;            &lt;th style=&#34;text-align: &#34;&gt;说明&lt;/th&gt;&#xA;        &lt;/tr&gt;&#xA;    &lt;/thead&gt;&#xA;    &lt;tbody&gt;&#xA;        &lt;tr&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;GOOS&lt;/td&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;GOARCH&lt;/td&gt;&#xA;        &lt;/tr&gt;&#xA;        &lt;tr&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;linux&lt;/td&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;386 / amd64 / arm&lt;/td&gt;&#xA;        &lt;/tr&gt;&#xA;        &lt;tr&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;darwin&lt;/td&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;386 / amd64&lt;/td&gt;&#xA;        &lt;/tr&gt;&#xA;        &lt;tr&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;feedbsd&lt;/td&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;386 / amd64&lt;/td&gt;&#xA;        &lt;/tr&gt;&#xA;        &lt;tr&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;windows&lt;/td&gt;&#xA;            &lt;td style=&#34;text-align: &#34;&gt;386 / amd64&lt;/td&gt;&#xA;        &lt;/tr&gt;&#xA;    &lt;/tbody&gt;&#xA;  &lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;对于编译给 ARM 使用的 Go 程序，需要根据实际情况配置&lt;code&gt;$GOARM&lt;/code&gt;，这是用来控制 CPU 的浮点协处理器的参数。&lt;/p&gt;</description>
    </item>
    <item>
      <title>running gcc failed: exit status 1</title>
      <link>https://www.xiaobinqt.cn/build-running-gcc-failed/</link>
      <pubDate>Thu, 10 Feb 2022 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/build-running-gcc-failed/</guid>
      <description>&lt;p&gt;今天在编译 go 项目时出现了如下错误：&lt;/p&gt;&#xA;&lt;div class=&#34;code-block highlight is-open show-line-numbers  tw-group tw-my-2&#34;&gt;&#xA;  &lt;div class=&#34;&#xA;    &#xA;    tw-flex &#xA;    tw-flex-row&#xA;    tw-flex-1 &#xA;    tw-justify-between &#xA;    tw-w-full tw-bg-bgColor-secondary&#xA;    &#34;&gt;      &#xA;    &lt;button &#xA;      class=&#34;&#xA;        code-block-button&#xA;        tw-mx-2 &#xA;        tw-flex&#xA;        tw-flex-row&#xA;        tw-flex-1&#34;&#xA;      aria-hidden=&#34;true&#34;&gt;&#xA;          &lt;div class=&#34;group-[.is-open]:tw-rotate-90 tw-transition-[transform] tw-duration-500 tw-ease-in-out print:!tw-hidden tw-w-min tw-h-min tw-my-1 tw-mx-1&#34;&gt;&lt;svg class=&#34;icon&#34;&#xA;    xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;0 0 320 512&#34;&gt;&lt;!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --&gt;&lt;path d=&#34;M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&#xA;          &lt;p class=&#34;tw-select-none !tw-my-1&#34;&gt;shell&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 实现下载文件的断点续传</title>
      <link>https://www.xiaobinqt.cn/go-breakpoint-resume/</link>
      <pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/go-breakpoint-resume/</guid>
      <description>&lt;!-- author： xiaobinqt --&gt;&#xA;&lt;!-- email： xiaobinqt@163.com --&gt;&#xA;&lt;!-- https://xiaobinqt.github.io --&gt;&#xA;&lt;!-- https://www.xiaobinqt.cn --&gt;&#xA;&lt;h2 id=&#34;断点续传&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#%e6%96%ad%e7%82%b9%e7%bb%ad%e4%bc%a0&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;1 断点续传&lt;/h2&gt;&lt;p&gt;断点继传就是下载的文件可以在你下载了一半的时候暂停，下一次下载的时候可以从你暂停的地方继续下载，不用从头开始下载。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 使用原生 Swagger</title>
      <link>https://www.xiaobinqt.cn/go-swagger/</link>
      <pubDate>Mon, 27 Dec 2021 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/go-swagger/</guid>
      <description>&lt;!-- author： xiaobinqt --&gt;&#xA;&lt;!-- email： xiaobinqt@163.com --&gt;&#xA;&lt;!-- https://xiaobinqt.github.io --&gt;&#xA;&lt;!-- https://www.xiaobinqt.cn --&gt;&#xA;&lt;p&gt;Swagger 是一个规范且完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。&lt;/p&gt;&#xA;&lt;p&gt;当通过 Swagger 进行正确定义，用户可以理解远程服务并使用最少实现逻辑与远程服务进行交互。&lt;/p&gt;</description>
    </item>
    <item>
      <title>常见设计模式-Go实现</title>
      <link>https://www.xiaobinqt.cn/design-patterns/</link>
      <pubDate>Wed, 20 Oct 2021 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/design-patterns/</guid>
      <description>&lt;!-- author： xiaobinqt --&gt;&#xA;&lt;!-- email： xiaobinqt@163.com --&gt;&#xA;&lt;!-- https://xiaobinqt.github.io --&gt;&#xA;&lt;!-- https://www.xiaobinqt.cn --&gt;&#xA;&lt;h2 id=&#34;创建型模式&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#%e5%88%9b%e5%bb%ba%e5%9e%8b%e6%a8%a1%e5%bc%8f&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;16 创建型模式&lt;/h2&gt;&lt;h3 id=&#34;单例模式&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;16.1 单例模式&lt;/h3&gt;&lt;p&gt;保证一个类永远只能有一个对象，并提供一个访问它的全局访问点，且该对象的功能依然能被其他模块使用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 使用 sse</title>
      <link>https://www.xiaobinqt.cn/go-use-sse/</link>
      <pubDate>Wed, 08 Sep 2021 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/go-use-sse/</guid>
      <description>&lt;!-- author： xiaobinqt --&gt;&#xA;&lt;!-- email： xiaobinqt@163.com --&gt;&#xA;&lt;!-- https://xiaobinqt.github.io --&gt;&#xA;&lt;!-- https://www.xiaobinqt.cn --&gt;&#xA;&lt;h2 id=&#34;sse-的本质&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#sse-%e7%9a%84%e6%9c%ac%e8%b4%a8&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;1 SSE 的本质&lt;/h2&gt;&lt;p&gt;严格地说，HTTP 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息（streaming）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go 函数式选项模式</title>
      <link>https://www.xiaobinqt.cn/functional-options-pattern/</link>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/functional-options-pattern/</guid>
      <description>&lt;p&gt;Go 语言没有构造函数，一般通过定义 New 函数来充当构造函数。但是，如果结构有较多字段，要初始化这些字段，就有很多种方式，有一种方式被认为是最优雅的，就是函数式选项模式（Functional Options Pattern）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>golang make 和 new 的区别</title>
      <link>https://www.xiaobinqt.cn/new-make-difference/</link>
      <pubDate>Mon, 21 Jun 2021 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/new-make-difference/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;make 的作用是初始化内置的数据结构，也就是 &lt;code&gt;slice&lt;/code&gt;、&lt;code&gt;map&lt;/code&gt;和 &lt;code&gt;channel&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;new 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;make&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#make&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;16 make&lt;/h2&gt;&lt;p&gt;内置函数 &lt;code&gt;make&lt;/code&gt; 仅支持 &lt;code&gt;slice&lt;/code&gt;、&lt;code&gt;map&lt;/code&gt;、&lt;code&gt;channel&lt;/code&gt; 三种数据类型的内存创建，&lt;strong&gt;其返回值是所创建类型的本身，而不是新的指针引用&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go build 添加版本等信息</title>
      <link>https://www.xiaobinqt.cn/go-build-add-ldflags/</link>
      <pubDate>Mon, 24 May 2021 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/go-build-add-ldflags/</guid>
      <description>&lt;!-- author： xiaobinqt --&gt;&#xA;&lt;!-- email： xiaobinqt@163.com --&gt;&#xA;&lt;!-- https://xiaobinqt.github.io --&gt;&#xA;&lt;!-- https://www.xiaobinqt.cn --&gt;&#xA;&lt;p&gt;Go 在编译时可以添加一些额外的参数，这些参数可以用来添加如版本等信息。&lt;/p&gt;&#xA;&lt;p&gt;比如有以下的 t.go 文件源码&amp;#x1f447;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go Web 框架 martini 笔记</title>
      <link>https://www.xiaobinqt.cn/go-web-martini-glance/</link>
      <pubDate>Thu, 20 May 2021 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/go-web-martini-glance/</guid>
      <description>&lt;!-- author： xiaobinqt --&gt;&#xA;&lt;!-- email： xiaobinqt@163.com --&gt;&#xA;&lt;!-- https://xiaobinqt.github.io --&gt;&#xA;&lt;!-- https://www.xiaobinqt.cn --&gt;&#xA;&lt;p&gt;之前在&lt;a href=&#34;https://blog.csdn.net/xiaobinqt&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;CSDN&lt;/a&gt;写过一个关于 martini&#xA;的笔记&lt;a href=&#34;https://blog.csdn.net/xiaobinqt/article/details/115749581&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;golang martini 包的简单使用&lt;/a&gt;&#xA;，最近读来感觉不是很清楚，而且也有一些错误，花了点时间重新整理了下那篇笔记。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 利用 chromedp 生成 pdf</title>
      <link>https://www.xiaobinqt.cn/go-print-pdf/</link>
      <pubDate>Tue, 11 May 2021 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/go-print-pdf/</guid>
      <description>&lt;!-- author： xiaobinqt --&gt;&#xA;&lt;!-- email： xiaobinqt@163.com --&gt;&#xA;&lt;!-- https://xiaobinqt.github.io --&gt;&#xA;&lt;!-- https://www.xiaobinqt.cn --&gt;&#xA;&lt;h2 id=&#34;chromedp&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#chromedp&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;1 chromedp&lt;/h2&gt;&lt;p&gt;Package &lt;a href=&#34;https://github.com/chromedp/chromedp&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;chromedp&lt;/a&gt; is a faster, simpler way to drive browsers supporting&#xA;the Chrome DevTools Protocol in Go without external dependencies.&lt;/p&gt;&#xA;&lt;p&gt;可以查看官方的&lt;a href=&#34;https://github.com/chromedp/examples&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;示例&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;p&gt;以下示例用的版本为 &lt;code&gt;github.com/chromedp/chromedp v0.8.4&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>grpc 入门应用</title>
      <link>https://www.xiaobinqt.cn/grpc-demo/</link>
      <pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/grpc-demo/</guid>
      <description>&lt;p&gt;RPC 是一种跨语言的协议，它可以让我们在不同的语言之间进行通信。 远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个&#xA;地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。&#xA;RPC是一种服务器-客户端（Client/Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go udp 简单使用</title>
      <link>https://www.xiaobinqt.cn/upd-demo/</link>
      <pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/upd-demo/</guid>
      <description>&lt;h2 id=&#34;server&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#server&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;1 server&lt;/h2&gt;&lt;div class=&#34;code-block highlight is-open show-line-numbers  tw-group tw-my-2&#34;&gt;&#xA;  &lt;div class=&#34;&#xA;    &#xA;    tw-flex &#xA;    tw-flex-row&#xA;    tw-flex-1 &#xA;    tw-justify-between &#xA;    tw-w-full tw-bg-bgColor-secondary&#xA;    &#34;&gt;      &#xA;    &lt;button &#xA;      class=&#34;&#xA;        code-block-button&#xA;        tw-mx-2 &#xA;        tw-flex&#xA;        tw-flex-row&#xA;        tw-flex-1&#34;&#xA;      aria-hidden=&#34;true&#34;&gt;&#xA;          &lt;div class=&#34;group-[.is-open]:tw-rotate-90 tw-transition-[transform] tw-duration-500 tw-ease-in-out print:!tw-hidden tw-w-min tw-h-min tw-my-1 tw-mx-1&#34;&gt;&lt;svg class=&#34;icon&#34;&#xA;    xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;0 0 320 512&#34;&gt;&lt;!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --&gt;&lt;path d=&#34;M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&#xA;          &lt;p class=&#34;tw-select-none !tw-my-1&#34;&gt;go&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 方法值接收者和指针接收者的区别</title>
      <link>https://www.xiaobinqt.cn/func-receive-value-pointer/</link>
      <pubDate>Sat, 15 Aug 2020 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/func-receive-value-pointer/</guid>
      <description>&lt;!-- author： xiaobinqt --&gt;&#xA;&lt;!-- email： xiaobinqt@163.com --&gt;&#xA;&lt;!-- https://xiaobinqt.github.io --&gt;&#xA;&lt;!-- https://www.xiaobinqt.cn --&gt;&#xA;&lt;p&gt;如果方法的接收者是指针类型，无论调用者是对象还是对象指针，修改的都是对象本身，&lt;strong&gt;会影响&lt;/strong&gt;调用者；&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux 环境下安装 Go</title>
      <link>https://www.xiaobinqt.cn/linux-platform-install-go/</link>
      <pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/linux-platform-install-go/</guid>
      <description>&lt;h2 id=&#34;安装&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#%e5%ae%89%e8%a3%85&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;1 安装&lt;/h2&gt;&lt;p&gt;在&lt;a href=&#34;https://go.dev/dl/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;官网 https://go.dev/dl/&lt;/a&gt;，根据自己的环境下载对应的安装包：&lt;/p&gt;&#xA;&lt;p&gt;&lt;figure&gt;&lt;a class=&#34;lightgallery&#34; href=&#34;https://www.xiaobinqt.cn/d9f09be56c424e4aac52bf334c302133_16652908466126035152.png&#34; title=&#34;官网安装包列表&#34; data-thumbnail=&#34;/d9f09be56c424e4aac52bf334c302133_16652908466126035152.png&#34; data-sub-html=&#34;&lt;h2&gt;官网安装包列表&lt;/h2&gt;&lt;p&gt;官网安装包列表&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go interface</title>
      <link>https://www.xiaobinqt.cn/go-interface/</link>
      <pubDate>Thu, 18 Jun 2020 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/go-interface/</guid>
      <description>&lt;h2 id=&#34;定义&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#%e5%ae%9a%e4%b9%89&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;13 定义&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;interface 可以表示任意一种类型&lt;/li&gt;&#xA;&lt;li&gt;interface 是接口的方法集合，只要实现了接口中的所有方法，那么就认为实现了这个接口&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;用途&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#%e7%94%a8%e9%80%94&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;14 用途&lt;/h2&gt;&lt;h3 id=&#34;实现多态&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#%e5%ae%9e%e7%8e%b0%e5%a4%9a%e6%80%81&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;14.1 实现多态&lt;/h3&gt;&lt;div class=&#34;code-block highlight is-open show-line-numbers  tw-group tw-my-2&#34;&gt;&#xA;  &lt;div class=&#34;&#xA;    &#xA;    tw-flex &#xA;    tw-flex-row&#xA;    tw-flex-1 &#xA;    tw-justify-between &#xA;    tw-w-full tw-bg-bgColor-secondary&#xA;    &#34;&gt;      &#xA;    &lt;button &#xA;      class=&#34;&#xA;        code-block-button&#xA;        tw-mx-2 &#xA;        tw-flex&#xA;        tw-flex-row&#xA;        tw-flex-1&#34;&#xA;      aria-hidden=&#34;true&#34;&gt;&#xA;          &lt;div class=&#34;group-[.is-open]:tw-rotate-90 tw-transition-[transform] tw-duration-500 tw-ease-in-out print:!tw-hidden tw-w-min tw-h-min tw-my-1 tw-mx-1&#34;&gt;&lt;svg class=&#34;icon&#34;&#xA;    xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;0 0 320 512&#34;&gt;&lt;!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --&gt;&lt;path d=&#34;M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z&#34;/&gt;&lt;/svg&gt;&lt;/div&gt;&#xA;          &lt;p class=&#34;tw-select-none !tw-my-1&#34;&gt;go&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go break，continue，goto label 的区别</title>
      <link>https://www.xiaobinqt.cn/break-continue-goto-label/</link>
      <pubDate>Sat, 16 May 2020 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/break-continue-goto-label/</guid>
      <description>&lt;!-- author： xiaobinqt --&gt;&#xA;&lt;!-- email： xiaobinqt@163.com --&gt;&#xA;&lt;!-- https://xiaobinqt.github.io --&gt;&#xA;&lt;!-- https://www.xiaobinqt.cn --&gt;&#xA;&lt;p&gt;在其他语言，比如 php 中可以直接在 break 和 continue 后加 num ，比如 &lt;code&gt;break 2&lt;/code&gt;或 &lt;code&gt;continue 2&lt;/code&gt;。 break num 是结束外层第 num 层整个循环体，continue num 是结束外层第&#xA;num 层单次循环。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go select 用法简述</title>
      <link>https://www.xiaobinqt.cn/go-select/</link>
      <pubDate>Wed, 15 Apr 2020 00:00:00 +0000</pubDate><author>xiaobinqt@163.com (xiaobinqt)</author>
      <guid>https://www.xiaobinqt.cn/go-select/</guid>
      <description>&lt;!-- author： xiaobinqt --&gt;&#xA;&lt;!-- email： xiaobinqt@163.com --&gt;&#xA;&lt;!-- https://xiaobinqt.github.io --&gt;&#xA;&lt;!-- https://www.xiaobinqt.cn --&gt;&#xA;&lt;h2 id=&#34;select-功能&#34; class=&#34;headerLink&#34;&gt;&#xA;    &lt;a href=&#34;#select-%e5%8a%9f%e8%83%bd&#34; class=&#34;header-mark&#34;&gt;&lt;/a&gt;1 select 功能&lt;/h2&gt;&lt;p&gt;在多个通道上进行读或写操作，让函数可以处理多个事情，但 1 次只处理 1 个。select 有以下特征：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
