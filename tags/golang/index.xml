<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>golang - 标签 - xiaobinqt 博客 - 技术改变生活</title>
        <link>https://www.xiaobinqt.cn/tags/golang/</link>
        <description>golang - 标签 - xiaobinqt 博客 - 技术改变生活</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaobinqt@163.com (xiaobinqt)</managingEditor>
            <webMaster>xiaobinqt@163.com (xiaobinqt)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 10 Oct 2023 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://www.xiaobinqt.cn/tags/golang/" rel="self" type="application/rss+xml" /><item>
    <title>Go Slice 实现原理</title>
    <link>https://www.xiaobinqt.cn/go-slice-principle/</link>
    <pubDate>Tue, 10 Oct 2023 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/go-slice-principle/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="什么是-slice" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-slice" class="header-mark"></a>什么是 slice</h2><p>切片是基于数组实现的，它的底层是数组，可以理解为对底层数组的抽象。</p>
<p>源码包中 src/runtime/slice.go 定义了 slice 的数据结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type slice struct {
</span></span><span class="line"><span class="cl">	array unsafe.Pointer // ArbitraryType int
</span></span><span class="line"><span class="cl">	len   int
</span></span><span class="line"><span class="cl">	cap   int
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>array 是指向底层数组的指针，占用 8 个字节。len 是切片的长度，占用 8 个字节。cap 是切片的容量，cap 总是大于等于 len 的，占用 8 个字节。所以 slice 占用 24 个字节。</p>
<p>slice 有 4 种初始化方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">	// 初始化方式1：直接声明
</span></span><span class="line"><span class="cl">	var slice1 []int
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// 初始化方式2：使用字面量
</span></span><span class="line"><span class="cl">	slice2 := []int{1, 2, 3, 4}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// 初始化方式3：使用 make 创建slice
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	slice3 := make([]int, 3, 5)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// 初始化方式4: 从切片或数组截取
</span></span><span class="line"><span class="cl">	slcie4 := arr[1:3]
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以通过下面的代码，看下 slice 初始化调用的底层函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">slice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 <code>go tool compile -S main.go | grep CALL</code> 得到汇编代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">0x0032 00050 (main.go:6)        CALL    runtime.makeslice(SB)
</span></span><span class="line"><span class="cl">0x004b 00075 (main.go:7)        CALL    runtime.growslice(SB)
</span></span><span class="line"><span class="cl">0x0076 00118 (main.go:8)        CALL    runtime.convTslice(SB)
</span></span><span class="line"><span class="cl">0x0091 00145 (main.go:8)        CALL    runtime.convT64(SB)
</span></span><span class="line"><span class="cl">0x00ac 00172 (main.go:8)        CALL    runtime.convT64(SB)
</span></span><span class="line"><span class="cl">0x00e0 00224 ($GOROOT/src/fmt/print.go:274)     CALL    fmt.Fprintln(SB)
</span></span><span class="line"><span class="cl">0x00f5 00245 (main.go:5)        CALL    runtime.morestack_noctxt(SB)
</span></span></code></pre></td></tr></table>
</div>
</div><p>初始化 slice 调用的是 runtime.makeslice，makeslice 函数的工作主要就是计算 slice 所需内存大小，然后调用 mallocgc 进行内存的分配。</p>
<p>所需内存大小 = 切片中元素大小 * 切片的容量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">runtime</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">makeslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&gt;</span> <span class="nx">cap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// NOTE: Produce a &#39;len out of range&#39; error instead of a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// &#39;cap out of range&#39; error when someone does make([]T, bignumber).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// &#39;cap out of range&#39; is true too, but since the cap is only being
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// supplied implicitly, saying len is clearer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// See golang.org/issue/4085.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">len</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">panicmakeslicelen</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nf">panicmakeslicecap</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">et</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="array-和-slice-区别" class="headerLink">
    <a href="#array-%e5%92%8c-slice-%e5%8c%ba%e5%88%ab" class="header-mark"></a>array 和 slice 区别</h2><ol>
<li>
<p>数组初始化必须指定长度，并且长度就是固定的 切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大</p>
</li>
<li>
<p>数组是值类型，将一个数组赋值给另一个数组时，传递的是一份深拷贝，函数传参操作都会复制整个数组数据，会占用额外的内存，函数内对数组元素值的修改，不会修改原数组内容。切片是引用类型，将一个切片赋值给另一个切片时，传递的是一份浅拷贝，函数传参操作不会拷贝整个切片，只会复制 len 和 cap，底层共用同一个数组，不会占用额外的内存，函数内对数组元素值的修改，会修改原数组内容。</p>
</li>
<li>
<p>数组需要遍历计算数组长度，时间复杂度为 O(n) 切片底层包含 len 字段，可以通过 len() 计算切片长度，时间复杂度为 O(1)</p>
</li>
</ol>
<h2 id="slice-扩容机制" class="headerLink">
    <a href="#slice-%e6%89%a9%e5%ae%b9%e6%9c%ba%e5%88%b6" class="header-mark"></a>slice 扩容机制</h2><h3 id="旧规则存在的问题" class="headerLink">
    <a href="#%e6%97%a7%e8%a7%84%e5%88%99%e5%ad%98%e5%9c%a8%e7%9a%84%e9%97%ae%e9%a2%98" class="header-mark"></a>旧规则存在的问题</h3><p>在 1.17 及之前的版本中，扩容机制是这样的👇：</p>
<ul>
<li>
<p>当新切片需要的容量 cap 大于两倍扩容的容量，则直接按照新切片需要的容量扩容；</p>
</li>
<li>
<p>当原 slice 容量 &lt; 1024 的时候，新 slice 容量变成原来的 2 倍；</p>
</li>
<li>
<p>当原 slice 容量 &gt; 1024，进入一个循环，每次容量变成原来的1.25倍，直到大于期望容量。</p>
</li>
</ul>
<p>slice 扩容时会调用 <code>runtime.growslice</code>。这里只关注该函数 slice 计算容量部分的逻辑，计算方法如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 1.17及以前的版本中
</span></span><span class="line"><span class="cl">// old指切片的旧容量, cap指期望的新容量
</span></span><span class="line"><span class="cl">func growslice(old, cap int) int {
</span></span><span class="line"><span class="cl">    newcap := old
</span></span><span class="line"><span class="cl">    doublecap := newcap + newcap
</span></span><span class="line"><span class="cl">    // 如果期望容量大于旧容量的2倍，则直接使用期望容量作为最终容量
</span></span><span class="line"><span class="cl">    if cap &gt; doublecap {
</span></span><span class="line"><span class="cl">        newcap = cap
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        // 如果旧容量小于1024，则直接翻倍
</span></span><span class="line"><span class="cl">        if old &lt; 1024 {
</span></span><span class="line"><span class="cl">            newcap = doublecap
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            // 每次增长大约1.25倍
</span></span><span class="line"><span class="cl">            for 0 &lt; newcap &amp;&amp; newcap &lt; cap {
</span></span><span class="line"><span class="cl">                newcap += newcap / 4
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            if newcap &lt;= 0 {
</span></span><span class="line"><span class="cl">                newcap = cap
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 这里忽略了对齐操作
</span></span><span class="line"><span class="cl">    return newcap
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个扩容机制令一些人产生了<a href="https://groups.google.com/g/golang-nuts/c/UaVlMQ8Nz3o" target="_blank" rel="noopener noreferrer">一些困惑</a>，因为它会产生一些 “看起来不那么自然的行为”。比如<strong>它计算出来的新容量不是单调递增的</strong>，下面的程序会将不同容量 slice 的扩容结果打印出来:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2000</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">100</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nb">append</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">bool</span><span class="p">,</span> <span class="nx">i</span><span class="p">),</span> <span class="kc">true</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该程序的输出如下（旧版本的扩容规则）:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 第一列是切片的旧容量
</span></span><span class="line"><span class="cl">// 第二列是扩容后的容量
</span></span><span class="line"><span class="cl">0 8
</span></span><span class="line"><span class="cl">100 208
</span></span><span class="line"><span class="cl">200 416
</span></span><span class="line"><span class="cl">300 640
</span></span><span class="line"><span class="cl">400 896
</span></span><span class="line"><span class="cl">500 1024
</span></span><span class="line"><span class="cl">600 1280
</span></span><span class="line"><span class="cl">700 1408
</span></span><span class="line"><span class="cl">800 1792
</span></span><span class="line"><span class="cl">900 2048
</span></span><span class="line"><span class="cl">1000 2048
</span></span><span class="line"><span class="cl">1100 1408 &lt;-- 在这个点，扩容后的新容量比上面的容量要小
</span></span><span class="line"><span class="cl">1200 1536
</span></span><span class="line"><span class="cl">1300 1792
</span></span><span class="line"><span class="cl">1400 1792
</span></span><span class="line"><span class="cl">1500 2048
</span></span><span class="line"><span class="cl">1600 2048
</span></span><span class="line"><span class="cl">1700 2304
</span></span><span class="line"><span class="cl">1800 2304
</span></span><span class="line"><span class="cl">1900 2688
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，在 slice 的容量刚刚触发<strong>大于 1024 增长 1.25 倍</strong>这个条件的时候，计算出来的新容量要小于之前计算出的容量，这里绘制了一张图表，可以感受一下:</p>
<div align="center"></div>
<h3 id="更加平滑的扩容算法" class="headerLink">
    <a href="#%e6%9b%b4%e5%8a%a0%e5%b9%b3%e6%bb%91%e7%9a%84%e6%89%a9%e5%ae%b9%e7%ae%97%e6%b3%95" class="header-mark"></a>更加平滑的扩容算法</h3><p>从 <code>go1.18</code> 开始，slice 容量的计算方法被改为了这样:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 只关心扩容规则的简化版growslice
</span></span><span class="line"><span class="cl">func growslice(old, cap int) int {
</span></span><span class="line"><span class="cl">    newcap := old
</span></span><span class="line"><span class="cl">    doublecap := newcap + newcap
</span></span><span class="line"><span class="cl">    if cap &gt; doublecap {
</span></span><span class="line"><span class="cl">        newcap = cap
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        const threshold = 256 // 不同点1
</span></span><span class="line"><span class="cl">        if old &lt; threshold {
</span></span><span class="line"><span class="cl">            newcap = doublecap
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            for 0 &lt; newcap &amp;&amp; newcap &lt; cap {
</span></span><span class="line"><span class="cl">                newcap += (newcap + 3*threshold) / 4 // 不同点2
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            if newcap &lt;= 0 {
</span></span><span class="line"><span class="cl">                newcap = cap
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return newcap
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>新版的扩容算法相较于旧的有两处不同，首先是双倍容量扩容的最大阈值<strong>从 1024 降为了 256</strong>，只要超过了 256，就开始进行缓慢的增长。其次是增长比例的调整，之前超过了阈值之后，基本为恒定的 1.25 倍增长，而现在超过了阈值之后，增长比例是会动态调整的:</p>
<ul>
<li>
<p>当新切片需要的容量 cap 大于两倍扩容的容量，则直接按照新切片需要的容量扩容；</p>
</li>
<li>
<p>当原 slice 容量 &lt; threshold（256） 的时候，新 slice 容量变成原来的 2 倍；</p>
</li>
<li>
<p>当原 slice 容量 &gt; threshold（256），进入一个循环，每次容量增加 <code>(旧容量+3*threshold)/4</code>。</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">初始长度         增长比例
</span></span><span class="line"><span class="cl">256             2.0
</span></span><span class="line"><span class="cl">512             1.63
</span></span><span class="line"><span class="cl">1024            1.44
</span></span><span class="line"><span class="cl">2048            1.35
</span></span><span class="line"><span class="cl">4096            1.30
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，<strong>随着切片容量的变大，增长比例逐渐向着 1.25 进行靠拢</strong>。</p>
<p>这次更改之后，slice 扩容整体的增长曲线变得更加平滑：</p>
<div align="center"></div>
<p>关于更多信息，可以查看<a href="https://github.com/golang/go/commit/2dda92ff6f9f07eeb110ecbf0fc2d7a0ddd27f9d" target="_blank" rel="noopener noreferrer">#2dda92ff6f9f07eeb110ecbf0fc2d7a0ddd27f9d</a></p>
<h2 id="slice-是否是线程安全的" class="headerLink">
    <a href="#slice-%e6%98%af%e5%90%a6%e6%98%af%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84" class="header-mark"></a>slice 是否是线程安全的</h2><p>线程安全的定义是：</p>
<p>多个线程访问（读）同一个对象时，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。</p>
<p>若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
<p>Go 语言实现线程安全常用的方式有：</p>
<ol>
<li>互斥锁</li>
<li>读写锁</li>
<li>原子操作</li>
<li>sync.once</li>
<li>sync.atomic</li>
<li>channel</li>
</ol>
<p>slice 底层结构并没有使用加锁等方式，不支持并发读写，所以 slice 并不是线程安全的，使用多个 goroutine 对类型为 slice 的变量进行操作，每次输出的值大概率都不会一样，与预期值不一致，slice 在并发执行中不会报错，但是数据可能会丢失。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 切片非并发安全* 多次执行，每次得到的结果都不一样* 可以考虑使用 channel 本身的特性 (阻塞) 来实现安全的并发读写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">TestSliceConcurrencySafe</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">TestSliceConcurrencySafe</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span> <span class="c1">// 这里的值不是 10000
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://juejin.cn/post/7136774425415794719" target="_blank" rel="noopener noreferrer">Go slice新的扩容机制</a></li>
<li><a href="https://juejin.cn/post/7101928883280150558" target="_blank" rel="noopener noreferrer">Go 1.18 全新的切片扩容机制</a></li>
</ul>
]]></description>
</item><item>
    <title>Golang 内存逃逸</title>
    <link>https://www.xiaobinqt.cn/escape-heap/</link>
    <pubDate>Tue, 10 Oct 2023 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/escape-heap/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<p>在 C/C++ 开发中，动态分配内存（new/malloc）需要开发者手动释放资源。这样做的好处是，需要申请多少内存空间可以很好的掌握怎么分配。但是这有个缺点，如果忘记释放内存，则会导致内存泄漏。在很多高级语言中（python/Go/java）都加上了垃圾回收机制。</p>
<h2 id="堆和栈" class="headerLink">
    <a href="#%e5%a0%86%e5%92%8c%e6%a0%88" class="header-mark"></a>堆和栈</h2><p>栈可以简单得理解成一次函数调用内部申请到的内存，它们会随着函数的返回把内存还给系统。下面来看看一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func F() {
</span></span><span class="line"><span class="cl">    temp := make([]int, 0, 20)
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的例子，内函数内部申请的临时变量，即使是用 make 申请到的内存，如果发现在退出函数后没有用了，那么就把丢到栈上，毕竟栈上的内存分配比堆上快很多。</p>
<p>再看一个堆的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func F() []int{
</span></span><span class="line"><span class="cl">    a := make([]int, 0, 20)
</span></span><span class="line"><span class="cl">    return a
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面这段代码，申请的代码和上面的一模一样，但是申请后作为返回值返回了，编译器会认为在退出函数之后还有其他地方在引用，当函数返回之后并不会将其内存归还。那么就申请到堆里。</p>
<p>如果变量都分配到堆上，堆不像栈可以自动清理。它会引起 Go 频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销。</p>
<h3 id="堆和栈相比" class="headerLink">
    <a href="#%e5%a0%86%e5%92%8c%e6%a0%88%e7%9b%b8%e6%af%94" class="header-mark"></a>堆和栈相比</h3><p>堆适合不可预知的大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。</p>
<p>栈内存分配则会非常快，栈分配内存只需要两个 CPU 指令：PUSH 和 RELEASE 分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块。之后要通过垃圾回收才能释放。</p>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>内存碎片<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>内存碎片（Memory Fragmentation）是指计算机系统中存在的一种内存分配和释放的情况，它可能导致系统中的可用内存不连续、零散分布，使得系统效率下降或者无法有效地利用可用内存。内存碎片通常分为两种类型：外部碎片和内部碎片。</p>
<ol>
<li>
<p>外部碎片（External Fragmentation）：</p>
<ul>
<li>外部碎片指的是在可用内存中存在的未分配的小块内存空间，虽然总的可用内存大小足够，但是这些小块内存分散在不同的地方，无法被有效地利用。</li>
<li>外部碎片通常发生在动态内存分配和释放的过程中。当程序请求分配一块内存时，系统会找到一个足够大的连续内存块来满足需求，但是如果可用内存被分割成多个小块，就可能出现无法分配所需大小的内存块的情况。</li>
</ul>
</li>
<li>
<p>内部碎片（Internal Fragmentation）：</p>
<ul>
<li>内部碎片是指已经分配给程序的内存块中，有一部分内存没有被程序有效利用，造成了浪费。</li>
<li>内部碎片通常发生在内存分配时，分配了比实际需要更大的内存块，但程序没有充分利用这些额外的内存空间。</li>
</ul>
</li>
</ol>
<p>内存碎片的重要性和影响：</p>
<ul>
<li>内存碎片会导致系统性能下降，因为操作系统需要更多的时间来寻找足够大的连续内存块来满足程序的需求。</li>
<li>内存碎片也可能导致程序崩溃或运行不稳定，特别是当内存碎片积累到一定程度时。</li>
<li>为了减少内存碎片的影响，程序员和操作系统通常采用不同的策略，如内存合并、内存池等，以更有效地管理内存。</li>
</ul>
</div>
        </div>
    </div>
<h2 id="逃逸分析" class="headerLink">
    <a href="#%e9%80%83%e9%80%b8%e5%88%86%e6%9e%90" class="header-mark"></a>逃逸分析</h2><p>逃逸分析是一种确定指针动态范围的方法。简单来说就是分析在程序的哪些地方可以访问到该指针。编译器会根据变量是否被外部引用来决定是否逃逸：</p>
<ol>
<li>如果函数外部没有引用，则优先放到栈中；</li>
<li>如果函数外部存在引用，则必定放到堆中；</li>
</ol>
<p>对此可以理解为，逃逸分析是编译器用于决定变量分配到堆上还是栈上的一种行为。</p>
<p><strong>go 在编译阶段确立逃逸，并不是在运行时</strong>。</p>
<h2 id="指针逃逸" class="headerLink">
    <a href="#%e6%8c%87%e9%92%88%e9%80%83%e9%80%b8" class="header-mark"></a>指针逃逸</h2><p>提问：函数传递指针真的比传值效率高吗？</p>
<p>传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加 GC 的负担，所以传递指针不一定是高效的。</p>
<p>官网上上有一个关于变量分配的问题 <a href="https://go.dev/doc/faq#stack_or_heap:~:text=From%20a%20correctness,on%20the%20stack." target="_blank" rel="noopener noreferrer">How do I know whether a variable is allocated on the heap or the stack?</a></p>
<p>Go 可以返回局部变量指针，这其实是一个典型的变量逃逸案例，示例代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Student</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Age</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">StudentRegister</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">age</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Student</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Student</span><span class="p">)</span> <span class="c1">//局部变量s逃逸到堆
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="nx">name</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">Age</span> <span class="p">=</span> <span class="nx">age</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">StudentRegister</span><span class="p">(</span><span class="s">&#34;Jim&#34;</span><span class="p">,</span> <span class="mi">18</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然在函数 StudentRegister() 内部 s 为局部变量，其值通过函数返回值返回，s 本身为一指针，其指向的内存地址不会是栈而是堆，这就是典型的逃逸案例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">λ go build -gcflags=-m main.go
</span></span><span class="line"><span class="cl"># command-line-arguments
</span></span><span class="line"><span class="cl">.\main.go:8:6: can inline StudentRegister
</span></span><span class="line"><span class="cl">.\main.go:17:6: can inline main
</span></span><span class="line"><span class="cl">.\main.go:18:17: inlining call to StudentRegister
</span></span><span class="line"><span class="cl">.\main.go:8:22: leaking param: name
</span></span><span class="line"><span class="cl">.\main.go:9:10: new(Student) escapes to heap
</span></span><span class="line"><span class="cl">.\main.go:18:17: new(Student) does not escape
</span></span></code></pre></td></tr></table>
</div>
</div><p>指令集 -gcflags 用于将标识参数传递给 Go 编译器，-m 会打印出逃逸分析的优化策略。</p>
<p>可见在 StudentRegister() 函数中，也即代码第 9 行显示 escapes to heap，代表该行内存分配发生了逃逸现象。</p>
<h3 id="栈空间不足逃逸" class="headerLink">
    <a href="#%e6%a0%88%e7%a9%ba%e9%97%b4%e4%b8%8d%e8%b6%b3%e9%80%83%e9%80%b8" class="header-mark"></a>栈空间不足逃逸</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">=</span> <span class="nx">index</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面代码主函数中分配了一个 1000 个长度的切片，是否逃逸取决于栈空间是否足够大。直接查看编译提示，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">λ go build -gcflags=-m main.go
</span></span><span class="line"><span class="cl"># command-line-arguments
</span></span><span class="line"><span class="cl">.\main.go:3:6: can inline main
</span></span><span class="line"><span class="cl">.\main.go:5:11: make([]int, 1000, 1000) does not escape
</span></span></code></pre></td></tr></table>
</div>
</div><p>根据上面的信息，没有发生逃逸。分配了一个 1000 的长度还不足以发生逃逸现象。x10 倍后，再看看情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">=</span> <span class="nx">index</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">λ go build -gcflags=-m main.go
</span></span><span class="line"><span class="cl"># command-line-arguments
</span></span><span class="line"><span class="cl">.\main.go:3:6: can inline main
</span></span><span class="line"><span class="cl">.\main.go:5:11: make([]int, 10000, 10000) escapes to heap
</span></span></code></pre></td></tr></table>
</div>
</div><p>当切片长度扩大到 10000 时就会逃逸。实际上当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中。</p>
<h3 id="动态类型逃逸" class="headerLink">
    <a href="#%e5%8a%a8%e6%80%81%e7%b1%bb%e5%9e%8b%e9%80%83%e9%80%b8" class="header-mark"></a>动态类型逃逸</h3><p>很多函数参数为 interface 类型。比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func Printf(format string, a ...interface{}) (n int, err error)
</span></span><span class="line"><span class="cl">func Sprintf(format string, a ...interface{}) string
</span></span><span class="line"><span class="cl">func Fprint(w io.Writer, a ...interface{}) (n int, err error)
</span></span><span class="line"><span class="cl">func Print(a ...interface{}) (n int, err error)
</span></span><span class="line"><span class="cl">func Println(a ...interface{}) (n int, err error)
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译期间很难确定其参数的具体类型，也能产生逃逸。</p>
<p>如下代码所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello 123&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;hello 456&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">λ go build -gcflags=-m main.go
</span></span><span class="line"><span class="cl"># command-line-arguments
</span></span><span class="line"><span class="cl">.\main.go:6:13: inlining call to fmt.Println
</span></span><span class="line"><span class="cl">.\main.go:7:11: inlining call to fmt.Print
</span></span><span class="line"><span class="cl">.\main.go:6:13: ... argument does not escape
</span></span><span class="line"><span class="cl">.\main.go:6:14: &#34;hello 123&#34; escapes to heap
</span></span><span class="line"><span class="cl">.\main.go:7:11: ... argument does not escape
</span></span><span class="line"><span class="cl">.\main.go:7:12: &#34;hello 456&#34; escapes to heap
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="逃逸分析的作用" class="headerLink">
    <a href="#%e9%80%83%e9%80%b8%e5%88%86%e6%9e%90%e7%9a%84%e4%bd%9c%e7%94%a8" class="header-mark"></a>逃逸分析的作用</h2><ol>
<li>
<p>逃逸分析的好处是为了减少 gc 的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要 gc 标记清除。</p>
</li>
<li>
<p>逃逸分析完后可以确定哪些变量可以分配在栈上，栈的分配比堆快，性能好（逃逸的局部变量会在堆上分配，而没有发生逃逸的则有编译器在栈上分配）。</p>
</li>
<li>
<p>同步消除，如果定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。</p>
</li>
</ol>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>info<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>当涉及到同步锁（Mutex）以及只有一个线程在访问的情况时，逃逸分析可能会起到关键作用。下面是一个简单的示例来解释这个情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">data</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">data</span> <span class="p">=</span> <span class="mi">42</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 在这里，编译器会执行逃逸分析
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 如果编译器能够确定 data 不会逃逸到堆上，它可能会去除同步锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 因为只有一个线程在访问 data，不涉及并发竞争
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个示例中，虽然我们使用了同步锁来保护 <code>data</code> 的访问，但是在逃逸分析的过程中，编译器可以发现 <code>data</code> 没有逃逸到堆上，因此它可以选择去掉同步锁，因为只有一个线程在访问 <code>data</code>，不存在并发竞争的情况。</p>
<p>这种优化可以提高程序的性能，因为同步锁的获取和释放操作可能会引入一些开销。不过需要注意的是，编译器会根据具体情况进行判断，而不是简单地因为只有一个线程就去掉所有同步锁。在多线程情况下，同步锁是必要的，以确保数据的安全访问。因此，在编写多线程程序时，仍然需要谨慎使用同步锁以确保线程安全。</p>
</div>
        </div>
    </div>
<h2 id="总结" class="headerLink">
    <a href="#%e6%80%bb%e7%bb%93" class="header-mark"></a>总结</h2><ol>
<li>
<p>堆上动态分配内存比栈上静态分配内存，开销大很多。</p>
</li>
<li>
<p>变量分配在栈上需要能在编译期确定它的作用域，否则会分配到堆上。</p>
</li>
<li>
<p>Go 编译器会在编译期对考察变量的作用域，并作一系列检查，如果它的作用域在运行期间对编译器一直是可知的，那么就会分配到栈上。简单来说，<strong>编译器会根据变量是否被外部引用来决定是否逃逸</strong>。</p>
</li>
<li>
<p>编译器的这些逃逸分析规则其实不需要掌握，只需通过 <code>go build -gcflags=-m</code> 命令来观察变量逃逸情况就行了。</p>
</li>
<li>
<p>不要盲目使用变量的指针作为函数参数，虽然它会减少复制操作。但其实当参数为变量自身的时候，复制是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多。</p>
</li>
<li>
<p>逃逸分析在编译阶段完成的。</p>
</li>
</ol>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://colynn.github.io/2020-07-16-go-memory-allocation/" target="_blank" rel="noopener noreferrer">Golang 内存分配 - stack and heap</a></li>
</ul>
]]></description>
</item><item>
    <title>Go 编译标签 build tag</title>
    <link>https://www.xiaobinqt.cn/go-build-tag/</link>
    <pubDate>Sat, 28 Jan 2023 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/go-build-tag/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="简介" class="headerLink">
    <a href="#%e7%ae%80%e4%bb%8b" class="header-mark"></a>简介</h2><p>在 Go 中，build tag 是添加到代码中第一行，来标识编译相关信息的，build tag 决定了当前文件是否会被当前 package 所包含，用于限制一整个文件是否应该被编译入最终的二进制文件，而不是一个文件中的部分代码片段。</p>
<p>Go <strong><ruby>编译标签<rt>build tag</rt></ruby></strong>语法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// +build [tag]
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>build tags 文件顶部附近，前面只能有空行和其他行注释。</li>
<li>编译标记必须出现在 package 子句之前，并且为了与包文档区分开来，它<strong>必须</strong>后跟一个空行。</li>
</ul>
<h2 id="编译标签的逻辑" class="headerLink">
    <a href="#%e7%bc%96%e8%af%91%e6%a0%87%e7%ad%be%e7%9a%84%e9%80%bb%e8%be%91" class="header-mark"></a>编译标签的逻辑</h2><p>当在一个包中使用多个标签时会使用 bool 逻辑进行交互，具体取决于我们如何进行声明的。</p>
<p>Build tags 遵循以下三个规则：</p>
<ul>
<li>以空格分隔的标签将在<code>OR</code>逻辑下进行解释。</li>
<li>逗号分隔的标签将在<code>AND</code>逻辑下进行解释。</li>
<li>每个术语都是一个字母数字单词，如果前面有<code>!</code>它意味着它被否定。</li>
</ul>
<h3 id="or-标签逻辑" class="headerLink">
    <a href="#or-%e6%a0%87%e7%ad%be%e9%80%bb%e8%be%91" class="header-mark"></a>or 标签逻辑</h3><p>给定标签：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// +build tag1 tag2
</span></span></code></pre></td></tr></table>
</div>
</div><p>OR 解释是，如果在执行 build 构建命令时存在 tag1 或 tag2，则将包含此文件。</p>
<h3 id="and-标签逻辑" class="headerLink">
    <a href="#and-%e6%a0%87%e7%ad%be%e9%80%bb%e8%be%91" class="header-mark"></a>and 标签逻辑</h3><p>如果我们使用标签：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// +build tag1, tag2
</span></span></code></pre></td></tr></table>
</div>
</div><p>解释是 tag1 且（AND） tag2 必须存在于 build 构建命令中，我们的文件才能包含在编译中。</p>
<h3 id="非标签逻辑" class="headerLink">
    <a href="#%e9%9d%9e%e6%a0%87%e7%ad%be%e9%80%bb%e8%be%91" class="header-mark"></a>！非标签逻辑</h3><p>如果我们使用标签</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> // +build !tag1
</span></span></code></pre></td></tr></table>
</div>
</div><p>解释是，非 tag1，我们的文件才会 build 编译</p>
<h2 id="如何使用" class="headerLink">
    <a href="#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8" class="header-mark"></a>如何使用</h2><h3 id="新建-build-tag" class="headerLink">
    <a href="#%e6%96%b0%e5%bb%ba-build-tag" class="header-mark"></a>新建 build tag</h3><p>我们新建一个 buildtag 文件夹，并在文件夹下新建如下4个空文件，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── dev.go
</span></span><span class="line"><span class="cl">├── main.go
</span></span><span class="line"><span class="cl">├── prod.go
</span></span><span class="line"><span class="cl">├── test.go
</span></span><span class="line"><span class="cl">└── without.go
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们打开 main.go 输入代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">configArr</span> <span class="p">[]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">conf</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">configArr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">conf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们打开 dev.go 输入代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// +build dev
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">configArr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">configArr</span><span class="p">,</span> <span class="s">&#34;mysql dev&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们打开 prod.go 输入代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// +build prod
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">configArr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">configArr</span><span class="p">,</span> <span class="s">&#34;mysql prod&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们打开 test.go 输入代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// +build test1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">configArr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">configArr</span><span class="p">,</span> <span class="s">&#34;mysql test&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们打开 without.go 输入代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// +build !without
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">configArr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">configArr</span><span class="p">,</span> <span class="s">&#34;mysql without&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="使用-tags-编译" class="headerLink">
    <a href="#%e4%bd%bf%e7%94%a8-tags-%e7%bc%96%e8%af%91" class="header-mark"></a>使用 tags 编译</h3><h4 id="1-没有tag编译" class="headerLink">
    <a href="#1-%e6%b2%a1%e6%9c%89tag%e7%bc%96%e8%af%91" class="header-mark"></a>1. 没有tag编译</h4><p>我们使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go build
</span></span></code></pre></td></tr></table>
</div>
</div><p>在文件夹里生成了二进制执行文件 buildtag，我们执行一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">➜ ./buildtag 
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mysql without
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="2-单个tag编译" class="headerLink">
    <a href="#2-%e5%8d%95%e4%b8%aatag%e7%bc%96%e8%af%91" class="header-mark"></a>2. 单个tag编译</h4><p>我们使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go build  -tags &#34;dev&#34; 
</span></span></code></pre></td></tr></table>
</div>
</div><p>在文件夹里生成了二进制执行文件 buildtag，我们执行一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">➜ ./buildtag 
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mysql dev
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="3-多个tag编译" class="headerLink">
    <a href="#3-%e5%a4%9a%e4%b8%aatag%e7%bc%96%e8%af%91" class="header-mark"></a>3. 多个tag编译</h4><p>我们使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go build  -tags &#34;dev prod&#34; 
</span></span></code></pre></td></tr></table>
</div>
</div><p>在文件夹里生成了二进制执行文件 buildtag，我们执行一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">➜ ./buildtag 
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mysql dev
</span></span><span class="line"><span class="cl">mysql prod
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="gobuild-与-build-的区别" class="headerLink">
    <a href="#gobuild-%e4%b8%8e-build-%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-mark"></a>go:build 与 +build 的区别</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//go:build
</span></span></code></pre></td></tr></table>
</div>
</div><p>☝️是 Go 1.17 中引入的新条件编译指令格式。它旨在替换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// +build
</span></span></code></pre></td></tr></table>
</div>
</div><p>指令。那么为何要采用新的格式呢？对比一下新旧格式的区别就知道了👇</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// go:build linux &amp;&amp; amd64 || darwin
</span></span><span class="line"><span class="cl">// +build linux,amd64 darwin
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>go:build</code>这种格式，对 coder 来说，更容易理解其逻辑组合，与<code>//go:embed</code>和<code>//go:generate</code>这些命令相比较，格式上进行了统一。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://github.com/xiaobinqt/go.src/tree/master/dev/buildtag" target="_blank" rel="noopener noreferrer">代码地址</a></li>
<li><a href="https://segmentfault.com/a/1190000042007310" target="_blank" rel="noopener noreferrer">go 编译标签( build tag)-注释里的编译语法</a></li>
<li><a href="https://wrfly.kfd.me/posts/golang-netgo-vs-cgo/" target="_blank" rel="noopener noreferrer">golang: netgo vs cgo</a></li>
</ul>
]]></description>
</item><item>
    <title>Go1.18 sync.Map 解读</title>
    <link>https://www.xiaobinqt.cn/go-sync-map/</link>
    <pubDate>Wed, 14 Sep 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/go-sync-map/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="背景" class="headerLink">
    <a href="#%e8%83%8c%e6%99%af" class="header-mark"></a>背景</h2><p>项目中遇到了需要使用高并发的 map 的场景，众所周知 Go 官方的原生 map 是不支持并发读写的，直接并发的读写很容易触发 panic。</p>
<p>解决的办法有两个：</p>
<ul>
<li>自己配一把锁 <code>sync.Mutex</code> 或者更加考究一点配一把读写锁 <code>sync.RWMutex</code>。这种方案简约直接，但是缺点也明显，就是性能不会太高。</li>
<li>使用 Go 语言在 2017 年发布的 Go 1.9 中正式加入了并发安全的字典类型 <code>sync.Map</code>。</li>
</ul>
<p>很显然，方案 2 是优雅且实用的。但是，为什么官方的 <code>sync.Map</code> 能够在 <strong><ruby>lock free<rt>无锁并发</rt></ruby></strong> 的前提下，保证足够高的性能❓本文结合 golang 1.18 源码进行简单的分析。</p>
<h2 id="核心思想" class="headerLink">
    <a href="#%e6%a0%b8%e5%bf%83%e6%80%9d%e6%83%b3" class="header-mark"></a>核心思想</h2><p>如果要保证并发的安全，最朴素的想法就是使用锁，但是这意味着要把一些并发的操作强制串行化，性能自然就会下降。</p>
<p>事实上，除了使用锁，还有一个办法也可以达到类似并发安全的目的，就是 <code>atomic</code> 原子操作。<code>sync.Map</code> 的设计非常巧妙，充分利用了 <code>atmoic</code> 和 <code>mutex</code> 互斥锁的配合。</p>
<ul>
<li>
<p>read map 由于是原子包托管，主要负责高性能，但是无法保证拥有全量的 key，因为对于新增 key，会首先加到 dirty 中，所以 read 某种程度上，类似于一个 key 的快照，这个快照在某些情况下可能是全量快照。</p>
</li>
<li>
<p>dirty map 拥有全量的 key，当 <code>Store</code> 操作要新增一个之前不存在的 key 的时候，会先增加到 dirty 中的。</p>
</li>
<li>
<p>在查找指定的 key 的时候，总会先去 read map 中寻找，并不需要锁定互斥锁。只有当 read 中没有，但 dirty 中可能会有这个 key 的时候，才会在锁的保护下去访问 dirty。</p>
</li>
<li>
<p>在存储键值对的时候，只要 read 中已存有这个 key，并且该键值对<strong>未被</strong>标记为 <code>expunged</code>，就会把新值存到里面并直接返回，这种情况下也不需要用到锁。</p>
</li>
<li>
<p>read 和 dirty 之间是会互相转换的，在 dirty 中查找 key 对次数足够多的时候，<code>sync.Map</code> 会把 dirty 直接作为 read，即触发  <code>dirty-&gt;read</code> 的转变，此时 read 中拥有全量的 key。同时在某些情况，也会出现 <code>read-&gt;dirty</code> 的转变。</p>
</li>
</ul>
<h2 id="数据结构" class="headerLink">
    <a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="header-mark"></a>数据结构</h2><p>尽量使用原子操作，最大程度上减少了锁的使用，从而接近了 lock free 的效果。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221205/3c105d85e5c24fecb51e45bc3a184cfe.png" title="数据结构" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221205/3c105d85e5c24fecb51e45bc3a184cfe.png" data-sub-html="<h2>数据结构</h2><p>数据结构</p>">
        
    </a><figcaption class="image-caption">数据结构</figcaption>
    </figure></p>
<p>sync.Map 类型的底层数据结构如下👇</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type Map struct {
</span></span><span class="line"><span class="cl"> mu Mutex
</span></span><span class="line"><span class="cl"> read atomic.Value // readOnly
</span></span><span class="line"><span class="cl"> dirty map[any]*entry
</span></span><span class="line"><span class="cl"> misses int
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// Map.read 属性实际存储的是 readOnly。
</span></span><span class="line"><span class="cl">type readOnly struct {
</span></span><span class="line"><span class="cl"> m map[any]*entry
</span></span><span class="line"><span class="cl"> amended bool
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>mu：互斥锁，用于保护 read 和 dirty。</p>
</li>
<li>
<p>read：只读数据，支持并发读取（<code>atomic.Value</code>）。如果涉及到更新操作，则只需要加锁来保证数据安全。</p>
</li>
<li>
<p>read 实际存储的是 readOnly 结构体，内部也是一个原生 map，amended 属性用于标记 read 和 dirty 的数据是否一致，当 dirty 中存在 read 中不存在的 key 时，amended 为 <code>true</code>。</p>
</li>
<li>
<p>dirty：读写数据，是一个原生 map，也就是非线程安全。操作 dirty 需要加锁来保证数据安全。</p>
</li>
<li>
<p>misses：统计有多少次读取 read 没有命中。每次 read 中读取失败后，misses 的计数值都会加 1。</p>
</li>
</ul>
<p>在 read 和 dirty 中，都有涉及到的结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type entry struct {
</span></span><span class="line"><span class="cl"> p unsafe.Pointer // *any
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>其包含一个指针 p, 用于指向用户存储的元素（key）所指向的 value 值。</p>
<h2 id="atomicvalue" class="headerLink">
    <a href="#atomicvalue" class="header-mark"></a>atomic.Value</h2><p>当需要在 Go 中进行并发安全的值存储和读取时，可以使用 <code>sync/atomic</code> 包中的 <code>atomic.Value</code> 类型。<code>atomic.Value</code> 提供了一种原子操作的方式来存储和读取值，以确保在并发环境下不会出现数据竞争。</p>
<p>以下是关于 <code>atomic.Value</code> 的详细说明：</p>
<ol>
<li>
<p><strong>创建 <code>atomic.Value</code></strong>：
要创建一个 <code>atomic.Value</code>，可以使用 <code>sync/atomic</code> 包中的 <code>atomic.Value</code> 类型的零值。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">var v atomic.Value
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>存储值</strong>：
使用 <code>Store</code> 方法来存储一个值到 <code>atomic.Value</code> 中。这个操作是原子的，不会出现数据竞争。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">v.Store(&#34;Hello, World!&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>读取值</strong>：
使用 <code>Load</code> 方法来从 <code>atomic.Value</code> 中读取值。这个操作也是原子的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">value := v.Load()
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>并发安全</strong>：
<code>atomic.Value</code> 保证了存储和读取的操作是并发安全的，不需要额外的锁或互斥体。这对于在多个 goroutine 之间共享数据非常有用。</p>
</li>
<li>
<p><strong>值的类型</strong>：
<code>atomic.Value</code> 可以存储任何类型的值。这意味着它可以用于存储字符串、整数、结构体、切片、接口等任何 Go 类型。</p>
</li>
<li>
<p><strong>注意事项</strong>：</p>
<ul>
<li>
<p>虽然 <code>atomic.Value</code> 提供了并发安全的存储和读取，但它并不适用于复杂的数据结构。如果需要对复杂数据结构进行并发访问和修改，可能需要使用其他同步机制，如互斥锁。</p>
</li>
<li>
<p>当从 <code>atomic.Value</code> 中读取值时，需要进行类型断言，以将接口类型转换为实际的值类型。这需要谨慎处理，以确保类型安全。</p>
</li>
</ul>
</li>
</ol>
<p><code>atomic.Value</code> 是 Go 语言中用于并发安全值存储和读取的有用工具。它在简单的值存储和读取场景中非常有用，可以帮助避免数据竞争问题。但在处理复杂数据结构或需要更复杂同步的情况下，可能需要考虑其他并发控制机制。</p>
<h2 id="entry-的-p-可能状态" class="headerLink">
    <a href="#entry-%e7%9a%84-p-%e5%8f%af%e8%83%bd%e7%8a%b6%e6%80%81" class="header-mark"></a>entry 的 p 可能状态</h2><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230714/9ab5f3ce270e4d39ac832e6bea79238b.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230714/9ab5f3ce270e4d39ac832e6bea79238b.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230714/9ab5f3ce270e4d39ac832e6bea79238b.png" data-sub-html="<h2>p 的状态</h2>">
        
    </a><figcaption class="image-caption">p 的状态</figcaption>
    </figure></p>
<h3 id="nil" class="headerLink">
    <a href="#nil" class="header-mark"></a>nil</h3><p>当删除一个 key 时，如果 read 中存在会把这个 key 的 value 也就是 e.p 标记为 nil。这样在下次查找的时候还会在 read 中找个这个 key，这时需要去判断下 e.p 是否是 nil，如果是 nil 就表示这个 key 是已经删除的。</p>
<p>如果 read 中不存在但是 dirty 中存在，会先从 dirty 中把这个 key 删除，然后把这个 key 对应的 value 也就是 e.p 标记为 nil。</p>
<ul>
<li><code>e.p==nil</code>：entry 已经被标记删除，不过此时还未经过 <code>read-&gt;dirty</code> 重塑，此时可能仍然属于 dirty（如果 dirty 非 nil）。</li>
</ul>
<h3 id="expunged" class="headerLink">
    <a href="#expunged" class="header-mark"></a>expunged</h3><p>当 <code>dirty-&gt;read</code> 完成后，又有新 key 写入时，此时 read 中的 amended 为 <code>false</code>，就会调用 <code>dirtyLocked()</code> 方法，此时会发生 <code>read-&gt;dirty</code> 的转变，此时会循环 read 数据，将 p 不为 nil 的值写到 dirty 中，如果 p 为 nil 则将 nil 转为 expunged，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Map) dirtyLocked() {
</span></span><span class="line"><span class="cl">	if m.dirty != nil {
</span></span><span class="line"><span class="cl">		return
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	read, _ := m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl">	m.dirty = make(map[any]*entry, len(read.m))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	println(&#34;read-&gt;dirty 转变&#34;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	for k, e := range read.m {
</span></span><span class="line"><span class="cl">		// 把 read 中 value e.p 不是 expunged 的 key,value 转到 dirty 中
</span></span><span class="line"><span class="cl">		// 这里是循环，如果数据量大可能会非常耗时
</span></span><span class="line"><span class="cl">		if !e.tryExpungeLocked() {
</span></span><span class="line"><span class="cl">			m.dirty[k] = e
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func (e *entry) tryExpungeLocked() (isExpunged bool) {
</span></span><span class="line"><span class="cl">	p := atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">	for p == nil {
</span></span><span class="line"><span class="cl">		// 将 e.p 的 nil 转成 expunged
</span></span><span class="line"><span class="cl">		if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) {
</span></span><span class="line"><span class="cl">			return true
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		p = atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	return p == expunged
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在从 <code>read-&gt;dirty</code> 的转变中，虽然 read 中还会存在 expunged 的内容（expunged 是 read 独有的），但是不影响 sync.map 的高性能。相反，如果在 Delete 时直接去删除元素，那么就会去加锁操作 dirty，只要涉及到锁，就会影响到性能。</p>
<h3 id="正常" class="headerLink">
    <a href="#%e6%ad%a3%e5%b8%b8" class="header-mark"></a>正常</h3><p>此时 entry 是一个普通的存在状态，属于 read，如果 dirty 非 nil，也属于 dirty。</p>
<h2 id="store写入过程" class="headerLink">
    <a href="#store%e5%86%99%e5%85%a5%e8%bf%87%e7%a8%8b" class="header-mark"></a>Store写入过程</h2><p>先来看 expunged</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">var expunged = unsafe.Pointer(new(any))
</span></span></code></pre></td></tr></table>
</div>
</div><p>expunged 是一个指向任意类型的指针，用来标记从 dirty map 中<strong>删除</strong>的 entry。</p>
<p>sync.Map 类型的 Store 方法，该方法的作用是新增或更新一个元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Map) Store(key, value any) {
</span></span><span class="line"><span class="cl"> read, _ := m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl"> if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {
</span></span><span class="line"><span class="cl">  return
</span></span><span class="line"><span class="cl"> }
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// tryStore stores a value if the entry has not been expunged.
</span></span><span class="line"><span class="cl">//
</span></span><span class="line"><span class="cl">// If the entry is expunged, tryStore returns false and leaves the entry
</span></span><span class="line"><span class="cl">// unchanged.
</span></span><span class="line"><span class="cl">func (e *entry) tryStore(i *any) bool {
</span></span><span class="line"><span class="cl">	for {
</span></span><span class="line"><span class="cl">		p := atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">		if p == expunged {
</span></span><span class="line"><span class="cl">			return false
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		if atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) {
</span></span><span class="line"><span class="cl">			return true
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>调用<code>Load</code>方法检查<code>m.read</code>中是否存在这个元素。若存在，且在 tryStore 时，判断没有被标记为 expunged 删除状态，则尝试存储。</p>
<p>若该元素不存在或在 tryStore 时判断时，已经被标记为删除状态，则继续走到下面流程👇</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Map) Store(key, value any) {
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    m.mu.Lock()
</span></span><span class="line"><span class="cl">	read, _ = m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl">	if e, ok := read.m[key]; ok {
</span></span><span class="line"><span class="cl">		if e.unexpungeLocked() {
</span></span><span class="line"><span class="cl">			// 如果 read map 中存在该 key，但 p == expunged，则说明在 read 中已经被删除了:
</span></span><span class="line"><span class="cl">			//    a. 将 p 的状态由中间值 expunged 更改为 nil
</span></span><span class="line"><span class="cl">			//    b. dirty map 插入 key
</span></span><span class="line"><span class="cl">			m.dirty[key] = e
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		// 更新 entry.p = value (read map 和 dirty map 指向同一个 entry)
</span></span><span class="line"><span class="cl">		e.storeLocked(&amp;value)
</span></span><span class="line"><span class="cl">	} else if e, ok := m.dirty[key]; ok {
</span></span><span class="line"><span class="cl">		// 如果 read map 中不存在该 key，但 dirty map 中存在该 key，直接写入更新 entry(read map 中仍然没有这个 key)
</span></span><span class="line"><span class="cl">		e.storeLocked(&amp;value)
</span></span><span class="line"><span class="cl">	} else {
</span></span><span class="line"><span class="cl">		// 如果 read map 和 dirty map 中都不存在该 key，则：
</span></span><span class="line"><span class="cl">		//	  a. 如果 dirty map 为空，则需要创建 dirty map，并从 read map 中拷贝未删除的元素到新创建的 dirty map
</span></span><span class="line"><span class="cl">		//    b. 更新 amended 字段，标识 dirty map 中存在 read map 中没有的 key
</span></span><span class="line"><span class="cl">		//    c. 将 kv 写入 dirty map 中，read 不变
</span></span><span class="line"><span class="cl">		if !read.amended {
</span></span><span class="line"><span class="cl">		    // 到这里就意味着，当前的 key 是第一次被加到 dirty map 中。
</span></span><span class="line"><span class="cl">			// store 之前先判断一下 dirty map 是否为空，如果为空，就把 read map 浅拷贝一次。
</span></span><span class="line"><span class="cl">			m.dirtyLocked()
</span></span><span class="line"><span class="cl">			m.read.Store(readOnly{m: read.m, amended: true})
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		// 写入新 key，在 dirty 中存储 value
</span></span><span class="line"><span class="cl">		m.dirty[key] = newEntry(value)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	m.mu.Unlock()
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func (m *Map) dirtyLocked() {
</span></span><span class="line"><span class="cl">	if m.dirty != nil {
</span></span><span class="line"><span class="cl">		return
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	read, _ := m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl">	m.dirty = make(map[any]*entry, len(read.m))
</span></span><span class="line"><span class="cl">	for k, e := range read.m {
</span></span><span class="line"><span class="cl">		if !e.tryExpungeLocked() {
</span></span><span class="line"><span class="cl">			m.dirty[k] = e
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func (e *entry) tryExpungeLocked() (isExpunged bool) {
</span></span><span class="line"><span class="cl">	p := atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">	for p == nil {
</span></span><span class="line"><span class="cl">		// 将已经删除标记为nil的数据标记为 expunged
</span></span><span class="line"><span class="cl">		if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) {
</span></span><span class="line"><span class="cl">			return true
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		p = atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	return p == expunged
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里使用了<strong>双检查</strong>的处理，因为在下面的两个语句中，这两行语句并不是一个原子操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if !ok &amp;&amp; read.amended {
</span></span><span class="line"><span class="cl">		m.mu.Lock()
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然第一句执行的时候条件满足，但是在加锁之前，<code>m.dirty</code> 可能被提升为 <code>m.read</code>，所以加锁后还得再检查一次 <code>m.read</code>，后续的方法中都使用了这个方法。</p>
<p>由于已经走到了 dirty 的流程，因此开头就直接调用了 <code>Lock</code> 方法上<strong>互斥锁</strong>，保证数据安全，也是凸显<strong>性能变差的第一幕</strong>。</p>
<p>写入过程的整体流程是👇</p>
<ol>
<li>如果在 read 里能够找到待存储的 key，并且对应的 entry 的 p 值不为 expunged，也就是没被删除时，直接更新对应的 entry 即可。</li>
<li>如果第一步没有成功，要么 read 中没有这个 key，要么 key 被标记为删除。则先加锁，再进行后续的操作。</li>
<li>再次在 read 中查找是否存在这个 key，也就是 double check 双检查一下，这是 lock-free 编程的常见套路。如果 read 中存在该 key，但 <code>p == expunged</code>，说明 <code>m.dirty != nil</code>（<code>m.dirty</code> 是被初始化过的）并且 <code>m.dirty</code> 中不存在该 key 值（因为已经被删除了，dirty 中的删除直接就删除了；read 中的删除，会先标记为 nil，<code>read-&gt;dirty</code> 重塑时再标记为 <code>expunged</code>），此时👇
<ol>
<li>将 p 的状态由 <code>expunged</code> 更改为 <code>nil</code></li>
<li>dirty map 插入 key。然后，直接更新对应的 value</li>
</ol>
</li>
<li>如果 read 中没有此 key，那就查看 dirty 中是否有此 key，如果有，则直接更新对应的 value，这时 read 中还是没有此 key。</li>
<li>最后一步，如果 read 和 dirty 中都不存在该 key，则👇
<ol>
<li>如果 <code>dirty</code> 为空，则需要创建 <code>dirty</code>，并从 <code>read</code> 中拷贝未被删除的元素</li>
<li>更新 <code>amended</code> 字段为 true，标识 dirty map 中存在 read map 中没有的 <code>key</code></li>
<li>将 <code>k-v</code> 写入 dirty map 中，<code>read.m</code> 不变。最后，更新此 key 对应的 <code>value</code>。</li>
</ol>
</li>
</ol>
<p><strong>为什么 read 中存在 key，但是 <code>p == expunged</code> 时需要把 p 的状态由 <code>expunged</code> 更改为 <code>nil</code></strong> ❓</p>
<p>expunged 的意义是在删除操作后，键的对应值被标记为 expunged，而不是简单地设置为 nil。这样做的好处是，nil 值可能是键本身的有效值，因此无法区分键已被删除和键对应的值为 nil 两种情况。通过使用 expunged 标记，sync.Map 可以清楚地区分键被删除和键对应的值为 nil。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if e.unexpungeLocked() {
</span></span><span class="line"><span class="cl">      // The entry was previously expunged, which implies that there is a
</span></span><span class="line"><span class="cl">      // non-nil dirty map and this entry is not in it.
</span></span><span class="line"><span class="cl">      m.dirty[key] = e
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  e.storeLocked(&amp;value)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// storeLocked unconditionally stores a value to the entry.
</span></span><span class="line"><span class="cl">//
</span></span><span class="line"><span class="cl">// The entry must be known not to be expunged.
</span></span><span class="line"><span class="cl">func (e *entry) storeLocked(i *any) {
</span></span><span class="line"><span class="cl">	atomic.StorePointer(&amp;e.p, unsafe.Pointer(i))
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Store 可能会在某种情况下（初始化或者 <code>m.dirty</code> 刚被提升后，此时 <code>m.read</code> 中的数据和 <code>m.dirty</code> 中的相等，readOnly 中的 <code>amended</code> 为 <code>false</code>，也就是说可能存在一个 key，read 中找不到 dirty 中也找不到）从 <code>m.read</code> 中复制数据，如果这个时候 <code>m.read</code> 中数据量非常大，可能会影响性能。</p>
<p>综上，sync.Map 类型<strong>不适合写多的场景</strong>，读多写少是比较好的。若有大数据量的场景，则需要考虑 read 复制数据时的偶然性能抖动是否能够接受。</p>
<h2 id="load查找过程" class="headerLink">
    <a href="#load%e6%9f%a5%e6%89%be%e8%bf%87%e7%a8%8b" class="header-mark"></a>Load查找过程</h2><p>sync.Map 类型本质上是有两个 map。一个叫 read、一个叫 dirty，长的也差不多👇</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221204/301dd5df668c43c08845983b106b0fc4.png" title="sync.map" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221204/301dd5df668c43c08845983b106b0fc4.png" data-sub-html="<h2>sync.map</h2><p>sync.map</p>">
        
    </a><figcaption class="image-caption">sync.map</figcaption>
    </figure></p>
<p>当从 sync.Map 类型中读取数据时，其会先查看 read 中是否包含所需的元素：</p>
<ul>
<li>若有，则通过 atomic 原子操作读取数据并返回。</li>
<li>若无，则会判断 read.readOnly 中的 amended 属性，他会告诉程序，dirty 是否包含 <code>read.readOnly.m</code> 中没有的数据；如果存在，也就是 amended 为 true，将会进 一步到 dirty 中查找数据。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Map) Load(key any) (value any, ok bool) {
</span></span><span class="line"><span class="cl">	// 1.首先从 m.read 中得到只读 readOnly,从它的 map 中查找，不需要加锁
</span></span><span class="line"><span class="cl">	read, _ := m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl">	e, ok := read.m[key]
</span></span><span class="line"><span class="cl">	// 2. 如果没找到，并且 m.dirty 中有新数据，需要从 m.dirty 查找，这个时候需要加锁
</span></span><span class="line"><span class="cl">	if !ok &amp;&amp; read.amended {
</span></span><span class="line"><span class="cl">		m.mu.Lock()
</span></span><span class="line"><span class="cl">		// 双检查，避免加锁的时候 m.dirty 提升为 m.read,这个时候 m.read 可能被替换了。
</span></span><span class="line"><span class="cl">		read, _ = m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl">		e, ok = read.m[key]
</span></span><span class="line"><span class="cl">		// 如果m.read中还是不存在，并且m.dirty中有新数据
</span></span><span class="line"><span class="cl">		if !ok &amp;&amp; read.amended {
</span></span><span class="line"><span class="cl">			// 从m.dirty查找
</span></span><span class="line"><span class="cl">			e, ok = m.dirty[key]
</span></span><span class="line"><span class="cl">			// 不管 m.dirty 中存不存在，都将 misses 计数加一
</span></span><span class="line"><span class="cl">			// missLocked()中满足条件后就会提升 m.dirty
</span></span><span class="line"><span class="cl">			m.missLocked()
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		m.mu.Unlock()
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	if !ok {
</span></span><span class="line"><span class="cl">		return nil, false
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	return e.load()
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>处理路径分为 fast path 和 slow path，整体流程如下：</p>
<ol>
<li>首先是 fast path，直接在 read 中找，如果找到了直接调用 entry 的 load 方法，取出其中的值。</li>
<li>如果 read 中没有这个 key，且 amended 为 false，说明 dirty 为空，那直接返回空和 false。</li>
<li>如果 read 中没有这个 key，且 amended 为 true，说明 dirty 中可能存在我们要找的 key。要先上锁，再尝试去 dirty 中查找。在这之前，仍然有一个 double check 的操作。若还是没有在 read 中找到，那么就从 dirty 中找。不管 dirty 中有没有找到，都要 “记一笔”，因为在 dirty 被提升为 read 之前，都会进入这条路径</li>
</ol>
<p>那么 <code>m.dirty</code> 是如何被提升的❓ <code>missLocked</code> 方法中可能会将 <code>m.dirty</code> 提升。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Map) missLocked() {
</span></span><span class="line"><span class="cl">	m.misses++ // 不管在 dirty 中没有读到，miss 都执行 ++ 操作
</span></span><span class="line"><span class="cl">	if m.misses &lt; len(m.dirty) {
</span></span><span class="line"><span class="cl">		return
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// 如果 miss 的值 &gt;= len(dirty)，将 dirty 赋给 read, dirty 和 miss 重新初始化
</span></span><span class="line"><span class="cl">	// 此时 dirty 就为空了，说明从 dirty 全部过渡到了 read, 此时 read 是全量的
</span></span><span class="line"><span class="cl">	m.read.Store(readOnly{m: m.dirty})
</span></span><span class="line"><span class="cl">	m.dirty = nil
</span></span><span class="line"><span class="cl">	m.misses = 0
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>直接将 misses 的值加 1，表示一次未命中，如果 misses 值小于 <code>m.dirty</code> 的长度，就直接返回。否则，将 <code>m.dirty</code> 晋升为 read，并清空 dirty，清空 misses 计数值，并且 <code>m.read.amended</code> 为 <code>false</code>。这样，之前一段时间新加入的 key 都会进入到 read 中，从而能够提升 read 的命中率。</p>
<p>再来看下 entry 的 load 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (e *entry) load() (value any, ok bool) {
</span></span><span class="line"><span class="cl">	p := atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">	if p == nil || p == expunged {
</span></span><span class="line"><span class="cl">		return nil, false
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	return *(*any)(p), true
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于 nil 和 expunged 状态的 entry，直接返回 <code>ok=false</code>；否则，将 p 转成 <code>any</code> 返回。</p>
<p>sync.Map 的读操作性能如此之高的原因，就在于存在 read 这一巧妙的设计，其作为一个缓存层，提供了<strong><ruby>快路径<rt>fast path</rt></ruby></strong>的查找。</p>
<h2 id="delete删除过程" class="headerLink">
    <a href="#delete%e5%88%a0%e9%99%a4%e8%bf%87%e7%a8%8b" class="header-mark"></a>Delete删除过程</h2><p>写入过程，理论上和删除不会差太远。怎么 sync.Map 类型的删除的性能似乎还行，那这里面到底是如何实现的呢❓</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Map) Delete(key any) {
</span></span><span class="line"><span class="cl">	read, _ := m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl">	e, ok := read.m[key]
</span></span><span class="line"><span class="cl">	// 如果 read 中没有这个 key，且 dirty map 不为空
</span></span><span class="line"><span class="cl">	if !ok &amp;&amp; read.amended {
</span></span><span class="line"><span class="cl">		m.mu.Lock()
</span></span><span class="line"><span class="cl">		read, _ = m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl">		e, ok = read.m[key]
</span></span><span class="line"><span class="cl">		if !ok &amp;&amp; read.amended {
</span></span><span class="line"><span class="cl">			delete(m.dirty, key) // 直接从 dirty 中删除这个 key
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		m.mu.Unlock()
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	if ok {
</span></span><span class="line"><span class="cl">		e.delete() // 如果在 read 中找到了这个 key，将 p 置为 nil
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>第一种情况：可以看到，先从 read 里查是否有这个 key，如果有则执行 <code>e.delete</code> 方法，将 p 置为 nil，这样 read 和 dirty 都能看到这个变化，因为它们指向的是同一块内存地址。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221205/3c105d85e5c24fecb51e45bc3a184cfe.png" title="数据结构" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221205/3c105d85e5c24fecb51e45bc3a184cfe.png" data-sub-html="<h2>数据结构</h2><p>数据结构</p>">
        
    </a><figcaption class="image-caption">数据结构</figcaption>
    </figure></p>
<p>以下是<code>entry.delete</code>方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (e *entry) delete() (hadValue bool) {
</span></span><span class="line"><span class="cl">	for {
</span></span><span class="line"><span class="cl">		p := atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">		if p == nil || p == expunged {
</span></span><span class="line"><span class="cl">			return false
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) {
</span></span><span class="line"><span class="cl">			return true
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>它真正做的事情是将正常状态（指向一个 any）的 p 设置成 nil。没有设置成 expunged 的原因是，当 p 为 expunged 时，表示它已经不在 dirty 中了，这是 p 的状态决定的，在 <code>tryExpungeLocked</code> 函数中，会将 nil 原子地设置成 expunged。</p>
<p><code>tryExpungeLocked</code> 是在新创建 dirty 时调用的，会将已被删除的 <code>entry.p</code> 从 nil 改成 expunged，这个 entry 就不会写入 dirty 了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (e *entry) tryExpungeLocked() (isExpunged bool) {
</span></span><span class="line"><span class="cl">	p := atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">	for p == nil {
</span></span><span class="line"><span class="cl">		// 如果原来是 nil，说明原 key 已被删除，则将其转为 expunged。
</span></span><span class="line"><span class="cl">		if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) {
</span></span><span class="line"><span class="cl">			return true
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		p = atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	return p == expunged
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>第二种情况：如果没在 read 中找到这个 key，并且 dirty 不为空，那么就要操作 dirty 了，操作之前，还是要先上锁。然后进行 double check，如果仍然没有在 read 里找到此 key，则从 dirty 中删掉这个 key。</p>
<p>注意到如果 key 同时存在于 read 和 dirty 中时，删除只是做了一个标记，将 p 置为 nil；而如果仅在 dirty 中含有这个 key 时，会直接删除这个 key。原因在于，若两者都存在这个 key，仅做标记删除，可以在下次查找这个 key 时，命中 read，提升效率。若只有在 dirty 中存在时，read 起不到 “缓存” 的作用，直接删除。</p>
<h2 id="dirty和read互转分别在什么样的时机下进行" class="headerLink">
    <a href="#dirty%e5%92%8cread%e4%ba%92%e8%bd%ac%e5%88%86%e5%88%ab%e5%9c%a8%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84%e6%97%b6%e6%9c%ba%e4%b8%8b%e8%bf%9b%e8%a1%8c" class="header-mark"></a>dirty和read互转，分别在什么样的时机下进行</h2><ul>
<li>
<p><code>dirty-&gt;read</code>：随着 load 的 miss 不断自增，达到阈值（<code>m.misses &gt;= len(m.dirty)</code>）后触发升级转储。</p>
</li>
<li>
<p><code>read-&gt;dirty</code>：当有 read 中不存在的新 key 需要增加，且 read 和 dirty 一致的时候，触发重塑，且 <code>read.amended</code> 设置为 true，然后再在 dirty 中新增。重塑的过程，会将 nil 状态的 entry，全部转换为 expunged 状态中，同时将非 expunged 的 entry 浅拷贝到 dirty 中，这样可以避免 read 的 key 无限的膨胀（存在大量逻辑删除的 key）。最终，在 dirty 再次升级为 read 的时候，这些逻辑删除的 key 就可以一次性丢弃释放（因为是直接覆盖上去）。</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if !read.amended {
</span></span><span class="line"><span class="cl">   // We&#39;re adding the first new key to the dirty map.
</span></span><span class="line"><span class="cl">   // Make sure it is allocated and mark the read-only map as incomplete.
</span></span><span class="line"><span class="cl">   m.dirtyLocked()
</span></span><span class="line"><span class="cl">   m.read.Store(readOnly{m: read.m, amended: true})
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221025/e8837d7eda904db586f5e78b23a69ef2.png" title="read-&amp;gt;dirty" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221025/e8837d7eda904db586f5e78b23a69ef2.png" data-sub-html="<h2>read-&gt;dirty</h2><p>read-&amp;gt;dirty</p>">
        
    </a><figcaption class="image-caption">read->dirty</figcaption>
    </figure></p>
<h2 id="read从何而来存在的意义是什么" class="headerLink">
    <a href="#read%e4%bb%8e%e4%bd%95%e8%80%8c%e6%9d%a5%e5%ad%98%e5%9c%a8%e7%9a%84%e6%84%8f%e4%b9%89%e6%98%af%e4%bb%80%e4%b9%88" class="header-mark"></a>read从何而来，存在的意义是什么</h2><ul>
<li>
<p>read 是由 dirty 升级而来，是利用了 <code>atomic.Store</code> 一次性覆盖，而不是一点点的 set 操作出来的。所以，read 更像是一个快照，read 中 key 的集合不能被改变（注意，这里说的 read 的 key 不可改变，不代表指定的 key 的 value 不可改变，value 是可以通过原子 <code>CAS</code> 来进行更改的），所以其中的键的集合有时候可能是不全的。</p>
</li>
<li>
<p>脏字典中的键值对集合总是完全的，但是其中<strong>不会包含</strong> expunged 的键值对。</p>
</li>
<li>
<p>read 的存在价值，在于加速读性能（通过原子操作避免了锁）。</p>
</li>
</ul>
<h2 id="dirty什么时候是nil" class="headerLink">
    <a href="#dirty%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e6%98%afnil" class="header-mark"></a>dirty什么时候是nil</h2><p>dirty 数据提升为 read 时 <code>m.dirty</code> 会置为 nil。此时，<code>m.read</code> 和 <code>m.dirty</code> 相等，<code>m.amended</code> 为 false，也就是说，read 中找不到的数据，dirty 中同样找不到。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">amended bool // true if the dirty map contains some key not in m.
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Map) missLocked() {
</span></span><span class="line"><span class="cl">	m.misses++
</span></span><span class="line"><span class="cl">	if m.misses &lt; len(m.dirty) {
</span></span><span class="line"><span class="cl">		return
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	m.read.Store(readOnly{m: m.dirty})
</span></span><span class="line"><span class="cl">	m.dirty = nil
</span></span><span class="line"><span class="cl">	m.misses = 0
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="删除时-ep-设置成了-nil-还是-expunged" class="headerLink">
    <a href="#%e5%88%a0%e9%99%a4%e6%97%b6-ep-%e8%ae%be%e7%bd%ae%e6%88%90%e4%ba%86-nil-%e8%bf%98%e6%98%af-expunged" class="header-mark"></a>删除时 e.p 设置成了 nil 还是 expunged</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Map) Delete(key any) {
</span></span><span class="line"><span class="cl">	m.LoadAndDelete(key)
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func (m *Map) LoadAndDelete(key any) (value any, loaded bool) {
</span></span><span class="line"><span class="cl">	read, _ := m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl">	e, ok := read.m[key]
</span></span><span class="line"><span class="cl">	// 如果 read 中不存在这个 key 并且 dirty map 中存在这个 key
</span></span><span class="line"><span class="cl">	if !ok &amp;&amp; read.amended {
</span></span><span class="line"><span class="cl">		m.mu.Lock()
</span></span><span class="line"><span class="cl">		read, _ = m.read.Load().(readOnly)
</span></span><span class="line"><span class="cl">		e, ok = read.m[key]
</span></span><span class="line"><span class="cl">		if !ok &amp;&amp; read.amended {
</span></span><span class="line"><span class="cl">			e, ok = m.dirty[key]
</span></span><span class="line"><span class="cl">			delete(m.dirty, key) // 直接删除 dirty 中的 key，不管 dirty 中存不存在
</span></span><span class="line"><span class="cl">			// Regardless of whether the entry was present, record a miss: this key
</span></span><span class="line"><span class="cl">			// will take the slow path until the dirty map is promoted to the read
</span></span><span class="line"><span class="cl">			// map.
</span></span><span class="line"><span class="cl">			m.missLocked()
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		m.mu.Unlock()
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// read 中存在或是 dirty 中存在都会走到这里,执行 e.delete()
</span></span><span class="line"><span class="cl">	if ok {
</span></span><span class="line"><span class="cl">		return e.delete()
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	return nil, false
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func (e *entry) delete() (value any, ok bool) {
</span></span><span class="line"><span class="cl">	for {
</span></span><span class="line"><span class="cl">		p := atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">		if p == nil || p == expunged {
</span></span><span class="line"><span class="cl">			return nil, false
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		// 把 entry 中的 p 转成 nil，表示已经删除
</span></span><span class="line"><span class="cl">		if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) {
</span></span><span class="line"><span class="cl">			// *(*any)(p) 的作用是将指针 p 指向的数据转换为 any 类型，并且解引用该指针，以便访问 any 类型的值。
</span></span><span class="line"><span class="cl">			return *(*any)(p), true
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>由源码可知，不管 key 是在 read 中还是 dirty 中，最后都调用了 <code>e.delete()</code> 方法，将 e.p 设置为 nil。</p>
<h2 id="什么时候-ep-由-nil-变成-expunged" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99-ep-%e7%94%b1-nil-%e5%8f%98%e6%88%90-expunged" class="header-mark"></a>什么时候 e.p 由 nil 变成 expunged</h2><ul>
<li><code>read-&gt;dirty</code> 重塑的时候，此时 read 中仍然是 nil 的会变成 expunged，表示这部分 key 等待被最终丢弃（expunged 是最终态，等待被丢弃，除非又出现了重新 Store 的情况）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 判断 e.p 是不是 expunged, 如果是 e.p 是 nil 则转为 expunged
</span></span><span class="line"><span class="cl">func (e *entry) tryExpungeLocked() (isExpunged bool) {
</span></span><span class="line"><span class="cl">	p := atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">	for p == nil {
</span></span><span class="line"><span class="cl">		// 将 e.p 的 nil 转成 expunged
</span></span><span class="line"><span class="cl">		if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) {
</span></span><span class="line"><span class="cl">			return true
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		p = atomic.LoadPointer(&amp;e.p)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	return p == expunged
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>最终丢弃的时机就是 <code>dirty-&gt;read</code> 升级的时候，dirty 的直接粗暴覆盖，会使得 read 中的所有成员都被丢弃，包括 expunged。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Map) missLocked() {
</span></span><span class="line"><span class="cl">	m.misses++ // 不管在 dirty 中没有读到，miss 都执行 ++ 操作
</span></span><span class="line"><span class="cl">	if m.misses &lt; len(m.dirty) {
</span></span><span class="line"><span class="cl">		return
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	// 如果 miss 的值 &gt;= len(dirty)，将 dirty 赋给 read, dirty 和 miss 重新初始化
</span></span><span class="line"><span class="cl">	// 此时 dirty 就为空了，说明从 dirty 全部过渡到了 read, 此时 read 是全量的
</span></span><span class="line"><span class="cl">	m.read.Store(readOnly{m: m.dirty})
</span></span><span class="line"><span class="cl">	m.dirty = nil
</span></span><span class="line"><span class="cl">	m.misses = 0
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="既然-nil-表示标记删除expunged-的意义是什么" class="headerLink">
    <a href="#%e6%97%a2%e7%84%b6-nil-%e8%a1%a8%e7%a4%ba%e6%a0%87%e8%ae%b0%e5%88%a0%e9%99%a4expunged-%e7%9a%84%e6%84%8f%e4%b9%89%e6%98%af%e4%bb%80%e4%b9%88" class="header-mark"></a>既然 nil 表示标记删除，expunged 的意义是什么</h2><p><code>expunged</code> 的意义是在删除操作后，键对应值被标记为 <code>expunged</code>，而不是简单地设置为 <code>nil</code>。这样做的好处是，<code>nil</code> 值可能是键本身的有效值，因此无法区分键已被删除和键对应的值为 <code>nil</code> 两种情况。通过使用 <code>expunged</code> 标记，<code>sync.Map</code> 可以清楚地区分键被删除和键对应的值为 <code>nil</code>。</p>
<p>具体来说，当执行删除操作时，<code>sync.Map</code> 将键对应的值设置为一个特殊的占位符 <code>expunged</code>，表示该键已被删除。在后续的操作中，通过检查值是否等于 <code>expunged</code>，可以判断键是否存在。</p>
<p>这种设计有以下好处：</p>
<ol>
<li>
<p>避免了 <code>nil</code> 值可能带来的歧义：<code>nil</code> 值可能是键的有效值，因此不能简单地依靠 <code>nil</code> 值来判断键是否存在或已被删除。</p>
</li>
<li>
<p>提高了删除操作的效率：直接将值标记为 <code>expunged</code>，而不是删除键值对，可以避免重新分配内存或进行其他复杂的操作，从而提高了删除操作的效率。</p>
</li>
<li>
<p>保持了并发安全性：通过将键的对应值设置为 <code>expunged</code>，<code>sync.Map</code> 在并发环境中仍然能够保持正确的状态和操作一致性。</p>
</li>
</ol>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://cloud.tencent.com/developer/article/2022098" target="_blank" rel="noopener noreferrer">不得不知道的Golang之sync.Map解读！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;mid=2247489164&amp;idx=1&amp;sn=e56e5c9836cda40f3c95a39e2ba57dde" target="_blank" rel="noopener noreferrer">一口气搞懂 Go sync.map 所有知识点</a></li>
<li><a href="https://colobu.com/2017/07/11/dive-into-sync-Map/" target="_blank" rel="noopener noreferrer">Go 1.9 sync.Map揭秘</a></li>
<li><a href="https://qcrao.com/post/dive-into-go-sync-map/" target="_blank" rel="noopener noreferrer">深度解密 Go 语言之 sync.map</a></li>
</ul>
]]></description>
</item><item>
    <title>Go GC 垃圾回收</title>
    <link>https://www.xiaobinqt.cn/go-gc/</link>
    <pubDate>Wed, 06 Apr 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/go-gc/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221118/74f00ad9b278426887ea4348fd7a0e1c.png" referrerpolicy="no-referrer">
            </div><p>垃圾回收（Garbage Collection，GC）是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC 过程中无需程序员手动执行。</p>
<p>GC 机制在现代很多编程语言都支持，GC 能力的性能与优劣也是不同语言之间对比度指标之一。</p>
<h2 id="gc-变革" class="headerLink">
    <a href="#gc-%e5%8f%98%e9%9d%a9" class="header-mark"></a>GC 变革</h2><p>// TODO</p>
<h2 id="堆和栈" class="headerLink">
    <a href="#%e5%a0%86%e5%92%8c%e6%a0%88" class="header-mark"></a>堆和栈</h2><p><strong>栈</strong>：由操作系统自动分配释放，存放函数的参数值，局部变量的值等。</p>
<p><strong>堆</strong>：一般由程序员分配和释放，若程序员不释放，程序结束时可能由 OS 回收。</p>
<p>栈使用的是一级缓存，他们通常都是被调用时处于存储空间中，<strong>调用完毕立即释放</strong>。</p>
<p>堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定，但并不是一旦成为孤儿对象就能被回收。</p>
<p>申请到栈内存好处：函数返回直接释放，不会引起垃圾回收，对性能没有影响。</p>
<h2 id="标记清除算法" class="headerLink">
    <a href="#%e6%a0%87%e8%ae%b0%e6%b8%85%e9%99%a4%e7%ae%97%e6%b3%95" class="header-mark"></a>标记清除算法</h2><p>Go V1.3 之前使用普通的<strong><ruby>标记-清除<rt>mark and sweep</rt></ruby></strong>算法，主要有两个主要的步骤：</p>
<ol>
<li>
<p>标记(Mark phase)，找出<strong>不可达</strong>的对象，然后做上标记。</p>
</li>
<li>
<p>清除(Sweep phase)，回收标记好的对象。</p>
</li>
</ol>
<h3 id="第一步" class="headerLink">
    <a href="#%e7%ac%ac%e4%b8%80%e6%ad%a5" class="header-mark"></a>第一步</h3><p><strong>暂停</strong>程序业务逻辑， 分类出可达和不可达的对象，然后做上标记。</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/692b1bd1669647518c96b6530c01b8a3.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/692b1bd1669647518c96b6530c01b8a3.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/692b1bd1669647518c96b6530c01b8a3.png" data-sub-html="<h2>程序与对象的可达关系</h2>">
        
    </a><figcaption class="image-caption">程序与对象的可达关系</figcaption>
    </figure>
<p>👆图中表示是程序与对象的可达关系，目前<strong>程序的可达</strong>对象有对象 1-2-3，对象 4-7 等五个对象。</p>
<h3 id="第二步" class="headerLink">
    <a href="#%e7%ac%ac%e4%ba%8c%e6%ad%a5" class="header-mark"></a>第二步</h3><p>开始标记，程序找出它所有可达的对象，并做上标记👇。</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/00d8aba1d229497c9cc907b359010178.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/00d8aba1d229497c9cc907b359010178.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/00d8aba1d229497c9cc907b359010178.png" data-sub-html="<h2>找出可达对象</h2>">
        
    </a><figcaption class="image-caption">找出可达对象</figcaption>
    </figure>
<p>对象 1-2-3 、对象 4-7 等五个对象被做上标记。</p>
<h3 id="第三步" class="headerLink">
    <a href="#%e7%ac%ac%e4%b8%89%e6%ad%a5" class="header-mark"></a>第三步</h3><p>标记完了之后，然后开始清除未标记的对象。</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/1a1ebfbd5c9b4f4183cb5bca704311e5.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/1a1ebfbd5c9b4f4183cb5bca704311e5.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/1a1ebfbd5c9b4f4183cb5bca704311e5.png" data-sub-html="<h2>清除对象</h2>">
        
    </a><figcaption class="image-caption">清除对象</figcaption>
    </figure>
<p>对象 5，6 不可达，被 GC 清除。</p>
<p>操作简单，但是 mark and sweep 算法在执行的时候，需要程序暂停！即 <strong><ruby>STW<rt>stop the world</rt></ruby></strong>，STW 的过程中，CPU 不执行用户代码，全部用于垃圾回收，这个过程的影响很大，所以 STW 也是一些回收机制最大的难题和希望优化的点。</p>
<p><strong>在执行第三步的这段时间，程序会暂定停止任何工作，卡在那等待回收执行完毕</strong>。</p>
<h3 id="第四步" class="headerLink">
    <a href="#%e7%ac%ac%e5%9b%9b%e6%ad%a5" class="header-mark"></a>第四步</h3><p>停止暂停，让程序继续执行。然后循环重复这个过程，直到 process 程序生命周期结束。</p>
<h3 id="缺点与优化" class="headerLink">
    <a href="#%e7%bc%ba%e7%82%b9%e4%b8%8e%e4%bc%98%e5%8c%96" class="header-mark"></a>缺点与优化</h3><p>标记清除算法明了，过程鲜明干脆，但是也有非常严重的问题，就是 STW，让程序暂停，程序出现卡顿。</p>
<p>Go V1.3 版本之前就是用这种方式来实施的。执行 GC 的基本流程就是首先启动 STW 暂停，然后执行标记，再执行数据回收，最后停止 STW ，如下图👇</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/7913f2957c4f4b5c9ba01013cb0c44fa.png" title="STW" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/7913f2957c4f4b5c9ba01013cb0c44fa.png" data-sub-html="<h2>STW</h2><p>STW</p>">
        
    </a><figcaption class="image-caption">STW</figcaption>
    </figure></p>
<p>从👆来看，全部的 GC 时间都是包裹在 STW 范围之内的，这样貌似程序暂停的时间过长，影响程序的运行性能。所以Go V1.3 做了简单的优化，将 STW 的步骤提前，减少 STW 暂停的时间范围
👇</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/2b64ccd849624544ae495ed36236a780.png" title="STW优化" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/2b64ccd849624544ae495ed36236a780.png" data-sub-html="<h2>STW优化</h2><p>STW优化</p>">
        
    </a><figcaption class="image-caption">STW优化</figcaption>
    </figure></p>
<p>主要是将 STW 的步骤提前了一步，因为在 Sweep 清除的时候，可以不需要 STW 停止，因为这些对象已经是不可达对象了，不会出现回收写冲突等问题，<strong>清除操作和用户逻辑可以并发</strong>。</p>
<p>但是无论怎么优化，Go v1.3 都面临这个一个重要问题，就是 mark-and-sweep 算法会暂停整个程序 。</p>
<h2 id="有stw的三色标记法" class="headerLink">
    <a href="#%e6%9c%89stw%e7%9a%84%e4%b8%89%e8%89%b2%e6%a0%87%e8%ae%b0%e6%b3%95" class="header-mark"></a>有STW的三色标记法</h2><p>Go 中的垃圾回收主要应用三色标记法，GC 过程和其他用户 goroutine 可并发运行，但需要一定时间的 STW。</p>
<p>所谓三色标记法实际上就是通过<strong>三个阶段的标记</strong>来确定需要清除的对象有哪些。</p>
<h3 id="第一步-1" class="headerLink">
    <a href="#%e7%ac%ac%e4%b8%80%e6%ad%a5-1" class="header-mark"></a>第一步</h3><p>每次新创建的对象，默认的颜色都是标记为 “白色”👇</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/3b601d5fc23247b4b05de52b7fb2ed52.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/3b601d5fc23247b4b05de52b7fb2ed52.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/3b601d5fc23247b4b05de52b7fb2ed52.png" data-sub-html="<h2>白色对象</h2>">
        
    </a><figcaption class="image-caption">白色对象</figcaption>
    </figure>
<p>上图所示，我们的程序可抵达的内存对象关系如左图所示，右边的标记表是用来记录目前每个对象的标记颜色分类。这里所谓 “程序”，是一些<strong>对象的根节点集合</strong>。如果我们将 “程序” 展开，会得到类似如下的表现形式：</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/25f6f7613a894569a426c70c6c8c2c10.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/25f6f7613a894569a426c70c6c8c2c10.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/25f6f7613a894569a426c70c6c8c2c10.png" data-sub-html="<h2>程序的根节点集合展开</h2>">
        
    </a><figcaption class="image-caption">程序的根节点集合展开</figcaption>
    </figure>
<h3 id="第二步-1" class="headerLink">
    <a href="#%e7%ac%ac%e4%ba%8c%e6%ad%a5-1" class="header-mark"></a>第二步</h3><p>每次 GC 回收开始， 会从根节点开始遍历所有对象，把遍历到的对象从白色集合放入 “灰色” 集合：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/c982dc0455cf437bace1b65454597995.png" title="遍历根对象" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/c982dc0455cf437bace1b65454597995.png" data-sub-html="<h2>遍历根对象</h2><p>遍历根对象</p>">
        
    </a><figcaption class="image-caption">遍历根对象</figcaption>
    </figure></p>
<p>本次遍历是<strong>一次遍历，非递归形式</strong>，是从程序初次可抵达的对象遍历一层，如上图所示，当前可抵达的对象是对象1和对象4，那么自然本轮遍历结束，对象1和对象4就会被标记为灰色，灰色标记表就会多出这两个对象。</p>
<h3 id="第三步-1" class="headerLink">
    <a href="#%e7%ac%ac%e4%b8%89%e6%ad%a5-1" class="header-mark"></a>第三步</h3><p>遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/f381a66d7e4944c998f7c893629accd4.png" title="遍历_2" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/f381a66d7e4944c998f7c893629accd4.png" data-sub-html="<h2>遍历_2</h2><p>遍历_2</p>">
        
    </a><figcaption class="image-caption">遍历_2</figcaption>
    </figure></p>
<p>这一次遍历是<strong>只扫描灰色对象</strong>，将灰色对象的第一层遍历可抵达的对象由白色变为灰色，如：对象2、对象7。 而之前的灰色对象1 和对象4 则会被标记为黑色，同时由灰色标记表移动到黑色标记表中。</p>
<h3 id="第四步-1" class="headerLink">
    <a href="#%e7%ac%ac%e5%9b%9b%e6%ad%a5-1" class="header-mark"></a>第四步</h3><p>重复第三步， 直到灰色中无任何对象，如图👇所示：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/3a751806772e445d813bee6344ab81d1.png" title="遍历_3" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/3a751806772e445d813bee6344ab81d1.png" data-sub-html="<h2>遍历_3</h2><p>遍历_3</p>">
        
    </a><figcaption class="image-caption">遍历_3</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/07f715dda56a4b6ab242367ce0e15e4b.png" title="遍历_4" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/07f715dda56a4b6ab242367ce0e15e4b.png" data-sub-html="<h2>遍历_4</h2><p>遍历_4</p>">
        
    </a><figcaption class="image-caption">遍历_4</figcaption>
    </figure></p>
<p>当我们全部的可达对象都遍历完后，<strong>灰色标记表将不再存在灰色对象</strong>。</p>
<p>目前全部内存的数据只有两种颜色，黑色和白色。那么，黑色对象就是我们程序逻辑可达（需要的）对象，这些数据是目前支撑程序正常业务运行的，是合法的有用数据，不可删除。白色的对象是全部不可达对象，目前程序逻辑并不依赖他们，那么白色对象就是内存中目前的垃圾数据，需要被清除。</p>
<h3 id="第五步" class="headerLink">
    <a href="#%e7%ac%ac%e4%ba%94%e6%ad%a5" class="header-mark"></a>第五步</h3><p>回收所有的白色标记表的对象，也就是回收垃圾，如图所示👇</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/f271ee96ace2416c8eaf808d3f45b8f0.png" title="GC 回收" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/f271ee96ace2416c8eaf808d3f45b8f0.png" data-sub-html="<h2>GC 回收</h2><p>GC 回收</p>">
        
    </a><figcaption class="image-caption">GC 回收</figcaption>
    </figure></p>
<p>将全部的白色对象进行删除回收，剩下的就是全部依赖的黑色对象。</p>
<p>这里面可能会有很多并发流程均会被扫描，执行并发流程的内存可能相互依赖，为了在 GC 过程中保证数据的安全，<strong>在开始三色标记之前就会加上 STW，在扫描确定黑白对象之后再放开 STW</strong>。但是很明显这样的 GC 扫描的性能实在是太低了。</p>
<p>所以现在的三色标记法还是会 STW。</p>
<h2 id="没有stw的三色标记法" class="headerLink">
    <a href="#%e6%b2%a1%e6%9c%89stw%e7%9a%84%e4%b8%89%e8%89%b2%e6%a0%87%e8%ae%b0%e6%b3%95" class="header-mark"></a>没有STW的三色标记法</h2><p>如果没有 STW，那么也就不会再存在性能上的问题，那么假设如果三色标记法不加入 STW 会发生什么事情❓</p>
<p>还是基于上述的三色标记法来分析，他是一定要依赖 STW 的，因为如果不暂停程序，程序的逻辑可能会改变对象的引用关系，这种动作如果在标记阶段做了修改，会影响标记结果的正确性。</p>
<p>来看看一个场景，如果三色标记法，标记过程不使用 STW 将会发生什么事情❓</p>
<p>我们把初始状态设置为已经经历了第一轮扫描，目前黑色的有对象 1 和对象 4，灰色的有对象 2 和对象 7，其他的为白色对象，且对象 2 是通过指针 p 指向对象 3 的，如下图所示。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/df4917c4b48d4e12857a5b8552cf3815.png" title="no ST2 01" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/df4917c4b48d4e12857a5b8552cf3815.png" data-sub-html="<h2>no ST2 01</h2><p>no ST2 01</p>">
        
    </a><figcaption class="image-caption">no ST2 01</figcaption>
    </figure></p>
<p>现在如果三色标记过程不启动 STW，那么在 GC 扫描过程中，<strong>任意的对象均可能发生读写操作</strong>
，如下图所示，在还没有扫描到对象 2 的时候，已经标记为黑色的对象 4，此时创建指针 q，并且指向白色的对象 3。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/c47b38d901dc46efb2ddc7b3d01fede4.png" title="no ST2 02" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/c47b38d901dc46efb2ddc7b3d01fede4.png" data-sub-html="<h2>no ST2 02</h2><p>no ST2 02</p>">
        
    </a><figcaption class="image-caption">no ST2 02</figcaption>
    </figure></p>
<p>与此同时灰色的对象 2 将指针 p 移除，那么白色的对象 3 实则是被挂在了已经扫描完成的黑色的对象 4 下，如下图所示。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/da651f3e078847ad8ba6ca0635301978.png" title="no ST2 03" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/da651f3e078847ad8ba6ca0635301978.png" data-sub-html="<h2>no ST2 03</h2><p>no ST2 03</p>">
        
    </a><figcaption class="image-caption">no ST2 03</figcaption>
    </figure></p>
<p>然后我们正常执行三色标记的算法逻辑，将所有灰色的对象标记为黑色，那么对象 2 和对象 7 就被标记成了黑色，如下图所示。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/2a00e38c265a4370923ed6b4bf4a7435.png" title="no ST2 04" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/2a00e38c265a4370923ed6b4bf4a7435.png" data-sub-html="<h2>no ST2 04</h2><p>no ST2 04</p>">
        
    </a><figcaption class="image-caption">no ST2 04</figcaption>
    </figure></p>
<p>那么就执行了三色标记的最后一步，将所有白色对象当做垃圾进行回收，如图所示。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/512e92ad527e4ac1871abb2a8df63e75.png" title="no ST2 05" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/512e92ad527e4ac1871abb2a8df63e75.png" data-sub-html="<h2>no ST2 05</h2><p>no ST2 05</p>">
        
    </a><figcaption class="image-caption">no ST2 05</figcaption>
    </figure></p>
<p>最后我们发现，本来是对象4合法引用的对象 3，却被GC给“误杀”回收掉了。</p>
<p>可以看出，有两种情况，在三色标记法中是不希望被发生的。</p>
<ul>
<li>👉 一个白色对象被黑色对象引用 <strong>（白色被挂在黑色下）</strong></li>
<li>👉 灰色对象与它之间可达关系的白色对象遭到破坏 <strong>（灰色同时丢了该白色）</strong></li>
</ul>
<p>如果当以上两个条件同时满足时，就会出现对象丢失现象！</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/f9e8dce78c274ccfb76bb491967d8fc2.png" title="三色标记对象丢失" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/f9e8dce78c274ccfb76bb491967d8fc2.png" data-sub-html="<h2>三色标记对象丢失</h2><p>三色标记对象丢失</p>">
        
    </a><figcaption class="image-caption">三色标记对象丢失</figcaption>
    </figure></p>
<p>并且，上面所示的场景中，如果示例中的白色对象3还有很多下游对象的话，也会一并都清理掉。</p>
<p>为了防止这种现象的发生，最简单的方式就是 STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是<strong>STW的过程有明显的资源浪费，对所有的用户程序都有很大影响</strong>。</p>
<p>那么是否可以在保证对象不丢失的情况下合理的尽可能的提高 GC 效率，减少 STW 时间呢❓</p>
<p>答案是可以的，我们只要使用一种机制，尝试去破坏上面的两个必要条件就可以了。</p>
<h2 id="屏障机制" class="headerLink">
    <a href="#%e5%b1%8f%e9%9a%9c%e6%9c%ba%e5%88%b6" class="header-mark"></a>屏障机制</h2><p>如果让 GC 回收器，满足下面两种情况之一时，即可保证对象不丢失。这两种方式就是<strong>强三色不变式</strong>和<strong>弱三色不变式</strong>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/95aefcee22ae4f72a04437582362e947.png" title="强/弱三色不变式" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/95aefcee22ae4f72a04437582362e947.png" data-sub-html="<h2>强/弱三色不变式</h2><p>强/弱三色不变式</p>">
        
    </a><figcaption class="image-caption">强/弱三色不变式</figcaption>
    </figure></p>
<h3 id="强三色不变式" class="headerLink">
    <a href="#%e5%bc%ba%e4%b8%89%e8%89%b2%e4%b8%8d%e5%8f%98%e5%bc%8f" class="header-mark"></a>强三色不变式</h3><p>强三色不变式实际上是强制性的<strong>不允许黑色对象引用白色对象</strong>，这样就不会出现有白色对象被误删的情况。</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230105/9f8f0337b20c475bbf637503e68b0766.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230105/9f8f0337b20c475bbf637503e68b0766.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230105/9f8f0337b20c475bbf637503e68b0766.png" data-sub-html="<h2>强三色不变式</h2>">
        
    </a><figcaption class="image-caption">强三色不变式</figcaption>
    </figure>
<h3 id="弱三色不变式" class="headerLink">
    <a href="#%e5%bc%b1%e4%b8%89%e8%89%b2%e4%b8%8d%e5%8f%98%e5%bc%8f" class="header-mark"></a>弱三色不变式</h3><p>所有被黑色对象引用的白色对象都处于灰色保护状态。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/9766a534c5244092b12e47a8255c7dc4.png" title="弱三色不变式" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/9766a534c5244092b12e47a8255c7dc4.png" data-sub-html="<h2>弱三色不变式</h2><p>弱三色不变式</p>">
        
    </a><figcaption class="image-caption">弱三色不变式</figcaption>
    </figure></p>
<p>弱三色不变式强调，黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。这样实则是黑色对象引用白色对象，白色对象处于一个危险被删除的状态，但是由于上游灰色对象的引用，可以保护该白色对象，使其安全。</p>
<p>为了遵循上述的两个方式，GC 算法演进到两种屏障方式，分别是<strong>插入屏障</strong>和<strong>删除屏障</strong>。</p>
<h3 id="插入屏障" class="headerLink">
    <a href="#%e6%8f%92%e5%85%a5%e5%b1%8f%e9%9a%9c" class="header-mark"></a>插入屏障</h3><p>具体操作： 在 A 对象引用 B 对象的时候，B 对象被标记为灰色。<strong>将 B 挂在 A 下游，B 必须被标记为灰色</strong>。</p>
<p>满足：<strong>强三色不变式</strong>。不存在黑色对象引用白色对象的情况了， 因为<strong>白色会强制变成灰色</strong>。</p>
<p>伪代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">添加下游对象(当前下游对象slot, 新下游对象ptr) {
</span></span><span class="line"><span class="cl">  //1
</span></span><span class="line"><span class="cl">  标记灰色(新下游对象ptr)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  //2
</span></span><span class="line"><span class="cl">  当前下游对象slot = 新下游对象ptr
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>场景：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">A.添加下游对象(nil, B)   //A 之前没有下游， 新添加一个下游对象B， B被标记为灰色
</span></span><span class="line"><span class="cl">A.添加下游对象(C, B)     //A 将下游对象C 更换为B，  B被标记为灰色
</span></span></code></pre></td></tr></table>
</div>
</div><p>这段伪代码逻辑就是写屏障，但是这里有个性能损耗的地方就是每次添加好插入对象都要去判断。</p>
<p>黑色对象的内存槽有两种位置，栈和堆。 栈空间的特点是容量小，但是要求响应速度快，因为函数调用弹出频繁使用，所以<strong>插入屏障机制，在栈空间的对象操作中不使用，而仅仅使用在堆空间对象的操作中</strong>。</p>
<p>接下来，我们用几张图，来模拟一下整个详细的过程，希望能更可观的看清整体流程。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/9d76191546e44252ac8edd0fae087465.png" title="插入屏障01" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/9d76191546e44252ac8edd0fae087465.png" data-sub-html="<h2>插入屏障01</h2><p>插入屏障01</p>">
        
    </a><figcaption class="image-caption">插入屏障01</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/3d4a215e1c8347e2a6ebf416617cb2ee.png" title="插入屏障02" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/3d4a215e1c8347e2a6ebf416617cb2ee.png" data-sub-html="<h2>插入屏障02</h2><p>插入屏障02</p>">
        
    </a><figcaption class="image-caption">插入屏障02</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/53f0850d9ca746668c9a8ebf9c628ca3.png" title="插入屏障03" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/53f0850d9ca746668c9a8ebf9c628ca3.png" data-sub-html="<h2>插入屏障03</h2><p>插入屏障03</p>">
        
    </a><figcaption class="image-caption">插入屏障03</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/2b66b768590b448f857a5dba72cd7146.png" title="插入屏障04" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/2b66b768590b448f857a5dba72cd7146.png" data-sub-html="<h2>插入屏障04</h2><p>插入屏障04</p>">
        
    </a><figcaption class="image-caption">插入屏障04</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/f0a379d3fd1d45df8dd20f7a68f615e0.png" title="插入屏障05" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/f0a379d3fd1d45df8dd20f7a68f615e0.png" data-sub-html="<h2>插入屏障05</h2><p>插入屏障05</p>">
        
    </a><figcaption class="image-caption">插入屏障05</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/c55625c54be54d848fb98ccfc88a76f9.png" title="插入屏障06" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/c55625c54be54d848fb98ccfc88a76f9.png" data-sub-html="<h2>插入屏障06</h2><p>插入屏障06</p>">
        
    </a><figcaption class="image-caption">插入屏障06</figcaption>
    </figure></p>
<p>但是如果栈不添加，当全部三色标记扫描之后，栈上有可能依然存在白色对象被引用的情况（如上图的对象9）。所以要对栈重新进行三色标记扫描，但这次为了对象不丢失，<strong>要对本次标记扫描启动 STW 暂停</strong>，直到栈空间的三色标记结束。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/80c67f3febd44156b71332b19172c2ec.png" title="插入屏障07" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/80c67f3febd44156b71332b19172c2ec.png" data-sub-html="<h2>插入屏障07</h2><p>插入屏障07</p>">
        
    </a><figcaption class="image-caption">插入屏障07</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/77edaf8cc2cb4fad9283b5eedd81d2cf.png" title="插入屏障08" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/77edaf8cc2cb4fad9283b5eedd81d2cf.png" data-sub-html="<h2>插入屏障08</h2><p>插入屏障08</p>">
        
    </a><figcaption class="image-caption">插入屏障08</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/268b613c2dbd44048b5fd32667957a6e.png" title="插入屏障09" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/268b613c2dbd44048b5fd32667957a6e.png" data-sub-html="<h2>插入屏障09</h2><p>插入屏障09</p>">
        
    </a><figcaption class="image-caption">插入屏障09</figcaption>
    </figure></p>
<p>最后将栈和堆空间扫描剩余的全部白色节点清除，这次 STW 大约的时间在 10~100ms 间。这也是插入写屏障的<strong>不足</strong>，因为还是需要 STW，虽然时间很短。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/c3fe1710d579448aa8b13f84cd2cd6f0.png" title="插入屏障10" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/c3fe1710d579448aa8b13f84cd2cd6f0.png" data-sub-html="<h2>插入屏障10</h2><p>插入屏障10</p>">
        
    </a><figcaption class="image-caption">插入屏障10</figcaption>
    </figure></p>
<h3 id="删除屏障" class="headerLink">
    <a href="#%e5%88%a0%e9%99%a4%e5%b1%8f%e9%9a%9c" class="header-mark"></a>删除屏障</h3><p>具体操作：被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p>
<p>满足：<strong>弱三色不变式</strong>，保护灰色对象到白色对象的路径不会断。</p>
<p>伪代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">添加下游对象(当前下游对象slot， 新下游对象ptr) {
</span></span><span class="line"><span class="cl">  //1
</span></span><span class="line"><span class="cl">  if (当前下游对象slot是灰色 || 当前下游对象slot是白色) {
</span></span><span class="line"><span class="cl">  		标记灰色(当前下游对象slot)     //slot为被删除对象， 标记为灰色
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  //2
</span></span><span class="line"><span class="cl">  当前下游对象slot = 新下游对象ptr
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>场景：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">A.添加下游对象(B, nil)   //A对象，删除B对象的引用。 B被A删除，被标记为灰(如果B之前为白)
</span></span><span class="line"><span class="cl">A.添加下游对象(B, C)         //A对象，更换下游B变成C。 B被A删除，被标记为灰(如果B之前为白)
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来，我们用几张图，来模拟一个详细的过程，希望能够更可观的看清楚整体流程。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/3ef46111cdca45b18626a0511f9b3df5.png" title="删除屏障01" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/3ef46111cdca45b18626a0511f9b3df5.png" data-sub-html="<h2>删除屏障01</h2><p>删除屏障01</p>">
        
    </a><figcaption class="image-caption">删除屏障01</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/e08ac9cd722c45ef98d9362fa5401c48.png" title="删除屏障02" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/e08ac9cd722c45ef98d9362fa5401c48.png" data-sub-html="<h2>删除屏障02</h2><p>删除屏障02</p>">
        
    </a><figcaption class="image-caption">删除屏障02</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/a8ad362faec241848935c82e1fa7e428.png" title="删除屏障03" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/a8ad362faec241848935c82e1fa7e428.png" data-sub-html="<h2>删除屏障03</h2><p>删除屏障03</p>">
        
    </a><figcaption class="image-caption">删除屏障03</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/e230f27d981248e1b4bfb254a776c038.png" title="删除屏障04" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/e230f27d981248e1b4bfb254a776c038.png" data-sub-html="<h2>删除屏障04</h2><p>删除屏障04</p>">
        
    </a><figcaption class="image-caption">删除屏障04</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/3887ebd09e204ec9932c0cfb10fb38fa.png" title="删除屏障05" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/3887ebd09e204ec9932c0cfb10fb38fa.png" data-sub-html="<h2>删除屏障05</h2><p>删除屏障05</p>">
        
    </a><figcaption class="image-caption">删除屏障05</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/65cdf09e3d3e454487a23e3e79c424ee.png" title="删除屏障06" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/65cdf09e3d3e454487a23e3e79c424ee.png" data-sub-html="<h2>删除屏障06</h2><p>删除屏障06</p>">
        
    </a><figcaption class="image-caption">删除屏障06</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/7d6c80f3eec34796ab3c3e333642de96.png" title="删除屏障07" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220406/7d6c80f3eec34796ab3c3e333642de96.png" data-sub-html="<h2>删除屏障07</h2><p>删除屏障07</p>">
        
    </a><figcaption class="image-caption">删除屏障07</figcaption>
    </figure></p>
<p>这种方式的<strong>不足是回收精度低</strong>，一个对象即使被删除了最后一个指向它的指针也<strong>依旧可以</strong>活过这一轮，在下一轮 GC 中被清理掉。</p>
<h2 id="混合写屏障" class="headerLink">
    <a href="#%e6%b7%b7%e5%90%88%e5%86%99%e5%b1%8f%e9%9a%9c" class="header-mark"></a>混合写屏障</h2><p>插入写屏障和删除写屏障的短板：</p>
<ul>
<li>插入写屏障：结束时需要 STW 来重新扫描栈，标记栈上引用的白色对象的存活，大约需要 10-100ms。</li>
<li>删除写屏障：回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮 GC 中被清理掉。GC 开始时 STW 扫描堆栈来记录初始快照（监控对象的内存修改，判断对象是否删除），这个过程会保护开始时刻的所有存活对象。</li>
</ul>
<p>Go v1.8 版本引入了<strong><ruby>混合写屏障机制<rt>hybrid write barrier</rt></ruby></strong>，避免了对栈 re-scan 的过程，极大的减少了 STW 的时间，结合了两者的优点。</p>
<h3 id="规则" class="headerLink">
    <a href="#%e8%a7%84%e5%88%99" class="header-mark"></a>规则</h3><p>具体操作：</p>
<ol>
<li>GC 开始将栈上的对象全部扫描并标记为黑色（之后不再进行第二次重复扫描，无需 STW ）。</li>
<li><strong>GC 期间，任何在栈上创建的新对象，均为黑色</strong>。</li>
<li>被删除的对象标记为灰色。</li>
<li>被添加的对象标记为灰色。</li>
</ol>
<p>满足：变形的弱三色不变式。</p>
<p>伪代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">添加下游对象(当前下游对象slot, 新下游对象ptr) {
</span></span><span class="line"><span class="cl">  	//1
</span></span><span class="line"><span class="cl">	标记灰色(当前下游对象slot)    //只要当前下游对象被移走，就标记灰色
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  	//2
</span></span><span class="line"><span class="cl">  	标记灰色(新下游对象ptr)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  	//3
</span></span><span class="line"><span class="cl">  	当前下游对象slot = 新下游对象ptr
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>屏障技术是不在栈上应用的，因为要保证栈的运行效率。</p>
</blockquote>
<h3 id="具体场景" class="headerLink">
    <a href="#%e5%85%b7%e4%bd%93%e5%9c%ba%e6%99%af" class="header-mark"></a>具体场景</h3><p>我们用几张图，来模拟一个详细的过程，希望能够更可观的看清楚整体流程。</p>
<p>混合写屏障是 GC 的一种屏障机制，所以只是当程序执行 GC 的时候，才会触发这种机制。</p>
<p>GC开始：优先扫描栈区，将可达对象全部标记为黑</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/d7aefd0f1c7e47fb94db02096fe857d9.png" title="混合写屏障01" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/d7aefd0f1c7e47fb94db02096fe857d9.png" data-sub-html="<h2>混合写屏障01</h2><p>混合写屏障01</p>">
        
    </a><figcaption class="image-caption">混合写屏障01</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/d674041682d940189041add754694bdf.png" title="混合写屏障02" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/d674041682d940189041add754694bdf.png" data-sub-html="<h2>混合写屏障02</h2><p>混合写屏障02</p>">
        
    </a><figcaption class="image-caption">混合写屏障02</figcaption>
    </figure></p>
<h4 id="场景一" class="headerLink">
    <a href="#%e5%9c%ba%e6%99%af%e4%b8%80" class="header-mark"></a>场景一</h4><p>对象被一个堆对象删除引用，成为栈对象的下游。</p>
<p>伪代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//前提：堆对象4-&gt;对象7 = 对象7；  //对象7 被 对象4引用
</span></span><span class="line"><span class="cl">栈对象1-&gt;对象7 = 堆对象7；  //将堆对象7 挂在 栈对象1 下游
</span></span><span class="line"><span class="cl">堆对象4-&gt;对象7 = null；    //对象4 删除引用 对象7
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/6eccf4b23f1044499d0bbf77c2069b21.png" title="场景1-01" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/6eccf4b23f1044499d0bbf77c2069b21.png" data-sub-html="<h2>场景1-01</h2><p>场景1-01</p>">
        
    </a><figcaption class="image-caption">场景1-01</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/03f8a2fc5bcc4d76a74f48495900d00f.png" title="场景1-02" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/03f8a2fc5bcc4d76a74f48495900d00f.png" data-sub-html="<h2>场景1-02</h2><p>场景1-02</p>">
        
    </a><figcaption class="image-caption">场景1-02</figcaption>
    </figure></p>
<h4 id="场景二" class="headerLink">
    <a href="#%e5%9c%ba%e6%99%af%e4%ba%8c" class="header-mark"></a>场景二</h4><p>对象被一个栈对象删除引用，成为另一个栈对象的下游。</p>
<p>伪代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">new 栈对象9；
</span></span><span class="line"><span class="cl">对象8-&gt;对象3 = 对象3；      //将栈对象3 挂在 栈对象9 下游
</span></span><span class="line"><span class="cl">对象2-&gt;对象3 = null；      //对象2 删除引用 对象3
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/da92001995cf4c8cbf2568c3bacd7fbd.png" title="场景2-01" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/da92001995cf4c8cbf2568c3bacd7fbd.png" data-sub-html="<h2>场景2-01</h2><p>场景2-01</p>">
        
    </a><figcaption class="image-caption">场景2-01</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/bc9ae45a820e4af682c58a25f96155e2.png" title="场景2-02" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/bc9ae45a820e4af682c58a25f96155e2.png" data-sub-html="<h2>场景2-02</h2><p>场景2-02</p>">
        
    </a><figcaption class="image-caption">场景2-02</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/310dda56e97f411bab5a2e5576fd4369.png" title="场景2-03" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/310dda56e97f411bab5a2e5576fd4369.png" data-sub-html="<h2>场景2-03</h2><p>场景2-03</p>">
        
    </a><figcaption class="image-caption">场景2-03</figcaption>
    </figure></p>
<h4 id="场景三" class="headerLink">
    <a href="#%e5%9c%ba%e6%99%af%e4%b8%89" class="header-mark"></a>场景三</h4><p>对象被一个堆对象删除引用，成为另一个堆对象的下游。</p>
<p>伪代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">堆对象10-&gt;对象7 = 堆对象7；       //将堆对象7 挂在 堆对象10 下游
</span></span><span class="line"><span class="cl">堆对象4-&gt;对象7 = null；         //对象4 删除引用 对象7
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/899ed05a51664c9eb09bfecce8b2945a.png" title="场景3-01" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/899ed05a51664c9eb09bfecce8b2945a.png" data-sub-html="<h2>场景3-01</h2><p>场景3-01</p>">
        
    </a><figcaption class="image-caption">场景3-01</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/cee749d8466d416f8a1ecb07d1c165de.png" title="场景3-02" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/cee749d8466d416f8a1ecb07d1c165de.png" data-sub-html="<h2>场景3-02</h2><p>场景3-02</p>">
        
    </a><figcaption class="image-caption">场景3-02</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/7d0257110cd2437dac1c7835c43b2a73.png" title="场景3-03" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/7d0257110cd2437dac1c7835c43b2a73.png" data-sub-html="<h2>场景3-03</h2><p>场景3-03</p>">
        
    </a><figcaption class="image-caption">场景3-03</figcaption>
    </figure></p>
<h4 id="场景四" class="headerLink">
    <a href="#%e5%9c%ba%e6%99%af%e5%9b%9b" class="header-mark"></a>场景四</h4><p>对象从一个栈对象删除引用，成为另一个堆对象的下游。</p>
<p>伪代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">堆对象10-&gt;对象7 = 堆对象7；       //将堆对象7 挂在 堆对象10 下游
</span></span><span class="line"><span class="cl">堆对象4-&gt;对象7 = null；         //对象4 删除引用 对象7
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/c1cc894d7bef4f1ba26e92c7427de8a5.png" title="场景4-01" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/c1cc894d7bef4f1ba26e92c7427de8a5.png" data-sub-html="<h2>场景4-01</h2><p>场景4-01</p>">
        
    </a><figcaption class="image-caption">场景4-01</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/0c64f5d24f674a90942170b8998deafa.png" title="场景4-02" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/0c64f5d24f674a90942170b8998deafa.png" data-sub-html="<h2>场景4-02</h2><p>场景4-02</p>">
        
    </a><figcaption class="image-caption">场景4-02</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/e25db1900a4d404189fdcb61d33ac5d2.png" title="场景4-03" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220407/e25db1900a4d404189fdcb61d33ac5d2.png" data-sub-html="<h2>场景4-03</h2><p>场景4-03</p>">
        
    </a><figcaption class="image-caption">场景4-03</figcaption>
    </figure></p>
<p>Go 中的混合写屏障满足<strong>弱三色不变式</strong>，结合了删除写屏障和插入写屏障的优点，<strong>只需要在开始时并发扫描各个 goroutine 的栈</strong>，使其变黑并一直保持，这个过程不需要 STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行 re-scan 操作了，减少了 STW 的时间。</p>
<h2 id="总结" class="headerLink">
    <a href="#%e6%80%bb%e7%bb%93" class="header-mark"></a>总结</h2><p>GoV1.3：普通标记清除法，整体过程需要启动 STW，效率极低。</p>
<p>GoV1.5：三色标记法，堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要 STW )，效率普通。</p>
<p>GoV1.8：三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://community.apinto.com/d/34057-golang-gc" target="_blank" rel="noopener noreferrer">一文弄懂 Golang GC、三色标记、混合写屏障机制</a></li>
<li><a href="https://www.kancloud.cn/aceld/golang/1958308" target="_blank" rel="noopener noreferrer">Golang三色标记+混合写屏障GC模式全分析</a></li>
<li><a href="https://www.bilibili.com/video/BV1wz4y1y7Kd/" target="_blank" rel="noopener noreferrer">Golang中GC回收机制三色标记与混合写屏障</a></li>
</ul>
]]></description>
</item><item>
    <title>Go GMP 调度模型</title>
    <link>https://www.xiaobinqt.cn/gmp-model/</link>
    <pubDate>Wed, 16 Mar 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/gmp-model/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221118/555f4905eb1c4615b9702ead116731d1.png" referrerpolicy="no-referrer">
            </div><h2 id="进程线程协程的区别" class="headerLink">
    <a href="#%e8%bf%9b%e7%a8%8b%e7%ba%bf%e7%a8%8b%e5%8d%8f%e7%a8%8b%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-mark"></a>进程、线程、协程的区别</h2><p><strong>进程</strong>：进程是操作系统为应用程序分配资源的最小单元。每个进程有独立的内存空间和状态。</p>
<p><strong>线程</strong>：线程是进程中的一个独立执行单元。在 Go 中，一个进程可以启动多个线程，以并行执行任务。</p>
<p><strong>协程</strong>：协程是 Go 语言中的一种轻量级的并发技术。它是<strong>用户态的，不需要操作系统的支持</strong>，可以在单个线程中启动多个协程，并行执行任务。协程共享同一个线程的资源，但拥有自己的栈和寄存器。</p>
<p>总的来说，进程和线程是操作系统级别的并发技术，用于在多核处理器上利用资源；而协程是 Go 语言提供的一种高效、轻量级的并发技术，用于实现程序内部的并发任务。</p>
<h3 id="进程" class="headerLink">
    <a href="#%e8%bf%9b%e7%a8%8b" class="header-mark"></a>进程</h3><p>进程是操作系统对一个正在运行的程序的一种抽象，<strong>进程是资源分配的最小单位</strong>，每一个进程都有一个自己的地址空间。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/c0032558db4249a0a8ce4d6473327d38.png" title="进程在操作系统中的抽象表现" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/c0032558db4249a0a8ce4d6473327d38.png" data-sub-html="<h2>进程在操作系统中的抽象表现</h2><p>进程在操作系统中的抽象表现</p>">
        
    </a><figcaption class="image-caption">进程在操作系统中的抽象表现</figcaption>
    </figure></p>
<p>通俗的说，<strong>进程就是一个正在执行的程序</strong>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221118/19ae7497830b4301831fe13d24a30f5f.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="Windows任务管理器" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221118/19ae7497830b4301831fe13d24a30f5f.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>Windows任务管理器</h2><p>Windows任务管理器</p>">
        
    </a><figcaption class="image-caption">Windows任务管理器</figcaption>
    </figure></p>
<p>进程存在的意义是为了<strong>合理压榨 CPU 的性能和分配运行的时间片，让 CPU 不能 “闲着“</strong>。</p>
<p>在计算机中，其计算核心是 CPU，负责所有计算相关的工作和资源。单个 CPU 一次只能运行一个任务。如果一个进程跑着，就把唯一一个 CPU 给完全占住，那是非常不合理的。</p>
<p>如果总是在运行一个进程上的任务，就会出现一个现象，就是任务不一定总是在执行 “计算型” 的任务，会有很大可能是在执行网络调用阻塞了，那么 CPU 岂不就浪费了？</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/a406c795e40e4b7395a0228b299dd6bd.png" title="进程上下文切换" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/a406c795e40e4b7395a0228b299dd6bd.png" data-sub-html="<h2>进程上下文切换</h2><p>进程上下文切换</p>">
        
    </a><figcaption class="image-caption">进程上下文切换</figcaption>
    </figure></p>
<p>所以出现了多进程，多个 CPU，多个进程。多进程就是指计算机系统可以同时执行多个进程，从一个进程到另外一个进程的转换是由操作系统内核管理的，一般是同时运行多个软件。</p>
<h3 id="线程" class="headerLink">
    <a href="#%e7%ba%bf%e7%a8%8b" class="header-mark"></a>线程</h3><p>有了多进程，在操作系统上可以同时运行多个进程。那么为什么有了进程，还要线程呢？这是因为：</p>
<ul>
<li>进程间的信息难以共享数据，父子进程并未共享内存，需要通过进程间通信（IPC），在进程间进行信息交换，性能开销较大。</li>
<li>创建进程（一般是调用 <code>fork</code> 方法）的性能开销较大。</li>
</ul>
<p>所以大家又把目光转向了进程内，能不能在进程里做点什么呢？</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/9462880ac1eb4cdeb5288716a15bac4d.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/9462880ac1eb4cdeb5288716a15bac4d.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/9462880ac1eb4cdeb5288716a15bac4d.png" data-sub-html="<h2>进程由多个线程组成</h2>">
        
    </a><figcaption class="image-caption">进程由多个线程组成</figcaption>
    </figure>
<p>一个进程可以由多个称为线程的执行单元组成。每个线程都运行在进程的上下文中，共享着同样的代码和全局数据。</p>
<p>多个进程，就可以有更多的线程。<strong>多线程比多进程之间更容易共享数据，在上下文切换中线程一般比进程更高效</strong>。这是因为，</p>
<ul>
<li>线程之间能够非常方便、快速地共享数据。 只需将数据复制到进程中的共享区域就可以了，但需要注意避免多个线程修改同一份内存。</li>
<li>创建线程比创建进程要快 10 倍甚至更多。 线程都是同一个进程下自家的孩子，像是内存页、页表等就不需要了。</li>
</ul>
<h3 id="协程" class="headerLink">
    <a href="#%e5%8d%8f%e7%a8%8b" class="header-mark"></a>协程</h3><p>协程（Co-routine）是用户态的线程。通常创建协程时，会从进程的堆中分配一段内存作为协程的栈。</p>
<p>线程的栈有 8MB，而协程栈的大小通常只有 KB 级别，而 Go 语言的协程更夸张，只有 2-4KB，非常的轻巧。</p>
<p>协程有以下优势👋：</p>
<ul>
<li>
<p>👉节省 CPU：避免系统内核级的线程频繁切换，造成的 CPU 资源浪费。而协程是用户态的线程，用户可以自行控制协程的创建于销毁，极大程度避免了系统级线程上下文切换造成的资源浪费。</p>
</li>
<li>
<p>👉节约内存：在 64 位的 Linux 中，一个线程需要分配 8MB 栈内存和 64MB 堆内存，系统内存的制约导致我们无法开启更多线程实现高并发。而在协程编程模式下，可以轻松有十几万协程，这是线程无法比拟的。</p>
</li>
<li>
<p>👉稳定性：线程之间通过内存来共享数据，这也导致了一个问题，任何一个线程出错时，进程中的所有线程都会跟着一起崩溃。</p>
</li>
<li>
<p>👉开发效率：使用协程在开发程序之中，可以很方便的将一些耗时的 IO 操作异步化，例如写文件、耗时 IO 请求等。</p>
</li>
</ul>
<h2 id="goroutine-是什么" class="headerLink">
    <a href="#goroutine-%e6%98%af%e4%bb%80%e4%b9%88" class="header-mark"></a>goroutine 是什么</h2><p>Goroutine 是一个由 Go 运行时管理的轻量级线程，我们称为 “协程”。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go f(x, y, z)
</span></span></code></pre></td></tr></table>
</div>
</div><p>操作系统本身是无法明确感知到 Goroutine 的存在的，Goroutine 的操作和切换归属于 “用户态” 中。</p>
<p>Goroutine 由特定的调度模式来控制，以 “多路复用” 的形式运行在操作系统为 Go 程序分配的几个系统线程上。</p>
<p>同时创建 Goroutine 的开销很小，初始只需要 2-4k 的栈空间。Goroutine 本身会根据实际使用情况进行自伸缩，非常轻量。</p>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>Tips<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>Go 程序中没有语言级的关键字让你去创建一个内核线程，你只能创建 goroutine，内核线程只能由 runtime 根据实际情况去创建。</p>
<p>Go 运行时系统并没有内核调度器的中断能力，内核调度器会发起抢占式调度将长期运行的线程中断并让出 CPU 资源，让其他线程获得执行机会。</p>
</div>
        </div>
    </div>
<h2 id="调度器的由来" class="headerLink">
    <a href="#%e8%b0%83%e5%ba%a6%e5%99%a8%e7%9a%84%e7%94%b1%e6%9d%a5" class="header-mark"></a>调度器的由来</h2><p>在多进程/多线程的操作系统中，解决了早期的单进程操作系统进程阻塞的问题，因为一个进程阻塞 CPU 可以立刻切换到其他进程中去执行，而且调度 CPU 的算法可以保证在运行的进程都可以被分配到 CPU 的运行时间片，这样从宏观来看，似乎多个进程是在同时被运行。</p>
<p>但新的问题就出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间。CPU 虽然利用起来了，但如果进程过多，CPU 有很大的一部分都被用来进行进程调度。为了能提高 CPU 的利用率，这里就需要用到调度。</p>
<p>CPU 调度切换的是进程和线程，CPU 对进程和线程的态度是一样的，虽然线程看起来很好，但实际上多线程开发设计会变得很复杂，要考虑很多同步竞争的问题，比如锁、竞争冲突等。</p>
<p>一个线程其实分为 “内核态“ 线程和 “用户态” 线程。一个 “用户态线程” 必须要绑定一个 “内核态线程”，但是 CPU 并不知道有 “用户态线程” 的存在，CPU 只知道它运行的是一个 “内核态线程”。这里我们可以把内核线程依然叫<strong>线程</strong>，用户线程叫<strong>协程</strong>。既然一个协程可以绑定一个线程，那么能不能多个协程绑定在一个或者多个线程上呢！</p>
<h2 id="协程和线程的映射" class="headerLink">
    <a href="#%e5%8d%8f%e7%a8%8b%e5%92%8c%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%98%a0%e5%b0%84" class="header-mark"></a>协程和线程的映射</h2><h3 id="n1-关系" class="headerLink">
    <a href="#n1-%e5%85%b3%e7%b3%bb" class="header-mark"></a>N:1 关系</h3><p>N 个协程绑定 1 个线程。</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/32ca2352460442e1b75aed52373558a0.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/32ca2352460442e1b75aed52373558a0.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/32ca2352460442e1b75aed52373558a0.png" data-sub-html="<h2>N:1</h2>">
        
    </a><figcaption class="image-caption">N:1</figcaption>
    </figure>
<p><strong>优点</strong>：</p>
<p>协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。但也有很大的缺点，1 个进程的所有协程都绑定在 1 个线程上。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>某个程序用不了硬件的多核加速能力</li>
<li>一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</li>
</ul>
<h3 id="11-关系" class="headerLink">
    <a href="#11-%e5%85%b3%e7%b3%bb" class="header-mark"></a>1:1 关系</h3><p>1 个协程绑定 1 个线程，协程的调度都由 CPU 完成了，不存在<code>N:1</code>的缺点，但是协程的创建、删除和切换的代价都由 CPU 完成，略显昂贵。</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/48726c7c54854150a7088dba1bc78860.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/48726c7c54854150a7088dba1bc78860.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/48726c7c54854150a7088dba1bc78860.png" data-sub-html="<h2>1:1</h2>">
        
    </a><figcaption class="image-caption">1:1</figcaption>
    </figure>
<h3 id="mn-关系" class="headerLink">
    <a href="#mn-%e5%85%b3%e7%b3%bb" class="header-mark"></a>M:N 关系</h3><p>M 个协程绑定 N 个线程，是<code>N:1</code>和<code>1:1</code>类型的结合，克服了以上 2 种模型的缺点，但实现复杂。</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/042a666564f44407a0efe47b5ffeaa7d.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/042a666564f44407a0efe47b5ffeaa7d.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/042a666564f44407a0efe47b5ffeaa7d.png" data-sub-html="<h2>M:N</h2>">
        
    </a><figcaption class="image-caption">M:N</figcaption>
    </figure>
<h2 id="go-的调度" class="headerLink">
    <a href="#go-%e7%9a%84%e8%b0%83%e5%ba%a6" class="header-mark"></a>Go 的调度</h2><p><strong>用户态的 Goroutine，操作系统看不到它</strong>
，必然需要有某个东西去管理他，才能更好的运作起来。这就是 Go 语言中的调度，也就是 GMP 模型。</p>
<p>Go scheduler<code> /ˈskedʒuːlər/</code> 的主要功能是针对在处理器上运行的 OS 线程分发可运行的 Goroutine，而我们一提到调度器，就离不开三个经常被提到的缩写，他们分别是：</p>
<ul>
<li>
<p>G：Goroutine，实际上我们每次调用<code>go func</code>就是生成了一个 G。</p>
</li>
<li>
<p>P：Processor，处理器，一般 P 的数量就是处理器的核数，可以通过<code>runtime.GOMAXPROCS(n)</code>进行修改。P 包含了运行 goroutine 的资源，如果线程 M 想运行 goroutine，必须先获取 P ，一个 M 在与一个 P 关联之后形成了一个有效的 G 运行环境「内核线程 + 上下文环境」。P 中还包含了可运行的本地 G 队列，本地 G 队列不超过 256 个 G，优先会将新创建的 G 放到某个 P 的本地队列中，如果本地队列满了会放到全局队列中。</p>
</li>
<li>
<p>M：Machine，系统/内核线程，是运行 goroutine 的实体，每个 M 都代表了 1 个内核线程。<strong>M 可以运行 2 种代码，当 M 运行 go 代码一定需要一个P，当 M 运行原生代码, 例如阻塞的<code>syscall</code>, 此时 M 不需要 P</strong>。</p>
</li>
</ul>
<p>M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，<strong>即使 P 的默认数量是 1，也有可能会创建很多个 M 出来</strong>。</p>
<p>这三者交互实际来源于 Go 的<code>M:N</code>调度模型，也就是 <strong>M 必须与 P 进行绑定</strong>，然后不断地在 M 上循环寻找可运行的 G 来执行相应的任务。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221119/849f150e61d6472ea2099f1097c581fa.png" title="GMP调度" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221119/849f150e61d6472ea2099f1097c581fa.png" data-sub-html="<h2>GMP调度</h2><p>GMP调度</p>">
        
    </a><figcaption class="image-caption">GMP调度</figcaption>
    </figure></p>
<h3 id="p和m何时被创建" class="headerLink">
    <a href="#p%e5%92%8cm%e4%bd%95%e6%97%b6%e8%a2%ab%e5%88%9b%e5%bb%ba" class="header-mark"></a>P和M何时被创建</h3><p><strong>P 何时创建</strong>：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。</p>
<p><strong>M 何时创建</strong>
：没有足够的 M 来关联 P 并运行其中的可运行的 G。比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，runtime 运行时就会去创建新的 M。当 M 有空闲就会被回收或是睡眠。</p>
<h2 id="调度流程" class="headerLink">
    <a href="#%e8%b0%83%e5%ba%a6%e6%b5%81%e7%a8%8b" class="header-mark"></a>调度流程</h2><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221119/945c94520e1b40c5adb516f58a0c2f30.png" title="调度流程" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221119/945c94520e1b40c5adb516f58a0c2f30.png" data-sub-html="<h2>调度流程</h2><p>调度流程</p>">
        
    </a><figcaption class="image-caption">调度流程</figcaption>
    </figure></p>
<ol>
<li>
<p>当我们执行 <code>go func()</code> 时，实际上就是创建一个全新的 Goroutine，我们称它为 G。</p>
</li>
<li>
<p>新创建的 G 会被放入 P 的本地队列（Local Queue）或全局队列（Global Queue）中，准备下一步的动作。需要注意的一点，这里的 P 指的是创建 G 的 P，如果 P 的本地队列已经满了就会保存在全局的队列中。</p>
</li>
<li>
<p>唤醒或创建 M 以便执行 G。G 只能运行在 M 中，一个 M 必须持有一个 P，M 与 P 是<code>1:1</code>的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会想其他的<code>MP</code>组合偷取一个可执行的 G 来执行。</p>
</li>
<li>
<p>一个 M 调度 G 执行的过程是一个循环机制。</p>
</li>
<li>
<p>当 M 执行某一个 G 的时候如果发生了<code>syscall</code>或者其余的阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除（detach），然后再创建一个新的操作系统的线程（如果有空闲的线程可用就复用空闲线程）来服务于这个 P。</p>
</li>
<li>
<p>当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态，加入到空闲线程中，然后这个 G 会被放入全局队列中。</p>
</li>
</ol>
<p>在描述中有提到全局和本地这两类队列，其实在功能上来讲都是用于存放正在等待运行的 G，但是不同点在于，<strong>本地队列有数量限制，不允许超过 256 个</strong>。</p>
<p>并且在新建 G 时，会优先选择 P 的本地队列，如果本地队列满了，则将 P 的本地队列的一半的 G 移动到全局队列。 可以理解为调度资源的共享和再平衡。</p>
<h2 id="m0和g0" class="headerLink">
    <a href="#m0%e5%92%8cg0" class="header-mark"></a>M0和G0</h2><p><code>M0</code>是启动程序后编号为 0 的主线程，这个 M 对应的实例会在全局变量<code>runtime.m0</code>中，<code>M0</code>负责执行初始化操作和启动第一个 G， 在之后<code>M0</code>就和其他的 M 一样。</p>
<p><code>G0</code>是每次启动一个 M 都会第一个创建的 gourtine，<code>G0</code>仅用于负责调度 G，<code>G0</code>不指向任何可执行的函数, 每个 M 都会有一个自己的<code>G0</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello world&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>☝️上面代码会经历如下过程：</p>
<ol>
<li>runtime 创建最初的线程 m0 和 goroutine g0，并把 2 者关联。</li>
<li>调度器初始化：初始化 m0、栈、垃圾回收，以及创建和初始化由<code>GOMAXPROCS</code>个 P 构成的 P 列表。</li>
<li>示例代码中的 main 函数是<code>main.main</code>，runtime 中也有 1 个 main 函数<code>runtime.main</code>，代码经过编译后，<code>runtime.main</code>会调用<code>main.main</code>，程序启动时会为<code>runtime.main</code>创建 goroutine，可以称它为 main goroutine，然后把 main goroutine 加入到 P 的本地队列。</li>
<li>启动 m0，m0 已经绑定了 P，会从 P 的本地队列获取 G，获取到 main goroutine。</li>
<li>M 根据 G 中的栈信息和调度信息设置运行环境，M 运行 G。</li>
<li>G 退出，再次回到 M 获取可运行的 G，这样重复下去，直到<code>main.main</code>退出，<code>runtime.main</code>执行 Defer 和 Panic 处理，或调用<code>runtime.exit</code>退出程序。</li>
</ol>
<p>调度器的生命周期几乎占满了一个 Go 程序的一生，<code>runtime.main</code>的 goroutine 执行之前都是为调度器做准备工作，<code>runtime.main</code>的 goroutine 运行，才是调度器的真正开始，直到<code>runtime.main</code>结束而结束。</p>
<h2 id="窃取行为" class="headerLink">
    <a href="#%e7%aa%83%e5%8f%96%e8%a1%8c%e4%b8%ba" class="header-mark"></a>窃取行为</h2><p>当创建新的 G 或者 G 变成可运行状态时，它会被推送加入到当前 P 的本地队列中。当 P 执行 G 完毕后，P 会将 G 从本地队列中弹出，同时会检查当前本地队列是否为空，如果为空不会立刻销毁线程，而是会随机的从其他 P 的本地队列中尝试
<strong>窃取一半</strong>可运行的 G 到自己的名下。</p>
<figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/a378474165e94b908f8fc7b44812cc4c.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/a378474165e94b908f8fc7b44812cc4c.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220405/a378474165e94b908f8fc7b44812cc4c.png" data-sub-html="<h2>窃取行为</h2>">
        
    </a><figcaption class="image-caption">窃取行为</figcaption>
    </figure>
<p>上图中👆，P2 在本地队列中找不到可以运行的 G，它会执行 <code>work-stealing</code> 调度算法，随机选择其它的处理器 P1，并从 P1 的本地队列中窃取了三个 G 到它自己的本地队列中去。至此，P1、P2 都拥有了可运行的 G，P1 多余的 G 也不会被浪费，调度资源将会更加平均的在多个处理器中流转。</p>
<h2 id="限制条件" class="headerLink">
    <a href="#%e9%99%90%e5%88%b6%e6%9d%a1%e4%bb%b6" class="header-mark"></a>限制条件</h2><h3 id="m-的限制" class="headerLink">
    <a href="#m-%e7%9a%84%e9%99%90%e5%88%b6" class="header-mark"></a>M 的限制</h3><p>在协程的执行中，真正干活的是 GPM 中的 M（系统线程） ，因为 G 是用户态上的东西，最终执行都是得映射，对应到 M 这一个系统线程上去运行。</p>
<p>那么 M 有没有限制呢？</p>
<p>答案是：有的。在 Go 语言中，<strong>M 的默认数量限制是 10000</strong>，如果超出则会报错：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">GO: runtime: program exceeds 10000-thread limit
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是通常只有在 Goroutine 出现阻塞操作的情况下，才会遇到这种情况。这可能也预示着你的程序有问题。</p>
<p>若确切是需要那么多，还可以通过 <code>debug.SetMaxThreads</code> 方法进行设置。</p>
<h3 id="g-的限制" class="headerLink">
    <a href="#g-%e7%9a%84%e9%99%90%e5%88%b6" class="header-mark"></a>G 的限制</h3><p>Goroutine 的创建数量是否有限制？</p>
<p>答案是：没有。但理论上会受内存的影响，假设一个 Goroutine 创建需要 4k 的<strong>连续的内存块</strong>：</p>
<p>4k * 80,000 = 320,000k ≈ 0.3G内存</p>
<p>4k * 1,000,000 = 4,000,000k ≈ 4G内存</p>
<p>以此就可以相对计算出来一台单机在通俗情况下，所能够创建 Goroutine 的大概数量级别。</p>
<h3 id="p-的限制" class="headerLink">
    <a href="#p-%e7%9a%84%e9%99%90%e5%88%b6" class="header-mark"></a>P 的限制</h3><p>P 的数量是否有限制，受什么影响？</p>
<p>答案是：有限制。<strong>P 的数量受环境变量 <code>GOMAXPROCS</code> 的直接影响</strong>。</p>
<p>环境变量 <code>GOMAXPROCS</code> 又是什么？在 Go 语言中，通过设置 <code>GOMAXPROCS</code>，用户可以调整调度中 P（Processor）的数量。</p>
<p>另一个重点在于，与 P 相关联的的 M（系统线程），是需要绑定 P 才能进行具体的任务执行的，因此<strong>P 的多少会影响到 Go 程序的运行表现</strong>。</p>
<p>P 的数量基本是受本机的核数影响，没必要太过度纠结他。</p>
<p>那 P 的数量是否会影响 Goroutine 的数量创建呢？</p>
<p>答案是：不影响。且 Goroutine 多了少了，P 也该干嘛干嘛，不会带来灾难性问题。</p>
<h3 id="小结" class="headerLink">
    <a href="#%e5%b0%8f%e7%bb%93" class="header-mark"></a>小结</h3><ul>
<li>M：有限制，默认数量限制是 10000，可调整。</li>
<li>G：没限制，但受内存影响。</li>
<li>P：受本机的核数影响，可大可小，不影响 G 的数量创建。</li>
</ul>
<p>所以<strong>Goroutine 数量怎么预算，才叫合理？</strong></p>
<p>在真实的应用场景中，如果你 Goroutine：</p>
<ul>
<li>在频繁请求 HTTP，MySQL，打开文件等，那假设短时间内有几十万个协程在跑，那肯定就不大合理了（可能会导致 too many files open）。</li>
<li>常见的 Goroutine 泄露所导致的 CPU、Memory 上涨等，还是得看你的 Goroutine 里具体在跑什么东西。</li>
</ul>
<p>跑的如果是 “资源怪兽”，只运行几个 Goroutine 都可以跑死。</p>
<h2 id="为什么要有-p" class="headerLink">
    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%9c%89-p" class="header-mark"></a>为什么要有 P</h2><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/bdcbfb4a788d477b991c0179a7180c3c.png" title="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/bdcbfb4a788d477b991c0179a7180c3c.png" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/bdcbfb4a788d477b991c0179a7180c3c.png" data-sub-html="<h2>早期调度器</h2>">
        
    </a><figcaption class="image-caption">早期调度器</figcaption>
    </figure>
<p>Go 早期的调度器是没有 P 的，只有 M 和 G。M 想要执行和放回 G 都必须访问全局 G 队列，并且 M 有多个，多线程访问同一资源需要加锁进行保证互斥/同步，所以全局 G 队列是有互斥锁进行保护的。</p>
<p>所以早期的调度器存在这样几个缺点：</p>
<ul>
<li>创建、销毁、调度 G 都需要每个 M 获取锁，这就形成了激烈的<strong>锁竞争</strong>。</li>
<li>M 转移 G 会造成延迟和额外的系统负载。比如当 G 中包含创建新协程的时候，M 创建了<code>G'</code>，为了继续执行 G，需要把<code>G'</code>交给<code>M'</code>执行，也造成了很差的局部性，因为<code>G'</code>和 G 是相关的，最好放在 M 上执行，而不是其他<code>M'</code>。</li>
<li>系统调用（CPU 在 M 之间的切换）导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li>
</ul>
<h2 id="faq" class="headerLink">
    <a href="#faq" class="header-mark"></a>FAQ</h2><ol>
<li><strong>hand off 机制</strong></li>
</ol>
<p>当本线程上执行的 G 阻塞时，线程会释放绑定的 P，把 P 和 M 分离，把 P 转移给其他空闲的线程执行。</p>
<ol start="2">
<li><strong>利用并行</strong></li>
</ol>
<p>可以通过<code>GOMAXPROCS</code>设置 P 的数量，最多有<code>GOMAXPROCS</code>个线程分布在多个 CPU 上同时运行，因为 P 是绑定在 M 上的，M 想要运行 G 必须先获取 P。<code>GOMAXPROCS</code>也限制了并发的程度，比如<code>GOMAXPROCS = 核数/2</code>，则最多利用了一半的 CPU 核进行并行。</p>
<ol start="3">
<li><strong>抢占</strong></li>
</ol>
<p>一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死。</p>
<ol start="4">
<li><strong>自旋线程</strong></li>
</ol>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/f6015c66c0b946e5a775ee6928f4d9a7.png" title="自旋线程" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20221120/f6015c66c0b946e5a775ee6928f4d9a7.png" data-sub-html="<h2>自旋线程</h2><p>自旋线程</p>">
        
    </a><figcaption class="image-caption">自旋线程</figcaption>
    </figure></p>
<p>假定 G2 唤醒了 M2，M2 绑定了 P2，M2 调用并运行<code>G0</code>，但 P2 本地队列没有 G，M2 此时的状态称为自旋线程（没有 G 但为运行状态的线程，不断寻找 G）。自旋线程<strong>优先</strong>会从全局队列里获取 G，当全局队列里没有了时，会去其他的<code>MP</code>组合中偷取 G。</p>
<p>自旋线程的最大限制符合公式：<code>自旋线程 + 执行线程 &lt;= GOMAXPROCS</code></p>
<ol start="5">
<li><strong>如何从全局队列取 G 的数量</strong></li>
</ol>
<p>某个 M 尝试从全局队列（简称 “GQ”）取一批 G 放到自己 P 的本地队列，从全局队列取的 G 数量符合下面的公式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">n =  min(len(GQ) / GOMAXPROCS +  1,  cap(LQ) / 2 )
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://www.yuque.com/aceld/golang/srxd6d" target="_blank" rel="noopener noreferrer">Golang的协程调度器原理及GMP设计思想</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/111346689" target="_blank" rel="noopener noreferrer">Go 为什么这么“快”</a></li>
<li><a href="https://blog.csdn.net/weixin_38054045/article/details/104098072" target="_blank" rel="noopener noreferrer">让你很快就能理解-go的协程调度原理</a></li>
<li><a href="https://mp.weixin.qq.com/s/uWP2X6iFu7BtwjIv5H55vw" target="_blank" rel="noopener noreferrer">Goroutine 数量控制在多少合适，会影响 GC 和调度？</a></li>
<li><a href="https://studygolang.com/articles/9211" target="_blank" rel="noopener noreferrer">Golang goroutine与调度器</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener noreferrer">进程与线程的一个简单解释</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;mid=2247488604&amp;idx=1&amp;sn=83219ea874b1345debc65904cd7f025a" target="_blank" rel="noopener noreferrer">Go 面试官：什么是协程，协程和线程的区别和联系？</a></li>
<li><a href="https://blog.csdn.net/genziisme/article/details/124324755" target="_blank" rel="noopener noreferrer">golang高级进阶（一）：进程、线程、并发、并行、goroutine协程</a></li>
<li><a href="https://blog.greycode.top/golang-wiki/#/doc/advanced/gmp_mode?id=gmp%e6%a8%a1%e5%9e%8b" target="_blank" rel="noopener noreferrer">GMP模型</a></li>
</ul>
]]></description>
</item><item>
    <title>Go 常用命令</title>
    <link>https://www.xiaobinqt.cn/go-build-args/</link>
    <pubDate>Wed, 16 Mar 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/go-build-args/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230714/766aed50dd3947ca9b2b2f9c0562a31a.png" referrerpolicy="no-referrer">
            </div><h2 id="常用编译参数" class="headerLink">
    <a href="#%e5%b8%b8%e7%94%a8%e7%bc%96%e8%af%91%e5%8f%82%e6%95%b0" class="header-mark"></a>常用编译参数</h2><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-o</td>
<td>指定输出可执行文件名</td>
</tr>
<tr>
<td>-v</td>
<td>编译时显示包名，可以理解成输出详细编译信息</td>
</tr>
<tr>
<td>-u</td>
<td>不加<code>-u</code>标记，执行 go get 一个已有的代码包，会发现命令什么都不执行。加了<code>-u</code>才会去拉取最新的代码包的最新版本</td>
</tr>
<tr>
<td>-race</td>
<td>开启竞态检测</td>
</tr>
<tr>
<td>*.go</td>
<td>编译当前目录下的所有go文件，也可以写成 f2.go f2.go &hellip;</td>
</tr>
<tr>
<td>-a</td>
<td>该选项用于强制重新编译所有的依赖项，即使它们似乎是最新的或未更改。这对于确保所有依赖项都与最新的代码一致非常有用。使用 <code>-a</code> 标志可以防止使用缓存的依赖项，从而确保每个依赖项都会被重新编译，并与最新的代码进行链接。</td>
</tr>
<tr>
<td>-w</td>
<td>该选项用于禁用链接器产生的警告信息。当构建可执行文件时，链接器通常会生成一些警告，例如未使用的变量或未导出的符号等。使用 <code>-w</code> 标志可以禁用这些警告信息，以减小可执行文件的大小。</td>
</tr>
<tr>
<td>-s</td>
<td><code>-s</code> 参数会告诉链接器在构建可执行文件时不生成符号表和调试信息。符号表包含了源代码中的符号（如变量名、函数名等）和对应的地址信息，而调试信息则包含了用于调试程序的相关信息（如源代码文件路径、行号等）。<br/> 禁用符号表和调试信息的生成可以减小最终生成的可执行文件的大小，同时也可以增强代码的安全性，因为这些信息对于攻击者来说可能是有价值的。</td>
</tr>
<tr>
<td>-X</td>
<td>设置包中的变量值</td>
</tr>
<tr>
<td><code>-gcflags &quot;-N -l&quot;</code></td>
<td><code>-N</code>：该标志告诉编译器不进行优化。优化是编译器对代码进行的一系列转换和重组，旨在提高代码的执行效率。通过禁用优化，可执行文件的生成将更符合源代码的结构，便于调试。<br/> <code>-l</code>：该标志告诉编译器禁用内联优化。内联优化是编译器将函数调用替换为函数体内容的一种优化技术，可以减少函数调用的开销。禁用内联优化可以确保函数调用保持不变，使得调试过程中可以精确地跟踪函数的执行。<br/>这两个标志的组合 <code>-gcflags &quot;-N -l&quot;</code> 一起使用，可以在构建过程中禁用优化和内联优化，从而产生更容易调试的可执行文件。</td>
</tr>
<tr>
<td>-ldflags</td>
<td>给 go 链接器传入参数，实际是给 go tool link 的参数，可以用 <code>go tool link --help</code> 查看可用的参数。</td>
</tr>
<tr>
<td><code>-ldflags '-extldflags &quot;-static&quot;' </code></td>
<td>静态编译。告诉链接器在构建可执行文件时使用静态链接。静态链接意味着将所有的依赖项（包括系统库）都包含在最终的可执行文件中，以便在其他系统上运行时不需要依赖外部的库。</td>
</tr>
</tbody>
</table>
<h2 id="交叉编译" class="headerLink">
    <a href="#%e4%ba%a4%e5%8f%89%e7%bc%96%e8%af%91" class="header-mark"></a>交叉编译</h2><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>GOOS</td>
<td>GOARCH</td>
</tr>
<tr>
<td>linux</td>
<td>386 / amd64 / arm</td>
</tr>
<tr>
<td>darwin</td>
<td>386 / amd64</td>
</tr>
<tr>
<td>feedbsd</td>
<td>386 / amd64</td>
</tr>
<tr>
<td>windows</td>
<td>386 / amd64</td>
</tr>
</tbody>
</table>
<p>对于编译给 ARM 使用的 Go 程序，需要根据实际情况配置<code>$GOARM</code>，这是用来控制 CPU 的浮点协处理器的参数。</p>
<p><code>$GOARM</code>默认是 6，对于不支持 VFP 使用软件运算的老版本 ARM 平台要设置成 5，支持 VFPv1 的设置成 6，支持 VFPv3 的设置成 7。</p>
<p>示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nv">GOARM</span><span class="o">=</span><span class="m">7</span> <span class="nv">GOARCH</span><span class="o">=</span>arm <span class="nv">GOOS</span><span class="o">=</span>linux go build -v -o fca
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-mod" class="headerLink">
    <a href="#go-mod" class="header-mark"></a>go mod</h2><p>当谈到 Go 语言的模块化管理时，Go Module（go mod）是一个重要的工具和概念。</p>
<p><strong>历史：</strong></p>
<ul>
<li>
<p>Go 1.11（2018年8月发布）引入了 Go Module 的原始支持。它提供了对版本化模块的支持，以解决 Go 语言包管理的问题。</p>
</li>
<li>
<p>Go 1.13（2019年9月发布）对 Go Module 进行了一些改进，增强了对代理和私有模块的支持，并提供了更好的性能和可靠性。</p>
</li>
<li>
<p>从 Go 1.14（2020年2月发布）开始，Go Module 成为 Go 语言默认的包管理工具，取代了之前的 GOPATH 模式。</p>
</li>
</ul>
<p><strong>为什么需要 Go Module：</strong></p>
<ul>
<li>
<p>版本管理：Go Module 允许开发者明确指定项目所使用的依赖项的版本，以便在不同的开发环境中获得一致的构建结果。</p>
</li>
<li>
<p>模块隔离：每个模块都有自己的依赖关系，使得不同的项目可以使用不同版本的依赖项，而不会相互干扰。</p>
</li>
<li>
<p>更好的包管理：Go Module 管理包的方式更加灵活、简单，可以自动解析和下载依赖项，使得包的导入和更新更加方便。</p>
</li>
</ul>
<p><strong>常见使用命令：</strong></p>
<ul>
<li>
<p><code>go mod init &lt;module&gt;</code>：初始化一个新的模块，可以指定模块的名称。</p>
</li>
<li>
<p><code>go mod tidy</code>：根据项目的源码文件，自动分析并更新模块的依赖关系，移除不再使用的依赖项。</p>
</li>
<li>
<p><code>go mod vendor</code>：将依赖项复制到项目的 <code>vendor</code> 目录下，以便离线使用或与版本控制系统一起管理。</p>
</li>
<li>
<p><code>go mod download</code>：下载模块的依赖项到本地缓存，以便离线使用。</p>
</li>
<li>
<p><code>go mod graph</code>：显示模块的依赖关系图。</p>
</li>
<li>
<p><code>go mod edit</code>：编辑模块的 go.mod 文件，可以添加、更新或移除依赖项。</p>
</li>
<li>
<p><code>go mod verify</code>：验证模块的依赖项，确保其完整性和正确性。</p>
</li>
<li>
<p><code>go mod list</code>：列出项目的所有依赖项及其版本。</p>
</li>
<li>
<p><code>go mod why &lt;module&gt;</code>：解释为什么需要特定的依赖项。</p>
</li>
<li>
<p><code>go mod graph</code>：显示模块的依赖关系图，以图形方式展示模块之间的依赖关系。</p>
</li>
<li>
<p><code>go mod edit -require &lt;module&gt;@&lt;version&gt;</code>：手动添加或更新依赖项的版本，可以使用特定的模块和版本号。</p>
</li>
<li>
<p><code>go mod edit -replace &lt;module&gt;=&lt;replacement&gt;@&lt;version&gt;</code>：用其他模块替代指定的依赖项，用于本地开发或测试。</p>
</li>
<li>
<p><code>go mod tidy -v</code>：以详细模式运行 <code>go mod tidy</code> 命令，显示操作的详细信息。</p>
</li>
<li>
<p><code>go mod download -x</code>：以详细模式运行 <code>go mod download</code> 命令，显示下载过程中的详细信息。</p>
</li>
<li>
<p><code>go mod vendor -v</code>：以详细模式运行 <code>go mod vendor</code> 命令，显示复制依赖项到 <code>vendor</code> 目录的详细信息。</p>
</li>
<li>
<p><code>go mod why -m &lt;module&gt;</code>：显示特定模块为什么被包含在模块图中，解释模块之间的直接和间接依赖关系。</p>
</li>
<li>
<p><code>go mod why -u</code>：检查可升级的依赖项，解释为什么某个依赖项需要更新到更高版本。</p>
</li>
</ul>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://studygolang.com/articles/23900" target="_blank" rel="noopener noreferrer">golang编译时的参数传递（gcflags, ldflags）</a></li>
<li><a href="https://blog.csdn.net/hx7013/article/details/91489642" target="_blank" rel="noopener noreferrer">Golang交叉编译（跨平台编译）简述</a></li>
<li><a href="https://holmesian.org/golang-cross-compile" target="_blank" rel="noopener noreferrer">交叉编译Go程序</a></li>
<li><a href="https://github.com/goreleaser/goreleaser/issues/36" target="_blank" rel="noopener noreferrer">ARM flags GOARM</a></li>
<li><a href="https://www.jianshu.com/p/760c97ff644c" target="_blank" rel="noopener noreferrer">go mod使用</a></li>
</ul>
]]></description>
</item><item>
    <title>running gcc failed: exit status 1</title>
    <link>https://www.xiaobinqt.cn/build-running-gcc-failed/</link>
    <pubDate>Thu, 10 Feb 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/build-running-gcc-failed/</guid>
    <description><![CDATA[<p>今天在编译 go 项目时出现了如下错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">/usr/local/go/pkg/tool/linux_amd64/link: running gcc failed: <span class="nb">exit</span> status <span class="m">1</span>
</span></span><span class="line"><span class="cl">/usr/bin/ld: cannot find -lpthread
</span></span><span class="line"><span class="cl">/usr/bin/ld: cannot find -lc
</span></span><span class="line"><span class="cl">collect2: error: ld returned <span class="m">1</span> <span class="nb">exit</span> status
</span></span></code></pre></td></tr></table>
</div>
</div><p>解决办法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">yum install glibc-static.x86_64 -y
</span></span></code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>Go 实现下载文件的断点续传</title>
    <link>https://www.xiaobinqt.cn/go-breakpoint-resume/</link>
    <pubDate>Fri, 21 Jan 2022 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/go-breakpoint-resume/</guid>
    <description><![CDATA[<!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<h2 id="断点续传" class="headerLink">
    <a href="#%e6%96%ad%e7%82%b9%e7%bb%ad%e4%bc%a0" class="header-mark"></a>断点续传</h2><p>断点继传就是下载的文件可以在你下载了一半的时候暂停，下一次下载的时候可以从你暂停的地方继续下载，不用从头开始下载。</p>
<h2 id="服务端" class="headerLink">
    <a href="#%e6%9c%8d%e5%8a%a1%e7%ab%af" class="header-mark"></a>服务端</h2><h3 id="martini-实现" class="headerLink">
    <a href="#martini-%e5%ae%9e%e7%8e%b0" class="header-mark"></a>martini 实现</h3><p><a href="https://github.com/go-martini/martini" target="_blank" rel="noopener noreferrer">martini</a> 框架实现👇</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;bufio&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;crypto/md5&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;encoding/hex&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;io&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;net/http&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;os&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strconv&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strings&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/go-martini/martini&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/pkg/errors&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 大文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">path</span> <span class="p">=</span> <span class="s">&#34;/mnt/d/code-server-3.11.0-linux-amd64.tar.gz&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">download</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">filename</span> <span class="o">:=</span> <span class="s">&#34;download&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;download openfile err&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">w</span><span class="p">.</span><span class="nf">WriteHeader</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">info</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Stat</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;download stat err&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">w</span><span class="p">.</span><span class="nf">WriteHeader</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">md5sum</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">MD5sum</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;download md5sum err&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">w</span><span class="p">.</span><span class="nf">WriteHeader</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;md5sum = &#34;</span><span class="p">,</span> <span class="nx">md5sum</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">w</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;Accept-Ranges&#34;</span><span class="p">,</span> <span class="s">&#34;bytes&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">w</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;Content-Disposition&#34;</span><span class="p">,</span> <span class="s">&#34;attachment; filename=&#34;</span><span class="o">+</span><span class="nx">filename</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">w</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;Content-Md5&#34;</span><span class="p">,</span> <span class="nx">md5sum</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Range&#34;</span><span class="p">);</span> <span class="nx">r</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="s">&#34;bytes=&#34;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="s">&#34;-&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Sscanf</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="s">&#34;bytes=%d-%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">end</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">end</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">end</span> <span class="p">=</span> <span class="nx">info</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">// start 从 0 开始,所以 end = info.Size() 也是有问题的，end 最大是 `info.Size() - 1`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">start</span> <span class="p">&gt;</span> <span class="nx">end</span> <span class="o">||</span> <span class="nx">start</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">end</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">end</span> <span class="o">&gt;=</span> <span class="nx">info</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">w</span><span class="p">.</span><span class="nf">WriteHeader</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusRequestedRangeNotSatisfiable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;参数错误....&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="nx">w</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;Content-Length&#34;</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">FormatInt</span><span class="p">(</span><span class="nx">end</span><span class="o">-</span><span class="nx">start</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="nx">w</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;Content-Range&#34;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;bytes %d-%d/%d&#34;</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">,</span> <span class="nx">info</span><span class="p">.</span><span class="nf">Size</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">			<span class="nx">w</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">,</span> <span class="s">&#34;application/octet-stream&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">w</span><span class="p">.</span><span class="nf">WriteHeader</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusPartialContent</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">w</span><span class="p">.</span><span class="nf">WriteHeader</span><span class="p">(</span><span class="mi">400</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;header Range&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">w</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;Content-Length&#34;</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">FormatInt</span><span class="p">(</span><span class="nx">info</span><span class="p">.</span><span class="nf">Size</span><span class="p">(),</span> <span class="mi">10</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">w</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">,</span> <span class="s">&#34;application/octet-stream&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">start</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="nx">end</span> <span class="p">=</span> <span class="nx">info</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Seek</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;file seek err&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">w</span><span class="p">.</span><span class="nf">WriteHeader</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">n</span> <span class="o">:=</span> <span class="mi">2048</span>
</span></span><span class="line"><span class="cl">	<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">end</span><span class="o">-</span><span class="nx">start</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">n</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">end</span> <span class="o">-</span> <span class="nx">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;io.Eof err&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="nx">w</span><span class="p">.</span><span class="nf">WriteHeader</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;Writer.Write err&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">w</span><span class="p">.</span><span class="nf">WriteHeader</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">start</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">start</span> <span class="o">&gt;=</span> <span class="nx">end</span><span class="o">+</span><span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">MD5sum</span><span class="p">(</span><span class="nx">file</span> <span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">md5</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">buf</span><span class="p">,</span> <span class="nx">reader</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">65536</span><span class="p">),</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span> <span class="p">;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">reader</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">hash</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">hex</span><span class="p">.</span><span class="nf">EncodeToString</span><span class="p">(</span><span class="nx">hash</span><span class="p">.</span><span class="nf">Sum</span><span class="p">(</span><span class="kc">nil</span><span class="p">)),</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">route</span> <span class="o">:=</span> <span class="nx">martini</span><span class="p">.</span><span class="nf">Classic</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">route</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;/download&#34;</span><span class="p">,</span> <span class="nx">download</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">route</span><span class="p">.</span><span class="nf">RunOnAddr</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="客户端下载" class="headerLink">
    <a href="#%e5%ae%a2%e6%88%b7%e7%ab%af%e4%b8%8b%e8%bd%bd" class="header-mark"></a>客户端下载</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;bufio&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;io&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;net/http&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;net/url&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;os&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;os/exec&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strconv&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/pkg/errors&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/sirupsen/logrus&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">DownloadDownloadArtifact</span><span class="p">(</span><span class="nx">downloadPath</span><span class="p">,</span> <span class="nx">surl</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">dfn</span> <span class="o">:=</span> <span class="nx">downloadPath</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="nx">file</span> <span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span>
</span></span><span class="line"><span class="cl">		<span class="nx">size</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">		<span class="nx">headerMd5sum</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">downloadMd5sum</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="nx">dfn</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_RDWR</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_CREATE</span><span class="p">,</span> <span class="mo">0644</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;download openfile err&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">stat</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Stat</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">size</span> <span class="p">=</span> <span class="nx">stat</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sk</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Seek</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;seek err&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">sk</span> <span class="o">!=</span> <span class="nx">size</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;seek length not equal file size,seek=%d,size=%d&#34;</span><span class="p">,</span> <span class="nx">sk</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">logrus</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">request</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">request</span><span class="p">.</span><span class="nx">Method</span> <span class="p">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">MethodGet</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">size</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">header</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Header</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Range&#34;</span><span class="p">,</span> <span class="s">&#34;bytes=&#34;</span><span class="o">+</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">FormatInt</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">+</span><span class="s">&#34;-&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">request</span><span class="p">.</span><span class="nx">Header</span> <span class="p">=</span> <span class="nx">header</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">parse</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">surl</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">request</span><span class="p">.</span><span class="nx">URL</span> <span class="p">=</span> <span class="nx">parse</span>
</span></span><span class="line"><span class="cl">	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">DefaultClient</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">request</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//resp, err := http.DefaultClient.Do(&amp;request)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;client do err&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">logrus</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">headerMd5sum</span> <span class="p">=</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Content-Md5&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">headerMd5sum</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;resp header md5sum empty&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">body</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span>
</span></span><span class="line"><span class="cl">	<span class="nx">writer</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewWriter</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kd">var</span> <span class="nx">read</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">		<span class="nx">read</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">body</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">bs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;body read not io eof&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="nx">logrus</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="o">&amp;&amp;</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">!=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">err</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">read</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">writer</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">bs</span><span class="p">[:</span><span class="nx">read</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;writer write err&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="nx">err</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">writer</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">bs</span><span class="p">[:</span><span class="nx">read</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;writer write err&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="p">=</span> <span class="nx">writer</span><span class="p">.</span><span class="nf">Flush</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;writer.Flush err&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 比对 md5 是否一致
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">downloadMd5sum</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">md5sum</span><span class="p">(</span><span class="nx">downloadPath</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;get download md5dum err&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">logrus</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// md5 不一致直接删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">os</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">downloadPath</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">logrus</span><span class="p">.</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;downloadMd5sum: %s,headerMd5sum:%s &#34;</span><span class="p">,</span> <span class="nx">downloadMd5sum</span><span class="p">,</span> <span class="nx">headerMd5sum</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">downloadMd5sum</span> <span class="o">==</span> <span class="nx">headerMd5sum</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 错误了删除 tar 包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">os</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">downloadPath</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;download md5sum not equal header md5dum&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">md5sum</span><span class="p">(</span><span class="nx">downloadPath</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cmdStr</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;printf $(md5sum %s)&#34;</span><span class="p">,</span> <span class="nx">downloadPath</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">cmdOutput</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">exec</span><span class="p">.</span><span class="nf">Command</span><span class="p">(</span><span class="s">&#34;/bin/sh&#34;</span><span class="p">,</span> <span class="s">&#34;-c&#34;</span><span class="p">,</span> <span class="nx">cmdStr</span><span class="p">).</span><span class="nf">CombinedOutput</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">logrus</span><span class="p">.</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;md5sum: %s &#34;</span><span class="p">,</span> <span class="nx">cmdStr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;md5sum [%s] exec.Command err&#34;</span><span class="p">,</span> <span class="nx">cmdStr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">logrus</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">cmdOutput</span><span class="p">),</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="o">:=</span> <span class="nf">DownloadDownloadArtifact</span><span class="p">(</span><span class="s">&#34;/mnt/d/tmp/xxx.111.test&#34;</span><span class="p">,</span> <span class="s">&#34;http://127.0.0.1:8080/download&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;download err&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;success..........&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>Go 使用原生 Swagger</title>
    <link>https://www.xiaobinqt.cn/go-swagger/</link>
    <pubDate>Mon, 27 Dec 2021 00:00:00 &#43;0000</pubDate><author>
        <name>xiaobinqt</name>
    </author><guid>https://www.xiaobinqt.cn/go-swagger/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220519/a12951789f2d401bab720fd3d4bb6472.png" referrerpolicy="no-referrer">
            </div><!-- author： xiaobinqt -->
<!-- email： xiaobinqt@163.com -->
<!-- https://xiaobinqt.github.io -->
<!-- https://www.xiaobinqt.cn -->
<p>Swagger 是一个规范且完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p>
<p>当通过 Swagger 进行正确定义，用户可以理解远程服务并使用最少实现逻辑与远程服务进行交互。</p>
<p>支持 API 自动生成同步的在线文档。使用 Swagger 后可以直接通过代码生成文档，不再需要自己手动编写接口文档了，对程序员来说非常友好，可以节约写文档的时间。</p>
<p>提供 Web 页面在线测试 API。光有文档还不够，Swagger 生成的文档还支持在线测试。参数和格式都定好了，直接在界面上输入参数对应的值即可在线测试接口。</p>
<h2 id="swag-cli-安装" class="headerLink">
    <a href="#swag-cli-%e5%ae%89%e8%a3%85" class="header-mark"></a>swag cli 安装</h2><p>Swag 能将 Go 的注释转换为 Swagger 文档。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 安装swag</span>
</span></span><span class="line"><span class="cl">go get github.com/swaggo/swag/cmd/swag
</span></span><span class="line"><span class="cl"><span class="c1"># 查看版本</span>
</span></span><span class="line"><span class="cl">swag -v
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220519/90cbf963f17a451187e3527877bd8172.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="swag cli" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220519/90cbf963f17a451187e3527877bd8172.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>swag cli</h2><p>swag cli</p>">
        
    </a><figcaption class="image-caption">swag cli</figcaption>
    </figure></p>
<h2 id="swagger-ui-库" class="headerLink">
    <a href="#swagger-ui-%e5%ba%93" class="header-mark"></a>swagger-ui 库</h2><p>从 <a href="https://github.com/swagger-api/swagger-ui" target="_blank" rel="noopener noreferrer">swagger-ui</a>
库下载 <a href="https://github.com/swagger-api/swagger-ui/tree/master/dist" target="_blank" rel="noopener noreferrer">dist</a>
文件夹到自己的项目中，并更名为 swagger（更名不是必须的）。</p>
<p>把 swagger 中的 swagger-initializer.js 文件中有个 url 参数，<strong>全局替换</strong> swagger 文件夹中的这个 url 参数值为 <code>./swagger.json</code>。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220519/28a4221079dd478e926209292027748b.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="swagger-initializer.js url" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220519/28a4221079dd478e926209292027748b.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>swagger-initializer.js url</h2><p>swagger-initializer.js url</p>">
        
    </a><figcaption class="image-caption">swagger-initializer.js url</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220519/1fd26413ebe2426e8263e8cd7182526a.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="替换所有" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220519/1fd26413ebe2426e8263e8cd7182526a.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>替换所有</h2><p>替换所有</p>">
        
    </a><figcaption class="image-caption">替换所有</figcaption>
    </figure></p>
<h2 id="swagger-文档" class="headerLink">
    <a href="#swagger-%e6%96%87%e6%a1%a3" class="header-mark"></a>swagger 文档</h2><p>swagger 是以注释的方式描述的，然后使用 swag cli 生成的文档。</p>
<p>比如我有一个 main.go 文件，文件内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;embed&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;net/http&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/go-martini/martini&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//go:embed swagger
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">embededFiles</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">FS</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// @title 测试 API
</span></span></span><span class="line"><span class="cl"><span class="c1">// @version 4.0
</span></span></span><span class="line"><span class="cl"><span class="c1">// @description 测试 API V4.0
</span></span></span><span class="line"><span class="cl"><span class="c1">// @securityDefinitions.apiKey MyApiKey
</span></span></span><span class="line"><span class="cl"><span class="c1">// @in header
</span></span></span><span class="line"><span class="cl"><span class="c1">// @name Xiaobinqt-Api-Key
</span></span></span><span class="line"><span class="cl"><span class="c1">// @BasePath /
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">m</span> <span class="o">:=</span> <span class="nx">martini</span><span class="p">.</span><span class="nf">Classic</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">m</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;/swagger/**&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">FS</span><span class="p">(</span><span class="nx">embededFiles</span><span class="p">)).</span><span class="nx">ServeHTTP</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">m</span><span class="p">.</span><span class="nf">Post</span><span class="p">(</span><span class="s">&#34;/api/login&#34;</span><span class="p">,</span> <span class="nx">Login</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">m</span><span class="p">.</span><span class="nf">Run</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Req</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Email</span>    <span class="kt">string</span> <span class="s">`json:&#34;email&#34;`</span> <span class="c1">// 邮箱
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Password</span> <span class="kt">string</span> <span class="s">`json:&#34;password&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// @Tags 用户管理
</span></span></span><span class="line"><span class="cl"><span class="c1">// @Summary 用户登录
</span></span></span><span class="line"><span class="cl"><span class="c1">// @Security MyApiKey
</span></span></span><span class="line"><span class="cl"><span class="c1">// @accept application/json
</span></span></span><span class="line"><span class="cl"><span class="c1">// @Produce application/json
</span></span></span><span class="line"><span class="cl"><span class="c1">// @Param data body Req true &#34;email: 用户名，password: 密码&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1">// @Success 200 {object} EdgeInstanceList
</span></span></span><span class="line"><span class="cl"><span class="c1">// @Router /api/login [POST]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Login</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">EdgeInstanceList</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">A</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">B</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用 swag cli 生成 swagger 文档：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220519/41886c08ae484deaa904bec886cfa532.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="生成 swagger 文档" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220519/41886c08ae484deaa904bec886cfa532.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>生成 swagger 文档</h2><p>生成 swagger 文档</p>">
        
    </a><figcaption class="image-caption">生成 swagger 文档</figcaption>
    </figure></p>
<p>访问 swagger 路由：</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220519/5bdd5117ff644d37a9a895c781a6b5b0.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="访问 swagger 路由" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220519/5bdd5117ff644d37a9a895c781a6b5b0.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>访问 swagger 路由</h2><p>访问 swagger 路由</p>">
        
    </a><figcaption class="image-caption">访问 swagger 路由</figcaption>
    </figure></p>
<h2 id="常见问题" class="headerLink">
    <a href="#%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98" class="header-mark"></a>常见问题</h2><h3 id="apikey" class="headerLink">
    <a href="#apikey" class="header-mark"></a>apiKey</h3><p>有的 api 需要加上 header 头信息才能正确访问，这时可以添加注释信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">// @securityDefinitions.apiKey MyApiKey
</span></span><span class="line"><span class="cl">// @in header
</span></span><span class="line"><span class="cl">// @name Xiaobinqt-Api-Key
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>@in header</code> 设置，在请求 header 中，<code>@name Xiaobinqt-Api-Key</code> header 字段为<code>Xiaobinqt-Api-Key</code>，<code>@securityDefinitions.apiKey</code>
固定写法，<code>MyApiKey</code>在每个方法中的<code>@Security</code>注释信息值，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">// @Tags 用户管理
</span></span><span class="line"><span class="cl">// @Summary 用户登录
</span></span><span class="line"><span class="cl">// @Security MyApiKey
</span></span><span class="line"><span class="cl">// @accept application/json
</span></span><span class="line"><span class="cl">// @Produce application/json
</span></span><span class="line"><span class="cl">// @Param data body Req <span class="nb">true</span> <span class="s2">&#34;email: 用户名，password: 密码&#34;</span>
</span></span><span class="line"><span class="cl">// @Success <span class="m">200</span> <span class="o">{</span>object<span class="o">}</span> EdgeInstanceList
</span></span><span class="line"><span class="cl">// @Router /api/login <span class="o">[</span>POST<span class="o">]</span>
</span></span><span class="line"><span class="cl">func Login<span class="o">(</span>w http.ResponseWriter, r *http.Request<span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	w.Write<span class="o">([]</span>byte<span class="o">(</span><span class="s2">&#34;hello&#34;</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果在 swagger 页面 Available authorizations 的值不为空，那么每次请求都会带着<code>Xiaobinqt-Api-Key</code>这个 header 头，值就是<code>Available authorizations</code>
填入的值。</p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220519/17586935d9494b30b83b30be0e46f45a.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="Available authorizations" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220519/17586935d9494b30b83b30be0e46f45a.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>Available authorizations</h2><p>Available authorizations</p>">
        
    </a><figcaption class="image-caption">Available authorizations</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220519/125010439aed41258b007ab94bba2309.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="Execute" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220519/125010439aed41258b007ab94bba2309.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>Execute</h2><p>Execute</p>">
        
    </a><figcaption class="image-caption">Execute</figcaption>
    </figure></p>
<h3 id="paramtype" class="headerLink">
    <a href="#paramtype" class="header-mark"></a>paramType</h3><p>具体可以参看：<a href="https://swagger.io/docs/specification/describing-parameters/" target="_blank" rel="noopener noreferrer">https://swagger.io/docs/specification/describing-parameters/</a></p>
<ul>
<li>body</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">type</span> Req struct <span class="o">{</span>
</span></span><span class="line"><span class="cl">	Email    string <span class="sb">`</span>json:<span class="s2">&#34;email&#34;</span><span class="sb">`</span> // 邮箱
</span></span><span class="line"><span class="cl">	Password string <span class="sb">`</span>json:<span class="s2">&#34;password&#34;</span><span class="sb">`</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// @Param data body Req <span class="nb">true</span> <span class="s2">&#34;email: 用户名，password: 密码&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>path</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">// @Param  user_id path string <span class="nb">true</span> <span class="s2">&#34;用户ID&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>query</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">// @Param  search query string <span class="nb">false</span> <span class="s2">&#34;搜索内容&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>完整注释如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">// @Tags 用户管理
</span></span><span class="line"><span class="cl">// @Summary 用户登录
</span></span><span class="line"><span class="cl">// @Security MyApiKey
</span></span><span class="line"><span class="cl">// @accept application/json
</span></span><span class="line"><span class="cl">// @Produce application/json
</span></span><span class="line"><span class="cl">// @Param  user_id path string <span class="nb">true</span> <span class="s2">&#34;用户ID&#34;</span>
</span></span><span class="line"><span class="cl">// @Param  search query string <span class="nb">false</span> <span class="s2">&#34;搜索内容&#34;</span>
</span></span><span class="line"><span class="cl">// @Param data body Req <span class="nb">true</span> <span class="s2">&#34;email: 用户名，password: 密码&#34;</span>
</span></span><span class="line"><span class="cl">// @Success <span class="m">200</span> <span class="o">{</span>object<span class="o">}</span> EdgeInstanceList
</span></span><span class="line"><span class="cl">// @Router /api/login/<span class="o">{</span>user_id<span class="o">}</span> <span class="o">[</span>POST<span class="o">]</span>
</span></span><span class="line"><span class="cl">func Login<span class="o">(</span>w http.ResponseWriter, r *http.Request<span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	w.Write<span class="o">([]</span>byte<span class="o">(</span><span class="s2">&#34;hello&#34;</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220519/e46042ea6a5e4ce8bd4c85ec34223d9f.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="效果_01" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220519/e46042ea6a5e4ce8bd4c85ec34223d9f.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>效果_01</h2><p>效果_01</p>">
        
    </a><figcaption class="image-caption">效果_01</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220519/c068d1585a49494992af4e7993a5a4f8.png?imageView2/0/q/75%7cwatermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" title="效果_02" data-thumbnail="https://cdn.xiaobinqt.cn/xiaobinqt.io/20220519/c068d1585a49494992af4e7993a5a4f8.png?imageView2/0/q/75|watermark/2/text/eGlhb2JpbnF0/font/dmlqYXlh/fontsize/1000/fill/IzVDNUI1Qg==/dissolve/52/gravity/SouthEast/dx/15/dy/15" data-sub-html="<h2>效果_02</h2><p>效果_02</p>">
        
    </a><figcaption class="image-caption">效果_02</figcaption>
    </figure></p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://github.com/xiaobinqt/go.src/tree/master/dev/martini-swagger" target="_blank" rel="noopener noreferrer">☝️文章示例源码</a></li>
<li><a href="https://swagger.io/docs/" target="_blank" rel="noopener noreferrer">swagger官方文档</a></li>
<li><a href="https://github.com/swaggo/swag/blob/master/README_zh-CN.md" target="_blank" rel="noopener noreferrer">https://github.com/swaggo/swag/blob/master/README_zh-CN.md</a></li>
<li><a href="https://www.jianshu.com/p/9313d0c5395d" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/9313d0c5395d</a></li>
<li><a href="https://colobu.com/2021/01/17/go-embed-tutorial/" target="_blank" rel="noopener noreferrer">Go embed 简明教程</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/351931501" target="_blank" rel="noopener noreferrer">Go 1.16新特性-embed包及其使用</a></li>
</ul>
]]></description>
</item></channel>
</rss>
