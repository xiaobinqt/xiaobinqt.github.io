<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编码实践 on KeepLearning</title>
    <link>https://example.com/keeplearning/docs/coding-practice/</link>
    <description>Recent content in 编码实践 on KeepLearning</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/keeplearning/docs/coding-practice/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>正则表达式</title>
      <link>https://example.com/keeplearning/docs/coding-practice/regex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/coding-practice/regex/</guid>
      <description>正则表达式 # 一、概述 # 正则表达式用于文本内容的查找和替换。
正则表达式内置于其它语言或者软件产品中，它本身不是一种语言或者软件。
正则表达式在线工具
二、匹配单个字符 # . 可以用来匹配任何的单个字符，但是在绝大多数实现里面，不能匹配换行符；
. 是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \ 进行转义，即在 . 前面加上 \ 。
正则表达式一般是区分大小写的，但也有些实现不区分。
正则表达式
C.C2018 匹配结果
My name is CyC2018 .
三、匹配一组字符 # [ ] 定义一个字符集合；
0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定，字符区间在 [ ] 中使用。
- 只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符；
^ 在 [ ] 中是取非操作。
应用
匹配以 abc 为开头，并且最后一个字母不为数字的字符串：
正则表达式
abc[^0-9] 匹配结果
abcd abc1 abc2 四、使用元字符 # 匹配空白字符 # 元字符 说明 [\b] 回退（删除）一个字符 \f 换页符 \n 换行符 \r 回车符 \t 制表符 \v 垂直制表符 \r\n 是 Windows 中的文本行结束标签，在 Unix/Linux 则是 \n。</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>https://example.com/keeplearning/docs/coding-practice/docker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/coding-practice/docker/</guid>
      <description> Docker # 一、解决的问题 # 由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。
Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其它机器上。
二、与虚拟机的比较 # 虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现。
启动速度 # 启动虚拟机需要先启动虚拟机的操作系统，再启动应用，这个过程非常慢；
而启动 Docker 相当于启动宿主操作系统上的一个进程。
占用资源 # 虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU 资源，一台机器只能开启几十个的虚拟机。
而 Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker。
三、优势 # 除了启动速度快以及占用资源少之外，Docker 具有以下优势：
更容易迁移 # 提供一致性的运行环境。已经打包好的应用可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行。
更容易维护 # 使用分层技术和镜像，使得应用可以更容易复用重复的部分。复用程度越高，维护工作也越容易。
更容易扩展 # 可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像。
四、使用场景 # 持续集成 # 持续集成指的是频繁地将代码集成到主干上，这样能够更快地发现错误。
Docker 具有轻量级以及隔离性的特点，在将代码集成到一个 Docker 中不会对其它 Docker 产生影响。
提供可伸缩的云服务 # 根据应用的负载情况，可以很容易地增加或者减少 Docker。
搭建微服务架构 # Docker 轻量级的特点使得它很适合用于部署、维护、组合微服务。
五、镜像与容器 # 镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。
镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。
构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。
参考资料 # DOCKER 101: INTRODUCTION TO DOCKER WEBINAR RECAP Docker 入门教程 Docker container vs Virtual machine How to Create Docker Container using Dockerfile 理解 Docker（2）：Docker 镜像 为什么要使用 Docker？ What is Docker 持续集成是什么？ </description>
    </item>
    
    <item>
      <title>Git</title>
      <link>https://example.com/keeplearning/docs/coding-practice/git/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/coding-practice/git/</guid>
      <description>Git # 集中式与分布式 # Git 属于分布式版本控制系统，而 SVN 属于集中式。
集中式版本控制只有中心服务器拥有一份代码，而分布式版本控制每个人的电脑上就有一份完整的代码。
集中式版本控制有安全性问题，当中心服务器挂了所有人都没办法工作了。
集中式版本控制需要连网才能工作，如果网速过慢，那么提交一个文件会慢的无法让人忍受。而分布式版本控制不需要连网就能工作。
分布式版本控制新建分支、合并分支操作速度非常快，而集中式版本控制新建一个分支相当于复制一份完整代码。
中心服务器 # 中心服务器用来交换每个用户的修改，没有中心服务器也能工作，但是中心服务器能够 24 小时保持开机状态，这样就能更方便的交换修改。
Github 就是一个中心服务器。
工作流 # 新建一个仓库之后，当前目录就成为了工作区，工作区下有一个隐藏目录 .git，它属于 Git 的版本库。
Git 的版本库有一个称为 Stage 的暂存区以及最后的 History 版本库，History 存储所有分支信息，使用一个 HEAD 指针指向当前分支。
git add files 把文件的修改添加到暂存区 git commit 把暂存区的修改提交到当前分支，提交之后暂存区就被清空了 git reset &amp;ndash; files 使用当前分支上的修改覆盖暂存区，用来撤销最后一次 git add files git checkout &amp;ndash; files 使用暂存区的修改覆盖工作目录，用来撤销本地修改 可以跳过暂存区域直接从分支中取出修改，或者直接提交修改到分支中。
git commit -a 直接把所有文件的修改添加到暂存区然后执行提交 git checkout HEAD &amp;ndash; files 取出最后一次修改，可以用来进行回滚操作 分支实现 # 使用指针将每个提交连接成一条时间线，HEAD 指针指向当前分支指针。</description>
    </item>
    
    <item>
      <title>代码可读性</title>
      <link>https://example.com/keeplearning/docs/coding-practice/code-readability/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/coding-practice/code-readability/</guid>
      <description>一、可读性的重要性 # 编程有很大一部分时间是在阅读代码，不仅要阅读自己的代码，而且要阅读别人的代码。因此，可读性良好的代码能够大大提高编程效率。
可读性良好的代码往往会让代码架构更好，因为程序员更愿意去修改这部分代码，而且也更容易修改。
只有在核心领域为了效率才可以放弃可读性，否则可读性是第一位。
二、用名字表达代码含义 # 一些比较有表达力的单词：
单词 可替代单词 send deliver、dispatch、announce、distribute、route find search、extract、locate、recover start launch、create、begin、open make create、set up、build、generate、compose、add、new 使用 i、j、k 作为循环迭代器的名字过于简单，user_i、member_i 这种名字会更有表达力。因为循环层次越多，代码越难理解，有表达力的迭代器名字可读性会更高。
为名字添加形容词等信息能让名字更具有表达力，但是名字也会变长。名字长短的准则是：作用域越大，名字越长。因此只有在短作用域才能使用一些简单名字。
三、名字不能带来歧义 # 起完名字要思考一下别人会对这个名字有何解读，会不会误解了原本想表达的含义。
布尔相关的命名加上 is、can、should、has 等前缀。
用 min、max 表示数量范围；
用 first、last 表示访问空间的包含范围；
begin、end 表示访问空间的排除范围，即 end 不包含尾部。
四、良好的代码风格 # 适当的空行和缩进。
排列整齐的注释：
int a = 1; // 注释 int b = 11; // 注释 int c = 111; // 注释 语句顺序不能随意，比如与 html 表单相关联的变量的赋值应该和表单在 html 中的顺序一致。
五、为何编写注释 # 阅读代码首先会注意到注释，如果注释没太大作用，那么就会浪费代码阅读的时间。那些能直接看出含义的代码不需要写注释，特别是不需要为每个方法都加上注释，比如那些简单的 getter 和 setter 方法，为这些方法写注释反而让代码可读性更差。</description>
    </item>
    
  </channel>
</rss>
