<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MySQL on KeepLearning</title>
    <link>https://example.com/keeplearning/docs/mysql/</link>
    <description>Recent content in MySQL on KeepLearning</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language><atom:link href="https://example.com/keeplearning/docs/mysql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>总览</title>
      <link>https://example.com/keeplearning/docs/mysql/overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/mysql/overview/</guid>
      <description>总览 # 一、索引 # B+ Tree 原理 # 1. 数据结构 # B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。
B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。
在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。
2. 操作 # 进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。
插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。
3. 与红黑树的比较 # 红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。
（一）B+ 树有更低的树高
平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。</description>
    </item>
    
    <item>
      <title>SQL 语法</title>
      <link>https://example.com/keeplearning/docs/mysql/sql-grammar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/mysql/sql-grammar/</guid>
      <description>SQL 语法 # 一、基础 # 模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。
主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。
SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。
SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。
SQL 支持以下三种注释：
--- 注释 SELECT * FROM mytable; -- 注释 /* 注释1 注释2 */ 数据库创建与使用：
CREATE DATABASE test; USE test; 二、创建表 # CREATE TABLE mytable ( --- int 类型，不为空，自增 id INT NOT NULL AUTO_INCREMENT, --- int 类型，不可为空，默认值为 1，不为空 col1 INT NOT NULL DEFAULT 1, --- 变长字符串类型，最长为 45 个字符，可以为空 col2 VARCHAR(45) NULL, --- 日期类型，可为空 col3 DATE NULL, --- 设置主键为 id PRIMARY KEY (`id`)); 三、修改表 # 添加列</description>
    </item>
    
    <item>
      <title>数据库系统原理</title>
      <link>https://example.com/keeplearning/docs/mysql/dbs-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/mysql/dbs-theory/</guid>
      <description>数据库系统原理 # 一、事务 # 概念 # 事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。
ACID # 1. 原子性（Atomicity） # 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
2. 一致性（Consistency） # 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。
3. 隔离性（Isolation） # 一个事务所做的修改在最终提交以前，对其它事务是不可见的。
4. 持久性（Durability） # 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。
事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：
只有满足一致性，事务的执行结果才是正确的。 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。 事务满足持久化是为了能应对系统崩溃的情况。 AUTOCOMMIT # MySQL 默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。
二、并发一致性问题 # 在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。
丢失修改 # 丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。
读脏数据 # 读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</description>
    </item>
    
    <item>
      <title>常见问题（一）</title>
      <link>https://example.com/keeplearning/docs/mysql/faq1.md/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/mysql/faq1.md/</guid>
      <description>MySQL 常见问题（一） # 1. 出现 Unknown column 错误是在哪个阶段 # MySQL 会在分析器中判断语句是否正确，表是否存在，列是否存在等，如果没有问题再提交给优化器。
2. 为什么对权限的检查不在优化器之前做 # 有些时候，SQL 语句要操作的表不只是 SQL 字面上那些。比如有个触发器，得在执行器阶段（过程中）才能确定，优化器阶段前是无能为力的。
客户端连接时，如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限，之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。一个用户成功建立连接后，即使用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。
3. 一个查询语句的执行流程是什么 # 一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。
4. bin log、redo log、undo log 的区别 # redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
redo log 是物理日志，记录的是「在某个数据页上做了什么修改」；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如「给 ID=2 这一行的 c 字段加 1」。
redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。
InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下图所示
write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。擦除后“空着的部分”就是 write pos 到 3 号文件末尾，再加上 0 号文件开头到 checkpoint 的部分。</description>
    </item>
    
  </channel>
</rss>
