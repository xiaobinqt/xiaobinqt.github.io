---
weight: 4

bookFlatSection: true

bookCollapseSection: false

bookToc: true

title: "1.4 镜像"
---

# 1.4 镜像

## 1.4.1 什么是镜像

镜像和常见的 tar、rpm、deb 等安装包一样，都打包了应用程序，但最大的不同点在于它里面不仅有基本的可执行文件，还有应用运行时的整个系统环境。这就让镜像具有了非常好的跨平台便携性和兼容性，能够让开发者在一个系统上开发（例如 Ubuntu），然后打包成镜像，再去另一个系统上运行（例如 CentOS），完全不需要考虑环境依赖的问题，是一种更高级的应用打包方式。

## 1.4.2 容器化应用

“容器化的应用” 或 “应用的容器化”，就是指应用程序不再直接和操作系统打交道，而是封装成镜像，再交给容器环境去运行。镜像就是静态的应用容器，容器就是动态的应用镜像，两者互相依存，互相转化，密不可分。

## 1.4.3 镜像的命名规则

镜像的完整名字由两个部分组成，名字和标签，中间用`:`连接起来。

名字表明了应用的身份，比如 busybox、Alpine、Nginx、Redis 等等。标签（tag）则可以理解成是为了区分不同版本的应用而做的额外标记，任何字符串都可以，比如 3.15 是纯数字的版本号、jammy 是项目代号、1.21-alpine 是版本号加操作系统名等等。其中有一个比较特殊的标签叫 “latest”，它是默认的标签，如果只提供名字没有附带标签，那么就会使用这个默认的 “latest” 标签。

<div align="center"><img src="https://cdn.xiaobinqt.cn/xiaobinqt.io/20230509/09b3ba11864c4dfe83be6b72d8f6781f.png" width=  /></div>

REPOSITORY 列就是镜像的名字，TAG 就是这个镜像的标签。IMAGE ID 是镜像唯一的标识，就好像是身份证号一样。这里用 REPOSITORY 而不是 IMAGE 是因为 Docker 认为一系列同名但不同版本的镜像构成了一个集合，是一个 “镜像存储库”，用 REPOSITORY 来表述更加恰当，相当于 GitHub 上的 Repository。

同一个镜像也可以打上不同的标签，也就是说 IMAGE ID 一样，但是 TAG 可以不一样。如果一个镜像同时具有多个标签就不能直接使用 IMAGE ID 来删除，Docker 会提示镜像存在多个引用（即标签），拒绝删除。

IMAGE ID 还有一个好处，因为它是十六进制形式且唯一，Docker 特意为它提供了 “短路” 操作，在本地使用镜像的时候，我们不用像名字那样要完全写出来这一长串数字，通常只需要写出**前三位**就能够快速定位，在镜像数量比较少的时候用两位甚至一位数字也许就可以了。



















