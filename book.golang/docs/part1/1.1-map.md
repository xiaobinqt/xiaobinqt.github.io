---
weight: 1

bookFlatSection: true

bookCollapseSection: false

bookToc: true

title: "1.1 map"
---

# 1.1 map

## 1.1.1 底层实现

Golang 的 `map` 是一种哈希表（Hash Table），用于存储键值对。

### 基本结构

在 Golang 中，`map` 是通过哈希表来实现的，其底层结构由一个名为 `hmap` 的结构体表示。这个结构体定义在 `runtime` 包中，主要包含以下几个关键字段：

- **count**：存储在 map 中的键值对的数量。
- **buckets**：指向哈希表的桶数组的指针。
- **B**：表示桶数组的大小是 `2^B`。
- **hash0**：哈希种子，用于哈希函数，以防止哈希冲突攻击。
- **oldbuckets**：用于增量扩展过程中，存放旧的桶数组。
- **nevacuate**：记录迁移过程中的迁移进度。

```c
type hmap struct {
    count      int
    flags      uint8
    B          uint8
    noverflow  uint16
    hash0      uint32
    buckets    unsafe.Pointer
    oldbuckets unsafe.Pointer
    nevacuate  uintptr
}
```

### 哈希函数

Golang 使用哈希函数将键映射到桶（bucket）。`map` 中的键可以是各种类型（如字符串、整数等），哈希函数会将这些键转换为一个整数值。`hash0` 是一个种子值，用于增加哈希函数的随机性，避免潜在的哈希冲突攻击。

### 桶（Bucket）

桶是存储键值对的基本单元。一个 `map` 由多个桶组成，每个桶存储多个键值对。桶的大小是固定的，通常一个桶可以存储 8 个键值对。

每个桶由以下几个部分组成：

- **tophash**：每个槽位的哈希前缀，用于快速比较。
- **keys**：存储键。
- **values**：存储值。
- **overflow**：指向溢出桶的指针，用于处理桶满的情况。

```c
    type bmap struct {
    tophash [bucketCnt]uint8
    // Followed by bucketCnt keys and then bucketCnt values.
    // NOTE: packing all three together makes the code a bit more complicated
    // than it would be if we had three separate arrays, but it allows us
    // to be more cache-friendly by using fewer memory accesses.
}
```

### 扩展和迁移

当 `map` 中的元素数量增长到一定程度时，会进行扩展操作。扩展操作增加桶的数量，以减少哈希冲突的概率。扩展过程中，Golang 采用增量扩展（Incremental Rehashing）的策略：

- 创建新的桶数组，大小是旧桶数组的两倍。
- 逐步将旧桶中的元素迁移到新桶中，分多次完成，以避免一次性扩展带来的性能问题。

在迁移过程中，会有一个指针 `oldbuckets` 指向旧的桶数组，`nevacuate` 记录了已经迁移的进度。这样可以保证在访问期间的性能不会受到太大影响。

### 哈希冲突

当多个键映射到同一个桶时，就会发生哈希冲突。Golang 的 `map` 使用链地址法（Separate Chaining）和开放地址法（Open Addressing）的混合策略来处理冲突：

- 在桶满的情况下，创建溢出桶（overflow bucket），并将其链接到当前桶。
- 当发生冲突时，会尝试在同一个桶中找到一个空闲的槽位存储新键值对。如果找不到，就会使用溢出桶。

### 查找、插入和删除操作

- **查找（Lookup）**：根据键计算哈希值，确定桶的位置，然后在桶中搜索对应的键。
- **插入（Insert）**：找到合适的桶和槽位后，存储新的键值对。如果桶满，则创建溢出桶。
- **删除（Delete）**：找到键后，将其标记为已删除，并清空相应的值。

Golang 的 `map` 通过哈希表实现高效的键值对存储和查找。它使用哈希函数将键映射到桶，通过桶和溢出桶存储键值对，并采用增量扩展策略来动态调整大小，从而保持高性能和低冲突。

## 1.1.2 扩容机制

在 Golang 中，`map` 的扩容机制是为了处理随着数据增加而导致的哈希冲突频率增高的问题。扩容可以提高 `map` 的查找和插入效率。下面详细解释 Golang `map` 的扩容机制及其工作原理。

### 扩容触发条件

Golang `map` 的扩容机制会在以下情况之一发生时触发：

1. **负载因子过高**：当 `map` 的负载因子（元素个数与桶数的比例）超过一个阈值时，`map` 会触发扩容。通常，当负载因子接近 6.5 时，扩容会发生。
2. **桶溢出**：当 `map` 的任意桶过于拥挤时，也会触发扩容。一个桶中默认可以存储 8 个键值对，如果存储的键值对超过这个数量，则需要溢出桶。当溢出桶的数量过多时，也会触发扩容。

### 扩容的过程

Golang `map` 的扩容是一个逐步完成的过程，称为**增量扩容**（Incremental Resizing），这可以避免一次性扩容带来的性能问题。

1. **创建新的桶数组**：扩容时，会创建一个新的桶数组，大小是当前桶数组的两倍。这个新的桶数组将用来重新存储所有的键值对。

2. **记录旧的桶数组**：在扩容过程中，`hmap` 结构体中的 `oldbuckets` 字段会指向旧的桶数组，同时 `nevacuate` 字段记录了已经迁移了多少个桶。

3. **渐进式迁移**：为了避免一次性扩容导致性能急剧下降，Golang `map` 在每次对 `map` 进行操作时，都会将少量的桶从旧数组迁移到新数组。这样扩容操作就分摊到了多次对 `map` 的操作上，避免了单次操作的性能问题。

4. **重新分配键值对**：在迁移过程中，旧桶中的键值对会被重新分配到新的桶中。由于新的桶数组大小是旧的两倍，所以同一个旧桶中的键值对在新数组中可能会分配到两个不同的桶中。

5. **更新元数据**：当所有旧桶都被迁移完毕后，`oldbuckets` 字段会被设置为 `nil`，表示扩容完成，新的桶数组将成为 `map` 的当前桶数组。

### 代码示例

以下代码展示了 Golang `map` 扩容前后的情况：

```go
package main

import (
	"fmt"
)

func main() {
	m := make(map[int]int)

	// 插入足够多的元素触发扩容
	for i := 0; i < 100; i++ {
		m[i] = i
	}

	// 使用反射获取内部结构
	fmt.Printf("Map: %+v\n", m)

	// 检查扩容
	fmt.Println("容量: ", len(m))

	// 增加更多元素，继续观察
	for i := 100; i < 200; i++ {
		m[i] = i
	}

	fmt.Printf("Map After Expansion: %+v\n", m)
	fmt.Println("容量: ", len(m))
}

```

在上面的代码中，插入足够多的元素后，`map` 将触发扩容。我们可以通过观察 `map` 的容量变化，来了解其扩容过程。

### 扩容示意图

以下是扩容过程的简化示意图：

```
初始状态：
+---+---+---+
| 0 | 1 | 2 |
+---+---+---+
 |    |    |
 v    v    v
[1, 2] [3, 4] [5, 6]

扩容后：
+---+---+---+---+---+---+
| 0 | 1 | 2 | 3 | 4 | 5 |
+---+---+---+---+---+---+
 |    |    |    |    |    |
 v    v    v    v    v    v
[1] [2] [3] [4] [5] [6]
```

Golang `map` 的扩容机制通过增量扩容策略有效地分散了扩容的计算负担，避免了操作阻塞，提高了 `map` 的整体性能和响应速度。这种机制使得 `map` 能够动态适应不同规模的数据集，提供高效的键值对存储和查找功能。

### 扩容对性能的影响

## 1.1.3 为什么是无序的

以下示例展示了 `map` 的无序特性：

```go
package main

import "fmt"

func main() {
	m := map[string]int{
		"a": 1,
		"b": 2,
		"c": 3,
	}

	for k, v := range m {
		fmt.Printf("%s: %d\n", k, v)
	}
}
```

每次运行这个程序，输出的顺序可能不同，因为 `map` 的遍历顺序是无序且不确定的。

在 Golang 中，`map` 是无序的，这意味着键值对的迭代顺序不是按插入顺序，也不是按键的自然顺序。这个特性源于 `map` 的底层实现和设计选择。以下是详细原因：

### 底层数据结构

Golang 的 `map` 是基于哈希表（Hash Table）实现的。哈希表的设计目的是为了高效地存储和查找键值对，它通过哈希函数将键映射到桶（bucket）来进行存储。由于键通过哈希函数被分配到不同的桶中，这种分配是无序的，导致 `map` 的迭代顺序也是无序的。

### 哈希表的工作原理

- **哈希函数**：将键转换为哈希值，然后根据哈希值将键值对分配到特定的桶中。
- **桶**：每个桶可以存储多个键值对，桶的位置是由哈希值决定的。
- **溢出桶**：当一个桶中的键值对超过容量时，会使用溢出桶来存储额外的键值对。

由于哈希函数的输出并不是顺序的，而且键值对在桶中的分布和溢出情况会随着操作（如插入、删除）而动态变化，因此遍历 `map` 时，键值对的顺序是无序且不可预测的。

### 高效的查找和插入

哈希表的一个主要优点是其查找和插入操作的时间复杂度是 O(1)，即常数时间。为了实现这一点，哈希表不维护键的顺序，而是关注如何高效地将键映射到桶并在桶中进行查找和存储。如果需要有序的结构，哈希表就不得不增加额外的复杂性和开销，比如维护一个排序的链表或数组，这样会影响到操作的效率。

### 随机化和安全性

Golang 的 `map` 使用了随机化技术来防御哈希冲突攻击。在 `map` 的底层，每次创建一个 `map` 时都会生成一个随机的哈希种子（`hash0`），用于计算键的哈希值。这种随机化增加了哈希表的安全性，但也进一步导致 `map` 的遍历顺序是不可预测的。

### 扩展和迁移

在 `map` 进行扩展（扩容）和迁移时，键值对会被重新分配到新的桶中。因为新的桶数组大小是旧的两倍，所以键值对在新的桶中的位置可能会发生变化。扩展过程中对键值对的重新分配进一步打乱了原来的顺序。

### 迭代的不确定性

Golang 在设计 `map` 的迭代时刻意保持其无序性，避免开发者依赖于任何假设的顺序。这种设计强制开发者不要期望 `map` 的键值对会以某种特定的顺序出现，从而避免在代码中引入不可靠的假设。

### 有序的替代方案

如果需要按顺序存储键值对，Golang 提供了其他数据结构和方法，例如：

- **切片（Slices）**：可以用切片和排序函数来维护一个有序的键列表。
- **排序 `map`**：可以使用 `sort` 包来对 `map` 的键进行排序，然后按排序后的顺序遍历 `map`。

示例：

```go
package main

import (
	"fmt"
	"sort"
)

func main() {
	m := map[string]int{
		"b": 2,
		"a": 1,
		"c": 3,
	}

	// 获取并排序键
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	// 按排序后的键顺序遍历
	for _, k := range keys {
		fmt.Printf("%s: %d\n", k, m[k])
	}
}
```

在这个例子中，我们首先获取所有的键并对它们进行排序，然后按排序后的顺序遍历 `map`，从而实现了有序的遍历。

Golang 中 `map` 的无序性是其底层哈希表实现和设计选择的结果，这种设计确保了高效的查找和插入操作。为了保持 `map` 的高性能和安全性，同时也避免开发者对顺序有不可靠的依赖，`map` 的遍历顺序是无序且不可预测的。如果需要有序的键值对，可以考虑使用其他数据结构或方法来实现。


