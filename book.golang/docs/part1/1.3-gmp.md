---
weight: 3

bookFlatSection: true

bookCollapseSection: false

bookToc: true

title: "1.3 GMP模型"
---

# GMP模型

## 什么是 gmp 模型

GMP 模型是 Go 语言运行时系统的核心部分，用于实现并发和并行。它是 Go 语言在处理协程（goroutine）的调度和执行时所采用的一种模型。GMP 代表的是三个重要的组件：G（Goroutine）、M（Machine）、P（Processor）。

Goroutine (G): 协程是 Go 语言中并发的基本单位，它类似于线程，但是比线程更轻量级。协程由 Go 语言运行时系统（runtime）进行管理和调度。每个协程都代表着一个独立的任务，它们可以在并发的情况下执行。协程的调度是由 GMP 模型中的 M 来实现的。

Machine (M): M 代表的是操作系统线程，它是协程的实际执行者。每个 M 都会负责执行一个或多个协程。M 管理协程的生命周期、调度和系统调用。在 GMP 模型中，M 负责将协程的执行与操作系统线程的关联。

Processor (P): P 代表逻辑处理器，它是 M 的调度者。P 的数量通常与计算机的处理器核心数量相近，它们负责将 M 分配到不同的操作系统线程上执行。P 的数量可以随着需要进行动态调整，以优化协程的调度和执行。

GMP 模型的工作流程大致如下：

1. Goroutine 创建: 当一个新的协程被创建时，它会被加入到全局的 G 队列中。

2. Processor（P）分配: 空闲的 P 从全局的 G 队列中获取一个协程（G）来执行。如果所有的 P 都在执行任务，新的协程就会被暂时挂起。

3. Machine（M）启动: P 负责启动一个新的 M（操作系统线程）来执行选定的协程（G）。一个 M 可以执行多个协程。

4. 协程执行: M 执行被分配的协程，这个过程可以在协程主动让出 CPU 的情况下切换到其他协程。

5. 系统调用和阻塞: 如果协程执行时发生了系统调用或者阻塞操作，M 会让出线程，将控制权交还给 P。这样，操作系统线程就不会被阻塞，可以继续执行其他协程。

6. 协程唤醒: 当阻塞操作完成后，M 将重新被唤醒，可以继续执行协程。

通过这种方式，GMP 模型允许 Go 语言在更少的操作系统线程上并发执行大量的协程，从而实现高效的并发和并行。这种设计使得协程的创建和销毁成本较低，而且在协程之间的切换也非常迅速。

## 如果一个 G 阻塞会出现什么情况

在 GMP 模型中，当一个 G（Goroutine）阻塞时，即当它需要等待某些事件或条件发生时，会触发以下情况：

1. 协程让出CPU: 当一个 G 阻塞时，关联的 M（Machine）会让出CPU，即暂停执行该协程。这是为了避免浪费CPU周期，因为协程当前无法继续执行。

2. M 还可以执行其他协程: 虽然一个 M 正在执行某个 G，但由于 G 阻塞，M 可以切换到执行其他处于可运行状态的 G。这样，其他没有阻塞的协程仍然可以继续执行，而不会因为一个 G 的阻塞而停滞。

3. 阻塞协程从 M 中脱离: 当一个协程阻塞时，它会从关联的 M 中分离出来，这允许 M 继续执行其他协程。协程与 M 的分离意味着该协程不会占用 M 的资源，直到它再次准备就绪。

4. P 选择其他可运行的 G: 由于 M 可以执行其他协程，相关的 P（Processor）会从全局的 G 队列中选择一个可运行的协程分配给空闲的 M 执行。这有助于充分利用所有的操作系统线程。

5. M 等待阻塞协程的唤醒: 被阻塞的协程会等待某个事件（比如文件读写、网络请求等）完成，然后它将会再次标记为可运行状态。此时，一个空闲的 M 可以被唤醒，并开始执行这个协程。

GMP 模型的设计使得一个阻塞的协程不会影响整体的并发性能。通过让出CPU、选择其他可运行的协程，以及将阻塞协程与M分离，系统能够在高并发情况下依然有效地处理多个协程的执行和调度。这也是Go语言在处理大规模并发时的一个优势。


OS的线程由OS内核调度，每隔⼏毫秒，⼀个硬件时钟中断发到CPU， CPU调⽤⼀个调度器内核函数。这个函数暂
停当前正在运⾏的线程，把他的寄存器信息保存到内存中，查看线程列表并决定接下来运⾏哪⼀个线程，再从内存
中恢复线程的注册表信息，最后继续执⾏选中的线程。这种线程切换需要⼀个完整的上下⽂切换：即保存⼀个线程
的状态到内存，再恢复另外⼀个线程的状态，最后更新调度器的数据结构。某种意义上，这种操作还是很慢的。

Go的调度器不是由硬件时钟来定期触发的，⽽是由特定的go语⾔结构
来触发的，他不需要切换到内核语境，所以调度⼀个goroutine⽐调度⼀个线程的成本低很多。

每个OS的线程都有⼀个**固定⼤⼩**的栈内存，通常是2MB，栈内存⽤于保存在其他函数调⽤期间那些正在执⾏或者
临时暂停的函数的局部变量。这个固定的栈⼤⼩，如果对于goroutine来说，可能是⼀种巨⼤的浪费。作为对⽐
goroutine在⽣命周期开始只有⼀个很⼩的栈，典型情况是2KB, 在go程序中，⼀次创建⼗万左右的goroutine也不
罕⻅（2KB*100,000=200MB）。⽽且goroutine的栈不是固定⼤⼩，它可以按需增⼤和缩⼩，最⼤限制可以到
1GB。

goalng 没有删除写屏障这⼀步， golang 的内存写屏障是由插⼊写屏障到混合写屏障过渡的

进程是内存资源管理和cpu调度的执⾏单元。为了有效利⽤多核处理器的优势，将进程进⼀步细分，允许⼀个进程
⾥存在多个线程，这多个线程还是共享同⼀⽚内存空间，但cpu调度的最⼩单元变成了线程。

goroutinue就是协程,可以实现并⾏，多个协程可以在多个处理器同时跑。⽽协程同⼀时刻只能在⼀个处理
器上跑（可以把宿主语⾔想象成单线程的就好了）。 然⽽,多个goroutine之间的通信是通过channel，

如果对⽅追问 pub/sub 有什么缺点？在消费者下线的情况下，⽣产的消息会丢失，得使⽤专业的消息队列如
RabbitMQ 等。
